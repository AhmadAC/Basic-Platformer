

########## START OF FILE: __init__.py ##########



########## START OF FILE: editor.py ##########

# editor/editor.py
# -*- coding: utf-8 -*-
"""
## version 1.0.0.11 (Allow Esc to quit from editor menu)
Level Editor for the Platformer Game (Pygame Only).
Allows creating, loading, and saving game levels visually.
"""
import pygame
import sys
import os
from typing import Tuple, Dict, Optional, Any, List, Callable
import traceback

# --- VERY EARLY DEBUGGING FOR IMPORTS ---
print("--- EDITOR.PY START ---")
print(f"Initial sys.path: {sys.path}")
print(f"Initial current working directory (CWD): {os.getcwd()}")

# --- Add parent directory to sys.path ---
current_script_path = os.path.dirname(os.path.abspath(__file__))
print(f"Current script path (__file__): {current_script_path}")
parent_directory = os.path.dirname(current_script_path) # This should be the project root
print(f"Calculated parent directory (project root attempt): {parent_directory}")

if parent_directory not in sys.path:
    sys.path.insert(0, parent_directory)
    print(f"Parent directory '{parent_directory}' was ADDED to sys.path.")
else:
    print(f"Parent directory '{parent_directory}' was ALREADY in sys.path.")

print(f"Modified sys.path (should contain project root at index 0 or 1): {sys.path}")
print(f"CWD after potential sys.path modification: {os.getcwd()}")

# Now try to import constants
try:
    import constants as C_imported # Use a different alias to avoid potential clashes
    print(f"Successfully imported 'constants as C_imported'. TILE_SIZE: {C_imported.TILE_SIZE}")
except ImportError as e:
    print(f"ERROR: Failed to import 'constants as C_imported'. ImportError: {e}")
    print("Please check:")
    print(f"1. Is '{parent_directory}' the correct project root where 'constants.py' is located?")
    print(f"2. Does '{os.path.join(parent_directory, 'constants.py')}' actually exist?")
    print(f"3. Is 'constants.py' a valid Python module (no syntax errors)?")
    sys.exit("ImportError for constants.py - exiting.")
except Exception as e_gen:
    print(f"ERROR: An unexpected error occurred during 'constants' import: {e_gen}")
    traceback.print_exc()
    sys.exit("Generic error importing constants.py - exiting.")
# --- END OF EARLY DEBUGGING FOR IMPORTS ---


import editor_config as ED_CONFIG # ED_CONFIG itself imports constants as C
from editor_state import EditorState
import editor_ui
import editor_assets
import editor_map_utils
import editor_drawing
import editor_event_handlers
# constants as C is imported by editor_config and other modules, ensure it's the correct one.
# We can use ED_CONFIG.C to be explicit that we're using the one constants resolved by editor_config.


def editor_main():
    print("DEBUG MAIN: editor_main() started.")
    try:
        pygame.init()
        print("DEBUG MAIN: pygame.init() called.")
        if not pygame.font.get_init(): # Check if font module is initialized
            print("DEBUG MAIN: pygame.font not initialized, calling pygame.font.init()")
            pygame.font.init()
        if not pygame.font.get_init():
             print("CRITICAL MAIN: pygame.font.init() failed after explicit call! Fonts will not work.")
        else:
            print("DEBUG MAIN: pygame.font.init() confirmed or already initialized.")


        if not editor_map_utils.ensure_maps_directory_exists():
            print("CRITICAL MAIN: Maps directory issue. Exiting.")
            pygame.quit(); sys.exit(1)
        print("DEBUG MAIN: Maps directory ensured.")

        editor_screen = pygame.display.set_mode(
            (ED_CONFIG.EDITOR_SCREEN_INITIAL_WIDTH, ED_CONFIG.EDITOR_SCREEN_INITIAL_HEIGHT),
            pygame.RESIZABLE
        )
        print(f"DEBUG MAIN: Editor screen created: {editor_screen.get_size()}")
        pygame.display.set_caption("Platformer Level Editor - Menu")
        editor_clock = pygame.time.Clock()
        editor_state = EditorState() # This initializes and prints its own debugs
        print("DEBUG MAIN: EditorState instance created.")
        editor_assets.load_editor_palette_assets(editor_state) # This also prints debugs
        print("DEBUG MAIN: load_editor_palette_assets called successfully.")

        fonts: Dict[str, Optional[pygame.font.Font]] = ED_CONFIG.FONT_CONFIG
        if not fonts.get("small") or not fonts.get("medium") or not fonts.get("large"):
            print("CRITICAL MAIN: Essential editor fonts (small, medium, or large) are None after ED_CONFIG load. Exiting.")
            pygame.quit(); sys.exit(1)
        print(f"DEBUG MAIN: Fonts from ED_CONFIG.FONT_CONFIG loaded: small={fonts['small'] is not None}, medium={fonts['medium'] is not None}, large={fonts['large'] is not None}, tooltip={fonts['tooltip'] is not None}")

        def calculate_layout_rects(screen_width: int, screen_height: int, current_mode: str) -> Tuple[pygame.Rect, pygame.Rect, pygame.Rect]:
            # print(f"DEBUG LAYOUT: calculate_layout_rects called. Screen: {screen_width}x{screen_height}, Mode: '{current_mode}'") # Verbose
            menu_rect = pygame.Rect(ED_CONFIG.SECTION_PADDING, ED_CONFIG.SECTION_PADDING,
                                     ED_CONFIG.MENU_SECTION_WIDTH, screen_height - (ED_CONFIG.SECTION_PADDING * 2))
            menu_rect.width = max(ED_CONFIG.BUTTON_WIDTH_STANDARD + ED_CONFIG.SECTION_PADDING * 2, menu_rect.width)
            menu_rect.height = max(menu_rect.height, ED_CONFIG.MENU_SECTION_HEIGHT) # Ensure min height

            asset_palette_rect = pygame.Rect(ED_CONFIG.SECTION_PADDING, ED_CONFIG.SECTION_PADDING,
                                            ED_CONFIG.ASSET_PALETTE_SECTION_WIDTH, screen_height - (ED_CONFIG.SECTION_PADDING * 2))
            
            map_view_x_start = ED_CONFIG.SECTION_PADDING 
            map_view_width_available = screen_width - (ED_CONFIG.SECTION_PADDING * 2)

            if current_mode == "menu":
                map_view_x_start = menu_rect.right + ED_CONFIG.SECTION_PADDING
                map_view_width_available = screen_width - map_view_x_start - ED_CONFIG.SECTION_PADDING
            elif current_mode == "editing_map":
                asset_palette_rect.left = ED_CONFIG.SECTION_PADDING
                map_view_x_start = asset_palette_rect.right + ED_CONFIG.SECTION_PADDING
                map_view_width_available = screen_width - map_view_x_start - ED_CONFIG.SECTION_PADDING
            
            map_view_rect = pygame.Rect(map_view_x_start, ED_CONFIG.SECTION_PADDING,
                                        map_view_width_available, screen_height - (ED_CONFIG.SECTION_PADDING * 2))
            map_view_rect.width = max(map_view_rect.width, ED_CONFIG.DEFAULT_GRID_SIZE * 10) # Min sensible width
            map_view_rect.height = max(map_view_rect.height, ED_CONFIG.DEFAULT_GRID_SIZE * 10) # Min sensible height
            
            # print(f"DEBUG LAYOUT: Calculated rects - Menu={menu_rect}, Assets={asset_palette_rect}, Map={map_view_rect}") # Verbose
            return menu_rect, asset_palette_rect, map_view_rect

        current_screen_width, current_screen_height = editor_screen.get_size()
        menu_section_rect, asset_palette_section_rect, map_view_section_rect = calculate_layout_rects(
            current_screen_width, current_screen_height, editor_state.current_editor_mode
        )
        print(f"DEBUG MAIN: Initial Layout - Menu={menu_section_rect}, Assets={asset_palette_section_rect}, Map={map_view_section_rect}")


        running = True
        print("DEBUG MAIN: Entering main loop.")
        loop_count = 0 
        while running:
            loop_count += 1
            dt = editor_clock.tick(ED_CONFIG.C.FPS if hasattr(ED_CONFIG.C, 'FPS') else 60) / 1000.0
            mouse_pos = pygame.mouse.get_pos()
            events = pygame.event.get()
            
            if loop_count % ( (ED_CONFIG.C.FPS if hasattr(ED_CONFIG.C, 'FPS') else 60) * 5) == 0: # Approx every 5 seconds
                print(f"\nDEBUG MAIN LOOP (Periodic Log @ frame {loop_count}, time ~{pygame.time.get_ticks()/1000:.1f}s): ----")
                print(f"  Mode: {editor_state.current_editor_mode}, Active Dialog: {editor_state.active_dialog_type}")
                print(f"  Unsaved Changes: {editor_state.unsaved_changes}, Map Name Func: '{editor_state.map_name_for_function}'")
                print(f"  Current Map File: '{editor_state.current_map_filename}'")
                print(f"  Selected Asset: '{editor_state.selected_asset_editor_key}'")
                print(f"  Num Placed Objects: {len(editor_state.placed_objects)}")
                print(f"  Camera: ({editor_state.camera_offset_x}, {editor_state.camera_offset_y})")
                print(f"  Screen: {current_screen_width}x{current_screen_height}")
                print(f"  Layout Rects: Menu={menu_section_rect}, Assets={asset_palette_section_rect}, Map={map_view_section_rect}")
                print(f"DEBUG MAIN LOOP ---- END ----\n")

            editor_state.update_status_message(dt)

            previous_mode = editor_state.current_editor_mode
            previous_dialog_type = editor_state.active_dialog_type # For detecting dialog closure
            layout_needs_recalc = False

            for event_idx, event in enumerate(events):
                if event.type == pygame.VIDEORESIZE:
                    print(f"DEBUG MAIN: VIDEORESIZE event to {event.w}x{event.h}")
                    current_screen_width, current_screen_height = event.w, event.h
                    try:
                        editor_screen = pygame.display.set_mode((current_screen_width, current_screen_height), pygame.RESIZABLE)
                        print(f"DEBUG MAIN: Screen resized to {editor_screen.get_size()}")
                    except pygame.error as e_resize:
                        print(f"ERROR MAIN: Pygame error on resize to {current_screen_width}x{current_screen_height}: {e_resize}")
                    layout_needs_recalc = True
                    editor_state.set_status_message(f"Resized to {event.w}x{event.h}", 2.0)
                
                # Let handle_global_events deal with QUIT, which might prompt for unsaved changes
                if not editor_event_handlers.handle_global_events(event, editor_state, editor_screen):
                    print("DEBUG MAIN: handle_global_events returned False (QUIT). Setting running=False.")
                    running = False; break 
                if not running: break

                # --- MODAL DIALOG EVENT PROCESSING ---
                if editor_state.active_dialog_type:
                    editor_event_handlers.handle_dialog_events(event, editor_state)
                    if editor_state.active_dialog_type != previous_dialog_type: # Dialog closed or changed
                        print(f"DEBUG MAIN: Dialog type changed from '{previous_dialog_type}' to '{editor_state.active_dialog_type}' after handle_dialog_events.")
                        if editor_state.current_editor_mode != previous_mode: # Mode changed via dialog callback
                            print(f"DEBUG MAIN: Mode changed (likely via dialog callback) from '{previous_mode}' to '{editor_state.current_editor_mode}'. Triggering layout recalc.")
                            layout_needs_recalc = True
                else: # No active dialog, process mode-specific events
                    if editor_state.current_editor_mode == "menu":
                        # Add Escape key handling for quitting from the menu
                        if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
                            print("DEBUG MAIN: Escape pressed in menu. Posting QUIT event.")
                            pygame.event.post(pygame.event.Event(pygame.QUIT)) # This will be caught by handle_global_events
                            # The handle_global_events will then manage unsaved changes dialog if needed
                            continue # Skip other menu event handling for this frame

                        editor_event_handlers.handle_menu_events(event, editor_state, editor_screen)
                    elif editor_state.current_editor_mode == "editing_map":
                        editor_event_handlers.handle_editing_map_events(
                            event, editor_state,
                            asset_palette_section_rect, map_view_section_rect,
                            editor_screen
                        )
                
                if editor_state.current_editor_mode != previous_mode:
                    print(f"DEBUG MAIN: Mode changed from '{previous_mode}' to '{editor_state.current_editor_mode}' after specific event handlers. Triggering layout recalc.")
                    layout_needs_recalc = True
            if not running: break 
            
            if layout_needs_recalc:
                print(f"DEBUG MAIN: Recalculating layout. Current Mode: '{editor_state.current_editor_mode}', Screen: {current_screen_width}x{current_screen_height}")
                menu_section_rect, asset_palette_section_rect, map_view_section_rect = calculate_layout_rects(
                    current_screen_width, current_screen_height, editor_state.current_editor_mode
                )
                print(f"DEBUG MAIN: New Layout after recalc - Menu={menu_section_rect}, Assets={asset_palette_section_rect}, Map={map_view_section_rect}")
                
                if editor_state.current_editor_mode == "editing_map" and editor_state.map_content_surface:
                    map_px_w = editor_state.get_map_pixel_width()
                    map_px_h = editor_state.get_map_pixel_height()
                    view_w = map_view_section_rect.width
                    view_h = map_view_section_rect.height
                    
                    if view_w > 0 and view_h > 0 : 
                        max_cam_x = max(0, map_px_w - view_w)
                        max_cam_y = max(0, map_px_h - view_h)
                        
                        prev_cam_x, prev_cam_y = editor_state.camera_offset_x, editor_state.camera_offset_y
                        editor_state.camera_offset_x = max(0, min(editor_state.camera_offset_x, max_cam_x))
                        editor_state.camera_offset_y = max(0, min(editor_state.camera_offset_y, max_cam_y))
                        if prev_cam_x != editor_state.camera_offset_x or prev_cam_y != editor_state.camera_offset_y:
                            print(f"DEBUG MAIN: Camera clamped after resize/layout change from ({prev_cam_x},{prev_cam_y}) to ({editor_state.camera_offset_x},{editor_state.camera_offset_y}). Max cam: ({max_cam_x},{max_cam_y})")
                    else:
                        print(f"Warning MAIN: Map view rect has zero or negative W/H ({view_w}x{view_h}) after layout recalc. Camera not adjusted.")

            editor_screen.fill(ED_CONFIG.C.DARK_GRAY) 

            if editor_state.current_editor_mode == "menu":
                editor_drawing.draw_menu_ui(editor_screen, editor_state, menu_section_rect, fonts, mouse_pos)
                placeholder_rect = pygame.Rect(
                    menu_section_rect.right + ED_CONFIG.SECTION_PADDING, 
                    ED_CONFIG.SECTION_PADDING,
                    current_screen_width - menu_section_rect.right - ED_CONFIG.SECTION_PADDING * 2,
                    current_screen_height - ED_CONFIG.SECTION_PADDING * 2
                )
                if placeholder_rect.width > 10 and placeholder_rect.height > 10: 
                    pygame.draw.rect(editor_screen, (20,20,20), placeholder_rect) 
                    font_large = fonts.get("large")
                    if font_large:
                        ph_text = font_large.render("Map Editor Area", True, (60,60,60)) 
                        editor_screen.blit(ph_text, ph_text.get_rect(center=placeholder_rect.center))

            elif editor_state.current_editor_mode == "editing_map":
                editor_drawing.draw_asset_palette_ui(editor_screen, editor_state, asset_palette_section_rect, fonts, mouse_pos)
                editor_drawing.draw_map_view_ui(editor_screen, editor_state, map_view_section_rect, fonts, mouse_pos)
            
            if editor_state.active_dialog_type: 
                editor_ui.draw_active_dialog(editor_screen, editor_state, fonts)

            font_tooltip = fonts.get("tooltip") 
            if font_tooltip: editor_ui.draw_tooltip(editor_screen, editor_state, font_tooltip)
            
            font_small = fonts.get("small") 
            if font_small: editor_ui.draw_status_message(editor_screen, editor_state, font_small)

            pygame.display.flip()

    except Exception as e:
        print(f"CRITICAL ERROR in editor_main: {e}")
        traceback.print_exc()
    finally:
        print("DEBUG MAIN: Exiting editor_main. Calling pygame.quit() and sys.exit().")
        pygame.quit()
        sys.exit()

if __name__ == "__main__":
    print("DEBUG MAIN: Script execution started (__name__ == '__main__').")
    editor_main()

########## START OF FILE: editor_assets.py ##########

# editor_assets.py
# -*- coding: utf-8 -*-
"""
## version 1.0.0.5 (Added bottom overhang for palette, configurable text offset)
Handles loading and managing assets for the editor's palette.
"""
import pygame
import os
import sys
import traceback 
from typing import Optional, List, Dict, Any

# --- (Sys.path manipulation and assets import - keeping essential prints) ---
current_dir = os.path.dirname(os.path.abspath(__file__)) 
parent_dir = os.path.dirname(current_dir)                 
if parent_dir not in sys.path:
    sys.path.insert(0, parent_dir)
    print(f"INFO ASSETS: Added '{parent_dir}' to sys.path for 'assets' module import.")
try:
    from assets import load_gif_frames, resource_path
    print("INFO ASSETS: Imported 'load_gif_frames' and 'resource_path' from assets.py")
except ImportError as e:
    print(f"CRITICAL ASSETS ERROR: Failed to import from 'assets.py': {e}")
    # Provide dummy functions if import fails, to allow editor to potentially run with limited functionality
    def load_gif_frames(path: str) -> list: # Matches original type hint
        print(f"CRITICAL ASSETS ERROR: Using DUMMY load_gif_frames for path: {path}")
        return []
    def resource_path(relative_path: str) -> str: # Matches original type hint
        # This dummy might not be robust enough if used, but it's a fallback.
        resolved_path = os.path.join(parent_dir, relative_path)
        print(f"CRITICAL ASSETS ERROR: Using DUMMY resource_path. Input: '{relative_path}', Output: '{resolved_path}'")
        return resolved_path
    print("CRITICAL ASSETS ERROR: Using dummy asset loading functions.")
except Exception as e_gen:
    print(f"CRITICAL ASSETS ERROR: Unexpected error importing from 'assets.py': {e_gen}"); traceback.print_exc()
    sys.exit("Failed to initialize assets module in editor_assets.py")

import editor_config as ED_CONFIG 
from editor_state import EditorState


def load_editor_palette_assets(editor_state: EditorState):
    editor_state.assets_palette.clear()
    print("INFO ASSETS: Loading editor palette assets...")
    successful_loads = 0; failed_loads = 0

    for asset_key, asset_info in ED_CONFIG.EDITOR_PALETTE_ASSETS.items():
        surf: Optional[pygame.Surface] = None
        tooltip = asset_info.get("tooltip", asset_key)
        game_type_id = asset_info.get("game_type_id", asset_key)
        category = asset_info.get("category", "unknown")

        if "source_file" in asset_info:
            source_file_path = asset_info["source_file"]
            try:
                full_path = resource_path(source_file_path)
                if not os.path.exists(full_path):
                    print(f"Assets Error: File NOT FOUND at '{full_path}' for asset '{asset_key}'")
                    # Don't try to load if not found, surf will remain None
                else:
                    frames = load_gif_frames(full_path)
                    if frames: surf = frames[0]
                    else: print(f"Warning ASSETS: load_gif_frames returned empty list for '{asset_key}' from '{full_path}'.")
            except Exception as e: print(f"Error ASSETS: Loading '{asset_key}' from '{source_file_path}': {e}"); # traceback.print_exc() # Less verbose
        elif "surface_params" in asset_info:
            try:
                w, h, color = asset_info["surface_params"]
                surf = pygame.Surface((max(1, w), max(1, h))); surf.fill(color)
            except Exception as e: print(f"Error ASSETS: Creating surface for '{asset_key}': {e}"); # traceback.print_exc()

        if not surf:
            print(f"Warning ASSETS: Surface for '{asset_key}' is None. Creating fallback.")
            surf = pygame.Surface((ED_CONFIG.DEFAULT_GRID_SIZE, ED_CONFIG.DEFAULT_GRID_SIZE))
            surf.fill(getattr(ED_CONFIG.C, 'RED', (255,0,0))) # Use ED_CONFIG.C for colors if available
            pygame.draw.line(surf, getattr(ED_CONFIG.C, 'BLACK', (0,0,0)), (0,0), surf.get_size(), 1)
            pygame.draw.line(surf, getattr(ED_CONFIG.C, 'BLACK', (0,0,0)), (0,surf.get_height()-1), (surf.get_width()-1,0), 1)
            tooltip += " (Load Error)"; failed_loads += 1
        else: successful_loads +=1

        original_w, original_h = surf.get_size()
        scaled_surf = surf
        if original_w > ED_CONFIG.ASSET_THUMBNAIL_MAX_WIDTH or original_h > ED_CONFIG.ASSET_THUMBNAIL_MAX_HEIGHT:
            ratio = min(ED_CONFIG.ASSET_THUMBNAIL_MAX_WIDTH / original_w if original_w > 0 else 1,
                        ED_CONFIG.ASSET_THUMBNAIL_MAX_HEIGHT / original_h if original_h > 0 else 1)
            new_w, new_h = max(1, int(original_w * ratio)), max(1, int(original_h * ratio))
            try: 
                scaled_surf = pygame.transform.smoothscale(surf, (new_w, new_h)) # Use smoothscale for better quality
            except Exception: 
                print(f"Error ASSETS: Scaling '{asset_key}' failed. Using original."); scaled_surf = surf # Fallback to original if scaling fails
        
        try:
            # Ensure conversion for consistent pixel formats
            final_surf_to_store = scaled_surf.convert_alpha() if scaled_surf.get_flags() & pygame.SRCALPHA else scaled_surf.convert()
        except pygame.error as e: 
            print(f"Error ASSETS: Converting surface for '{asset_key}' failed: {e}. Using unoptimized surface."); 
            final_surf_to_store = scaled_surf # Fallback to unoptimized surface

        editor_state.assets_palette[asset_key] = {
            "image": final_surf_to_store, "game_type_id": game_type_id,
            "tooltip": tooltip, "category": category,
            "original_size_pixels": (original_w, original_h)
        }
    print(f"INFO ASSETS: Palette loading done. Success: {successful_loads}, Failed: {failed_loads}.")
    _calculate_asset_palette_total_height(editor_state)


def _calculate_asset_palette_total_height(editor_state: EditorState):
    current_calc_y = ED_CONFIG.ASSET_PALETTE_ITEM_PADDING 
    
    font_category = ED_CONFIG.FONT_CONFIG.get("medium")
    font_tooltip = ED_CONFIG.FONT_CONFIG.get("small")
    # Provide default heights if font objects are None (e.g., font file not found)
    cat_font_h = font_category.get_height() if font_category else 28 
    tip_font_h = font_tooltip.get_height() if font_tooltip else 20
    
    # Configurable vertical offset for tooltip text (space between image and text)
    tooltip_text_v_offset = getattr(ED_CONFIG, 'ASSET_PALETTE_TOOLTIP_TEXT_V_OFFSET', 2) # Default to 2px
    
    categories_in_order = getattr(ED_CONFIG, 'EDITOR_PALETTE_ASSETS_CATEGORIES_ORDER', 
                                  ["tile", "hazard", "item", "enemy", "spawn", "unknown"]) # Default order
    
    # Initialize dictionary to hold categorized assets
    categorized_assets_present: Dict[str, List[Dict[str, Any]]] = {cat_name: [] for cat_name in categories_in_order}
    if "unknown" not in categorized_assets_present: # Ensure "unknown" key exists if not in categories_in_order
        categorized_assets_present["unknown"] = []
    
    # Sort assets into categories
    for asset_key, data in editor_state.assets_palette.items():
        category_name = data.get("category", "unknown")
        # If category_name is not in pre-defined categories_in_order, add to "unknown"
        categorized_assets_present.get(category_name, categorized_assets_present["unknown"]).append(data)

    for category_name in categories_in_order:
        assets_in_this_category = categorized_assets_present.get(category_name, [])
        if not assets_in_this_category: 
            continue # Skip this category if it has no assets

        # Add height for category title and padding below it
        current_calc_y += cat_font_h + ED_CONFIG.ASSET_PALETTE_ITEM_PADDING
        
        # Special handling for side-by-side spawn items (player1_spawn, player2_spawn)
        if category_name == "spawn" and \
           any(d.get("game_type_id") == "player1_spawn" for d in assets_in_this_category) and \
           any(d.get("game_type_id") == "player2_spawn" for d in assets_in_this_category):
            
            p1_data = next((d for d in assets_in_this_category if d.get("game_type_id") == "player1_spawn"), None)
            p2_data = next((d for d in assets_in_this_category if d.get("game_type_id") == "player2_spawn"), None)
            
            max_img_h = 0
            if p1_data and p1_data.get("image"): max_img_h = max(max_img_h, p1_data["image"].get_height())
            if p2_data and p2_data.get("image"): max_img_h = max(max_img_h, p2_data["image"].get_height())
            
            if max_img_h > 0: # If at least one spawn item has an image
                current_calc_y += max_img_h # Height of the row of images
                current_calc_y += tip_font_h + tooltip_text_v_offset # Height for one line of text below, using configurable offset
                current_calc_y += ED_CONFIG.ASSET_PALETTE_ITEM_PADDING # Padding after this row
            
            # Remove P1 and P2 spawn from list so they are not processed again in the loop below
            # This rebinds `assets_in_this_category` to a new list for the subsequent loop;
            # it does not modify the list in `categorized_assets_present`.
            assets_in_this_category = [d for d in assets_in_this_category if d.get("game_type_id") not in ["player1_spawn", "player2_spawn"]]
            # Fallthrough to process any OTHER spawn items normally (if any)
        
        # Process remaining items in the category (or all if not "spawn" with P1/P2 handled above)
        for asset_data in assets_in_this_category:
            asset_img = asset_data.get("image")
            if not asset_img: 
                continue # Skip if asset has no image (e.g., load error)
            current_calc_y += asset_img.get_height() # Height of the asset image
            current_calc_y += tip_font_h + tooltip_text_v_offset # Height for tooltip text below, using configurable offset
            current_calc_y += ED_CONFIG.ASSET_PALETTE_ITEM_PADDING # Padding after this item
        
        # Add extra padding after the entire category block
        current_calc_y += ED_CONFIG.ASSET_PALETTE_ITEM_PADDING
            
    # Add a final overhang (e.g., ~1 inch in pixels) at the bottom of the palette content.
    # This ensures there's ample blank space, preventing potential UI elements at the
    # bottom of the palette (like a "bg color button") from obscuring the last asset items.
    asset_palette_bottom_overhang_px = getattr(ED_CONFIG, 'ASSET_PALETTE_BOTTOM_OVERHANG_PX', 72) # Default to 72 pixels (common for 1 inch at 72 DPI)
    current_calc_y += asset_palette_bottom_overhang_px
            
    editor_state.total_asset_palette_content_height = current_calc_y
    print(f"INFO ASSETS: Calculated total asset palette content height (incl. {asset_palette_bottom_overhang_px}px overhang): {editor_state.total_asset_palette_content_height}")

########## START OF FILE: editor_config.py ##########

# editor_config.py
# -*- coding: utf-8 -*-
"""
## version 1.0.0.5 (Added MAGENTA to FallbackConstants)
Configuration constants for the Platformer Level Editor.
"""
import pygame
import sys
import os
import traceback
from typing import Dict, Optional, Tuple, Any # ADDED Optional, Dict, Tuple, Any for type hints

# --- Add parent directory to sys.path ---
# (sys.path manipulation and constants import remains the same)
current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
print(f"DEBUG CONFIG: current_dir (editor_config.py location): {current_dir}")
print(f"DEBUG CONFIG: parent_dir (project root attempt): {parent_dir}")

if parent_dir not in sys.path:
    sys.path.insert(0, parent_dir)
    print(f"DEBUG CONFIG: Added '{parent_dir}' to sys.path for 'constants' import.")
else:
    print(f"DEBUG CONFIG: '{parent_dir}' already in sys.path.")

try:
    import constants as C
    print(f"DEBUG CONFIG: Successfully imported 'constants as C'. TILE_SIZE: {C.TILE_SIZE if hasattr(C, 'TILE_SIZE') else 'NOT FOUND'}")
except ImportError as e:
    print(f"CRITICAL CONFIG ERROR: Failed to import 'constants as C' from '{parent_dir}'. Error: {e}")
    print(f"DEBUG CONFIG: sys.path was: {sys.path}")
    class FallbackConstants:
        TILE_SIZE = 32; WHITE = (255,255,255); BLACK = (0,0,0); RED = (255,0,0); GREEN = (0,255,0)
        BLUE = (0,0,255); GRAY = (128,128,128); DARK_GRAY = (50,50,50); YELLOW = (255,255,0)
        LIGHT_BLUE = (173,216,230); DARK_GREEN = (0,100,0); ORANGE_RED = (255,69,0)
        LIGHT_GRAY = (200,200,200); FPS = 60
        MAGENTA = (255, 0, 255)  # <--- ADDED MAGENTA HERE
    C = FallbackConstants()
    print("CRITICAL CONFIG ERROR: Using fallback constants. Editor functionality will be impaired.")
except Exception as e_gen:
    print(f"CRITICAL CONFIG ERROR: Unexpected error importing 'constants': {e_gen}"); traceback.print_exc()
    sys.exit("Failed to initialize constants in editor_config.py")


# --- Editor Window Dimensions ---
EDITOR_SCREEN_INITIAL_WIDTH = 1280
EDITOR_SCREEN_INITIAL_HEIGHT = 720

MENU_SECTION_WIDTH = 280
MENU_SECTION_HEIGHT = 250

ASSET_PALETTE_SECTION_WIDTH = 220

SECTION_PADDING = 10

MAP_VIEW_SECTION_DEFAULT_WIDTH = EDITOR_SCREEN_INITIAL_WIDTH - MENU_SECTION_WIDTH - ASSET_PALETTE_SECTION_WIDTH - (SECTION_PADDING * 3)
MAP_VIEW_SECTION_DEFAULT_HEIGHT = EDITOR_SCREEN_INITIAL_HEIGHT - (SECTION_PADDING * 2)

# --- UI Element Sizes & Colors ---
BUTTON_WIDTH_STANDARD = 200
BUTTON_HEIGHT_STANDARD = 50
BUTTON_TEXT_COLOR: Tuple[int,int,int] = getattr(C, 'WHITE', (255,255,255))
BUTTON_COLOR_NORMAL: Tuple[int,int,int] = getattr(C, 'BLUE', (0,0,255))
BUTTON_COLOR_HOVER: Tuple[int,int,int] = getattr(C, 'GREEN', (0,255,0))
BUTTON_COLOR_BORDER: Tuple[int,int,int] = getattr(C, 'BLACK', (0,0,0))
BUTTON_BORDER_WIDTH = 2

ASSET_THUMBNAIL_MAX_WIDTH = getattr(C, 'TILE_SIZE', 32) * 2
ASSET_THUMBNAIL_MAX_HEIGHT = getattr(C, 'TILE_SIZE', 32) * 2
ASSET_PALETTE_ITEM_PADDING = 5
ASSET_PALETTE_BG_COLOR: Tuple[int,int,int] = (30, 30, 30)
ASSET_PALETTE_CATEGORY_TEXT_COLOR: Tuple[int,int,int] = getattr(C, 'YELLOW', (255,255,0))
ASSET_PALETTE_TOOLTIP_COLOR: Tuple[int,int,int] = getattr(C, 'LIGHT_GRAY', (200,200,200))
ASSET_PALETTE_HOVER_BG_COLOR: Tuple[int,int,int] = (50, 80, 50)

MAP_VIEW_GRID_COLOR: Tuple[int,int,int] = getattr(C, 'GRAY', (128,128,128))
MAP_VIEW_BORDER_COLOR: Tuple[int,int,int] = getattr(C, 'GRAY', (128,128,128))
MAP_VIEW_CAMERA_PAN_SPEED: int = getattr(C, 'TILE_SIZE', 32) // 2

DIALOG_BG_COLOR: Tuple[int,int,int] = (60, 60, 70)
DIALOG_INPUT_BOX_COLOR: Tuple[int,int,int] = getattr(C, 'WHITE', (255,255,255))
DIALOG_INPUT_TEXT_COLOR: Tuple[int,int,int] = getattr(C, 'BLACK', (0,0,0))
DIALOG_PROMPT_COLOR: Tuple[int,int,int] = getattr(C, 'WHITE', (255,255,255))
DIALOG_CURSOR_COLOR: Tuple[int,int,int] = getattr(C, 'BLACK', (0,0,0))

COLOR_PICKER_BUTTON_SIZE = 40
COLOR_PICKER_PADDING = 8
COLOR_PICKER_COLS = 5
COLOR_PICKER_BG_COLOR: Tuple[int,int,int] = (40, 40, 50)
COLOR_PICKER_TITLE_COLOR: Tuple[int,int,int] = getattr(C, 'WHITE', (255,255,255))
COLOR_PICKER_HOVER_BORDER_COLOR: Tuple[int,int,int] = getattr(C, 'YELLOW', (255,255,0))

MAPS_DIRECTORY = "maps"

# --- Asset Definitions for Editor Palette ---
EDITOR_PALETTE_ASSETS: Dict[str, Dict[str, Any]] = { # Added Any
    "player1_spawn": {
        "source_file": "characters/player1/__Idle.gif", "game_type_id": "player1_spawn",
        "tooltip": "P1", "category": "spawn"
    },
    "player2_spawn": {
        "source_file": "characters/player2/__Idle.gif", "game_type_id": "player2_spawn",
        "tooltip": "P2", "category": "spawn"
    },
    "enemy_cyan": {
        "source_file": "characters/cyan/__Idle.gif", "game_type_id": "enemy_cyan",
        "tooltip": "Enemy (Cyan)", "category": "enemy"
    },
    "enemy_green": {
        "source_file": "characters/green/__Idle.gif", "game_type_id": "enemy_green",
        "tooltip": "Enemy (Green)", "category": "enemy"
    },
    "enemy_pink": {
        "source_file": "characters/pink/__Idle.gif", "game_type_id": "enemy_pink",
        "tooltip": "Enemy (Pink)", "category": "enemy"
    },
    "enemy_purple": {
        "source_file": "characters/purple/__Idle.gif", "game_type_id": "enemy_purple",
        "tooltip": "Enemy (Purple)", "category": "enemy"
    },
    "enemy_red": {
        "source_file": "characters/red/__Idle.gif", "game_type_id": "enemy_red",
        "tooltip": "Enemy (Red)", "category": "enemy"
    },
    "enemy_yellow": {
        "source_file": "characters/yellow/__Idle.gif", "game_type_id": "enemy_yellow",
        "tooltip": "Enemy (Yellow)", "category": "enemy"
    },
    "chest": {
        "source_file": "characters/items/chest.gif", "game_type_id": "chest",
        "tooltip": "Chest", "category": "item"
    },
    "platform_wall_gray": {
        "surface_params": (getattr(C, 'TILE_SIZE', 32), getattr(C, 'TILE_SIZE', 32), getattr(C, 'GRAY', (128,128,128))),
        "game_type_id": "platform_wall_gray", "tooltip": "Wall (Gray)", "category": "tile"
    },
    "platform_ledge_green": {
        "surface_params": (getattr(C, 'TILE_SIZE', 32), getattr(C, 'TILE_SIZE', 32), getattr(C, 'DARK_GREEN', (0,100,0))),
        "game_type_id": "platform_ledge_green", "tooltip": "Ledge (Green)", "category": "tile"
    },
    "hazard_lava_tile": {
        "surface_params": (getattr(C, 'TILE_SIZE', 32), getattr(C, 'TILE_SIZE', 32), getattr(C, 'ORANGE_RED', (255,69,0))),
        "game_type_id": "hazard_lava", "tooltip": "Lava Tile", "category": "hazard"
    },
}

EDITOR_PALETTE_ASSETS_CATEGORIES_ORDER = ["tile", "hazard", "item", "enemy", "spawn", "unknown"]

DEFAULT_MAP_WIDTH_TILES = 30
DEFAULT_MAP_HEIGHT_TILES = 20
DEFAULT_GRID_SIZE = getattr(C, 'TILE_SIZE', 32)
DEFAULT_BACKGROUND_COLOR: Tuple[int,int,int] = getattr(C, 'LIGHT_BLUE', (173,216,230))

LEVEL_EDITOR_SAVE_FORMAT_EXTENSION = ".json"
GAME_LEVEL_FILE_EXTENSION = ".py"

TOOLTIP_FONT_SIZE = 18
TOOLTIP_TEXT_COLOR: Tuple[int,int,int] = getattr(C, 'BLACK', (0,0,0))
TOOLTIP_BG_COLOR: Tuple[int,int,int] = (240, 240, 210)
TOOLTIP_PADDING = 5
TOOLTIP_OFFSET_Y = 25

COLOR_PICKER_PRESETS: Dict[str, Tuple[int,int,int]] = {
    "Light Blue": getattr(C, 'LIGHT_BLUE', (173,216,230)), "White": getattr(C, 'WHITE', (255,255,255)),
    "Black": getattr(C, 'BLACK', (0,0,0)), "Gray": getattr(C, 'GRAY', (128,128,128)),
    "Dark Gray": getattr(C, 'DARK_GRAY', (50,50,50)), "Red": getattr(C, 'RED', (255,0,0)),
    "Green": getattr(C, 'GREEN', (0,255,0)), "Blue": getattr(C, 'BLUE', (0,0,255)),
    "Yellow": getattr(C, 'YELLOW', (255,255,0)), "Orange": getattr(C, 'ORANGE_RED', (255,69,0)),
    "Purple": (128, 0, 128), "Brown": (139, 69, 19),
    "Dark Green": getattr(C, 'DARK_GREEN', (0,100,0)), "Sky Blue": (100, 150, 255),
    "Dark Purple": (75,0,130), "Sand": (244,164,96),
    "Magenta": getattr(C, 'MAGENTA', (255, 0, 255)) # Ensure Magenta is also here if needed as a selectable preset
}

FONT_CONFIG: Dict[str, Optional[pygame.font.Font]] = {
    "small": None, "medium": None, "large": None, "tooltip": None
}
try:
    if not pygame.font.get_init():
        print("DEBUG CONFIG: pygame.font not initialized, calling pygame.font.init()")
        pygame.font.init()

    if pygame.font.get_init():
        FONT_CONFIG["small"] = pygame.font.Font(None, 22)
        FONT_CONFIG["medium"] = pygame.font.Font(None, 28)
        FONT_CONFIG["large"] = pygame.font.Font(None, 36)
        FONT_CONFIG["tooltip"] = pygame.font.Font(None, TOOLTIP_FONT_SIZE)
        print("DEBUG CONFIG: Successfully initialized fonts in FONT_CONFIG.")
    else:
        print("CRITICAL CONFIG ERROR: pygame.font.init() failed. Fonts will be None.")
except pygame.error as e:
    print(f"CRITICAL CONFIG ERROR: Pygame error initializing fonts in editor_config: {e}"); traceback.print_exc()
except Exception as e_font:
    print(f"CRITICAL CONFIG ERROR: Generic error initializing fonts in editor_config: {e_font}"); traceback.print_exc()

for font_name, font_obj in FONT_CONFIG.items():
    if font_obj is None:
        print(f"WARNING CONFIG: Font '{font_name}' is None. UI elements using it might not render text correctly.")

print("DEBUG CONFIG: editor_config.py loaded.")

########## START OF FILE: editor_drawing.py ##########

# editor_drawing.py
# -*- coding: utf-8 -*-
"""
## version 1.0.0.13 (Removed all semicolons again, verified side-by-side spawn)
Contains functions for drawing the different sections and elements
of the Platformer Level Editor UI using Pygame.
"""
import pygame
from typing import Dict, Tuple, Any, Optional 
import traceback 

import editor_config as ED_CONFIG
from editor_state import EditorState
from editor_ui import draw_button


def draw_menu_ui(surface: pygame.Surface, editor_state: EditorState, menu_section_rect: pygame.Rect,
                 fonts: Dict[str, Optional[pygame.font.Font]], mouse_pos: Tuple[int, int]):
    try:
        pygame.draw.rect(surface, getattr(ED_CONFIG.C, 'BLACK', (0,0,0)), menu_section_rect) 
        title_font = fonts.get("large") or ED_CONFIG.FONT_CONFIG.get("large")
        button_font = fonts.get("medium") or ED_CONFIG.FONT_CONFIG.get("medium")

        if title_font:
            title_surf = title_font.render("Level Editor", True, getattr(ED_CONFIG.C, 'WHITE', (255,255,255)))
            title_rect = title_surf.get_rect(centerx=menu_section_rect.centerx, top=menu_section_rect.top + 20)
            surface.blit(title_surf, title_rect)
        
        button_w = ED_CONFIG.BUTTON_WIDTH_STANDARD
        button_h = ED_CONFIG.BUTTON_HEIGHT_STANDARD
        spacing = 20
        num_buttons = 3
        total_button_h = (num_buttons * button_h) + ((num_buttons - 1) * spacing)
        title_h_approx = title_font.get_height() if title_font else 40
        content_start_y = menu_section_rect.top + title_h_approx + 30
        remaining_h = menu_section_rect.height - (content_start_y - menu_section_rect.top)
        start_y = max(content_start_y + (remaining_h - total_button_h) // 2, content_start_y)

        if not hasattr(editor_state, 'ui_elements_rects') or editor_state.ui_elements_rects is None:
            editor_state.ui_elements_rects = {}
        for k in [key for key in editor_state.ui_elements_rects if key.startswith("menu_")]:
            del editor_state.ui_elements_rects[k]
        
        if button_font:
            rect_params = [
                (start_y, "menu_new_map", "New Map"), 
                (start_y + button_h + spacing, "menu_load_map", "Load Map (.json)"),
                (start_y + 2 * (button_h + spacing), "menu_quit", "Quit Editor")
            ]
            for top_y, key, text in rect_params:
                btn_r = pygame.Rect(0,0,button_w,button_h)
                btn_r.centerx = menu_section_rect.centerx
                btn_r.top = top_y
                editor_state.ui_elements_rects[key] = btn_r
                draw_button(surface, btn_r, text, button_font, mouse_pos)
        else: 
            print("Warning DRAW: Menu button font missing.")
    except Exception as e: 
        print(f"ERROR DRAW: Exception in draw_menu_ui: {e}")
        traceback.print_exc()


def _draw_single_palette_item(scroll_surf: pygame.Surface, 
                              editor_state: EditorState, 
                              palette_section_rect: pygame.Rect, 
                              asset_key: str, asset_data: Dict[str, Any], 
                              item_x: int, item_y_on_scroll: int, 
                              tip_font: Optional[pygame.font.Font], 
                              mouse_pos: Tuple[int, int]) -> int:
    img = asset_data.get("image")
    tooltip_text = asset_data.get("tooltip", asset_key)
    if not img: return 0 

    item_rect_on_screen = pygame.Rect(
        palette_section_rect.left + item_x,
        palette_section_rect.top + item_y_on_scroll - editor_state.asset_palette_scroll_y,
        img.get_width(), img.get_height()
    )
    editor_state.ui_elements_rects['asset_palette_items'][asset_key] = item_rect_on_screen

    is_hovered = item_rect_on_screen.collidepoint(mouse_pos) and palette_section_rect.collidepoint(mouse_pos)
    is_selected = editor_state.selected_asset_editor_key == asset_key

    if is_hovered:
        editor_state.hovered_tooltip_text = tooltip_text
        editor_state.hovered_tooltip_pos = mouse_pos
        hover_bg_r = pygame.Rect(item_x - 2, item_y_on_scroll - 2, img.get_width() + 4, img.get_height() + 4)
        pygame.draw.rect(scroll_surf, ED_CONFIG.ASSET_PALETTE_HOVER_BG_COLOR, hover_bg_r, border_radius=2)
    if is_selected:
        select_b_r = pygame.Rect(item_x - 3, item_y_on_scroll - 3, img.get_width() + 6, img.get_height() + 6)
        pygame.draw.rect(scroll_surf, ED_CONFIG.C.YELLOW, select_b_r, 2, border_radius=3)
    
    scroll_surf.blit(img, (item_x, item_y_on_scroll))
    current_item_total_height = img.get_height()

    if tip_font:
        name_s = tip_font.render(tooltip_text, True, ED_CONFIG.ASSET_PALETTE_TOOLTIP_COLOR)
        text_x = item_x + (img.get_width() - name_s.get_width()) // 2
        scroll_surf.blit(name_s, (max(item_x, text_x), item_y_on_scroll + img.get_height() + 2))
        current_item_total_height += name_s.get_height() + 2
    
    return current_item_total_height


def draw_asset_palette_ui(surface: pygame.Surface, editor_state: EditorState, palette_section_rect: pygame.Rect,
                          fonts: Dict[str, Optional[pygame.font.Font]], mouse_pos: Tuple[int, int]):
    try:
        pygame.draw.rect(surface, ED_CONFIG.ASSET_PALETTE_BG_COLOR, palette_section_rect)
        if editor_state.total_asset_palette_content_height <= 0:
            font_small = fonts.get("small") or ED_CONFIG.FONT_CONFIG.get("small")
            if font_small:
                no_assets_text = "Assets Loading/Error..."
                if not ED_CONFIG.EDITOR_PALETTE_ASSETS: no_assets_text = "No assets defined."
                elif not editor_state.assets_palette : no_assets_text = "Asset palette empty."
                msg_surf = font_small.render(no_assets_text, True, getattr(ED_CONFIG.C, 'WHITE', (255,255,255)))
                surface.blit(msg_surf, msg_surf.get_rect(center=palette_section_rect.center))
            return

        scroll_surf = pygame.Surface((palette_section_rect.width, editor_state.total_asset_palette_content_height), pygame.SRCALPHA)
        scroll_surf.fill((0,0,0,0)) 
        current_y_on_scroll_surf = ED_CONFIG.ASSET_PALETTE_ITEM_PADDING
        cat_font = fonts.get("medium") or ED_CONFIG.FONT_CONFIG.get("medium")
        tip_font = fonts.get("small") or ED_CONFIG.FONT_CONFIG.get("small")
        
        editor_state.hovered_tooltip_text = None
        if not hasattr(editor_state, 'ui_elements_rects') or editor_state.ui_elements_rects is None: editor_state.ui_elements_rects = {}
        editor_state.ui_elements_rects['asset_palette_items'] = {}
        
        categories_order = getattr(ED_CONFIG, 'EDITOR_PALETTE_ASSETS_CATEGORIES_ORDER', 
                                   ["tile", "hazard", "item", "enemy", "spawn", "unknown"])

        for cat_name in categories_order:
            assets_in_category_tuples = [(k, d) for k, d in editor_state.assets_palette.items() if d.get("category", "unknown") == cat_name]
            if not assets_in_category_tuples: continue

            if cat_font:
                cat_surf = cat_font.render(cat_name.title(), True, ED_CONFIG.ASSET_PALETTE_CATEGORY_TEXT_COLOR)
                scroll_surf.blit(cat_surf, (ED_CONFIG.ASSET_PALETTE_ITEM_PADDING, current_y_on_scroll_surf))
                current_y_on_scroll_surf += cat_surf.get_height() + ED_CONFIG.ASSET_PALETTE_ITEM_PADDING
            
            row_start_y_for_current_items = current_y_on_scroll_surf 
            
            if cat_name == "spawn":
                p1_item_tuple = next(((k,d) for k,d in assets_in_category_tuples if k == "player1_spawn"), None)
                p2_item_tuple = next(((k,d) for k,d in assets_in_category_tuples if k == "player2_spawn"), None)
                other_items_in_this_category = [item for item in assets_in_category_tuples if item[0] not in ["player1_spawn", "player2_spawn"]]
                
                current_x_in_row = ED_CONFIG.ASSET_PALETTE_ITEM_PADDING
                max_h_for_this_row = 0

                if p1_item_tuple:
                    h = _draw_single_palette_item(scroll_surf, editor_state, palette_section_rect, p1_item_tuple[0], p1_item_tuple[1], current_x_in_row, row_start_y_for_current_items, tip_font, mouse_pos)
                    max_h_for_this_row = max(max_h_for_this_row, h)
                    if p1_item_tuple[1].get("image"):
                        current_x_in_row += p1_item_tuple[1]["image"].get_width() + ED_CONFIG.ASSET_PALETTE_ITEM_PADDING 
                
                if p2_item_tuple:
                    p2_img = p2_item_tuple[1].get("image")
                    if p2_img and current_x_in_row + p2_img.get_width() > palette_section_rect.width - ED_CONFIG.ASSET_PALETTE_ITEM_PADDING:
                        # Not enough horizontal space for P2 on the same line, advance Y
                        current_y_on_scroll_surf = row_start_y_for_current_items + max_h_for_this_row + ED_CONFIG.ASSET_PALETTE_ITEM_PADDING
                        row_start_y_for_current_items = current_y_on_scroll_surf # Update row_start_y for P2
                        current_x_in_row = ED_CONFIG.ASSET_PALETTE_ITEM_PADDING # Reset X for P2
                        max_h_for_this_row = 0 # Reset max height for this new "row" (which only has P2)

                    h = _draw_single_palette_item(scroll_surf, editor_state, palette_section_rect, p2_item_tuple[0], p2_item_tuple[1], current_x_in_row, row_start_y_for_current_items, tip_font, mouse_pos)
                    max_h_for_this_row = max(max_h_for_this_row, h)
                
                if max_h_for_this_row > 0:
                    current_y_on_scroll_surf = row_start_y_for_current_items + max_h_for_this_row + ED_CONFIG.ASSET_PALETTE_ITEM_PADDING
                
                assets_to_draw_this_category_loop = other_items_in_this_category
            else:
                assets_to_draw_this_category_loop = assets_in_category_tuples

            for asset_key, asset_data in assets_to_draw_this_category_loop:
                item_x_vertical = ED_CONFIG.ASSET_PALETTE_ITEM_PADDING
                item_y_vertical = current_y_on_scroll_surf
                
                item_total_height = _draw_single_palette_item(scroll_surf, editor_state, palette_section_rect, asset_key, asset_data, item_x_vertical, item_y_vertical, tip_font, mouse_pos)
                current_y_on_scroll_surf = item_y_vertical + item_total_height + ED_CONFIG.ASSET_PALETTE_ITEM_PADDING
            
            if assets_in_category_tuples : 
                current_y_on_scroll_surf += ED_CONFIG.ASSET_PALETTE_ITEM_PADDING

        surface.blit(scroll_surf, palette_section_rect.topleft, (0, editor_state.asset_palette_scroll_y, palette_section_rect.width, palette_section_rect.height))
        pygame.draw.rect(surface, getattr(ED_CONFIG.C, 'GRAY', (128,128,128)), palette_section_rect, 2)
        btn_font = fonts.get("small") or ED_CONFIG.FONT_CONFIG.get("small")
        if btn_font:
            btn_h = ED_CONFIG.BUTTON_HEIGHT_STANDARD*0.8
            cp_btn_r = pygame.Rect(palette_section_rect.left+ED_CONFIG.ASSET_PALETTE_ITEM_PADDING, palette_section_rect.bottom-btn_h-ED_CONFIG.ASSET_PALETTE_ITEM_PADDING, palette_section_rect.width-ED_CONFIG.ASSET_PALETTE_ITEM_PADDING*2, int(btn_h))
            editor_state.ui_elements_rects["palette_bg_color_button"] = cp_btn_r
            bg_lum = sum(editor_state.background_color)/3
            txt_col = getattr(ED_CONFIG.C, 'BLACK', (0,0,0)) if bg_lum > 128*1.5 else getattr(ED_CONFIG.C, 'WHITE', (255,255,255))
            draw_button(surface,cp_btn_r,"BG Color",btn_font,mouse_pos,text_color=txt_col,button_color_normal=editor_state.background_color,button_color_hover=pygame.Color(editor_state.background_color).lerp(getattr(ED_CONFIG.C, 'WHITE', (255,255,255)),0.3),border_color=getattr(ED_CONFIG.C, 'BLACK', (0,0,0)))
    except Exception as e: 
        print(f"ERROR DRAW: draw_asset_palette_ui: {e}")
        traceback.print_exc()


def draw_map_view_ui(surface: pygame.Surface, editor_state: EditorState, map_view_rect: pygame.Rect,
                     fonts: Dict[str, Optional[pygame.font.Font]], mouse_pos: Tuple[int, int]):
    try:
        if not editor_state.map_content_surface:
            pygame.draw.rect(surface, getattr(ED_CONFIG.C, 'DARK_GRAY', (50,50,50)), map_view_rect) 
            ph_font = fonts.get("medium") or ED_CONFIG.FONT_CONFIG.get("medium")
            if ph_font: 
                txt_surf = ph_font.render("No Map/Surface Error", True, getattr(ED_CONFIG.C, 'WHITE', (255,255,255)))
                surface.blit(txt_surf, txt_surf.get_rect(center=map_view_rect.center))
            pygame.draw.rect(surface, ED_CONFIG.MAP_VIEW_BORDER_COLOR, map_view_rect, 2)
            return

        editor_state.map_content_surface.fill(editor_state.background_color)
        for obj in editor_state.placed_objects:
            key,wx,wy=obj.get("asset_editor_key"),obj.get("world_x"),obj.get("world_y")
            if wx is None or wy is None: continue
            info = editor_state.assets_palette.get(key) if key else None
            if info and info.get("image"): 
                editor_state.map_content_surface.blit(info["image"], (wx,wy))
            else: 
                pygame.draw.rect(editor_state.map_content_surface, getattr(ED_CONFIG.C, 'RED', (255,0,0)), (wx,wy,editor_state.grid_size,editor_state.grid_size),1)
        
        if editor_state.show_grid: 
            draw_grid_on_map_surface(editor_state.map_content_surface, editor_state)
        
        surface.blit(editor_state.map_content_surface, map_view_rect.topleft, (editor_state.camera_offset_x, editor_state.camera_offset_y, map_view_rect.width, map_view_rect.height))
        pygame.draw.rect(surface, ED_CONFIG.MAP_VIEW_BORDER_COLOR, map_view_rect, 2)
        
        if editor_state.selected_asset_image_for_cursor:
            img = editor_state.selected_asset_image_for_cursor
            pos = img.get_rect(center=mouse_pos).topleft
            if map_view_rect.collidepoint(mouse_pos):
                world_mx = mouse_pos[0]-map_view_rect.left+editor_state.camera_offset_x
                world_my = mouse_pos[1]-map_view_rect.top+editor_state.camera_offset_y
                grid_wx = (world_mx//editor_state.grid_size)*editor_state.grid_size
                grid_wy = (world_my//editor_state.grid_size)*editor_state.grid_size
                pos = (grid_wx-editor_state.camera_offset_x+map_view_rect.left, grid_wy-editor_state.camera_offset_y+map_view_rect.top)
            
            clip_orig = surface.get_clip()
            surface.set_clip(map_view_rect)
            surface.blit(img,pos)
            surface.set_clip(clip_orig)
        
        _draw_map_view_info_text(surface, editor_state, map_view_rect, fonts, mouse_pos)
    except Exception as e: 
        print(f"ERROR DRAW: draw_map_view_ui: {e}")
        traceback.print_exc()

def _draw_map_view_info_text(surface: pygame.Surface, editor_state: EditorState, map_view_rect: pygame.Rect, 
                             fonts: Dict[str, Optional[pygame.font.Font]], general_mouse_pos: Tuple[int, int]):
    info_font = fonts.get("small") or ED_CONFIG.FONT_CONFIG.get("small")
    if not info_font: return

    lines = ["LMB Drag: Paint, RMB Drag: Erase", "WASD: Pan, G: Grid, ESC: Deselect/Menu", "Shift+RMB(Map): Save All", "Ctrl+S: Save All"]
    line_h = info_font.get_height()+3
    y_start = map_view_rect.bottom+7
    
    for i,line_text in enumerate(lines):
        txt_surf = info_font.render(line_text,True,getattr(ED_CONFIG.C, 'YELLOW', (255,255,0)))
        y_draw = y_start + i*line_h
        if y_draw + line_h > surface.get_height()-5: 
            y_draw = surface.get_height()-5 - line_h*(len(lines)-i)
        if i==0: y_draw = max(5, y_draw) 
        surface.blit(txt_surf, (map_view_rect.left+5, y_draw))
        
    coords_text_str = f"Cam:({editor_state.camera_offset_x},{editor_state.camera_offset_y})"
    if map_view_rect.collidepoint(general_mouse_pos):
        world_mx = general_mouse_pos[0]-map_view_rect.left+editor_state.camera_offset_x
        world_my = general_mouse_pos[1]-map_view_rect.top+editor_state.camera_offset_y
        tx,ty = world_mx//editor_state.grid_size, world_my//editor_state.grid_size
        coords_text_str += f" MouseW:({world_mx},{world_my}) Tile:({tx},{ty})"
    
    coords_surf = info_font.render(coords_text_str,True,getattr(ED_CONFIG.C, 'WHITE', (255,255,255)))
    coords_y_pos = map_view_rect.top-coords_surf.get_height()-4
    coords_x_pos = map_view_rect.left+5
    if coords_y_pos < 5: 
        coords_y_pos = y_start + len(lines)*line_h + 5 
        if coords_y_pos + coords_surf.get_height() > surface.get_height()-5: 
             coords_y_pos = surface.get_height()-5-coords_surf.get_height()
    surface.blit(coords_surf, (coords_x_pos, coords_y_pos))

def draw_grid_on_map_surface(map_content_surface: pygame.Surface, editor_state: EditorState):
    if not (editor_state.show_grid and editor_state.map_content_surface and editor_state.grid_size > 0): return
    w,h,gs = editor_state.get_map_pixel_width(), editor_state.get_map_pixel_height(), editor_state.grid_size
    gc = getattr(ED_CONFIG, 'MAP_VIEW_GRID_COLOR', (128,128,128)) 
    try:
        for x_coord in range(0, w + gs, gs): 
            pygame.draw.line(map_content_surface,gc,(x_coord,0),(x_coord,h)) 
        for y_coord in range(0, h + gs, gs): 
            pygame.draw.line(map_content_surface,gc,(0,y_coord),(w,y_coord)) 
    except Exception as e: 
        print(f"ERROR DRAW: draw_grid_on_map_surface: {e}")
        traceback.print_exc()

########## START OF FILE: editor_event_handlers.py ##########

# editor_event_handlers.py
# -*- coding: utf-8 -*-
"""
## version 1.0.0.15 (Corrected MOUSEMOTION for painting/erasing, general cleanup)
Handles Pygame events for different modes and UI elements
of the Platformer Level Editor.
"""
import pygame
import os
from typing import Optional, Dict, Tuple, Any, Callable, List
import traceback

import editor_config as ED_CONFIG
from editor_state import EditorState
from editor_ui import start_text_input_dialog, start_color_picker_dialog, start_file_load_dialog
from editor_map_utils import (init_new_map_state, save_map_to_json,
                              load_map_from_json, export_map_to_game_python_script)

def handle_global_events(event: pygame.event.Event, editor_state: EditorState, main_screen: pygame.Surface) -> bool:
    if event.type == pygame.QUIT:
        print("DEBUG GLOBAL_EVENT: pygame.QUIT event received.")
        if editor_state.unsaved_changes:
            if not getattr(editor_state, '_quit_attempted_with_unsaved_changes', False):
                editor_state.set_status_message("Unsaved changes! Quit again to exit without saving, or save your map.", 5.0)
                editor_state._quit_attempted_with_unsaved_changes = True
                return True 
            else: 
                print("DEBUG GLOBAL_EVENT: Second quit attempt with unsaved changes. Proceeding to quit.")
                if hasattr(editor_state, '_quit_attempted_with_unsaved_changes'):
                    del editor_state._quit_attempted_with_unsaved_changes
                return False
        else: 
            if hasattr(editor_state, '_quit_attempted_with_unsaved_changes'):
                del editor_state._quit_attempted_with_unsaved_changes
            return False

    if event.type == pygame.VIDEORESIZE:
        print(f"DEBUG GLOBAL_EVENT: pygame.VIDEORESIZE to {event.w}x{event.h}")
        editor_state.set_status_message(f"Resized to {event.w}x{event.h}", 2.0)
    
    if event.type != pygame.QUIT and hasattr(editor_state, '_quit_attempted_with_unsaved_changes'):
        del editor_state._quit_attempted_with_unsaved_changes
        
    return True


def handle_dialog_events(event: pygame.event.Event, editor_state: EditorState):
    if not editor_state.active_dialog_type:
        return

    confirmed = False
    cancelled = False
    selected_value_from_dialog: Any = None
    dialog_type_being_processed = editor_state.active_dialog_type

    if event.type == pygame.KEYDOWN:
        if event.key == pygame.K_ESCAPE: cancelled = True
        elif event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
            if dialog_type_being_processed == "text_input":
                confirmed = True; selected_value_from_dialog = editor_state.dialog_input_text
            elif dialog_type_being_processed == "file_load" and editor_state.dialog_selected_file_index != -1 and \
                 0 <= editor_state.dialog_selected_file_index < len(editor_state.dialog_file_list):
                confirmed = True; selected_value_from_dialog = os.path.join(ED_CONFIG.MAPS_DIRECTORY, editor_state.dialog_file_list[editor_state.dialog_selected_file_index])
            elif dialog_type_being_processed == "file_load": editor_state.set_status_message("No file selected.", 2.5)
        if dialog_type_being_processed == "text_input":
            if event.key == pygame.K_BACKSPACE: editor_state.dialog_input_text = editor_state.dialog_input_text[:-1]
            elif event.unicode.isprintable() and (event.unicode.isalnum() or event.unicode in ['.', '_', '-', ' ', ',', '/', '\\']): editor_state.dialog_input_text += event.unicode
        elif dialog_type_being_processed == "file_load" and editor_state.dialog_file_list:
            list_len = len(editor_state.dialog_file_list)
            if list_len > 0:
                if event.key == pygame.K_UP: editor_state.dialog_selected_file_index = (editor_state.dialog_selected_file_index - 1 + list_len) % list_len
                elif event.key == pygame.K_DOWN: editor_state.dialog_selected_file_index = (editor_state.dialog_selected_file_index + 1) % list_len
            else: editor_state.dialog_selected_file_index = -1
            if editor_state.dialog_selected_file_index != -1: editor_state.dialog_input_text = editor_state.dialog_file_list[editor_state.dialog_selected_file_index]
            else: editor_state.dialog_input_text = ""
    elif event.type == pygame.MOUSEBUTTONDOWN: # event.pos is valid
        if editor_state.dialog_rect and editor_state.dialog_rect.collidepoint(event.pos) and event.button == 1:
            if dialog_type_being_processed == "color_picker":
                for color_name, swatch_rect_relative in editor_state.color_picker_rects.items():
                    absolute_swatch_rect = swatch_rect_relative.move(editor_state.dialog_rect.left, editor_state.dialog_rect.top)
                    if absolute_swatch_rect.collidepoint(event.pos):
                        selected_value_from_dialog = ED_CONFIG.COLOR_PICKER_PRESETS.get(color_name);
                        if selected_value_from_dialog: confirmed = True
                        break
            elif dialog_type_being_processed == "file_load":
                ok_rect, cancel_rect = editor_state.ui_elements_rects.get("dialog_file_load_ok"), editor_state.ui_elements_rects.get("dialog_file_load_cancel")
                if ok_rect and ok_rect.collidepoint(event.pos) and editor_state.dialog_selected_file_index != -1:
                    confirmed = True; selected_value_from_dialog = os.path.join(ED_CONFIG.MAPS_DIRECTORY, editor_state.dialog_file_list[editor_state.dialog_selected_file_index])
                elif cancel_rect and cancel_rect.collidepoint(event.pos): cancelled = True
                else:
                    for item_info in editor_state.ui_elements_rects.get('dialog_file_item_rects', []):
                        if item_info["rect"].collidepoint(event.pos): editor_state.dialog_selected_file_index = item_info["index"]; editor_state.dialog_input_text = item_info["text"]; break
                    scrollbar_handle_rect = editor_state.ui_elements_rects.get('file_dialog_scrollbar_handle')
                    if scrollbar_handle_rect and scrollbar_handle_rect.collidepoint(event.pos): editor_state.is_dragging_scrollbar = True; editor_state.scrollbar_drag_mouse_offset_y = event.pos[1] - scrollbar_handle_rect.top
        elif dialog_type_being_processed != "text_input": cancelled = True
    elif event.type == pygame.MOUSEBUTTONUP: # event.pos is valid
        if event.button == 1 and editor_state.is_dragging_scrollbar: editor_state.is_dragging_scrollbar = False
    elif event.type == pygame.MOUSEMOTION: # event.pos is valid
        if editor_state.is_dragging_scrollbar:
            scrollbar_area = editor_state.ui_elements_rects.get('file_dialog_scrollbar_area'); scrollbar_handle = editor_state.ui_elements_rects.get('file_dialog_scrollbar_handle')
            if scrollbar_area and scrollbar_handle and editor_state.dialog_file_list:
                mouse_y_in_area = event.pos[1] - scrollbar_area.top; handle_pos_y = mouse_y_in_area - editor_state.scrollbar_drag_mouse_offset_y
                item_font = ED_CONFIG.FONT_CONFIG.get("small"); item_h = (item_font.get_height() + 6) if item_font else 22
                content_h = len(editor_state.dialog_file_list) * item_h; display_h = scrollbar_area.height
                track_h = max(1, display_h - scrollbar_handle.height); scroll_px = max(0, content_h - display_h)
                if track_h > 0 and scroll_px > 0: clamped_y = max(0, min(handle_pos_y, track_h)); ratio = clamped_y / track_h; editor_state.dialog_file_scroll_y = ratio * scroll_px
    elif event.type == pygame.MOUSEWHEEL: # event.y is valid, event.pos might not be relevant for wheel itself
        if dialog_type_being_processed == "file_load" and editor_state.dialog_rect and editor_state.dialog_rect.collidepoint(pygame.mouse.get_pos()): # check mouse over dialog
            font_small = ED_CONFIG.FONT_CONFIG.get("small"); item_h = (font_small.get_height() + 6) if font_small else 22
            scroll_val = event.y * item_h; content_h = len(editor_state.dialog_file_list) * item_h
            font_medium = ED_CONFIG.FONT_CONFIG.get("medium"); prompt_h = (font_medium.get_height() + 25) if font_medium else 55
            buttons_h = 40; display_h = editor_state.dialog_rect.height - prompt_h - buttons_h - 10
            max_s = max(0, content_h - display_h); editor_state.dialog_file_scroll_y -= scroll_val; editor_state.dialog_file_scroll_y = max(0, min(editor_state.dialog_file_scroll_y, max_s))

    if confirmed:
        print(f"DEBUG DIALOG_EVENT: Dialog '{dialog_type_being_processed}' outcome: CONFIRMED.")
        active_dialog_type_before_cb = editor_state.active_dialog_type
        original_confirm_cb = editor_state.dialog_callback_confirm
        original_cancel_cb = editor_state.dialog_callback_cancel
        original_prompt = editor_state.dialog_prompt_message
        
        if confirm_cb_to_call := editor_state.dialog_callback_confirm: # Python 3.8+ walrus operator
            try:
                value_to_pass = selected_value_from_dialog if selected_value_from_dialog is not None else editor_state.dialog_input_text
                print(f"DEBUG DIALOG_EVENT: Calling confirm_callback for '{dialog_type_being_processed}' with value: '{value_to_pass}'")
                confirm_cb_to_call(value_to_pass) 
            except Exception as e: print(f"ERROR: Confirm CB Exception: {e}"); traceback.print_exc()
        
        new_dialog_was_started = False
        if editor_state.active_dialog_type is not None: # If a dialog is still set
            # Check if it's a *different* dialog than the one we just processed the confirm for,
            # or if its core properties (callbacks, prompt) changed, indicating re-initialization.
            if (editor_state.active_dialog_type != active_dialog_type_before_cb or
                editor_state.dialog_callback_confirm != original_confirm_cb or
                editor_state.dialog_callback_cancel != original_cancel_cb or
                editor_state.dialog_prompt_message != original_prompt):
                new_dialog_was_started = True
        
        if new_dialog_was_started:
            print(f"DEBUG DIALOG_EVENT: Dialog '{dialog_type_being_processed}' confirmed. Callback started a NEW dialog: '{editor_state.active_dialog_type}'.")
        else: # No new dialog took over, or callback explicitly cleared active_dialog_type
            print(f"DEBUG DIALOG_EVENT: Dialog '{dialog_type_being_processed}' confirmed. No new dialog active. Cleaning up.")
            editor_state.active_dialog_type = None 
            editor_state.dialog_callback_confirm = None; editor_state.dialog_callback_cancel = None
            editor_state.dialog_input_text = ""; editor_state.dialog_selected_file_index = -1
            editor_state.is_dragging_scrollbar = False

    elif cancelled:
        print(f"DEBUG DIALOG_EVENT: Dialog '{dialog_type_being_processed}' outcome: CANCELLED.")
        active_dialog_type_before_cb = editor_state.active_dialog_type
        original_confirm_cb = editor_state.dialog_callback_confirm
        original_cancel_cb = editor_state.dialog_callback_cancel
        original_prompt = editor_state.dialog_prompt_message

        if cancel_cb_to_call := editor_state.dialog_callback_cancel:
            try:
                print(f"DEBUG DIALOG_EVENT: Calling cancel_callback for '{dialog_type_being_processed}'.")
                cancel_cb_to_call()
            except Exception as e: print(f"ERROR: Cancel CB Exception: {e}"); traceback.print_exc()

        new_dialog_was_started = False
        if editor_state.active_dialog_type is not None:
            if (editor_state.active_dialog_type != active_dialog_type_before_cb or
                editor_state.dialog_callback_confirm != original_confirm_cb or
                editor_state.dialog_callback_cancel != original_cancel_cb or
                editor_state.dialog_prompt_message != original_prompt):
                new_dialog_was_started = True
        
        if new_dialog_was_started:
             print(f"DEBUG DIALOG_EVENT: Dialog '{dialog_type_being_processed}' cancelled. Callback started a NEW dialog: '{editor_state.active_dialog_type}'.")
        else:
            print(f"DEBUG DIALOG_EVENT: Dialog '{dialog_type_being_processed}' cancelled. No new dialog active. Cleaning up.")
            editor_state.active_dialog_type = None
            editor_state.dialog_callback_confirm = None; editor_state.dialog_callback_cancel = None
            editor_state.dialog_input_text = ""; editor_state.dialog_selected_file_index = -1
            editor_state.is_dragging_scrollbar = False


def handle_menu_events(event: pygame.event.Event, editor_state: EditorState, main_screen: pygame.Surface):
    if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
        mouse_pos = event.pos # Safe here
        ui_rects = editor_state.ui_elements_rects 
        
        if ui_rects.get("menu_new_map") and ui_rects["menu_new_map"].collidepoint(mouse_pos):
            print("DEBUG MENU_EVENT: 'New Map' button clicked.")
            def on_new_map_name_confirm(map_name: str):
                map_name = map_name.strip()
                if not map_name:
                    editor_state.set_status_message("Map name cannot be empty.", 3)
                    start_text_input_dialog(editor_state, "Name:", "", on_new_map_name_confirm, lambda: print("DEBUG MENU_EVENT: Name re-prompt cancelled"))
                    return
                editor_state.map_name_for_function_input = map_name
                def on_map_size_confirm(size_str: str):
                    try:
                        parts = [s.strip() for s in size_str.split(',')]
                        if len(parts) != 2 or not all(s.isdigit() for s in parts): raise ValueError("Format: W,H (numbers)")
                        w, h = int(parts[0]), int(parts[1])
                        if not (w > 0 and h > 0): raise ValueError("Dimensions > 0")
                        
                        init_new_map_state(editor_state, editor_state.map_name_for_function_input, w, h)
                        print(f"DEBUG MENU_EVENT: Auto-saving new map '{editor_state.map_name_for_function}'")
                        if save_map_to_json(editor_state) and export_map_to_game_python_script(editor_state):
                            editor_state.set_status_message(f"Map '{editor_state.map_name_for_function}' auto-saved.", 3)
                            # unsaved_changes is set False by export_map_to_game_python_script
                            pygame.display.set_caption(f"Editor - {editor_state.map_name_for_function}.py")
                        else:
                            editor_state.set_status_message(f"Auto-save failed for '{editor_state.map_name_for_function}'.", 4)
                            # Ensure unsaved_changes is true if save failed
                            editor_state.unsaved_changes = True 
                            pygame.display.set_caption(f"Editor - {editor_state.map_name_for_function}.py*")
                        editor_state.current_editor_mode = "editing_map"
                    except Exception as e:
                        editor_state.set_status_message(f"Invalid size: {e}", 3.5)
                        start_text_input_dialog(editor_state, "Size (W,H):", f"{ED_CONFIG.DEFAULT_MAP_WIDTH_TILES},{ED_CONFIG.DEFAULT_MAP_HEIGHT_TILES}", on_map_size_confirm, lambda: print("DEBUG MENU_EVENT: Size re-prompt cancelled"))
                start_text_input_dialog(editor_state, "Size (W,H):", f"{ED_CONFIG.DEFAULT_MAP_WIDTH_TILES},{ED_CONFIG.DEFAULT_MAP_HEIGHT_TILES}", on_map_size_confirm, lambda: print("DEBUG MENU_EVENT: Size dialog cancelled"))
            start_text_input_dialog(editor_state, "New Map Name:", "my_map", on_new_map_name_confirm, lambda: print("DEBUG MENU_EVENT: Name dialog cancelled"))
            return

        elif ui_rects.get("menu_load_map") and ui_rects["menu_load_map"].collidepoint(mouse_pos):
            print("DEBUG MENU_EVENT: 'Load Map' button clicked.")
            def on_file_selected(fp: str):
                if load_map_from_json(editor_state, fp):
                    editor_state.current_editor_mode = "editing_map"; pygame.display.set_caption(f"Editor - {editor_state.map_name_for_function}.py")
            start_file_load_dialog(editor_state, on_confirm=on_file_selected, on_cancel=lambda: print("DEBUG MENU_EVENT: Load dialog cancelled"))
            return

        elif ui_rects.get("menu_quit") and ui_rects["menu_quit"].collidepoint(mouse_pos):
            pygame.event.post(pygame.event.Event(pygame.QUIT))


def _place_tile_at_grid(editor_state: EditorState, grid_coords: Tuple[int, int]):
    if not editor_state.selected_asset_editor_key: return
    grid_world_x = grid_coords[0] * editor_state.grid_size
    grid_world_y = grid_coords[1] * editor_state.grid_size
    asset_data = editor_state.assets_palette[editor_state.selected_asset_editor_key]
    new_obj_game_type_id = asset_data["game_type_id"]
    is_spawn_item = asset_data.get("category") == "spawn"

    if not is_spawn_item:
        for obj in editor_state.placed_objects:
            if obj.get("world_x") == grid_world_x and \
               obj.get("world_y") == grid_world_y and \
               obj.get("game_type_id") == new_obj_game_type_id:
                return 
    elif is_spawn_item: # Only one of each spawn type allowed
        editor_state.placed_objects = [obj for obj in editor_state.placed_objects if obj.get("game_type_id") != new_obj_game_type_id]

    new_obj = {"asset_editor_key": editor_state.selected_asset_editor_key, "world_x": grid_world_x, "world_y": grid_world_y, "game_type_id": new_obj_game_type_id}
    editor_state.placed_objects.append(new_obj)
    if not editor_state.unsaved_changes: editor_state.unsaved_changes = True # Mark unsaved if not already
    pygame.display.set_caption(f"Editor - {editor_state.map_name_for_function}.py*")


def _erase_tile_at_grid(editor_state: EditorState, grid_coords: Tuple[int, int]):
    grid_world_x = grid_coords[0] * editor_state.grid_size
    grid_world_y = grid_coords[1] * editor_state.grid_size
    
    obj_erased = False
    for i in range(len(editor_state.placed_objects) - 1, -1, -1):
        obj = editor_state.placed_objects[i]
        # Simple check: if object's origin is in this grid cell.
        # More precise would be checking if any part of object's rect intersects grid cell.
        if obj.get("world_x") == grid_world_x and obj.get("world_y") == grid_world_y:
            asset_info = editor_state.assets_palette.get(obj.get("asset_editor_key"))
            tooltip = asset_info['tooltip'] if asset_info else "Object"
            print(f"DEBUG EDIT_MAP_EVENT: Erasing '{tooltip}' at grid ({grid_coords[0]},{grid_coords[1]}).")
            editor_state.placed_objects.pop(i)
            if not editor_state.unsaved_changes: editor_state.unsaved_changes = True
            pygame.display.set_caption(f"Editor - {editor_state.map_name_for_function}.py*")
            obj_erased = True
            break # Erase one object per erase action at a grid spot
    if obj_erased:
        editor_state.set_status_message(f"Erased tile at ({grid_coords[0]},{grid_coords[1]})", 1.5)


def handle_editing_map_events(event: pygame.event.Event, editor_state: EditorState,
                              palette_section_rect: pygame.Rect, map_view_rect: pygame.Rect,
                              main_screen: pygame.Surface):
    general_mouse_pos = pygame.mouse.get_pos() 

    if event.type == pygame.MOUSEWHEEL:
        if palette_section_rect.collidepoint(general_mouse_pos):
            font_small = ED_CONFIG.FONT_CONFIG.get("small"); scroll_speed = (font_small.get_height() + ED_CONFIG.ASSET_PALETTE_ITEM_PADDING) if font_small else 20
            editor_state.asset_palette_scroll_y -= event.y * scroll_speed 
            max_scroll = max(0, editor_state.total_asset_palette_content_height - palette_section_rect.height)
            editor_state.asset_palette_scroll_y = max(0, min(editor_state.asset_palette_scroll_y, max_scroll))
    
    elif event.type == pygame.MOUSEBUTTONDOWN:
        mouse_pos_for_click = event.pos
        if palette_section_rect.collidepoint(mouse_pos_for_click) and event.button == 1:
            bg_btn = editor_state.ui_elements_rects.get("palette_bg_color_button")
            if bg_btn and bg_btn.collidepoint(mouse_pos_for_click):
                def on_bg_sel(nc: Tuple[int,int,int]):
                    if nc: editor_state.background_color = nc; editor_state.unsaved_changes = True; pygame.display.set_caption(f"Editor - {editor_state.map_name_for_function}.py*"); editor_state.set_status_message(f"BG: {nc}")
                start_color_picker_dialog(editor_state, on_confirm=on_bg_sel, on_cancel=lambda: None); return
            for key, rect in editor_state.ui_elements_rects.get('asset_palette_items', {}).items():
                if rect.collidepoint(mouse_pos_for_click):
                    data = editor_state.assets_palette[key]; editor_state.selected_asset_editor_key = key
                    editor_state.selected_asset_image_for_cursor = data["image"].copy(); editor_state.set_status_message(f"Selected: {data['tooltip']}"); return
        elif map_view_rect.collidepoint(mouse_pos_for_click):
            map_world_mx = mouse_pos_for_click[0]-map_view_rect.left+editor_state.camera_offset_x; map_world_my = mouse_pos_for_click[1]-map_view_rect.top+editor_state.camera_offset_y
            tile_x, tile_y = map_world_mx//editor_state.grid_size, map_world_my//editor_state.grid_size
            if event.button == 1:
                if editor_state.selected_asset_editor_key:
                    editor_state.is_painting_tiles = True; editor_state.last_painted_tile_coords = (tile_x,tile_y); _place_tile_at_grid(editor_state, (tile_x,tile_y))
                else: 
                    editor_state.dragging_object_index = None
                    for i, obj in reversed(list(enumerate(editor_state.placed_objects))):
                        info = editor_state.assets_palette.get(obj.get("asset_editor_key"));
                        if info and "original_size_pixels" in info:
                            obj_w,obj_h=info["original_size_pixels"]; obj_r=pygame.Rect(obj["world_x"],obj["world_y"],obj_w,obj_h)
                            if obj_r.collidepoint(map_world_mx, map_world_my):
                                editor_state.dragging_object_index=i; editor_state.drag_start_mouse_map_x=map_world_mx; editor_state.drag_start_mouse_map_y=map_world_my
                                editor_state.drag_object_original_x=obj["world_x"]; editor_state.drag_object_original_y=obj["world_y"]; editor_state.set_status_message(f"Dragging {info['tooltip']}"); break
            elif event.button == 3:
                if pygame.key.get_mods() & (pygame.KMOD_LSHIFT | pygame.KMOD_RSHIFT): 
                    if editor_state.map_name_for_function and editor_state.map_name_for_function != "untitled_map": # Check for valid map name
                        if save_map_to_json(editor_state) and export_map_to_game_python_script(editor_state): pygame.display.set_caption(f"Editor - {editor_state.map_name_for_function}.py")
                    else: editor_state.set_status_message("Cannot save: Map not named.", 4)
                else: 
                    editor_state.is_erasing_tiles = True; editor_state.last_erased_tile_coords = (tile_x,tile_y); _erase_tile_at_grid(editor_state, (tile_x,tile_y))
    
    elif event.type == pygame.MOUSEBUTTONUP:
        if event.button == 1: 
            editor_state.is_painting_tiles = False
            editor_state.last_painted_tile_coords = None
            if editor_state.dragging_object_index is not None: 
                editor_state.dragging_object_index = None; editor_state.set_status_message("Drag complete")
        elif event.button == 3: 
            editor_state.is_erasing_tiles = False
            editor_state.last_erased_tile_coords = None
        if editor_state.is_dragging_scrollbar: editor_state.is_dragging_scrollbar = False # General scrollbar release
    
    elif event.type == pygame.MOUSEMOTION:
        mouse_pos_motion = event.pos
        if editor_state.dragging_object_index is not None and \
           0 <= editor_state.dragging_object_index < len(editor_state.placed_objects): # Dragging object
            obj_to_drag = editor_state.placed_objects[editor_state.dragging_object_index]
            map_world_mx = mouse_pos_motion[0] - map_view_rect.left + editor_state.camera_offset_x
            map_world_my = mouse_pos_motion[1] - map_view_rect.top + editor_state.camera_offset_y
            new_x = editor_state.drag_object_original_x + (map_world_mx - editor_state.drag_start_mouse_map_x)
            new_y = editor_state.drag_object_original_y + (map_world_my - editor_state.drag_start_mouse_map_y)
            snapped_x = (new_x // editor_state.grid_size) * editor_state.grid_size
            snapped_y = (new_y // editor_state.grid_size) * editor_state.grid_size
            if obj_to_drag["world_x"] != snapped_x or obj_to_drag["world_y"] != snapped_y:
                obj_to_drag["world_x"], obj_to_drag["world_y"] = snapped_x, snapped_y
                if not editor_state.unsaved_changes: editor_state.unsaved_changes = True
                pygame.display.set_caption(f"Editor - {editor_state.map_name_for_function}.py*")
        elif map_view_rect.collidepoint(mouse_pos_motion): # Painting or Erasing
            map_world_mx = mouse_pos_motion[0] - map_view_rect.left + editor_state.camera_offset_x
            map_world_my = mouse_pos_motion[1] - map_view_rect.top + editor_state.camera_offset_y
            curr_tx, curr_ty = map_world_mx // editor_state.grid_size, map_world_my // editor_state.grid_size
            curr_grid_coords = (curr_tx, curr_ty)
            
            mouse_buttons_pressed = pygame.mouse.get_pressed() # (left, middle, right)
            if editor_state.is_painting_tiles and mouse_buttons_pressed[0] and \
               editor_state.selected_asset_editor_key and curr_grid_coords != editor_state.last_painted_tile_coords:
                _place_tile_at_grid(editor_state, curr_grid_coords)
                editor_state.last_painted_tile_coords = curr_grid_coords
            elif editor_state.is_erasing_tiles and mouse_buttons_pressed[2] and \
                 curr_grid_coords != editor_state.last_erased_tile_coords:
                _erase_tile_at_grid(editor_state, curr_grid_coords)
                editor_state.last_erased_tile_coords = curr_grid_coords
        # If mouse moves outside map view while a drag-paint/erase was active, stop it.
        elif not map_view_rect.collidepoint(mouse_pos_motion):
            if editor_state.is_painting_tiles:
                editor_state.is_painting_tiles = False; editor_state.last_painted_tile_coords = None
            if editor_state.is_erasing_tiles:
                editor_state.is_erasing_tiles = False; editor_state.last_erased_tile_coords = None

    elif event.type == pygame.KEYDOWN:
        if event.key == pygame.K_ESCAPE:
            if editor_state.selected_asset_editor_key:
                editor_state.selected_asset_editor_key, editor_state.selected_asset_image_for_cursor = None, None
                editor_state.set_status_message("Asset deselected")
            else:
                if editor_state.unsaved_changes:
                    if not getattr(editor_state, '_esc_exit_attempted', False):
                        editor_state.set_status_message("Unsaved changes! Save or Esc again to discard.", 4); editor_state._esc_exit_attempted = True
                    else:
                        editor_state.current_editor_mode = "menu"; editor_state.reset_map_context()
                        pygame.display.set_caption("Platformer Level Editor - Menu")
                        if hasattr(editor_state, '_esc_exit_attempted'): del editor_state._esc_exit_attempted
                else:
                    editor_state.current_editor_mode = "menu"; editor_state.reset_map_context()
                    pygame.display.set_caption("Platformer Level Editor - Menu")
                    if hasattr(editor_state, '_esc_exit_attempted'): del editor_state._esc_exit_attempted
        
        elif event.key != pygame.K_ESCAPE and hasattr(editor_state, '_esc_exit_attempted'):
            del editor_state._esc_exit_attempted
        
        elif event.key == pygame.K_g:
            editor_state.show_grid = not editor_state.show_grid
            editor_state.set_status_message(f"Grid {'ON' if editor_state.show_grid else 'OFF'}")
        
        pan = ED_CONFIG.MAP_VIEW_CAMERA_PAN_SPEED
        if map_view_rect.width > 0 and map_view_rect.height > 0:
            map_w, map_h = editor_state.get_map_pixel_width(), editor_state.get_map_pixel_height()
            cam_moved = False
            if event.key == pygame.K_a: editor_state.camera_offset_x = max(0, editor_state.camera_offset_x - pan); cam_moved = True
            elif event.key == pygame.K_d: editor_state.camera_offset_x = min(max(0,map_w-map_view_rect.width), editor_state.camera_offset_x+pan); cam_moved = True
            elif event.key == pygame.K_w: editor_state.camera_offset_y = max(0, editor_state.camera_offset_y - pan); cam_moved = True
            elif event.key == pygame.K_s and not (pygame.key.get_mods() & pygame.KMOD_CTRL):
                editor_state.camera_offset_y = min(max(0,map_h-map_view_rect.height), editor_state.camera_offset_y+pan); cam_moved = True
            if cam_moved: print(f"DEBUG EDIT_MAP_EVENT: Camera panned to ({editor_state.camera_offset_x},{editor_state.camera_offset_y})")

        if event.key == pygame.K_s and (pygame.key.get_mods() & pygame.KMOD_CTRL):
            if editor_state.map_name_for_function and editor_state.map_name_for_function != "untitled_map":
                if save_map_to_json(editor_state) and export_map_to_game_python_script(editor_state): 
                    pygame.display.set_caption(f"Editor - {editor_state.map_name_for_function}.py")
            else: editor_state.set_status_message("Cannot save: Map not named.", 4)

########## START OF FILE: editor_map_utils.py ##########

# editor_map_utils.py
# -*- coding: utf-8 -*-
"""
## version 1.0.0.5 (Added extensive debug prints for saving/loading and export)
Utility functions for map operations in the Level Editor,
including initializing new maps, saving/loading editor-specific
map data (JSON), and exporting maps to game-compatible Python scripts.
"""
import pygame
import sys
import os
import json
import traceback # For detailed error reporting
from typing import Optional, Dict, List, Tuple, Any

# --- Add parent directory to sys.path for editor_config & editor_state if this file is run standalone (unlikely here) ---
# This is more robustly handled in the main editor.py script.
# current_script_path_map_utils = os.path.dirname(os.path.abspath(__file__))
# parent_directory_map_utils = os.path.dirname(current_script_path_map_utils) # This should be 'editor'
# project_root_map_utils = os.path.dirname(parent_directory_map_utils) # This should be 'Platformer'
# if project_root_map_utils not in sys.path:
#     sys.path.insert(0, project_root_map_utils)
# if parent_directory_map_utils not in sys.path: # If editor_config is in 'editor' not project root
#    sys.path.insert(0, parent_directory_map_utils)

import editor_config as ED_CONFIG
from editor_state import EditorState

# constants.py and tiles.py should be accessible from the project root.
# This setup relies on editor.py correctly setting up sys.path.
import constants as C
from tiles import Platform, Ladder, Lava # Assuming these are used in export


def init_new_map_state(editor_state: EditorState, map_name_for_function: str,
                       map_width_tiles: int, map_height_tiles: int):
    """
    Initializes the editor_state for a new, empty map.
    Sets up dimensions, clears objects, prepares the map_content_surface.
    """
    print(f"DEBUG MAP_UTILS: init_new_map_state called. Map Name: '{map_name_for_function}', Size: {map_width_tiles}x{map_height_tiles}")
    
    clean_map_name = map_name_for_function.lower().replace(" ", "_").replace("-", "_")
    if not clean_map_name:
        clean_map_name = "untitled_map" # Fallback if name becomes empty
        print(f"DEBUG MAP_UTILS: map_name_for_function was empty after cleaning, defaulting to '{clean_map_name}'")
    
    editor_state.map_name_for_function = clean_map_name
    editor_state.map_width_tiles = map_width_tiles
    editor_state.map_height_tiles = map_height_tiles
    editor_state.placed_objects = []
    editor_state.background_color = ED_CONFIG.DEFAULT_BACKGROUND_COLOR
    editor_state.camera_offset_x = 0
    editor_state.camera_offset_y = 0
    editor_state.unsaved_changes = True # A new map inherently has unsaved changes until first save
    
    py_filename = editor_state.map_name_for_function + ED_CONFIG.GAME_LEVEL_FILE_EXTENSION
    editor_state.current_map_filename = os.path.join(ED_CONFIG.MAPS_DIRECTORY, py_filename)
    
    editor_state.recreate_map_content_surface() # This also prints a debug message
    
    print(f"DEBUG MAP_UTILS: Editor state initialized for new map. "
          f"map_name_for_function='{editor_state.map_name_for_function}', "
          f"current_map_filename='{editor_state.current_map_filename}', "
          f"unsaved_changes={editor_state.unsaved_changes}")

def ensure_maps_directory_exists() -> bool:
    """Checks if the MAPS_DIRECTORY exists, creates it if not. Returns success."""
    maps_dir = ED_CONFIG.MAPS_DIRECTORY
    # print(f"DEBUG MAP_UTILS: Checking if maps directory '{maps_dir}' exists.") # Can be verbose
    if not os.path.exists(maps_dir):
        print(f"DEBUG MAP_UTILS: Maps directory '{maps_dir}' does not exist. Attempting to create.")
        try:
            os.makedirs(maps_dir)
            print(f"DEBUG MAP_UTILS: Successfully created directory: {maps_dir}")
            return True
        except OSError as e:
            print(f"ERROR MAP_UTILS: Error creating directory {maps_dir}: {e}")
            traceback.print_exc()
            return False
    # print(f"DEBUG MAP_UTILS: Maps directory '{maps_dir}' already exists.")
    return True

def save_map_to_json(editor_state: EditorState) -> bool:
    """
    Saves the current editor state to a JSON file for editor reloading.
    Returns True on success, False on failure.
    """
    print(f"DEBUG MAP_UTILS: save_map_to_json called. Map name func: '{editor_state.map_name_for_function}'")
    if not editor_state.map_name_for_function or editor_state.map_name_for_function == "untitled_map":
        msg = "Map name is not set or is 'untitled_map'. Cannot save JSON."
        editor_state.set_status_message(f"Error: {msg}", 3)
        print(f"ERROR MAP_UTILS: {msg}")
        return False

    if not ensure_maps_directory_exists():
        msg = "Could not create or access maps directory."
        editor_state.set_status_message(f"Error: {msg}", 3)
        print(f"ERROR MAP_UTILS: {msg} JSON save aborted.")
        return False

    json_filename = editor_state.map_name_for_function + ED_CONFIG.LEVEL_EDITOR_SAVE_FORMAT_EXTENSION
    json_filepath = os.path.join(ED_CONFIG.MAPS_DIRECTORY, json_filename)
    print(f"DEBUG MAP_UTILS: Attempting to save JSON to: '{json_filepath}'")

    serializable_objects = []
    for i, obj in enumerate(editor_state.placed_objects):
        asset_key = obj.get("asset_editor_key")
        game_id = obj.get("game_type_id")
        world_x = obj.get("world_x")
        world_y = obj.get("world_y")

        if not all([asset_key, game_id is not None, world_x is not None, world_y is not None]):
             print(f"Warning MAP_UTILS: Object at index {i} has missing data, skipping for JSON: {obj}")
             continue

        s_obj = {
            "asset_editor_key": asset_key,
            "world_x": world_x,
            "world_y": world_y,
            "game_type_id": game_id
        }
        serializable_objects.append(s_obj)

    data_to_save = {
        "map_name_for_function": editor_state.map_name_for_function,
        "map_width_tiles": editor_state.map_width_tiles,
        "map_height_tiles": editor_state.map_height_tiles,
        "grid_size": editor_state.grid_size,
        "background_color": list(editor_state.background_color), # Convert tuple to list for JSON
        "placed_objects": serializable_objects,
        "camera_offset_x": editor_state.camera_offset_x,
        "camera_offset_y": editor_state.camera_offset_y,
        "show_grid": editor_state.show_grid
    }
    print(f"DEBUG MAP_UTILS: Data to save to JSON: {json.dumps(data_to_save, indent=2)}") # Log the data

    try:
        with open(json_filepath, "w") as f:
            json.dump(data_to_save, f, indent=4)
        success_msg = f"Editor data saved to: {json_filename}"
        print(f"DEBUG MAP_UTILS: {success_msg}")
        editor_state.set_status_message(success_msg)
        # editor_state.unsaved_changes = False # This should be set False AFTER .py export if successful
        return True
    except IOError as e:
        error_msg = f"IOError saving map to JSON '{json_filepath}': {e}"
    except Exception as e:
        error_msg = f"Unexpected error saving map to JSON '{json_filepath}': {e}"
        traceback.print_exc()
    
    print(f"ERROR MAP_UTILS: {error_msg}")
    editor_state.set_status_message(error_msg, 4)
    return False

def load_map_from_json(editor_state: EditorState, json_filepath: str) -> bool:
    """
    Loads map data from a JSON file into the editor_state.
    Returns True on success, False on failure.
    """
    print(f"DEBUG MAP_UTILS: load_map_from_json called. Filepath: '{json_filepath}'")
    if not os.path.exists(json_filepath) or not os.path.isfile(json_filepath):
        error_msg = f"JSON map file not found or is not a file: '{json_filepath}'"
        print(f"ERROR MAP_UTILS: {error_msg}")
        editor_state.set_status_message(error_msg, 3)
        return False
        
    try:
        with open(json_filepath, 'r') as f:
            data = json.load(f)
        print(f"DEBUG MAP_UTILS: Successfully read JSON data from '{json_filepath}'. Content snapshot: { {k: (type(v) if k != 'placed_objects' else f'{len(v)} items') for k,v in data.items()} }")
        
        editor_state.map_name_for_function = data.get("map_name_for_function", "loaded_map_error_name")
        editor_state.map_width_tiles = data.get("map_width_tiles", ED_CONFIG.DEFAULT_MAP_WIDTH_TILES)
        editor_state.map_height_tiles = data.get("map_height_tiles", ED_CONFIG.DEFAULT_MAP_HEIGHT_TILES)
        editor_state.grid_size = data.get("grid_size", ED_CONFIG.DEFAULT_GRID_SIZE)
        
        bg_color_data = data.get("background_color", ED_CONFIG.DEFAULT_BACKGROUND_COLOR)
        if isinstance(bg_color_data, list) and len(bg_color_data) == 3:
            editor_state.background_color = tuple(bg_color_data) # type: ignore
        else:
            editor_state.background_color = ED_CONFIG.DEFAULT_BACKGROUND_COLOR
            print(f"Warning MAP_UTILS: Invalid background_color format in JSON, using default. Got: {bg_color_data}")


        editor_state.placed_objects = []
        loaded_placed_objects = data.get("placed_objects", [])
        print(f"DEBUG MAP_UTILS: Loading {len(loaded_placed_objects)} objects from JSON.")
        for i, obj_data in enumerate(loaded_placed_objects):
            asset_key = obj_data.get("asset_editor_key")
            game_type_id_from_json = obj_data.get("game_type_id") # Get game_type_id from JSON
            world_x = obj_data.get("world_x")
            world_y = obj_data.get("world_y")

            if not all([asset_key, game_type_id_from_json is not None, world_x is not None, world_y is not None]):
                print(f"Warning MAP_UTILS: Loaded object at index {i} has missing core data, skipping: {obj_data}")
                continue

            if asset_key in ED_CONFIG.EDITOR_PALETTE_ASSETS:
                # It's generally safer to trust the game_type_id from the JSON file if it exists,
                # as the config might change. However, for consistency if asset_key is primary link:
                # game_type_id_from_config = ED_CONFIG.EDITOR_PALETTE_ASSETS[asset_key].get("game_type_id", asset_key)
                editor_state.placed_objects.append({
                    "asset_editor_key": asset_key,
                    "world_x": world_x,
                    "world_y": world_y,
                    "game_type_id": game_type_id_from_json # Use the one from the file
                })
            else:
                print(f"Warning MAP_UTILS: Asset key '{asset_key}' from loaded object (JSON type: '{game_type_id_from_json}') "
                      f"not found in current ED_CONFIG.EDITOR_PALETTE_ASSETS. Object at ({world_x},{world_y}) skipped.")

        editor_state.camera_offset_x = data.get("camera_offset_x", 0)
        editor_state.camera_offset_y = data.get("camera_offset_y", 0)
        editor_state.show_grid = data.get("show_grid", True)
        
        py_filename = editor_state.map_name_for_function + ED_CONFIG.GAME_LEVEL_FILE_EXTENSION
        editor_state.current_map_filename = os.path.join(ED_CONFIG.MAPS_DIRECTORY, py_filename)
        
        editor_state.recreate_map_content_surface()
        editor_state.unsaved_changes = False # Freshly loaded map has no unsaved changes
        
        success_msg = f"Map '{editor_state.map_name_for_function}' loaded from {os.path.basename(json_filepath)}"
        print(f"DEBUG MAP_UTILS: {success_msg}. unsaved_changes={editor_state.unsaved_changes}, current_map_filename='{editor_state.current_map_filename}'")
        editor_state.set_status_message(success_msg)
        return True
        
    except json.JSONDecodeError as e:
        error_msg = f"Error: Could not decode JSON from map file '{json_filepath}': {e}"
    except Exception as e:
        error_msg = f"Unexpected error loading map from JSON '{json_filepath}': {e}"
        traceback.print_exc()
    
    print(f"ERROR MAP_UTILS: {error_msg}")
    editor_state.set_status_message(error_msg, 4)
    return False

def export_map_to_game_python_script(editor_state: EditorState) -> bool:
    """
    Generates and saves the Python level script compatible with the main game.
    Returns True on success, False on failure.
    """
    print(f"DEBUG MAP_UTILS: export_map_to_game_python_script called. Map func name: '{editor_state.map_name_for_function}'")
    
    if not editor_state.map_name_for_function or editor_state.map_name_for_function == "untitled_map":
        msg = "Map name not set or is 'untitled_map'. Cannot export .py."
        editor_state.set_status_message(f"Error: {msg}", 3)
        print(f"ERROR MAP_UTILS: {msg}")
        return False
        
    if not editor_state.current_map_filename: # Should be set by init_new_map or load_map
        py_filename = editor_state.map_name_for_function + ED_CONFIG.GAME_LEVEL_FILE_EXTENSION
        editor_state.current_map_filename = os.path.join(ED_CONFIG.MAPS_DIRECTORY, py_filename)
        print(f"Warning MAP_UTILS: current_map_filename was not set, derived as '{editor_state.current_map_filename}' for export.")

    if not ensure_maps_directory_exists():
        msg = "Could not create or access maps directory for .py export."
        editor_state.set_status_message(f"Error: {msg}", 3)
        print(f"ERROR MAP_UTILS: {msg} PY export aborted.")
        return False

    function_name = f"load_map_{editor_state.map_name_for_function}"
    print(f"DEBUG MAP_UTILS: Exporting to function '{function_name}' in file '{editor_state.current_map_filename}'")

    platforms_code_lines = []
    ladders_code_lines = [] # Ensure ladders are handled if you add them
    hazards_code_lines = []
    enemy_spawns_code_lines = []
    collectible_spawns_code_lines = []

    # Default player spawn - will be overridden if a player spawn object is placed
    default_spawn_tile_x = editor_state.map_width_tiles // 2
    default_spawn_tile_y = editor_state.map_height_tiles // 2 
    default_spawn_world_x = default_spawn_tile_x * editor_state.grid_size + editor_state.grid_size // 2 # Mid of tile
    default_spawn_world_y = (default_spawn_tile_y + 1) * editor_state.grid_size # Bottom of tile
    player1_spawn_str = f"player1_spawn = ({default_spawn_world_x}, {default_spawn_world_y}) # Default P1 Spawn (midbottom of tile {default_spawn_tile_x},{default_spawn_tile_y})"

    all_placed_world_rects_for_bounds: List[pygame.Rect] = []
    print(f"DEBUG MAP_UTILS: Processing {len(editor_state.placed_objects)} objects for .py export.")

    for i, obj_data in enumerate(editor_state.placed_objects):
        game_type_id = obj_data.get("game_type_id")
        world_x = obj_data.get("world_x")
        world_y = obj_data.get("world_y")
        asset_editor_key = obj_data.get("asset_editor_key")

        if not all([game_type_id, world_x is not None, world_y is not None, asset_editor_key]):
            print(f"Warning MAP_UTILS: Export - Object at index {i} missing data, skipping: {obj_data}")
            continue
        
        asset_config = ED_CONFIG.EDITOR_PALETTE_ASSETS.get(asset_editor_key)
        
        # Determine object size for bounds calculation and export
        obj_width_px = editor_state.grid_size # Default
        obj_height_px = editor_state.grid_size # Default

        if asset_config:
            if "surface_params" in asset_config: # For simple colored rects
                obj_width_px = asset_config["surface_params"][0]
                obj_height_px = asset_config["surface_params"][1]
            elif asset_editor_key in editor_state.assets_palette: # For image-based assets
                palette_asset_data = editor_state.assets_palette[asset_editor_key]
                original_size = palette_asset_data.get("original_size_pixels")
                if original_size and len(original_size) == 2:
                    obj_width_px, obj_height_px = original_size
                else:
                    print(f"Warning MAP_UTILS: Asset '{asset_editor_key}' missing valid 'original_size_pixels' in assets_palette. Using grid_size for export bounds.")
        else:
             print(f"Warning MAP_UTILS: Asset key '{asset_editor_key}' for object (type '{game_type_id}') not in ED_CONFIG. Using grid_size for export bounds.")
        
        current_obj_rect = pygame.Rect(world_x, world_y, obj_width_px, obj_height_px)
        all_placed_world_rects_for_bounds.append(current_obj_rect)

        # --- Object type to code generation ---
        if game_type_id == "platform_wall_gray":
            platforms_code_lines.append(f"    platforms.add(Platform({world_x}, {world_y}, {obj_width_px}, {obj_height_px}, C.GRAY, platform_type='wall'))")
        elif game_type_id == "platform_ledge_green":
            platforms_code_lines.append(f"    platforms.add(Platform({world_x}, {world_y}, {obj_width_px}, {obj_height_px}, C.DARK_GREEN, platform_type='ledge'))")
        elif game_type_id == "hazard_lava": # Assuming Lava takes full tile size (or its original pixel size)
            hazards_code_lines.append(f"    hazards.add(Lava({world_x}, {world_y}, {obj_width_px}, {obj_height_px}, C.ORANGE_RED))")
        elif game_type_id == "player1_spawn":
            # Player spawn point is usually midbottom of the visual representation
            spawn_mid_x = world_x + obj_width_px // 2
            spawn_bottom_y = world_y + obj_height_px 
            player1_spawn_str = f"player1_spawn = ({spawn_mid_x}, {spawn_bottom_y})"
        elif "enemy" in game_type_id: # Generic enemy handling
            specific_enemy_color_id = game_type_id.split('_')[-1] if '_' in game_type_id else "unknown_enemy_color"
            # Enemy spawn point is usually midbottom
            spawn_mid_x = world_x + obj_width_px // 2
            spawn_bottom_y = world_y + obj_height_px
            enemy_spawns_code_lines.append(f"    enemy_spawns_data.append({{'pos': ({spawn_mid_x}, {spawn_bottom_y}), 'patrol': None, 'enemy_color_id': '{specific_enemy_color_id}'}})")
        elif game_type_id == "chest":
            # Chest spawn point is usually midbottom
            chest_spawn_x_midbottom = world_x + obj_width_px // 2
            chest_spawn_y_midbottom = world_y + obj_height_px
            collectible_spawns_code_lines.append(f"    collectible_spawns_data.append({{'type': 'chest', 'pos': ({chest_spawn_x_midbottom}, {chest_spawn_y_midbottom})}})")
        # Add other object types here (e.g., ladders)
        # elif game_type_id == "ladder":
        #     ladders_code_lines.append(f"    ladders.add(Ladder({world_x}, {world_y}, {obj_width_px}, {obj_height_px}))")
        else:
            print(f"Warning MAP_UTILS: Unknown game_type_id '{game_type_id}' for object at ({world_x},{world_y}). Not exported to .py.")


    platforms_code_str = "\n".join(platforms_code_lines)
    ladders_code_str = "\n".join(ladders_code_lines)
    hazards_code_str = "\n".join(hazards_code_lines)
    enemy_spawns_code_str = "\n".join(enemy_spawns_code_lines)
    collectible_spawns_code_str = "\n".join(collectible_spawns_code_lines)
    print(f"DEBUG MAP_UTILS: Generated code lines - Platforms: {len(platforms_code_lines)}, Ladders: {len(ladders_code_lines)}, etc.")

    # --- Calculate Map Boundaries for Game ---
    if not all_placed_world_rects_for_bounds: # Empty map
        print("DEBUG MAP_UTILS: No objects placed, using default map dimensions for export boundaries.")
        map_min_x_content = 0
        map_max_x_content = editor_state.get_map_pixel_width()
        map_min_y_content = 0
        map_max_y_content = editor_state.get_map_pixel_height()
    else:
        map_min_x_content = min(r.left for r in all_placed_world_rects_for_bounds)
        map_max_x_content = max(r.right for r in all_placed_world_rects_for_bounds)
        map_min_y_content = min(r.top for r in all_placed_world_rects_for_bounds)
        map_max_y_content = max(r.bottom for r in all_placed_world_rects_for_bounds)
    
    # Add padding around content for camera movement and player safety
    padding_px = C.TILE_SIZE * 2 
    game_map_total_width_pixels = int(max(ED_CONFIG.EDITOR_SCREEN_INITIAL_WIDTH, (map_max_x_content - map_min_x_content) + 2 * padding_px))
    # Ensure total width covers at least the editor's view of the map or the content width + padding

    # Absolute Y coordinates for the game camera system and boundaries
    game_level_min_y_absolute = int(map_min_y_content - padding_px) 
    game_level_max_y_absolute = int(map_max_y_content + padding_px) 
    
    # Reference for ground, typically where player stands or bottom of lowest platform
    game_main_ground_y_reference = int(map_max_y_content) 
    game_main_ground_height_reference = int(C.TILE_SIZE) # Typical tile height

    if game_level_min_y_absolute >= game_level_max_y_absolute :
        print(f"Warning MAP_UTILS: Calculated min_y_abs ({game_level_min_y_absolute}) >= max_y_abs ({game_level_max_y_absolute}) for map '{editor_state.map_name_for_function}'. Adjusting max_y_abs.")
        game_level_max_y_absolute = game_level_min_y_absolute + C.TILE_SIZE * 5 # Ensure some height

    print(f"DEBUG MAP_UTILS: Export boundaries - TotalWidthPx: {game_map_total_width_pixels}, MinYAbs: {game_level_min_y_absolute}, MaxYAbs: {game_level_max_y_absolute}")

    script_content = f"""# Level: {editor_state.map_name_for_function}
# Generated by Platformer Level Editor on {pygame.time.get_ticks()}
import pygame
from tiles import Platform, Ladder, Lava # Ensure all used tile types are imported by game
import constants as C

# Optional: Define level-specific background color if your game supports it
LEVEL_SPECIFIC_BACKGROUND_COLOR = {editor_state.background_color}

def {function_name}(initial_screen_width, initial_screen_height):
    \"\"\"
    Loads the '{editor_state.map_name_for_function}' level.
    Generated by the level editor.
    \"\"\"
    print(f"Loading map: {function_name}...") # Game-side log
    platforms = pygame.sprite.Group()
    ladders = pygame.sprite.Group()
    hazards = pygame.sprite.Group()
    enemy_spawns_data = []
    collectible_spawns_data = []

    {player1_spawn_str}
    
    # --- Placed Objects ---
{platforms_code_str if platforms_code_str else "    # No platforms placed."}
{ladders_code_str if ladders_code_str else "    # No ladders placed."}
{hazards_code_str if hazards_code_str else "    # No hazards placed."}
{enemy_spawns_code_str if enemy_spawns_code_str else "    # No enemy spawns defined."}
{collectible_spawns_code_str if collectible_spawns_code_str else "    # No collectible spawns defined."}

    # --- Level Dimensions for Game Camera & Boundaries ---
    map_total_width_pixels = {game_map_total_width_pixels}
    level_min_y_absolute = {game_level_min_y_absolute} # Top-most Y coordinate for camera/content
    level_max_y_absolute = {game_level_max_y_absolute} # Bottom-most Y coordinate for camera/content (e.g., death plane below this)
    
    main_ground_y_reference = {game_main_ground_y_reference} # Y-value of the main 'floor' surface
    main_ground_height_reference = {game_main_ground_height_reference} # Height of typical ground tiles

    # --- Auto-generated Boundary Walls (Invisible in game unless styled) ---
    # These ensure entities cannot go outside the defined level space.
    _boundary_thickness = C.TILE_SIZE * 2 # Make them thick enough
    _boundary_wall_height = level_max_y_absolute - level_min_y_absolute + (2 * _boundary_thickness) # Span slightly beyond min/max_y

    # Top boundary (ceiling) - place its bottom edge at level_min_y_absolute
    platforms.add(Platform(0, level_min_y_absolute - _boundary_thickness, map_total_width_pixels, _boundary_thickness, C.DARK_GRAY, platform_type="boundary_wall_top"))
    # Bottom boundary (floor/kill plane) - place its top edge at level_max_y_absolute
    platforms.add(Platform(0, level_max_y_absolute, map_total_width_pixels, _boundary_thickness, C.DARK_GRAY, platform_type="boundary_wall_bottom"))
    # Left boundary wall
    platforms.add(Platform(-_boundary_thickness, level_min_y_absolute - _boundary_thickness, _boundary_thickness, _boundary_wall_height, C.DARK_GRAY, platform_type="boundary_wall_left"))
    # Right boundary wall
    platforms.add(Platform(map_total_width_pixels, level_min_y_absolute - _boundary_thickness, _boundary_thickness, _boundary_wall_height, C.DARK_GRAY, platform_type="boundary_wall_right"))

    print(f"Map '{function_name}' loaded with: {{len(platforms)}} platforms, {{len(ladders)}} ladders, {{len(hazards)}} hazards.") # Game-side log
    return (platforms, ladders, hazards, enemy_spawns_data, collectible_spawns_data,
            player1_spawn,
            map_total_width_pixels, level_min_y_absolute, level_max_y_absolute,
            main_ground_y_reference, main_ground_height_reference,
            LEVEL_SPECIFIC_BACKGROUND_COLOR) # Return background color
"""
    py_filepath = editor_state.current_map_filename 
    print(f"DEBUG MAP_UTILS: Final .py script content to write to '{py_filepath}':\n{script_content[:500]}...") # Log start of content

    try:
        with open(py_filepath, "w") as f:
            f.write(script_content)
        success_msg = f"Map exported to game script: {os.path.basename(py_filepath)}"
        print(f"DEBUG MAP_UTILS: {success_msg}")
        editor_state.set_status_message(success_msg)
        editor_state.unsaved_changes = False # Crucial: set unsaved to false AFTER successful .py export
        print(f"DEBUG MAP_UTILS: unsaved_changes set to False after .py export.")
        return True
    except IOError as e:
        error_msg = f"IOError exporting map to .py '{py_filepath}': {e}"
    except Exception as e:
        error_msg = f"Unexpected error during .py export to '{py_filepath}': {e}"
        traceback.print_exc()
        
    print(f"ERROR MAP_UTILS: {error_msg}")
    editor_state.set_status_message(error_msg, 4)
    return False

########## START OF FILE: editor_state.py ##########

# editor_state.py
# -*- coding: utf-8 -*-
"""
## version 1.0.0.6 (Added painting/erasing state attributes)
Defines the EditorState class, which holds all the dynamic state
and data for the level editor.
"""

import pygame
from typing import Optional, Dict, List, Tuple, Any, Callable 
import traceback 

import editor_config as ED_CONFIG

class EditorState:
    """
    Manages the current state of the level editor, including map data,
    UI selections, and editor modes.
    """
    def __init__(self):
        print("DEBUG STATE: Initializing EditorState...")
        # --- Map Data & File ---
        self.current_map_data: Dict[str, Any] = {}
        self.current_map_filename: Optional[str] = None
        self.map_name_for_function: str = "untitled_map"

        self.map_width_tiles: int = ED_CONFIG.DEFAULT_MAP_WIDTH_TILES
        self.map_height_tiles: int = ED_CONFIG.DEFAULT_MAP_HEIGHT_TILES
        self.grid_size: int = ED_CONFIG.DEFAULT_GRID_SIZE
        self.background_color: Tuple[int, int, int] = ED_CONFIG.DEFAULT_BACKGROUND_COLOR

        self.map_content_surface: Optional[pygame.Surface] = None

        # --- Placed Objects ---
        self.placed_objects: List[Dict[str, Any]] = []

        # --- Asset Palette & Selection ---
        self.assets_palette: Dict[str, Dict[str, Any]] = {}
        self._selected_asset_editor_key: Optional[str] = None
        self.selected_asset_image_for_cursor: Optional[pygame.Surface] = None
        self.asset_palette_scroll_y: int = 0
        self.total_asset_palette_content_height: int = 0

        # --- Map View & Camera ---
        self.camera_offset_x: int = 0
        self.camera_offset_y: int = 0
        self.show_grid: bool = True

        # --- Object Interaction ---
        self.dragging_object_index: Optional[int] = None
        self.drag_start_mouse_map_x: int = 0
        self.drag_start_mouse_map_y: int = 0
        self.drag_object_original_x: int = 0
        self.drag_object_original_y: int = 0

        # --- Tile Painting/Erasing State --- # ENSURE THESE ARE PRESENT
        self.is_painting_tiles: bool = False
        self.last_painted_tile_coords: Optional[Tuple[int, int]] = None
        self.is_erasing_tiles: bool = False 
        self.last_erased_tile_coords: Optional[Tuple[int, int]] = None
        # --- End Tile Painting/Erasing State ---

        # --- UI State ---
        self._current_editor_mode: str = "menu"
        self.unsaved_changes: bool = False
        self.hovered_tooltip_text: Optional[str] = None
        self.hovered_tooltip_pos: Optional[Tuple[int, int]] = None
        self.ui_elements_rects: Dict[str, Any] = {} 

        # --- Dialogs and Input Fields ---
        self._active_dialog_type: Optional[str] = None
        self.dialog_input_text: str = ""
        self.dialog_prompt_message: str = ""
        self.dialog_input_default: str = ""
        self.dialog_callback_confirm: Optional[Callable[..., None]] = None
        self.dialog_callback_cancel: Optional[Callable[[], None]] = None
        self.dialog_rect: Optional[pygame.Rect] = None 

        self.color_picker_rects: Dict[str, pygame.Rect] = {} 
        self.dialog_file_list: List[str] = []
        self.dialog_file_scroll_y: int = 0
        self.dialog_selected_file_index: int = -1
        self.is_dragging_scrollbar: bool = False
        self.scrollbar_drag_mouse_offset_y: int = 0

        self.map_name_for_function_input: str = "" 

        # --- Status Messages ---
        self.status_message: Optional[str] = None
        self.status_message_timer: float = 0.0
        self.status_message_duration: float = 3.0 

        # --- Final Initialization Steps ---
        self.recreate_map_content_surface() 
        print("DEBUG STATE: EditorState initialization complete.")

    @property
    def current_editor_mode(self) -> str:
        return self._current_editor_mode

    @current_editor_mode.setter
    def current_editor_mode(self, value: str):
        if self._current_editor_mode != value:
            print(f"DEBUG STATE: current_editor_mode changed from '{self._current_editor_mode}' to '{value}'")
            self._current_editor_mode = value

    @property
    def active_dialog_type(self) -> Optional[str]:
        return self._active_dialog_type

    @active_dialog_type.setter
    def active_dialog_type(self, value: Optional[str]):
        if self._active_dialog_type != value:
            old_dialog_type = self._active_dialog_type 
            print(f"DEBUG STATE: active_dialog_type changed from '{old_dialog_type}' to '{value}'")
            self._active_dialog_type = value
            if value is None or (old_dialog_type is not None and old_dialog_type != value):
                keys_to_remove = []
                if old_dialog_type == "file_load":
                    keys_to_remove.extend(['dialog_file_item_rects', 'file_dialog_scrollbar_handle',
                                           'file_dialog_scrollbar_area', 'dialog_file_load_ok', 'dialog_file_load_cancel'])
                elif old_dialog_type == "color_picker": self.color_picker_rects.clear()
                removed_count = 0
                for key in keys_to_remove:
                    if key in self.ui_elements_rects:
                        try: del self.ui_elements_rects[key]; removed_count +=1
                        except KeyError: pass 
                if removed_count > 0: print(f"DEBUG STATE: Cleared {removed_count} UI rect(s) for dialog '{old_dialog_type}'.")
            if value is None: self.dialog_rect = None

    @property
    def selected_asset_editor_key(self) -> Optional[str]:
        return self._selected_asset_editor_key

    @selected_asset_editor_key.setter
    def selected_asset_editor_key(self, value: Optional[str]):
        if self._selected_asset_editor_key != value:
            print(f"DEBUG STATE: selected_asset_editor_key changed from '{self._selected_asset_editor_key}' to '{value}'")
            self._selected_asset_editor_key = value

    def recreate_map_content_surface(self):
        map_pixel_width = self.map_width_tiles * self.grid_size
        map_pixel_height = self.map_height_tiles * self.grid_size
        safe_width, safe_height = max(1, map_pixel_width), max(1, map_pixel_height)
        try:
            self.map_content_surface = pygame.Surface((safe_width, safe_height))
            print(f"DEBUG STATE: Recreated map_content_surface: {safe_width}x{safe_height}")
        except pygame.error as e:
            print(f"ERROR STATE: Failed to create map_content_surface: {e}"); traceback.print_exc()
            try: self.map_content_surface = pygame.Surface((ED_CONFIG.DEFAULT_GRID_SIZE, ED_CONFIG.DEFAULT_GRID_SIZE))
            except Exception as e_fallback: self.map_content_surface = None; print(f"CRITICAL STATE: Fallback surface failed: {e_fallback}")

    def get_map_pixel_width(self) -> int: return self.map_width_tiles * self.grid_size
    def get_map_pixel_height(self) -> int: return self.map_height_tiles * self.grid_size
    def set_status_message(self, message: str, duration: float = 3.0):
        self.status_message, self.status_message_duration, self.status_message_timer = message, duration, duration
        print(f"STATUS MSG: {message} (duration: {duration:.1f}s)")

    def update_status_message(self, dt: float):
        if self.status_message and self.status_message_timer > 0:
            self.status_message_timer -= dt
            if self.status_message_timer <= 0: self.status_message, self.status_message_timer = None, 0.0

    def reset_map_context(self):
        print("DEBUG STATE: reset_map_context called.")
        self.map_name_for_function = "untitled_map"; self.current_map_filename = None
        self.placed_objects = []; self.map_width_tiles = ED_CONFIG.DEFAULT_MAP_WIDTH_TILES
        self.map_height_tiles = ED_CONFIG.DEFAULT_MAP_HEIGHT_TILES; self.background_color = ED_CONFIG.DEFAULT_BACKGROUND_COLOR
        self.camera_offset_x, self.camera_offset_y = 0, 0; self.unsaved_changes = False
        self.selected_asset_editor_key, self.selected_asset_image_for_cursor = None, None
        self.is_painting_tiles, self.last_painted_tile_coords = False, None # Reset painting state
        self.is_erasing_tiles, self.last_erased_tile_coords = False, None   # Reset erasing state
        # self.recreate_map_content_surface() # Typically called by init_new_map or load_map
        print(f"DEBUG STATE: Map context reset. Map name: '{self.map_name_for_function}'.")

########## START OF FILE: editor_ui.py ##########

# editor_ui.py
# -*- coding: utf-8 -*-
"""
## version 1.0.0.7 (Reduced verbose prints, added debug for MAGENTA issue)
Pygame-based UI functions for the Level Editor.
Includes buttons, input dialogs, color pickers, and tooltips.
"""
import pygame
import os
from typing import Optional, Dict, Tuple, Any, Callable, List
import traceback # ADDED for more detailed error reporting

import editor_config as ED_CONFIG
from editor_state import EditorState
# Assuming constants.py (referenced by ED_CONFIG.C) is accessible from the project root.
# This setup relies on editor.py correctly setting up sys.path.

# --- UI Drawing Helpers ---

def draw_button(surface: pygame.Surface,
                rect: pygame.Rect,
                text: str,
                font: Optional[pygame.font.Font],
                mouse_pos: Tuple[int, int],
                text_color: Tuple[int, int, int] = ED_CONFIG.BUTTON_TEXT_COLOR,
                button_color_normal: Tuple[int, int, int] = ED_CONFIG.BUTTON_COLOR_NORMAL,
                button_color_hover: Tuple[int, int, int] = ED_CONFIG.BUTTON_COLOR_HOVER,
                border_color: Tuple[int, int, int] = ED_CONFIG.BUTTON_COLOR_BORDER,
                border_width: int = ED_CONFIG.BUTTON_BORDER_WIDTH,
                is_active: bool = True) -> bool:
    # print(f"DEBUG UI_DRAW: draw_button called for '{text}' at {rect}, active={is_active}") # Kept commented: Can be verbose
    is_hovered = False
    if is_active and rect.collidepoint(mouse_pos):
        is_hovered = True

    current_button_color = button_color_normal
    current_text_color = text_color

    if not is_active:
        current_button_color = tuple(int(c * 0.67) for c in button_color_normal) # Darker shade
        current_text_color = tuple(int(c * 0.67) for c in text_color)
    elif is_hovered:
        current_button_color = button_color_hover

    try:
        pygame.draw.rect(surface, current_button_color, rect)
        if border_width > 0:
            pygame.draw.rect(surface, border_color, rect, border_width)

        if font:
            text_surf = font.render(text, True, current_text_color)
            text_rect = text_surf.get_rect(center=rect.center)
            surface.blit(text_surf, text_rect)
        else:
            print(f"Warning UI_DRAW: draw_button called with no font for text '{text}'")
    except Exception as e:
        print(f"ERROR UI_DRAW: Exception in draw_button for '{text}': {e}")
        traceback.print_exc()

    return is_hovered

def draw_tooltip(surface: pygame.Surface,
                 editor_state: EditorState,
                 font: Optional[pygame.font.Font]):
    if editor_state.hovered_tooltip_text and editor_state.hovered_tooltip_pos and font:
        # print(f"DEBUG UI_DRAW: Drawing tooltip: '{editor_state.hovered_tooltip_text}' at {editor_state.hovered_tooltip_pos}") # Kept commented: Verbose
        try:
            text_surf = font.render(editor_state.hovered_tooltip_text, True, ED_CONFIG.TOOLTIP_TEXT_COLOR)
            text_rect = text_surf.get_rect(
                topleft=(editor_state.hovered_tooltip_pos[0] + 15,
                         editor_state.hovered_tooltip_pos[1] + 15)
            )
            bg_rect = text_rect.inflate(ED_CONFIG.TOOLTIP_PADDING * 2, ED_CONFIG.TOOLTIP_PADDING * 2)

            bg_rect.clamp_ip(surface.get_rect()) # Ensure tooltip stays on screen
            text_rect.clamp_ip(bg_rect.inflate(-ED_CONFIG.TOOLTIP_PADDING, -ED_CONFIG.TOOLTIP_PADDING)) # And text within tooltip bg

            pygame.draw.rect(surface, ED_CONFIG.TOOLTIP_BG_COLOR, bg_rect, border_radius=3)
            pygame.draw.rect(surface, ED_CONFIG.BUTTON_COLOR_BORDER, bg_rect, 1, border_radius=3)
            surface.blit(text_surf, text_rect)
        except Exception as e:
            print(f"ERROR UI_DRAW: Exception in draw_tooltip for '{editor_state.hovered_tooltip_text}': {e}")
            traceback.print_exc()

def draw_status_message(surface: pygame.Surface, editor_state: EditorState, font: Optional[pygame.font.Font]):
    if editor_state.status_message and font:
        # print(f"DEBUG UI_DRAW: Drawing status message: '{editor_state.status_message}'") # Kept commented: Verbose
        try:
            message_surf = font.render(editor_state.status_message, True, getattr(ED_CONFIG.C, 'YELLOW', (255,255,0))) # Use getattr for safety
            message_rect = message_surf.get_rect(centerx=surface.get_width() // 2,
                                                  bottom=surface.get_height() - 10)
            bg_padding = 5
            bg_rect = message_rect.inflate(bg_padding * 2, bg_padding * 2)
            bg_rect.clamp_ip(surface.get_rect())
            message_rect.clamp_ip(bg_rect)

            s = pygame.Surface(bg_rect.size, pygame.SRCALPHA)
            s.fill((50, 50, 50, 180)) # Semi-transparent dark background
            surface.blit(s, bg_rect.topleft)
            surface.blit(message_surf, message_rect)
        except Exception as e:
            print(f"ERROR UI_DRAW: Exception in draw_status_message for '{editor_state.status_message}': {e}")
            traceback.print_exc()

# --- Pygame-based Dialogs ---

def start_text_input_dialog(editor_state: EditorState,
                            prompt: str,
                            default_text: str = "",
                            on_confirm: Optional[Callable[[str], None]] = None,
                            on_cancel: Optional[Callable[[], None]] = None):
    print(f"DEBUG UI_DIALOG: start_text_input_dialog. Prompt: '{prompt}', Default: '{default_text}'") # Removed cb presence for brevity
    editor_state.active_dialog_type = "text_input"
    editor_state.dialog_prompt_message = prompt
    editor_state.dialog_input_text = default_text
    editor_state.dialog_input_default = default_text # Store original default
    editor_state.dialog_callback_confirm = on_confirm
    editor_state.dialog_callback_cancel = on_cancel
    editor_state.dialog_rect = None # Will be set by draw_active_dialog

def start_color_picker_dialog(editor_state: EditorState,
                              on_confirm: Optional[Callable[[Tuple[int,int,int]], None]] = None,
                              on_cancel: Optional[Callable[[], None]] = None):
    print(f"DEBUG UI_DIALOG: start_color_picker_dialog.") # Removed cb presence for brevity
    editor_state.active_dialog_type = "color_picker"
    editor_state.dialog_prompt_message = "Select Background Color (Esc to Cancel)"
    editor_state.color_picker_rects.clear()

    cols = ED_CONFIG.COLOR_PICKER_COLS
    button_size = ED_CONFIG.COLOR_PICKER_BUTTON_SIZE
    padding = ED_CONFIG.COLOR_PICKER_PADDING

    start_x_in_dialog = padding * 2
    current_y_in_dialog = 50 # Initial Y offset for swatches below title
    current_x_in_dialog = start_x_in_dialog
    idx = 0
    for name in ED_CONFIG.COLOR_PICKER_PRESETS.keys():
        rect = pygame.Rect(current_x_in_dialog, current_y_in_dialog, button_size, button_size)
        editor_state.color_picker_rects[name] = rect
        current_x_in_dialog += button_size + padding
        idx += 1
        if idx % cols == 0:
            current_x_in_dialog = start_x_in_dialog
            current_y_in_dialog += button_size + padding

    editor_state.dialog_callback_confirm = on_confirm
    editor_state.dialog_callback_cancel = on_cancel
    editor_state.dialog_rect = None # Will be set by draw_active_dialog

def start_file_load_dialog(editor_state: EditorState,
                           on_confirm: Optional[Callable[[str], None]] = None,
                           on_cancel: Optional[Callable[[], None]] = None,
                           initial_path: str = ED_CONFIG.MAPS_DIRECTORY,
                           file_extension: str = ED_CONFIG.LEVEL_EDITOR_SAVE_FORMAT_EXTENSION):
    print(f"DEBUG UI_DIALOG: start_file_load_dialog. Path: '{initial_path}', Ext: '{file_extension}'") # Removed cb presence
    editor_state.active_dialog_type = "file_load"
    editor_state.dialog_prompt_message = f"Select Map to Load (from ./{initial_path})"
    editor_state.dialog_input_text = ""
    editor_state.dialog_file_list = []
    editor_state.dialog_file_scroll_y = 0
    editor_state.dialog_selected_file_index = -1
    editor_state.dialog_rect = None

    if 'dialog_file_item_rects' not in editor_state.ui_elements_rects:
        editor_state.ui_elements_rects['dialog_file_item_rects'] = []
    else:
        editor_state.ui_elements_rects['dialog_file_item_rects'].clear()

    if not os.path.exists(initial_path):
        try:
            os.makedirs(initial_path)
            # print(f"DEBUG UI_DIALOG: Created maps directory at '{initial_path}' during file_load_dialog start.") # Less frequent, so ok
            editor_state.set_status_message(f"Created maps dir '{initial_path}'. No files yet.", 2)
        except OSError as e:
            err_msg = f"Error creating dir '{initial_path}': {e}"
            editor_state.set_status_message(err_msg, 3)
            print(f"ERROR UI_DIALOG: {err_msg}")
            if on_cancel: on_cancel()
            editor_state.active_dialog_type = None
            return

    try:
        for item in os.listdir(initial_path):
            if item.endswith(file_extension) and os.path.isfile(os.path.join(initial_path, item)):
                editor_state.dialog_file_list.append(item)
        editor_state.dialog_file_list.sort()
        # print(f"DEBUG UI_DIALOG: Found files in '{initial_path}': {editor_state.dialog_file_list}") # Less frequent, so ok
    except OSError as e:
        err_msg = f"Error listing files in '{initial_path}': {e}"
        editor_state.set_status_message(err_msg, 3)
        print(f"ERROR UI_DIALOG: {err_msg}")
        if on_cancel: on_cancel()
        editor_state.active_dialog_type = None
        return

    if not editor_state.dialog_file_list:
        editor_state.set_status_message(f"No '{file_extension}' files found in ./{initial_path}", 2.5)

    editor_state.dialog_callback_confirm = on_confirm
    editor_state.dialog_callback_cancel = on_cancel


def draw_active_dialog(surface: pygame.Surface, editor_state: EditorState, fonts: Dict[str, Optional[pygame.font.Font]]):
    if not editor_state.active_dialog_type:
        return

    # print(f"DEBUG UI_DRAW_DIALOG: Drawing dialog type '{editor_state.active_dialog_type}'") # Kept commented: Can be verbose
    try:
        screen_center_x, screen_center_y = surface.get_rect().center
        dialog_width, dialog_height = 450, 350

        if editor_state.active_dialog_type == "text_input":
            dialog_width, dialog_height = 400, 200
        elif editor_state.active_dialog_type == "color_picker":
            num_colors = len(ED_CONFIG.COLOR_PICKER_PRESETS)
            cols = ED_CONFIG.COLOR_PICKER_COLS
            rows = (num_colors + cols - 1) // cols
            content_w = cols * ED_CONFIG.COLOR_PICKER_BUTTON_SIZE + (cols -1 if cols > 0 else 0) * ED_CONFIG.COLOR_PICKER_PADDING
            content_h = rows * ED_CONFIG.COLOR_PICKER_BUTTON_SIZE + (rows -1 if rows > 0 else 0) * ED_CONFIG.COLOR_PICKER_PADDING
            dialog_width = max(300, content_w + ED_CONFIG.COLOR_PICKER_PADDING * 4)
            title_space = 60
            dialog_height = max(200, content_h + title_space + ED_CONFIG.COLOR_PICKER_PADDING * 2)
        elif editor_state.active_dialog_type == "file_load":
            dialog_width, dialog_height = 400, 350

        current_dialog_rect = pygame.Rect(0, 0, dialog_width, dialog_height)
        current_dialog_rect.center = screen_center_x, screen_center_y
        editor_state.dialog_rect = current_dialog_rect

        pygame.draw.rect(surface, ED_CONFIG.DIALOG_BG_COLOR, current_dialog_rect, border_radius=5)
        pygame.draw.rect(surface, getattr(ED_CONFIG.C, 'BLACK', (0,0,0)), current_dialog_rect, 2, border_radius=5) # Use getattr

        prompt_font = fonts.get("medium") or ED_CONFIG.FONT_CONFIG.get("medium")
        if prompt_font and editor_state.dialog_prompt_message:
            prompt_surf = prompt_font.render(editor_state.dialog_prompt_message, True, ED_CONFIG.DIALOG_PROMPT_COLOR)
            prompt_draw_rect = prompt_surf.get_rect(midtop=(current_dialog_rect.centerx, current_dialog_rect.top + 15))
            surface.blit(prompt_surf, prompt_draw_rect)

        if editor_state.active_dialog_type == "text_input":
            _draw_text_input_content(surface, editor_state, current_dialog_rect, fonts)
        elif editor_state.active_dialog_type == "color_picker":
            _draw_color_picker_content(surface, editor_state, current_dialog_rect, fonts)
        elif editor_state.active_dialog_type == "file_load":
            _draw_file_load_content(surface, editor_state, current_dialog_rect, fonts)

    except Exception as e:
        print(f"ERROR UI_DRAW_DIALOG: Exception in draw_active_dialog for type '{editor_state.active_dialog_type}': {e}")
        traceback.print_exc()
        error_font = fonts.get("small")
        if error_font and editor_state.dialog_rect:
            err_surf = error_font.render(f"Dialog Error! See console.", True, getattr(ED_CONFIG.C, 'RED', (255,0,0))) # Use getattr
            surface.blit(err_surf, err_surf.get_rect(center=editor_state.dialog_rect.center))


def _draw_text_input_content(surface: pygame.Surface, editor_state: EditorState, dialog_rect: pygame.Rect, fonts: Dict[str, Optional[pygame.font.Font]]):
    input_box_rect = pygame.Rect(0, 0, dialog_rect.width - 40, 40)
    input_box_rect.center = dialog_rect.centerx, dialog_rect.centery + 10
    pygame.draw.rect(surface, ED_CONFIG.DIALOG_INPUT_BOX_COLOR, input_box_rect)
    pygame.draw.rect(surface, getattr(ED_CONFIG.C, 'BLACK', (0,0,0)), input_box_rect, 2) # Use getattr

    text_font = fonts.get("medium") or ED_CONFIG.FONT_CONFIG.get("medium")
    if text_font:
        current_text_to_render = str(editor_state.dialog_input_text) if editor_state.dialog_input_text is not None else ""
        input_text_surf = text_font.render(current_text_to_render, True, ED_CONFIG.DIALOG_INPUT_TEXT_COLOR)
        text_clip_area_rect = input_box_rect.inflate(-12, -12)
        text_surf_width = input_text_surf.get_width()
        blit_area = None
        text_draw_pos_on_surface_x = text_clip_area_rect.left

        if text_surf_width > text_clip_area_rect.width:
            text_draw_pos_on_surface_x = text_clip_area_rect.right - text_surf_width
            blit_source_x_offset = text_surf_width - text_clip_area_rect.width
            blit_area = pygame.Rect(blit_source_x_offset, 0, text_clip_area_rect.width, input_text_surf.get_height())

        blit_destination_topleft = (text_draw_pos_on_surface_x,
                                    text_clip_area_rect.top + (text_clip_area_rect.height - input_text_surf.get_height()) // 2)
        original_clip = surface.get_clip()
        surface.set_clip(text_clip_area_rect)
        surface.blit(input_text_surf, blit_destination_topleft, area=blit_area)
        surface.set_clip(original_clip)

        if blit_area:
            cursor_render_x = text_clip_area_rect.right -1
        else:
            cursor_render_x = text_clip_area_rect.left + input_text_surf.get_width() + 1
        cursor_render_x = max(text_clip_area_rect.left, min(cursor_render_x, text_clip_area_rect.right -1))

        if int(pygame.time.get_ticks() / 500) % 2 == 0:
             pygame.draw.line(surface, ED_CONFIG.DIALOG_CURSOR_COLOR,
                             (cursor_render_x, input_box_rect.top + 5),
                             (cursor_render_x, input_box_rect.bottom - 5), 2)

    info_font = fonts.get("small") or ED_CONFIG.FONT_CONFIG.get("small")
    if info_font:
        info_surf = info_font.render("Enter: Confirm, Esc: Cancel", True, getattr(ED_CONFIG.C, 'LIGHT_GRAY', (200,200,200))) # Use getattr
        surface.blit(info_surf, info_surf.get_rect(midbottom=(dialog_rect.centerx, dialog_rect.bottom - 10)))

def _draw_color_picker_content(surface: pygame.Surface, editor_state: EditorState, dialog_rect: pygame.Rect, fonts: Dict[str, Optional[pygame.font.Font]]):
    mouse_pos_dialog = pygame.mouse.get_pos()

    # --- TEMPORARY DEBUG for MAGENTA issue (Uncomment if still happening after restart) ---
    # print(f"DEBUG UI_COLOR_PICKER: In _draw_color_picker_content")
    # print(f"DEBUG UI_COLOR_PICKER: ED_CONFIG type: {type(ED_CONFIG)}")
    # print(f"DEBUG UI_COLOR_PICKER: ED_CONFIG.C type: {type(ED_CONFIG.C)}")
    # print(f"DEBUG UI_COLOR_PICKER: ED_CONFIG.C attributes: {dir(ED_CONFIG.C)}")
    # print(f"DEBUG UI_COLOR_PICKER: Has MAGENTA in ED_CONFIG.C? {hasattr(ED_CONFIG.C, 'MAGENTA')}")
    # if hasattr(ED_CONFIG.C, 'MAGENTA'):
    #     print(f"DEBUG UI_COLOR_PICKER: ED_CONFIG.C.MAGENTA value: {ED_CONFIG.C.MAGENTA}")
    # else:
    #     print(f"CRITICAL DEBUG UI_COLOR_PICKER: ED_CONFIG.C does NOT have MAGENTA attribute!")
    # print(f"DEBUG UI_COLOR_PICKER: COLOR_PICKER_PRESETS keys: {list(ED_CONFIG.COLOR_PICKER_PRESETS.keys())}")
    # --- END TEMPORARY DEBUG ---

    default_fallback_color = (255, 0, 255) # Define a literal magenta just in case C.MAGENTA access fails

    for name, swatch_rect_relative in editor_state.color_picker_rects.items():
        absolute_swatch_rect = swatch_rect_relative.move(dialog_rect.left, dialog_rect.top)
        
        # Safely get MAGENTA from ED_CONFIG.C, or use the literal default_fallback_color
        magenta_default = getattr(ED_CONFIG.C, 'MAGENTA', default_fallback_color)
        color_val = ED_CONFIG.COLOR_PICKER_PRESETS.get(name, magenta_default)

        pygame.draw.rect(surface, color_val, absolute_swatch_rect)
        border_col = getattr(ED_CONFIG.C, 'BLACK', (0,0,0)) # Use getattr
        border_w = 1
        if absolute_swatch_rect.collidepoint(mouse_pos_dialog):
            border_col = getattr(ED_CONFIG.COLOR_PICKER_HOVER_BORDER_COLOR, 'YELLOW', (255,255,0)) # Use getattr for this too
            border_w = 3
        pygame.draw.rect(surface, border_col, absolute_swatch_rect, border_w)

def _draw_file_load_content(surface: pygame.Surface, editor_state: EditorState, dialog_rect: pygame.Rect, fonts: Dict[str, Optional[pygame.font.Font]]):
    prompt_font = fonts.get("medium") or ED_CONFIG.FONT_CONFIG.get("medium")
    title_height = prompt_font.get_height() + 25 if prompt_font else 55
    buttons_panel_height = ED_CONFIG.BUTTON_HEIGHT_STANDARD // 2 + 20

    list_area_y_start = dialog_rect.top + title_height
    list_area_height = dialog_rect.height - title_height - buttons_panel_height

    list_area_rect = pygame.Rect(dialog_rect.left + 10, list_area_y_start, dialog_rect.width - 20, list_area_height)
    pygame.draw.rect(surface, ED_CONFIG.DIALOG_INPUT_BOX_COLOR, list_area_rect)
    pygame.draw.rect(surface, getattr(ED_CONFIG.C, 'BLACK', (0,0,0)), list_area_rect, 1) # Use getattr

    item_font = fonts.get("small") or ED_CONFIG.FONT_CONFIG.get("small")
    item_line_height = (item_font.get_height() + 6) if item_font else 22

    editor_state.ui_elements_rects['dialog_file_item_rects'] = []
    list_clip_rect = list_area_rect.inflate(-8, -8)
    total_content_height_pixels = len(editor_state.dialog_file_list) * item_line_height
    scrollbar_width_drawn = 0

    if total_content_height_pixels > list_clip_rect.height:
        scrollbar_width_drawn = 15
        scrollbar_track_rect = pygame.Rect(list_clip_rect.right + 2, list_clip_rect.top,
                                          scrollbar_width_drawn, list_clip_rect.height)
        pygame.draw.rect(surface, getattr(ED_CONFIG.C, 'DARK_GRAY', (50,50,50)), scrollbar_track_rect) # Use getattr
        handle_height_ratio = min(1.0, list_clip_rect.height / total_content_height_pixels if total_content_height_pixels > 0 else 1.0)
        handle_height = max(20, scrollbar_track_rect.height * handle_height_ratio)
        scrollable_content_outside_view = max(0, total_content_height_pixels - list_clip_rect.height)
        current_scroll_ratio_of_hidden = editor_state.dialog_file_scroll_y / scrollable_content_outside_view if scrollable_content_outside_view > 0 else 0
        handle_y_pos_on_track = (scrollbar_track_rect.height - handle_height) * current_scroll_ratio_of_hidden
        scrollbar_handle_rect = pygame.Rect(scrollbar_track_rect.left,
                                            scrollbar_track_rect.top + handle_y_pos_on_track,
                                            scrollbar_width_drawn, handle_height)
        pygame.draw.rect(surface, getattr(ED_CONFIG.C, 'GRAY', (128,128,128)), scrollbar_handle_rect, border_radius=3) # Use getattr
        editor_state.ui_elements_rects['file_dialog_scrollbar_handle'] = scrollbar_handle_rect
        editor_state.ui_elements_rects['file_dialog_scrollbar_area'] = scrollbar_track_rect

    list_item_text_render_width = list_clip_rect.width - (scrollbar_width_drawn + 2 if scrollbar_width_drawn > 0 else 0)
    original_clip_pygame = surface.get_clip()
    surface.set_clip(list_clip_rect)
    current_y_offset_in_clip_rect = 0

    for i, filename in enumerate(editor_state.dialog_file_list):
        item_draw_y_on_surface = list_clip_rect.top + current_y_offset_in_clip_rect - editor_state.dialog_file_scroll_y
        item_full_rect_on_screen = pygame.Rect(list_clip_rect.left, item_draw_y_on_surface,
                                           list_item_text_render_width, item_line_height)
        if list_clip_rect.colliderect(item_full_rect_on_screen):
            editor_state.ui_elements_rects['dialog_file_item_rects'].append(
                {"text": filename, "rect": item_full_rect_on_screen, "index": i}
            )
            if item_font:
                text_color = getattr(ED_CONFIG.C, 'BLACK', (0,0,0)) # Use getattr
                bg_color_item = ED_CONFIG.DIALOG_INPUT_BOX_COLOR
                if editor_state.dialog_selected_file_index == i:
                    bg_color_item = getattr(ED_CONFIG.C, 'BLUE', (0,0,255)) # Use getattr
                    text_color = getattr(ED_CONFIG.C, 'WHITE', (255,255,255)) # Use getattr
                pygame.draw.rect(surface, bg_color_item, item_full_rect_on_screen)
                text_surf = item_font.render(filename, True, text_color)
                text_draw_pos = (item_full_rect_on_screen.left + 5,
                                 item_full_rect_on_screen.centery - text_surf.get_height() // 2)
                surface.blit(text_surf, text_draw_pos)
        current_y_offset_in_clip_rect += item_line_height
    surface.set_clip(original_clip_pygame)

    button_font = fonts.get("small") or ED_CONFIG.FONT_CONFIG.get("small")
    if button_font:
        btn_width = ED_CONFIG.BUTTON_WIDTH_STANDARD // 2 - 15
        btn_height = ED_CONFIG.BUTTON_HEIGHT_STANDARD // 2 + 5
        buttons_y_pos = list_area_rect.bottom + 10
        ok_button_rect = pygame.Rect(dialog_rect.centerx - btn_width - 5, buttons_y_pos, btn_width, btn_height)
        cancel_button_rect = pygame.Rect(dialog_rect.centerx + 5, buttons_y_pos, btn_width, btn_height)
        mouse_pos = pygame.mouse.get_pos()
        ok_is_active = (editor_state.dialog_selected_file_index != -1 and
                        0 <= editor_state.dialog_selected_file_index < len(editor_state.dialog_file_list))
        draw_button(surface, ok_button_rect, "Load", button_font, mouse_pos, is_active=ok_is_active)
        draw_button(surface, cancel_button_rect, "Cancel", button_font, mouse_pos)
        editor_state.ui_elements_rects["dialog_file_load_ok"] = ok_button_rect
        editor_state.ui_elements_rects["dialog_file_load_cancel"] = cancel_button_rect