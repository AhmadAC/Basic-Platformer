

########## START OF FILE: __init__.py ##########



########## START OF FILE: editor.py ##########

# editor/editor.py
# -*- coding: utf-8 -*-
"""
## version 1.0.0.16 (Corrected constants import, robust logging)
Level Editor for the Platformer Game (Pygame Only).
Allows creating, loading, and saving game levels visually.
"""
import pygame
import sys
import os
from typing import Tuple, Dict, Optional, Any, List, Callable
import traceback
import math
import logging

# --- Logger Setup ---
logger = None
log_file_path_for_error_msg = "Not determined" # For use in except block if path fails
try:
    current_script_dir = os.path.dirname(os.path.abspath(__file__))
    logs_dir = os.path.join(current_script_dir, 'logs')

    if not os.path.exists(logs_dir):
        print(f"Attempting to create logs directory: {logs_dir}")
        os.makedirs(logs_dir)
        print(f"Logs directory created (or already existed at {logs_dir}).")
    else:
        print(f"Logs directory already exists at: {logs_dir}")

    log_file_path_for_error_msg = os.path.join(logs_dir, 'editor_debug.log') # Assign for potential error message
    print(f"Attempting to configure logging to file: {log_file_path_for_error_msg}")

    for handler in logging.root.handlers[:]:
        logging.root.removeHandler(handler)

    logging.basicConfig(
        level=logging.DEBUG,
        format='%(asctime)s - %(levelname)s - %(filename)s:%(lineno)d - %(funcName)s - %(message)s',
        handlers=[
            logging.FileHandler(log_file_path_for_error_msg, mode='w'),
        ],
    )
    logger = logging.getLogger(__name__)
    logger.info("Editor session started. Logging initialized successfully to file.")
    print(f"LOGGING INITIALIZED. Log file should be at: {log_file_path_for_error_msg}")

except Exception as e_log:
    print(f"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
    print(f"CRITICAL ERROR DURING LOGGING SETUP: {e_log}")
    print(f"Traceback for logging error:")
    traceback.print_exc()
    print(f"Log file might not be created due to this error.")
    print(f"Attempted log file path was: {log_file_path_for_error_msg}")
    print(f"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
    logging.basicConfig(level=logging.DEBUG, format='CONSOLE LOG (File log failed): %(asctime)s - %(levelname)s - %(message)s')
    logger = logging.getLogger(__name__)
    logger.error("File logging setup failed. Switched to console logging only for this session.")
# --- End Logger Setup ---

# --- sys.path modification and constants import ---
try:
    # Correctly determine the project root directory
    # __file__ is editor/editor.py
    # os.path.dirname(__file__) is editor/
    # os.path.dirname(os.path.dirname(__file__)) is the project root
    project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))

    if project_root not in sys.path:
        sys.path.insert(0, project_root)
        logger.debug(f"Added project root '{project_root}' to sys.path.")
    else:
        logger.debug(f"Project root '{project_root}' already in sys.path.")

    import constants as C_imported # This should now find constants.py in the project root
    logger.info(f"Successfully imported 'constants as C_imported'. TILE_SIZE: {getattr(C_imported, 'TILE_SIZE', 'NOT FOUND')}")

except ImportError as e_imp:
    logger.critical(f"Failed to import 'constants'. Error: {e_imp}", exc_info=True)
    logger.critical(f"Current sys.path: {sys.path}")
    logger.critical(f"Calculated project_root: {project_root if 'project_root' in locals() else 'Not calculated'}")
    print("ERROR: Could not import 'constants.py'. Ensure it is in the project root directory, one level above the 'editor' directory.")
    sys.exit("ImportError for constants.py")
except Exception as e_gen_imp:
    logger.critical(f"An unexpected error occurred during constants import: {e_gen_imp}", exc_info=True)
    sys.exit("Generic error during constants import.")
# --- End sys.path modification and constants import ---

# --- Editor module imports ---
try:
    import editor_config as ED_CONFIG
    from editor_state import EditorState # EditorState also uses logger
    import editor_ui
    import editor_assets
    import editor_map_utils
    import editor_drawing
    import editor_event_handlers # Event handlers also use logger
    logger.debug("Successfully imported all editor-specific modules.")
except ImportError as e_editor_mod:
    logger.critical(f"Failed to import an editor-specific module. Error: {e_editor_mod}", exc_info=True)
    print(f"ERROR: Failed to import an editor module. Check sys.path and module names. Current sys.path: {sys.path}")
    sys.exit("ImportError for editor module - exiting.")
# --- End Editor module imports ---


def editor_main():
    logger.info("editor_main() started.")
    try:
        pygame.init()
        logger.debug("pygame.init() called.")
        if not pygame.font.get_init():
            logger.debug("pygame.font not initialized, calling pygame.font.init()")
            pygame.font.init()
        if not pygame.font.get_init():
             logger.critical("pygame.font.init() failed after explicit call! Fonts will not work.")
        else:
            logger.debug("pygame.font.init() confirmed or already initialized.")

        if not editor_map_utils.ensure_maps_directory_exists():
            logger.critical("Maps directory issue. Exiting.")
            pygame.quit(); sys.exit(1)
        # ensure_maps_directory_exists logs success internally

        editor_screen = pygame.display.set_mode(
            (ED_CONFIG.EDITOR_SCREEN_INITIAL_WIDTH, ED_CONFIG.EDITOR_SCREEN_INITIAL_HEIGHT),
            pygame.RESIZABLE
        )
        logger.info(f"Editor screen created: {editor_screen.get_size()}")
        pygame.display.set_caption("Platformer Level Editor - Menu")
        editor_clock = pygame.time.Clock()
        editor_state = EditorState() # EditorState __init__ now logs
        editor_assets.load_editor_palette_assets(editor_state) # This function logs internally

        fonts: Dict[str, Optional[pygame.font.Font]] = ED_CONFIG.FONT_CONFIG
        if not fonts.get("small") or not fonts.get("medium") or not fonts.get("large"):
            logger.critical("Essential editor fonts (small, medium, or large) are None. Exiting.")
            pygame.quit(); sys.exit(1)
        logger.debug(f"Fonts from ED_CONFIG.FONT_CONFIG loaded: small={fonts['small'] is not None}, medium={fonts['medium'] is not None}, large={fonts['large'] is not None}, tooltip={fonts['tooltip'] is not None}")

        def calculate_layout_rects(screen_width: int, screen_height: int, current_mode: str) -> Tuple[pygame.Rect, pygame.Rect, pygame.Rect]:
            menu_rect = pygame.Rect(ED_CONFIG.SECTION_PADDING, ED_CONFIG.SECTION_PADDING,
                                     ED_CONFIG.MENU_SECTION_WIDTH, screen_height - (ED_CONFIG.SECTION_PADDING * 2))
            menu_rect.width = max(ED_CONFIG.BUTTON_WIDTH_STANDARD + ED_CONFIG.SECTION_PADDING * 2, menu_rect.width) # type: ignore
            menu_rect.height = max(menu_rect.height, ED_CONFIG.MENU_SECTION_HEIGHT) # type: ignore

            asset_palette_rect = pygame.Rect(ED_CONFIG.SECTION_PADDING, ED_CONFIG.SECTION_PADDING,
                                            ED_CONFIG.ASSET_PALETTE_SECTION_WIDTH, screen_height - (ED_CONFIG.SECTION_PADDING * 2)) # type: ignore
            map_view_x_start = ED_CONFIG.SECTION_PADDING
            map_view_width_available = screen_width - (ED_CONFIG.SECTION_PADDING * 2)

            if current_mode == "menu":
                map_view_x_start = menu_rect.right + ED_CONFIG.SECTION_PADDING
                map_view_width_available = screen_width - map_view_x_start - ED_CONFIG.SECTION_PADDING
            elif current_mode == "editing_map":
                asset_palette_rect.left = ED_CONFIG.SECTION_PADDING
                map_view_x_start = asset_palette_rect.right + ED_CONFIG.SECTION_PADDING
                map_view_width_available = screen_width - map_view_x_start - ED_CONFIG.SECTION_PADDING

            map_view_rect = pygame.Rect(map_view_x_start, ED_CONFIG.SECTION_PADDING,
                                        map_view_width_available, screen_height - (ED_CONFIG.SECTION_PADDING * 2))
            map_view_rect.width = max(map_view_rect.width, ED_CONFIG.DEFAULT_GRID_SIZE * 10)
            map_view_rect.height = max(map_view_rect.height, ED_CONFIG.DEFAULT_GRID_SIZE * 10)
            return menu_rect, asset_palette_rect, map_view_rect

        current_screen_width, current_screen_height = editor_screen.get_size()
        menu_section_rect, asset_palette_section_rect, map_view_section_rect = calculate_layout_rects(
            current_screen_width, current_screen_height, editor_state.current_editor_mode
        )
        logger.debug(f"Initial Layout - Menu={menu_section_rect}, Assets={asset_palette_section_rect}, Map={map_view_section_rect}")

        running = True
        logger.info("Entering main loop.")
        loop_count = 0
        while running:
            loop_count += 1
            dt = editor_clock.tick(ED_CONFIG.C.FPS if hasattr(ED_CONFIG.C, 'FPS') else 60) / 1000.0
            dt = min(dt, 0.1)

            mouse_pos = pygame.mouse.get_pos()
            events = pygame.event.get()

            editor_state.update_status_message(dt)
            previous_mode = editor_state.current_editor_mode
            previous_dialog_type = editor_state.active_dialog_type
            layout_needs_recalc = False

            if editor_state.current_editor_mode == "editing_map" and not editor_state.active_dialog_type:
                editor_event_handlers._update_continuous_camera_pan(editor_state, map_view_section_rect, mouse_pos, dt)

            for event_idx, event in enumerate(events):
                if event.type == pygame.VIDEORESIZE:
                    logger.info(f"VIDEORESIZE event to {event.w}x{event.h}")
                    current_screen_width, current_screen_height = event.w, event.h
                    try: editor_screen = pygame.display.set_mode((current_screen_width, current_screen_height), pygame.RESIZABLE)
                    except pygame.error as e_resize: logger.error(f"Pygame error on resize to {current_screen_width}x{current_screen_height}: {e_resize}", exc_info=True)
                    layout_needs_recalc = True; editor_state.set_status_message(f"Resized to {event.w}x{event.h}", 2.0)
                
                if not editor_event_handlers.handle_global_events(event, editor_state, editor_screen):
                    logger.info("handle_global_events returned False (QUIT). Setting running=False.")
                    running = False; break
                if not running: break

                if editor_state.active_dialog_type:
                    editor_event_handlers.handle_dialog_events(event, editor_state)
                    if editor_state.active_dialog_type != previous_dialog_type:
                        logger.debug(f"Dialog type changed from '{previous_dialog_type}' to '{editor_state.active_dialog_type}' after handle_dialog_events.")
                        if editor_state.current_editor_mode != previous_mode:
                            logger.debug(f"Mode changed (likely via dialog callback) from '{previous_mode}' to '{editor_state.current_editor_mode}'. Triggering layout recalc.")
                            layout_needs_recalc = True
                else:
                    if editor_state.current_editor_mode == "menu":
                        if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
                            logger.info("Escape pressed in menu. Posting QUIT event.")
                            pygame.event.post(pygame.event.Event(pygame.QUIT))
                            continue
                        editor_event_handlers.handle_menu_events(event, editor_state, editor_screen)
                    elif editor_state.current_editor_mode == "editing_map":
                        editor_event_handlers.handle_editing_map_events(event, editor_state, asset_palette_section_rect, map_view_section_rect, editor_screen)
                
                if editor_state.current_editor_mode != previous_mode:
                    logger.debug(f"Mode changed from '{previous_mode}' to '{editor_state.current_editor_mode}' after specific event handlers. Triggering layout recalc.")
                    layout_needs_recalc = True
            if not running: break

            if editor_state.current_editor_mode == "editing_map" and \
               not editor_state.active_dialog_type and \
               not editor_state.is_mouse_over_map_view and \
               (abs(editor_state.camera_momentum_pan[0]) > ED_CONFIG.CAMERA_MOMENTUM_MIN_SPEED_THRESHOLD or \
                abs(editor_state.camera_momentum_pan[1]) > ED_CONFIG.CAMERA_MOMENTUM_MIN_SPEED_THRESHOLD) and \
                not pygame.key.get_pressed()[pygame.K_a] and not pygame.key.get_pressed()[pygame.K_d] and \
                not pygame.key.get_pressed()[pygame.K_w] and not pygame.key.get_pressed()[pygame.K_s] :

                cam_vx, cam_vy = editor_state.camera_momentum_pan
                damping_this_frame = ED_CONFIG.CAMERA_MOMENTUM_DAMPING_FACTOR ** (dt * 60.0)
                cam_vx *= damping_this_frame
                cam_vy *= damping_this_frame
                editor_state.camera_offset_x += cam_vx * dt
                editor_state.camera_offset_y += cam_vy * dt
                max_cam_x = max(0, editor_state.get_map_pixel_width() - map_view_section_rect.width)
                max_cam_y = max(0, editor_state.get_map_pixel_height() - map_view_section_rect.height)
                boundary_hit = False
                if editor_state.camera_offset_x <= 0:
                    editor_state.camera_offset_x = 0; cam_vx = 0; boundary_hit = True
                elif editor_state.camera_offset_x >= max_cam_x:
                    editor_state.camera_offset_x = max_cam_x; cam_vx = 0; boundary_hit = True
                if editor_state.camera_offset_y <= 0:
                    editor_state.camera_offset_y = 0; cam_vy = 0; boundary_hit = True
                elif editor_state.camera_offset_y >= max_cam_y:
                    editor_state.camera_offset_y = max_cam_y; cam_vy = 0; boundary_hit = True
                editor_state.camera_offset_x = int(editor_state.camera_offset_x)
                editor_state.camera_offset_y = int(editor_state.camera_offset_y)
                if math.sqrt(cam_vx**2 + cam_vy**2) < ED_CONFIG.CAMERA_MOMENTUM_MIN_SPEED_THRESHOLD or boundary_hit:
                    editor_state.camera_momentum_pan = (0.0, 0.0)
                else:
                    editor_state.camera_momentum_pan = (cam_vx, cam_vy)
            
            if layout_needs_recalc:
                logger.debug(f"Recalculating layout. Current Mode: '{editor_state.current_editor_mode}', Screen: {current_screen_width}x{current_screen_height}")
                menu_section_rect, asset_palette_section_rect, map_view_section_rect = calculate_layout_rects(
                    current_screen_width, current_screen_height, editor_state.current_editor_mode
                )
                logger.debug(f"New Layout - Menu={menu_section_rect}, Assets={asset_palette_section_rect}, Map={map_view_section_rect}")
                if editor_state.current_editor_mode == "editing_map" and editor_state.map_content_surface:
                    map_px_w = editor_state.get_map_pixel_width(); map_px_h = editor_state.get_map_pixel_height()
                    view_w = map_view_section_rect.width; view_h = map_view_section_rect.height
                    if view_w > 0 and view_h > 0 :
                        max_cx = max(0, map_px_w - view_w); max_cy = max(0, map_px_h - view_h)
                        prev_cx, prev_cy = editor_state.camera_offset_x, editor_state.camera_offset_y
                        editor_state.camera_offset_x = max(0,min(editor_state.camera_offset_x,max_cx))
                        editor_state.camera_offset_y = max(0,min(editor_state.camera_offset_y,max_cy))
                        if prev_cx!=editor_state.camera_offset_x or prev_cy!=editor_state.camera_offset_y:
                            logger.debug(f"Camera clamped after resize/layout from ({prev_cx},{prev_cy}) to ({editor_state.camera_offset_x},{editor_state.camera_offset_y}). Max: ({max_cx},{max_cy})")
                    else: logger.warning(f"Map view rect zero/negative W/H ({view_w}x{view_h}). Camera not adjusted.")

            editor_screen.fill(ED_CONFIG.C.DARK_GRAY if hasattr(ED_CONFIG.C, 'DARK_GRAY') else (50,50,50)) # type: ignore

            if editor_state.current_editor_mode == "menu":
                editor_drawing.draw_menu_ui(editor_screen, editor_state, menu_section_rect, fonts, mouse_pos)
                ph_rect = pygame.Rect(menu_section_rect.right + ED_CONFIG.SECTION_PADDING, ED_CONFIG.SECTION_PADDING,
                                      current_screen_width - menu_section_rect.right - ED_CONFIG.SECTION_PADDING*2,
                                      current_screen_height - ED_CONFIG.SECTION_PADDING*2)
                if ph_rect.width > 10 and ph_rect.height > 10:
                    pygame.draw.rect(editor_screen, (20,20,20), ph_rect)
                    f_large = fonts.get("large");
                    if f_large: editor_screen.blit(f_large.render("Map Editor Area",True,(60,60,60)), f_large.render("Map Editor Area",True,(60,60,60)).get_rect(center=ph_rect.center))
            elif editor_state.current_editor_mode == "editing_map":
                editor_drawing.draw_asset_palette_ui(editor_screen, editor_state, asset_palette_section_rect, fonts, mouse_pos, map_view_section_rect)
                editor_drawing.draw_map_view_ui(editor_screen, editor_state, map_view_section_rect, fonts, mouse_pos)

            if editor_state.active_dialog_type: editor_ui.draw_active_dialog(editor_screen, editor_state, fonts)
            f_tooltip = fonts.get("tooltip");
            if f_tooltip: editor_ui.draw_tooltip(editor_screen, editor_state, f_tooltip)
            f_small = fonts.get("small");
            if f_small: editor_ui.draw_status_message(editor_screen, editor_state, f_small)
            pygame.display.flip()

    except Exception as e:
        if logger: logger.critical(f"CRITICAL ERROR in editor_main: {e}", exc_info=True)
        else: print(f"CRITICAL ERROR in editor_main (logger not available): {e}")
        traceback.print_exc()
    finally:
        if logger: logger.info("Exiting editor_main. Calling pygame.quit().")
        else: print("Exiting editor_main. Calling pygame.quit().")
        pygame.quit()
        if logger: logger.info("Editor session ended.")
        else: print("Editor session ended.")
        sys.exit()

if __name__ == "__main__":
    print("--- editor.py execution started (__name__ == '__main__') ---") # Initial console print
    editor_main()

########## START OF FILE: editor_assets.py ##########

# editor_assets.py
# -*- coding: utf-8 -*-
"""
## version 1.0.0.7 (Adjust palette height calculation for minimap)
Handles loading and managing assets for the editor's palette.
"""
import pygame
import os
import sys
import traceback
from typing import Optional, List, Dict, Any

# --- (Sys.path manipulation and assets import - keeping essential prints) ---
current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
if parent_dir not in sys.path:
    sys.path.insert(0, parent_dir)
    # print(f"INFO ASSETS: Added '{parent_dir}' to sys.path for 'assets' module import.")
# try:
    # from assets import load_gif_frames, resource_path
    # print("INFO ASSETS: Imported 'load_gif_frames' and 'resource_path' from assets.py")
# except ImportError as e:
    # print(f"CRITICAL ASSETS ERROR: Failed to import from 'assets.py': {e}")
    # def load_gif_frames(path: str) -> list:
        # print(f"CRITICAL ASSETS ERROR: Using DUMMY load_gif_frames for path: {path}")
        # return []
    # def resource_path(relative_path: str) -> str:
        # resolved_path = os.path.join(parent_dir, relative_path)
        # print(f"CRITICAL ASSETS ERROR: Using DUMMY resource_path. Input: '{relative_path}', Output: '{resolved_path}'")
        # return resolved_path
    # print("CRITICAL ASSETS ERROR: Using dummy asset loading functions.")
# except Exception as e_gen:
    # print(f"CRITICAL ASSETS ERROR: Unexpected error importing from 'assets.py': {e_gen}"); traceback.print_exc()
    # sys.exit("Failed to initialize assets module in editor_assets.py")

# Simplified import for brevity in this example, ensure your actual import works
try:
    from assets import load_gif_frames, resource_path # Assuming this is in your project root/assets.py
except ImportError:
    print("CRITICAL: 'assets' module not found. Using dummy functions.")
    def load_gif_frames(path): return []
    def resource_path(path): return os.path.join(parent_dir, path) # Basic fallback


import editor_config as ED_CONFIG
from editor_state import EditorState


def load_editor_palette_assets(editor_state: EditorState):
    editor_state.assets_palette.clear()
    # print("INFO ASSETS: Loading editor palette assets...")
    successful_loads = 0; failed_loads = 0
    ts = ED_CONFIG.DEFAULT_GRID_SIZE

    for asset_key, asset_info in ED_CONFIG.EDITOR_PALETTE_ASSETS.items():
        surf: Optional[pygame.Surface] = None
        tooltip = asset_info.get("tooltip", asset_key)
        game_type_id = asset_info.get("game_type_id", asset_key)
        category = asset_info.get("category", "unknown")
        original_w, original_h = ts, ts

        if "source_file" in asset_info:
            source_file_path = asset_info["source_file"]
            try:
                full_path = resource_path(source_file_path)
                if not os.path.exists(full_path):
                    print(f"Assets Error: File NOT FOUND at '{full_path}' for asset '{asset_key}'")
                else:
                    frames = load_gif_frames(full_path)
                    if frames: surf = frames[0]
                    # else: print(f"Warning ASSETS: load_gif_frames returned empty list for '{asset_key}' from '{full_path}'.")
            except Exception as e: print(f"Error ASSETS: Loading '{asset_key}' from '{source_file_path}': {e}");
        elif "surface_params" in asset_info:
            try:
                w, h, color = asset_info["surface_params"]
                original_w, original_h = w, h
                surf = pygame.Surface((max(1, w), max(1, h))); surf.fill(color)
            except Exception as e: print(f"Error ASSETS: Creating surface for '{asset_key}': {e}");
        elif "render_mode" in asset_info and asset_info["render_mode"] == "half_tile":
            try:
                surf = pygame.Surface((ts, ts), pygame.SRCALPHA)
                surf.fill((0,0,0,0))
                color = asset_info.get("base_color_tuple", getattr(ED_CONFIG.C, "MAGENTA", (255,0,255)))
                half_type = asset_info.get("half_type", "left")
                rect_to_draw = pygame.Rect(0,0,0,0)
                if half_type == "left": rect_to_draw = pygame.Rect(0, 0, ts // 2, ts)
                elif half_type == "right": rect_to_draw = pygame.Rect(ts // 2, 0, ts // 2, ts)
                elif half_type == "top": rect_to_draw = pygame.Rect(0, 0, ts, ts // 2)
                elif half_type == "bottom": rect_to_draw = pygame.Rect(0, ts // 2, ts, ts // 2)
                pygame.draw.rect(surf, color, rect_to_draw)
                original_w, original_h = ts, ts
            except Exception as e: print(f"Error ASSETS: Creating half_tile surface for '{asset_key}': {e}");
        elif "icon_type" in asset_info:
            try:
                surf = pygame.Surface((ts, ts), pygame.SRCALPHA)
                surf.fill((0,0,0,0))
                color = asset_info.get("base_color_tuple", getattr(ED_CONFIG.C, "YELLOW", (255,255,0)))
                icon_type = asset_info["icon_type"]
                if icon_type == "2x2_placer":
                    pygame.draw.rect(surf, color, (ts*0.1, ts*0.1, ts*0.35, ts*0.35))
                    pygame.draw.rect(surf, color, (ts*0.55, ts*0.1, ts*0.35, ts*0.35))
                    pygame.draw.rect(surf, color, (ts*0.1, ts*0.55, ts*0.35, ts*0.35))
                    pygame.draw.rect(surf, color, (ts*0.55, ts*0.55, ts*0.35, ts*0.35))
                    pygame.draw.rect(surf, getattr(ED_CONFIG.C, "BLACK", (0,0,0)), (0,0,ts,ts), 1)
                elif icon_type == "triangle_tool":
                    points = [(ts*0.5, ts*0.1), (ts*0.1, ts*0.9), (ts*0.9, ts*0.9)]
                    pygame.draw.polygon(surf, color, points)
                    pygame.draw.polygon(surf, getattr(ED_CONFIG.C, "BLACK", (0,0,0)), points, 2)
                original_w, original_h = ts, ts
            except Exception as e: print(f"Error ASSETS: Creating icon surface for '{asset_key}': {e}");

        if not surf:
            # print(f"Warning ASSETS: Surface for '{asset_key}' is None. Creating fallback.")
            surf = pygame.Surface((ts, ts))
            surf.fill(getattr(ED_CONFIG.C, 'RED', (255,0,0)))
            pygame.draw.line(surf, getattr(ED_CONFIG.C, 'BLACK', (0,0,0)), (0,0), surf.get_size(), 1)
            pygame.draw.line(surf, getattr(ED_CONFIG.C, 'BLACK', (0,0,0)), (0,surf.get_height()-1), (surf.get_width()-1,0), 1)
            tooltip += " (Load Error)"; failed_loads += 1
        else:
            if asset_info.get("source_file"):
                 original_w, original_h = surf.get_size()
            successful_loads +=1

        scaled_surf = surf
        if (asset_info.get("source_file") and (original_w > ED_CONFIG.ASSET_THUMBNAIL_MAX_WIDTH or original_h > ED_CONFIG.ASSET_THUMBNAIL_MAX_HEIGHT)) or \
           (not asset_info.get("source_file") and (original_w != ED_CONFIG.ASSET_THUMBNAIL_MAX_WIDTH or original_h != ED_CONFIG.ASSET_THUMBNAIL_MAX_HEIGHT) and \
            (original_w > ED_CONFIG.ASSET_THUMBNAIL_MAX_WIDTH or original_h > ED_CONFIG.ASSET_THUMBNAIL_MAX_HEIGHT)):
            if original_w > ED_CONFIG.ASSET_THUMBNAIL_MAX_WIDTH or original_h > ED_CONFIG.ASSET_THUMBNAIL_MAX_HEIGHT:
                ratio = min(ED_CONFIG.ASSET_THUMBNAIL_MAX_WIDTH / original_w if original_w > 0 else 1,
                            ED_CONFIG.ASSET_THUMBNAIL_MAX_HEIGHT / original_h if original_h > 0 else 1)
                new_w, new_h = max(1, int(original_w * ratio)), max(1, int(original_h * ratio))
                try:
                    scaled_surf = pygame.transform.smoothscale(surf, (new_w, new_h))
                except Exception:
                    # print(f"Error ASSETS: Scaling '{asset_key}' failed. Using original.");
                    scaled_surf = surf
        try:
            final_surf_to_store = scaled_surf.convert_alpha() if scaled_surf.get_flags() & pygame.SRCALPHA else scaled_surf.convert()
        except pygame.error as e:
            # print(f"Error ASSETS: Converting surface for '{asset_key}' failed: {e}. Using unoptimized surface.");
            final_surf_to_store = scaled_surf

        editor_state.assets_palette[asset_key] = {
            "image": final_surf_to_store, "game_type_id": game_type_id,
            "tooltip": tooltip, "category": category,
            "original_size_pixels": (original_w, original_h),
            "places_asset_key": asset_info.get("places_asset_key"),
            "colorable": asset_info.get("colorable", False),
            "render_mode": asset_info.get("render_mode"),
            "half_type": asset_info.get("half_type"),
            "base_color_tuple": asset_info.get("base_color_tuple"),
            "surface_params_dims_color": asset_info.get("surface_params")
        }
    # print(f"INFO ASSETS: Palette loading done. Success: {successful_loads}, Failed: {failed_loads}.")
    _calculate_asset_palette_total_height(editor_state)


def _calculate_asset_palette_total_height(editor_state: EditorState):
    # This calculates the height of the *scrollable content* below the minimap
    current_calc_y = ED_CONFIG.ASSET_PALETTE_ITEM_PADDING # Start padding for the first category

    font_category = ED_CONFIG.FONT_CONFIG.get("medium")
    font_tooltip = ED_CONFIG.FONT_CONFIG.get("small")
    cat_font_h = font_category.get_height() if font_category else 28
    tip_font_h = font_tooltip.get_height() if font_tooltip else 20

    tooltip_text_v_offset = getattr(ED_CONFIG, 'ASSET_PALETTE_TOOLTIP_TEXT_V_OFFSET', 2)

    categories_in_order = getattr(ED_CONFIG, 'EDITOR_PALETTE_ASSETS_CATEGORIES_ORDER',
                                  ["tool", "tile", "hazard", "item", "enemy", "spawn", "unknown"])

    categorized_assets_present: Dict[str, List[Dict[str, Any]]] = {cat_name: [] for cat_name in categories_in_order}
    # Ensure all expected keys exist
    for cat_name in ["tool", "tile", "hazard", "item", "enemy", "spawn", "unknown"]:
        if cat_name not in categorized_assets_present:
            categorized_assets_present[cat_name] = []


    for asset_key, data in editor_state.assets_palette.items():
        category_name = data.get("category", "unknown")
        categorized_assets_present.get(category_name, categorized_assets_present["unknown"]).append(data)

    for category_name in categories_in_order:
        assets_in_this_category = categorized_assets_present.get(category_name, [])
        if not assets_in_this_category:
            continue

        current_calc_y += cat_font_h + ED_CONFIG.ASSET_PALETTE_ITEM_PADDING # Height for category title

        if category_name == "spawn" and \
           any(d.get("game_type_id") == "player1_spawn" for d in assets_in_this_category) and \
           any(d.get("game_type_id") == "player2_spawn" for d in assets_in_this_category):
            # ... (spawn specific layout logic, already uses asset_data["image"].get_height()) ...
            p1_data = next((d for d in assets_in_this_category if d.get("game_type_id") == "player1_spawn"), None)
            p2_data = next((d for d in assets_in_this_category if d.get("game_type_id") == "player2_spawn"), None)
            max_img_h = 0
            if p1_data and p1_data.get("image"): max_img_h = max(max_img_h, p1_data["image"].get_height())
            if p2_data and p2_data.get("image"): max_img_h = max(max_img_h, p2_data["image"].get_height())

            if max_img_h > 0:
                current_calc_y += max_img_h
                current_calc_y += tip_font_h + tooltip_text_v_offset
                current_calc_y += ED_CONFIG.ASSET_PALETTE_ITEM_PADDING
            assets_in_this_category = [d for d in assets_in_this_category if d.get("game_type_id") not in ["player1_spawn", "player2_spawn"]]


        for asset_data in assets_in_this_category: # Process remaining or all other items
            asset_img = asset_data.get("image")
            if not asset_img:
                continue
            current_calc_y += asset_img.get_height()
            current_calc_y += tip_font_h + tooltip_text_v_offset
            current_calc_y += ED_CONFIG.ASSET_PALETTE_ITEM_PADDING

        current_calc_y += ED_CONFIG.ASSET_PALETTE_ITEM_PADDING # Extra padding after the entire category block

    asset_palette_bottom_overhang_px = getattr(ED_CONFIG, 'ASSET_PALETTE_BOTTOM_OVERHANG_PX', 72)
    current_calc_y += asset_palette_bottom_overhang_px

    editor_state.total_asset_palette_content_height = current_calc_y # This is for the scrollable part
    # print(f"INFO ASSETS: Calculated total asset palette SCROLLABLE content height: {editor_state.total_asset_palette_content_height}")

########## START OF FILE: editor_config.py ##########

# editor_config.py
# -*- coding: utf-8 -*-
"""
## version 1.0.0.8 (Added camera momentum config)
Configuration constants for the Platformer Level Editor.
"""
import pygame
import sys
import os
import traceback
from typing import Dict, Optional, Tuple, Any

# --- Add parent directory to sys.path ---
current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
if parent_dir not in sys.path:
    sys.path.insert(0, parent_dir)

try:
    import constants as C
except ImportError as e:
    print(f"CRITICAL CONFIG ERROR: Failed to import 'constants as C' from '{parent_dir}'. Error: {e}")
    class FallbackConstants:
        TILE_SIZE = 32; WHITE = (255,255,255); BLACK = (0,0,0); RED = (255,0,0); GREEN = (0,255,0)
        BLUE = (0,0,255); GRAY = (128,128,128); DARK_GRAY = (50,50,50); YELLOW = (255,255,0)
        LIGHT_BLUE = (173,216,230); DARK_GREEN = (0,100,0); ORANGE_RED = (255,69,0)
        LIGHT_GRAY = (200,200,200); FPS = 60
        MAGENTA = (255, 0, 255)
    C = FallbackConstants()
    print("CRITICAL CONFIG ERROR: Using fallback constants. Editor functionality will be impaired.")
except Exception as e_gen:
    print(f"CRITICAL CONFIG ERROR: Unexpected error importing 'constants': {e_gen}"); traceback.print_exc()
    sys.exit("Failed to initialize constants in editor_config.py")


# --- Editor Window Dimensions ---
EDITOR_SCREEN_INITIAL_WIDTH = 1280
EDITOR_SCREEN_INITIAL_HEIGHT = 720

MENU_SECTION_WIDTH = 280
MENU_SECTION_HEIGHT = 250

ASSET_PALETTE_SECTION_WIDTH = 220

SECTION_PADDING = 10

MAP_VIEW_SECTION_DEFAULT_WIDTH = EDITOR_SCREEN_INITIAL_WIDTH - MENU_SECTION_WIDTH - ASSET_PALETTE_SECTION_WIDTH - (SECTION_PADDING * 3)
MAP_VIEW_SECTION_DEFAULT_HEIGHT = EDITOR_SCREEN_INITIAL_HEIGHT - (SECTION_PADDING * 2)


# --- Camera Control ---
KEY_PAN_SPEED_PIXELS_PER_SECOND = 300
EDGE_SCROLL_ZONE_THICKNESS = 30
EDGE_SCROLL_SPEED_PIXELS_PER_SECOND = 250
CAMERA_MOMENTUM_INITIAL_MULTIPLIER = 1.5
CAMERA_MOMENTUM_DAMPING_FACTOR = 0.96
CAMERA_MOMENTUM_MIN_SPEED_THRESHOLD = 5.0
CAMERA_MOMENTUM_BOUNDARY_DAMP_FACTOR = 0.5


# --- Minimap Configuration ---
MINIMAP_AREA_HEIGHT = 120
MINIMAP_PADDING = 5
MINIMAP_BG_COLOR: Tuple[int,int,int] = (10, 10, 10)
MINIMAP_BORDER_COLOR: Tuple[int,int,int] = getattr(C, 'GRAY', (128,128,128))
MINIMAP_CAMERA_VIEW_RECT_COLOR: Tuple[int,int,int] = getattr(C, 'YELLOW', (255,255,0))
MINIMAP_CAMERA_VIEW_RECT_ALPHA = 100

# --- UI Element Sizes & Colors ---
BUTTON_WIDTH_STANDARD = 200
BUTTON_HEIGHT_STANDARD = 50
BUTTON_TEXT_COLOR: Tuple[int,int,int] = getattr(C, 'WHITE', (255,255,255))
BUTTON_COLOR_NORMAL: Tuple[int,int,int] = getattr(C, 'BLUE', (0,0,255))
BUTTON_COLOR_HOVER: Tuple[int,int,int] = getattr(C, 'GREEN', (0,255,0))
BUTTON_COLOR_BORDER: Tuple[int,int,int] = getattr(C, 'BLACK', (0,0,0))
BUTTON_BORDER_WIDTH = 2

ASSET_THUMBNAIL_MAX_WIDTH = getattr(C, 'TILE_SIZE', 32) * 2
ASSET_THUMBNAIL_MAX_HEIGHT = getattr(C, 'TILE_SIZE', 32) * 2
ASSET_PALETTE_ITEM_PADDING = 5
ASSET_PALETTE_BG_COLOR: Tuple[int,int,int] = (30, 30, 30)
ASSET_PALETTE_CATEGORY_TEXT_COLOR: Tuple[int,int,int] = getattr(C, 'YELLOW', (255,255,0))
ASSET_PALETTE_TOOLTIP_COLOR: Tuple[int,int,int] = getattr(C, 'LIGHT_GRAY', (200,200,200))
ASSET_PALETTE_HOVER_BG_COLOR: Tuple[int,int,int] = (50, 80, 50)
ASSET_PALETTE_BOTTOM_OVERHANG_PX = 72
ASSET_PALETTE_TOOLTIP_TEXT_V_OFFSET = 2

MAP_VIEW_GRID_COLOR: Tuple[int,int,int] = getattr(C, 'GRAY', (128,128,128))
MAP_VIEW_BORDER_COLOR: Tuple[int,int,int] = getattr(C, 'GRAY', (128,128,128))

DIALOG_BG_COLOR: Tuple[int,int,int] = (60, 60, 70)
DIALOG_INPUT_BOX_COLOR: Tuple[int,int,int] = getattr(C, 'WHITE', (255,255,255))
DIALOG_INPUT_TEXT_COLOR: Tuple[int,int,int] = getattr(C, 'BLACK', (0,0,0))
DIALOG_PROMPT_COLOR: Tuple[int,int,int] = getattr(C, 'WHITE', (255,255,255))
DIALOG_CURSOR_COLOR: Tuple[int,int,int] = getattr(C, 'BLACK', (0,0,0))

COLOR_PICKER_BUTTON_SIZE = 40
COLOR_PICKER_PADDING = 8
COLOR_PICKER_COLS = 5
COLOR_PICKER_BG_COLOR: Tuple[int,int,int] = (40, 40, 50)
COLOR_PICKER_TITLE_COLOR: Tuple[int,int,int] = getattr(C, 'WHITE', (255,255,255))
COLOR_PICKER_HOVER_BORDER_COLOR: Tuple[int,int,int] = getattr(C, 'YELLOW', (255,255,0))

MAPS_DIRECTORY = "maps"

TS = getattr(C, 'TILE_SIZE', 32)

EDITOR_PALETTE_ASSETS: Dict[str, Dict[str, Any]] = {
    "color_change_tool": {
        "icon_type": "triangle_tool", "base_color_tuple": getattr(C, 'MAGENTA', (255,0,255)),
        "game_type_id": "tool_color_change", "tooltip": "Color Tool", "category": "tool"
    },
    "player1_spawn": {
        "source_file": "characters/player1/__Idle.gif", "game_type_id": "player1_spawn",
        "tooltip": "P1 Spawn", "category": "spawn"
    },
    "player2_spawn": {
        "source_file": "characters/player2/__Idle.gif", "game_type_id": "player2_spawn",
        "tooltip": "P2 Spawn", "category": "spawn"
    },
    "enemy_cyan": {"source_file": "characters/cyan/__Idle.gif", "game_type_id": "enemy_cyan", "tooltip": "Enemy (Cyan)", "category": "enemy"},
    "enemy_green": { "source_file": "characters/green/__Idle.gif", "game_type_id": "enemy_green", "tooltip": "Enemy (Green)", "category": "enemy"},
    "enemy_pink": { "source_file": "characters/pink/__Idle.gif", "game_type_id": "enemy_pink", "tooltip": "Enemy (Pink)", "category": "enemy"},
    "enemy_purple": { "source_file": "characters/purple/__Idle.gif", "game_type_id": "enemy_purple", "tooltip": "Enemy (Purple)", "category": "enemy"},
    "enemy_red": { "source_file": "characters/red/__Idle.gif", "game_type_id": "enemy_red", "tooltip": "Enemy (Red)", "category": "enemy"},
    "enemy_yellow": { "source_file": "characters/yellow/__Idle.gif", "game_type_id": "enemy_yellow", "tooltip": "Enemy (Yellow)", "category": "enemy"},
    "chest": {"source_file": "characters/items/chest.gif", "game_type_id": "chest", "tooltip": "Chest", "category": "item"},
    "platform_wall_gray": {"surface_params": (TS, TS, getattr(C, 'GRAY', (128,128,128))), "colorable": True, "game_type_id": "platform_wall_gray", "tooltip": "Wall (Gray)", "category": "tile"},
    "platform_wall_gray_2x2_placer": {"icon_type": "2x2_placer", "base_color_tuple": getattr(C, 'GRAY', (128,128,128)), "places_asset_key": "platform_wall_gray", "game_type_id": "tool_wall_2x2_placer", "tooltip": "Wall 2x2 (Gray)", "category": "tile"},
    "platform_ledge_green": {"surface_params": (TS, TS // 4, getattr(C, 'DARK_GREEN', (0,100,0))), "colorable": True, "game_type_id": "platform_ledge_green", "tooltip": "Ledge (Green)", "category": "tile"},
    "platform_wall_gray_left_half": {"render_mode": "half_tile", "half_type": "left", "base_color_tuple": getattr(C, 'GRAY', (128,128,128)), "colorable": True, "game_type_id": "platform_wall_gray_left_half", "tooltip": "Wall L-Half (Gray)", "category": "tile"},
    "platform_wall_gray_right_half": {"render_mode": "half_tile", "half_type": "right", "base_color_tuple": getattr(C, 'GRAY', (128,128,128)), "colorable": True, "game_type_id": "platform_wall_gray_right_half", "tooltip": "Wall R-Half (Gray)", "category": "tile"},
    "platform_wall_gray_top_half": {"render_mode": "half_tile", "half_type": "top", "base_color_tuple": getattr(C, 'GRAY', (128,128,128)), "colorable": True, "game_type_id": "platform_wall_gray_top_half", "tooltip": "Wall T-Half (Gray)", "category": "tile"},
    "platform_wall_gray_bottom_half": {"render_mode": "half_tile", "half_type": "bottom", "base_color_tuple": getattr(C, 'GRAY', (128,128,128)), "colorable": True, "game_type_id": "platform_wall_gray_bottom_half", "tooltip": "Wall B-Half (Gray)", "category": "tile"},
    "platform_ledge_green_left_half": {"render_mode": "half_tile", "half_type": "left", "base_color_tuple": getattr(C, 'DARK_GREEN', (0,100,0)), "colorable": True, "game_type_id": "platform_ledge_green_left_half", "tooltip": "Ledge L-Half (Green)", "category": "tile"},
    "platform_ledge_green_right_half": {"render_mode": "half_tile", "half_type": "right", "base_color_tuple": getattr(C, 'DARK_GREEN', (0,100,0)), "colorable": True, "game_type_id": "platform_ledge_green_right_half", "tooltip": "Ledge R-Half (Green)", "category": "tile"},
    "platform_ledge_green_top_half": {"render_mode": "half_tile", "half_type": "top", "base_color_tuple": getattr(C, 'DARK_GREEN', (0,100,0)), "colorable": True, "game_type_id": "platform_ledge_green_top_half", "tooltip": "Ledge T-Half (Green)", "category": "tile"},
    "platform_ledge_green_bottom_half": {"render_mode": "half_tile", "half_type": "bottom", "base_color_tuple": getattr(C, 'DARK_GREEN', (0,100,0)), "colorable": True, "game_type_id": "platform_ledge_green_bottom_half", "tooltip": "Ledge B-Half (Green)", "category": "tile"},
    "hazard_lava_tile": {"surface_params": (TS, TS, getattr(C, 'ORANGE_RED', (255,69,0))), "colorable": True, "game_type_id": "hazard_lava", "tooltip": "Lava Tile", "category": "hazard"},
}

EDITOR_PALETTE_ASSETS_CATEGORIES_ORDER = ["tool", "tile", "hazard", "item", "enemy", "spawn", "unknown"]

DEFAULT_MAP_WIDTH_TILES = 30
DEFAULT_MAP_HEIGHT_TILES = 20
DEFAULT_GRID_SIZE = TS
DEFAULT_BACKGROUND_COLOR: Tuple[int,int,int] = getattr(C, 'LIGHT_BLUE', (173,216,230))

LEVEL_EDITOR_SAVE_FORMAT_EXTENSION = ".json"
GAME_LEVEL_FILE_EXTENSION = ".py"

TOOLTIP_FONT_SIZE = 18
TOOLTIP_TEXT_COLOR: Tuple[int,int,int] = getattr(C, 'BLACK', (0,0,0))
TOOLTIP_BG_COLOR: Tuple[int,int,int] = (240, 240, 210)
TOOLTIP_PADDING = 5
TOOLTIP_OFFSET_Y = 25

COLOR_PICKER_PRESETS: Dict[str, Tuple[int,int,int]] = {
    "Light Blue": getattr(C, 'LIGHT_BLUE', (173,216,230)), "White": getattr(C, 'WHITE', (255,255,255)),
    "Black": getattr(C, 'BLACK', (0,0,0)), "Gray": getattr(C, 'GRAY', (128,128,128)),
    "Dark Gray": getattr(C, 'DARK_GRAY', (50,50,50)), "Red": getattr(C, 'RED', (255,0,0)),
    "Green": getattr(C, 'GREEN', (0,255,0)), "Blue": getattr(C, 'BLUE', (0,0,255)),
    "Yellow": getattr(C, 'YELLOW', (255,255,0)), "Orange": getattr(C, 'ORANGE_RED', (255,69,0)),
    "Purple": (128, 0, 128), "Brown": (139, 69, 19),
    "Dark Green": getattr(C, 'DARK_GREEN', (0,100,0)), "Sky Blue": (100, 150, 255),
    "Dark Purple": (75,0,130), "Sand": (244,164,96),
    "Magenta": getattr(C, 'MAGENTA', (255, 0, 255))
}

FONT_CONFIG: Dict[str, Optional[pygame.font.Font]] = {
    "small": None, "medium": None, "large": None, "tooltip": None
}
try:
    if not pygame.font.get_init():
        pygame.font.init()
    if pygame.font.get_init():
        FONT_CONFIG["small"] = pygame.font.Font(None, 22)
        FONT_CONFIG["medium"] = pygame.font.Font(None, 28)
        FONT_CONFIG["large"] = pygame.font.Font(None, 36)
        FONT_CONFIG["tooltip"] = pygame.font.Font(None, TOOLTIP_FONT_SIZE)
except pygame.error as e:
    print(f"CRITICAL CONFIG ERROR: Pygame error initializing fonts: {e}"); traceback.print_exc()
except Exception as e_font:
    print(f"CRITICAL CONFIG ERROR: Generic error initializing fonts: {e_font}"); traceback.print_exc()

########## START OF FILE: editor_drawing.py ##########

# editor_drawing.py
# -*- coding: utf-8 -*-
"""
## version 1.0.0.16 (Minimap object drawing refinement)
Contains functions for drawing the different sections and elements
of the Platformer Level Editor UI using Pygame.
"""
import pygame
from typing import Dict, Tuple, Any, Optional
import traceback

import editor_config as ED_CONFIG
from editor_state import EditorState
from editor_ui import draw_button


def draw_menu_ui(surface: pygame.Surface, editor_state: EditorState, menu_section_rect: pygame.Rect,
                 fonts: Dict[str, Optional[pygame.font.Font]], mouse_pos: Tuple[int, int]):
    try:
        pygame.draw.rect(surface, getattr(ED_CONFIG.C, 'BLACK', (0,0,0)), menu_section_rect)
        title_font = fonts.get("large") or ED_CONFIG.FONT_CONFIG.get("large")
        button_font = fonts.get("medium") or ED_CONFIG.FONT_CONFIG.get("medium")

        if title_font:
            title_surf = title_font.render("Level Editor", True, getattr(ED_CONFIG.C, 'WHITE', (255,255,255)))
            title_rect = title_surf.get_rect(centerx=menu_section_rect.centerx, top=menu_section_rect.top + 20)
            surface.blit(title_surf, title_rect)

        button_w = ED_CONFIG.BUTTON_WIDTH_STANDARD
        button_h = ED_CONFIG.BUTTON_HEIGHT_STANDARD
        spacing = 20
        num_buttons = 3
        total_button_h = (num_buttons * button_h) + ((num_buttons - 1) * spacing)
        title_h_approx = title_font.get_height() if title_font else 40
        content_start_y = menu_section_rect.top + title_h_approx + 30
        remaining_h = menu_section_rect.height - (content_start_y - menu_section_rect.top)
        start_y = max(content_start_y + (remaining_h - total_button_h) // 2, content_start_y)

        if not hasattr(editor_state, 'ui_elements_rects') or editor_state.ui_elements_rects is None:
            editor_state.ui_elements_rects = {}
        for k in [key for key in editor_state.ui_elements_rects if key.startswith("menu_")]:
            del editor_state.ui_elements_rects[k]

        if button_font:
            rect_params = [
                (start_y, "menu_new_map", "New Map"),
                (start_y + button_h + spacing, "menu_load_map", "Load Map (.json)"),
                (start_y + 2 * (button_h + spacing), "menu_quit", "Quit Editor")
            ]
            for top_y, key, text in rect_params:
                btn_r = pygame.Rect(0,0,button_w,button_h)
                btn_r.centerx = menu_section_rect.centerx
                btn_r.top = top_y
                editor_state.ui_elements_rects[key] = btn_r
                draw_button(surface, btn_r, text, button_font, mouse_pos)
        else:
            print("Warning DRAW: Menu button font missing.")
    except Exception as e:
        print(f"ERROR DRAW: Exception in draw_menu_ui: {e}")
        traceback.print_exc()

def _regenerate_minimap_surface(editor_state: EditorState, available_width: int, available_height: int):
    if not editor_state.map_content_surface:
        editor_state.minimap_surface = None
        return

    map_px_w = editor_state.get_map_pixel_width()
    map_px_h = editor_state.get_map_pixel_height()

    if map_px_w <= 0 or map_px_h <= 0:
        editor_state.minimap_surface = None
        return

    scale_w = available_width / map_px_w if map_px_w > 0 else 0
    scale_h = available_height / map_px_h if map_px_h > 0 else 0
    scale = min(scale_w, scale_h) if scale_w > 0 and scale_h > 0 else 0

    minimap_w = int(map_px_w * scale)
    minimap_h = int(map_px_h * scale)

    if minimap_w <=0 or minimap_h <=0:
        editor_state.minimap_surface = pygame.Surface((1,1))
        editor_state.minimap_surface.fill(ED_CONFIG.MINIMAP_BG_COLOR)
        return

    minimap_content_surf = pygame.Surface((map_px_w, map_px_h))
    minimap_content_surf.fill(editor_state.background_color)
    
    ts = editor_state.grid_size
    for obj in editor_state.placed_objects:
        asset_key = obj.get("asset_editor_key")
        world_x, world_y = obj.get("world_x"), obj.get("world_y")
        if asset_key is None or world_x is None or world_y is None: continue

        asset_palette_info = editor_state.assets_palette.get(asset_key)
        if not asset_palette_info: continue

        obj_color_override = obj.get("override_color")
        
        # Determine the actual color to use for drawing this object on the minimap
        final_color_for_minimap_obj = getattr(ED_CONFIG.C, "LIGHT_GRAY", (200,200,200)) # Default fallback
        is_colorable = asset_palette_info.get("colorable", False)

        if is_colorable and obj_color_override:
            final_color_for_minimap_obj = obj_color_override
        elif asset_palette_info.get("surface_params_dims_color"):
            final_color_for_minimap_obj = asset_palette_info["surface_params_dims_color"][2]
        elif asset_palette_info.get("base_color_tuple"): # For half-tiles or icon_types with a base color
            final_color_for_minimap_obj = asset_palette_info["base_color_tuple"]
        # For GIFs (image-based without specific color params), they won't draw as simple rects here
        # unless we decide to draw a placeholder. For now, surface_params/half_tiles will show color.

        # Determine drawing dimensions for the object on the full-scale minimap_content_surf
        draw_w, draw_h = ts, ts # Default to full tile for minimap representation
        draw_x, draw_y = world_x, world_y
        
        # Use original_size_pixels if available from palette for more accuracy before scaling
        original_dims = asset_palette_info.get("original_size_pixels")
        if original_dims:
            draw_w, draw_h = original_dims[0], original_dims[1]

        # Adjust for half-tiles actual geometry
        if asset_palette_info.get("render_mode") == "half_tile":
            half_type = asset_palette_info.get("half_type")
            if half_type == "left": draw_w = ts // 2
            elif half_type == "right": draw_x = world_x + ts // 2; draw_w = ts // 2
            elif half_type == "top": draw_h = ts // 2
            elif half_type == "bottom": draw_y = world_y + ts // 2; draw_h = ts // 2
        
        obj_rect_on_map = pygame.Rect(draw_x, draw_y, draw_w, draw_h)
        
        # Only draw if we determined a color (i.e., it's not purely an image like a GIF character)
        # This primarily makes sense for tiles, hazards etc. that are color-based.
        if asset_palette_info.get("surface_params_dims_color") or \
           asset_palette_info.get("render_mode") == "half_tile" or \
           (is_colorable and obj_color_override): # If it's colorable and overridden, draw the color
            try:
                pygame.draw.rect(minimap_content_surf, final_color_for_minimap_obj, obj_rect_on_map)
            except TypeError:
                 pygame.draw.rect(minimap_content_surf, getattr(ED_CONFIG.C, "MAGENTA", (255,0,255)), obj_rect_on_map)
        elif asset_palette_info.get("image"): # For image based things like characters, try to blit scaled thumbnail
            # This can be slow if many complex images. For now, let's try it.
            # We need to scale the thumbnail appropriately for the *full map size* before it gets scaled down with the whole minimap.
            # This is tricky. Simpler: just draw colored rects for objects on minimap.
            # For now, stick to drawing colored rects for simplicity and performance.
            # If you want scaled images for GIFS on minimap, that's a more complex blit operation here.
            pass


    if editor_state.show_grid: # Optionally draw grid on minimap_content_surf before scaling
        grid_color_minimap = (50,50,50) # Darker grid for minimap
        for x_coord in range(0, map_px_w, ts):
            pygame.draw.line(minimap_content_surf, grid_color_minimap, (x_coord,0), (x_coord, map_px_h))
        for y_coord in range(0, map_px_h, ts):
            pygame.draw.line(minimap_content_surf, grid_color_minimap, (0, y_coord), (map_px_w, y_coord))


    try:
        editor_state.minimap_surface = pygame.transform.smoothscale(minimap_content_surf, (minimap_w, minimap_h))
    except pygame.error as e:
        print(f"ERROR DRAW: Minimap smoothscale failed: {e}. Using simple scale.")
        try:
            editor_state.minimap_surface = pygame.transform.scale(minimap_content_surf, (minimap_w, minimap_h))
        except pygame.error as e_simple:
            print(f"ERROR DRAW: Minimap simple scale also failed: {e_simple}.")
            editor_state.minimap_surface = pygame.Surface((minimap_w if minimap_w > 0 else 1, minimap_h if minimap_h > 0 else 1))
            editor_state.minimap_surface.fill(ED_CONFIG.MINIMAP_BG_COLOR)

    editor_state.minimap_needs_regeneration = False


def _draw_minimap(surface: pygame.Surface, editor_state: EditorState, palette_section_rect: pygame.Rect, map_view_rect: pygame.Rect):
    if not editor_state.map_content_surface: return

    minimap_outer_rect_width = palette_section_rect.width - (ED_CONFIG.MINIMAP_PADDING * 2)
    minimap_outer_rect_height = ED_CONFIG.MINIMAP_AREA_HEIGHT - (ED_CONFIG.MINIMAP_PADDING * 2)

    minimap_outer_rect = pygame.Rect(
        palette_section_rect.left + ED_CONFIG.MINIMAP_PADDING,
        palette_section_rect.top + ED_CONFIG.MINIMAP_PADDING,
        minimap_outer_rect_width,
        minimap_outer_rect_height
    )
    # Store the actual screen rect where the *scaled minimap image* will be drawn, for click detection.
    # This will be set after we know the scaled minimap's dimensions.
    # editor_state.minimap_rect_in_palette = minimap_outer_rect # This is the container, not the image itself

    pygame.draw.rect(surface, ED_CONFIG.MINIMAP_BG_COLOR, minimap_outer_rect)

    minimap_draw_area_width = minimap_outer_rect.width
    minimap_draw_area_height = minimap_outer_rect.height

    if editor_state.minimap_needs_regeneration:
        _regenerate_minimap_surface(editor_state, minimap_draw_area_width, minimap_draw_area_height)

    if editor_state.minimap_surface:
        # Center the scaled minimap surface within the minimap_outer_rect
        minimap_blit_x = minimap_outer_rect.left + (minimap_outer_rect.width - editor_state.minimap_surface.get_width()) // 2
        minimap_blit_y = minimap_outer_rect.top + (minimap_outer_rect.height - editor_state.minimap_surface.get_height()) // 2
        
        actual_minimap_screen_rect = editor_state.minimap_surface.get_rect(topleft=(minimap_blit_x, minimap_blit_y))
        editor_state.minimap_rect_in_palette = actual_minimap_screen_rect # Store this precise rect for clicks

        surface.blit(editor_state.minimap_surface, actual_minimap_screen_rect.topleft)
        pygame.draw.rect(surface, ED_CONFIG.MINIMAP_BORDER_COLOR, actual_minimap_screen_rect, 1)

        map_px_w = editor_state.get_map_pixel_width()
        map_px_h = editor_state.get_map_pixel_height()
        if map_px_w > 0 and map_px_h > 0 and editor_state.minimap_surface.get_width() > 0:
            scale_x = editor_state.minimap_surface.get_width() / map_px_w
            scale_y = editor_state.minimap_surface.get_height() / map_px_h
            cam_rect_mm_x = editor_state.camera_offset_x * scale_x
            cam_rect_mm_y = editor_state.camera_offset_y * scale_y
            cam_rect_mm_w = map_view_rect.width * scale_x
            cam_rect_mm_h = map_view_rect.height * scale_y
            cam_view_on_minimap = pygame.Rect(
                actual_minimap_screen_rect.left + cam_rect_mm_x,
                actual_minimap_screen_rect.top + cam_rect_mm_y,
                max(1, cam_rect_mm_w), max(1, cam_rect_mm_h)
            )
            s = pygame.Surface(cam_view_on_minimap.size, pygame.SRCALPHA)
            s.fill((*ED_CONFIG.MINIMAP_CAMERA_VIEW_RECT_COLOR, ED_CONFIG.MINIMAP_CAMERA_VIEW_RECT_ALPHA))
            surface.blit(s, cam_view_on_minimap.topleft)
            pygame.draw.rect(surface, ED_CONFIG.MINIMAP_CAMERA_VIEW_RECT_COLOR, cam_view_on_minimap, 1)


def _draw_single_palette_item(scroll_surf: pygame.Surface,
                              editor_state: EditorState,
                              palette_section_rect: pygame.Rect,
                              asset_key: str, asset_data: Dict[str, Any],
                              item_x: int, item_y_on_scroll: int,
                              tip_font: Optional[pygame.font.Font],
                              mouse_pos: Tuple[int, int]) -> int:
    img = asset_data.get("image")
    tooltip_text = asset_data.get("tooltip", asset_key)
    if not img: return 0

    scrollable_content_y_start_on_screen = palette_section_rect.top + ED_CONFIG.MINIMAP_AREA_HEIGHT
    item_rect_on_screen = pygame.Rect(
        palette_section_rect.left + item_x,
        scrollable_content_y_start_on_screen + item_y_on_scroll - editor_state.asset_palette_scroll_y,
        img.get_width(), img.get_height()
    )
    editor_state.ui_elements_rects['asset_palette_items'][asset_key] = item_rect_on_screen
    
    asset_list_on_screen_rect = pygame.Rect(
        palette_section_rect.left,
        scrollable_content_y_start_on_screen,
        palette_section_rect.width,
        palette_section_rect.height - ED_CONFIG.MINIMAP_AREA_HEIGHT - (ED_CONFIG.BUTTON_HEIGHT_STANDARD*0.8 + ED_CONFIG.ASSET_PALETTE_ITEM_PADDING*2)
    )
    is_hovered = item_rect_on_screen.collidepoint(mouse_pos) and asset_list_on_screen_rect.collidepoint(mouse_pos)
    is_selected = editor_state.selected_asset_editor_key == asset_key

    if is_hovered:
        editor_state.hovered_tooltip_text = tooltip_text
        editor_state.hovered_tooltip_pos = mouse_pos
        hover_bg_r = pygame.Rect(item_x - 2, item_y_on_scroll - 2, img.get_width() + 4, img.get_height() + 4)
        pygame.draw.rect(scroll_surf, ED_CONFIG.ASSET_PALETTE_HOVER_BG_COLOR, hover_bg_r, border_radius=2)
    if is_selected:
        select_b_r = pygame.Rect(item_x - 3, item_y_on_scroll - 3, img.get_width() + 6, img.get_height() + 6)
        pygame.draw.rect(scroll_surf, ED_CONFIG.C.YELLOW, select_b_r, 2, border_radius=3) # type: ignore

    scroll_surf.blit(img, (item_x, item_y_on_scroll))
    current_item_total_height = img.get_height()

    if tip_font:
        name_s = tip_font.render(tooltip_text, True, ED_CONFIG.ASSET_PALETTE_TOOLTIP_COLOR)
        text_x = item_x + (img.get_width() - name_s.get_width()) // 2
        scroll_surf.blit(name_s, (max(item_x, text_x), item_y_on_scroll + img.get_height() + ED_CONFIG.ASSET_PALETTE_TOOLTIP_TEXT_V_OFFSET))
        current_item_total_height += name_s.get_height() + ED_CONFIG.ASSET_PALETTE_TOOLTIP_TEXT_V_OFFSET
    return current_item_total_height


def draw_asset_palette_ui(surface: pygame.Surface, editor_state: EditorState, palette_section_rect: pygame.Rect,
                          fonts: Dict[str, Optional[pygame.font.Font]], mouse_pos: Tuple[int, int],
                          map_view_rect: pygame.Rect):
    try:
        _draw_minimap(surface, editor_state, palette_section_rect, map_view_rect)

        scrollable_assets_y_start = palette_section_rect.top + ED_CONFIG.MINIMAP_AREA_HEIGHT
        scrollable_assets_height = palette_section_rect.height - ED_CONFIG.MINIMAP_AREA_HEIGHT \
                                   - (ED_CONFIG.BUTTON_HEIGHT_STANDARD * 0.8 + ED_CONFIG.ASSET_PALETTE_ITEM_PADDING * 2)
        scrollable_assets_rect_on_screen = pygame.Rect(
            palette_section_rect.left, scrollable_assets_y_start,
            palette_section_rect.width, scrollable_assets_height
        )
        pygame.draw.rect(surface, ED_CONFIG.ASSET_PALETTE_BG_COLOR, scrollable_assets_rect_on_screen)

        if editor_state.total_asset_palette_content_height <= 0:
            font_small = fonts.get("small") or ED_CONFIG.FONT_CONFIG.get("small")
            if font_small:
                no_assets_text = "Assets Loading..."
                if not ED_CONFIG.EDITOR_PALETTE_ASSETS: no_assets_text = "No assets defined."
                elif not editor_state.assets_palette : no_assets_text = "Asset palette empty."
                msg_surf = font_small.render(no_assets_text, True, getattr(ED_CONFIG.C, 'WHITE', (255,255,255)))
                surface.blit(msg_surf, msg_surf.get_rect(center=scrollable_assets_rect_on_screen.center))

        if editor_state.total_asset_palette_content_height > 0:
            scroll_surf = pygame.Surface((palette_section_rect.width, editor_state.total_asset_palette_content_height), pygame.SRCALPHA)
            scroll_surf.fill((0,0,0,0))
            current_y_on_scroll_surf = ED_CONFIG.ASSET_PALETTE_ITEM_PADDING
            cat_font = fonts.get("medium") or ED_CONFIG.FONT_CONFIG.get("medium")
            tip_font = fonts.get("small") or ED_CONFIG.FONT_CONFIG.get("small")
            editor_state.hovered_tooltip_text = None
            if not hasattr(editor_state, 'ui_elements_rects') or editor_state.ui_elements_rects is None:
                editor_state.ui_elements_rects = {}
            editor_state.ui_elements_rects['asset_palette_items'] = {}
            categories_order = getattr(ED_CONFIG, 'EDITOR_PALETTE_ASSETS_CATEGORIES_ORDER',
                                    ["tool", "tile", "hazard", "item", "enemy", "spawn", "unknown"])
            for cat_name in categories_order:
                assets_in_category_tuples = [(k, d) for k, d in editor_state.assets_palette.items() if d.get("category", "unknown") == cat_name]
                if not assets_in_category_tuples: continue
                if cat_font:
                    cat_surf = cat_font.render(cat_name.title(), True, ED_CONFIG.ASSET_PALETTE_CATEGORY_TEXT_COLOR)
                    scroll_surf.blit(cat_surf, (ED_CONFIG.ASSET_PALETTE_ITEM_PADDING, current_y_on_scroll_surf))
                    current_y_on_scroll_surf += cat_surf.get_height() + ED_CONFIG.ASSET_PALETTE_ITEM_PADDING
                row_start_y_for_current_items = current_y_on_scroll_surf
                if cat_name == "spawn":
                    p1 = next(((k,d) for k,d in assets_in_category_tuples if k == "player1_spawn"), None)
                    p2 = next(((k,d) for k,d in assets_in_category_tuples if k == "player2_spawn"), None)
                    other = [i for i in assets_in_category_tuples if i[0] not in ["player1_spawn", "player2_spawn"]]
                    curr_x, max_h = ED_CONFIG.ASSET_PALETTE_ITEM_PADDING, 0
                    if p1:
                        h = _draw_single_palette_item(scroll_surf, editor_state, palette_section_rect, p1[0], p1[1], curr_x, row_start_y_for_current_items, tip_font, mouse_pos)
                        max_h = max(max_h, h); curr_x += (p1[1]["image"].get_width() + ED_CONFIG.ASSET_PALETTE_ITEM_PADDING) if p1[1].get("image") else 0
                    if p2:
                        p2_img = p2[1].get("image")
                        if p2_img and curr_x + p2_img.get_width() > palette_section_rect.width - ED_CONFIG.ASSET_PALETTE_ITEM_PADDING:
                            current_y_on_scroll_surf = row_start_y_for_current_items + max_h + ED_CONFIG.ASSET_PALETTE_ITEM_PADDING
                            row_start_y_for_current_items = current_y_on_scroll_surf; curr_x = ED_CONFIG.ASSET_PALETTE_ITEM_PADDING; max_h = 0
                        h = _draw_single_palette_item(scroll_surf, editor_state, palette_section_rect, p2[0], p2[1], curr_x, row_start_y_for_current_items, tip_font, mouse_pos)
                        max_h = max(max_h, h)
                    if max_h > 0: current_y_on_scroll_surf = row_start_y_for_current_items + max_h + ED_CONFIG.ASSET_PALETTE_ITEM_PADDING
                    assets_to_draw_this_category_loop = other
                else:
                    assets_to_draw_this_category_loop = assets_in_category_tuples
                for asset_key, asset_data in assets_to_draw_this_category_loop:
                    item_h = _draw_single_palette_item(scroll_surf, editor_state, palette_section_rect, asset_key, asset_data, ED_CONFIG.ASSET_PALETTE_ITEM_PADDING, current_y_on_scroll_surf, tip_font, mouse_pos)
                    current_y_on_scroll_surf += item_h + ED_CONFIG.ASSET_PALETTE_ITEM_PADDING
                if assets_in_category_tuples: current_y_on_scroll_surf += ED_CONFIG.ASSET_PALETTE_ITEM_PADDING
            surface.blit(scroll_surf, scrollable_assets_rect_on_screen.topleft,
                        (0, editor_state.asset_palette_scroll_y, scrollable_assets_rect_on_screen.width, scrollable_assets_rect_on_screen.height))
        pygame.draw.rect(surface, getattr(ED_CONFIG.C, 'GRAY', (128,128,128)), scrollable_assets_rect_on_screen, 1)

        btn_font = fonts.get("small") or ED_CONFIG.FONT_CONFIG.get("small")
        if btn_font:
            btn_h = ED_CONFIG.BUTTON_HEIGHT_STANDARD*0.8
            cp_btn_r = pygame.Rect(palette_section_rect.left+ED_CONFIG.ASSET_PALETTE_ITEM_PADDING,
                                   palette_section_rect.bottom-btn_h-ED_CONFIG.ASSET_PALETTE_ITEM_PADDING,
                                   palette_section_rect.width-ED_CONFIG.ASSET_PALETTE_ITEM_PADDING*2, int(btn_h))
            editor_state.ui_elements_rects["palette_bg_color_button"] = cp_btn_r
            bg_lum = sum(editor_state.background_color)/3
            txt_col = getattr(ED_CONFIG.C, 'BLACK', (0,0,0)) if bg_lum > 192 else getattr(ED_CONFIG.C, 'WHITE', (255,255,255)) # type: ignore
            draw_button(surface,cp_btn_r,"BG Color",btn_font,mouse_pos,text_color=txt_col,button_color_normal=editor_state.background_color,button_color_hover=pygame.Color(editor_state.background_color).lerp(getattr(ED_CONFIG.C, 'WHITE', (255,255,255)),0.3),border_color=getattr(ED_CONFIG.C, 'BLACK', (0,0,0))) # type: ignore
        pygame.draw.rect(surface, getattr(ED_CONFIG.C, 'DARK_GRAY', (50,50,50)), palette_section_rect, 2)
    except Exception as e:
        print(f"ERROR DRAW: draw_asset_palette_ui: {e}")
        traceback.print_exc()


def draw_map_view_ui(surface: pygame.Surface, editor_state: EditorState, map_view_rect: pygame.Rect,
                     fonts: Dict[str, Optional[pygame.font.Font]], mouse_pos: Tuple[int, int]):
    try:
        if not editor_state.map_content_surface:
            pygame.draw.rect(surface, getattr(ED_CONFIG.C, 'DARK_GRAY', (50,50,50)), map_view_rect)
            ph_font = fonts.get("medium") or ED_CONFIG.FONT_CONFIG.get("medium")
            if ph_font:
                txt_surf = ph_font.render("No Map/Surface Error", True, getattr(ED_CONFIG.C, 'WHITE', (255,255,255)))
                surface.blit(txt_surf, txt_surf.get_rect(center=map_view_rect.center))
            pygame.draw.rect(surface, ED_CONFIG.MAP_VIEW_BORDER_COLOR, map_view_rect, 2)
            return

        editor_state.map_content_surface.fill(editor_state.background_color)
        ts = editor_state.grid_size
        for obj in editor_state.placed_objects:
            asset_key = obj.get("asset_editor_key")
            world_x, world_y = obj.get("world_x"), obj.get("world_y")
            if asset_key is None or world_x is None or world_y is None: continue
            asset_palette_info = editor_state.assets_palette.get(asset_key)
            if not asset_palette_info:
                pygame.draw.rect(editor_state.map_content_surface, getattr(ED_CONFIG.C, 'RED', (255,0,0)), (world_x,world_y,ts,ts),1)
                continue
            
            image_to_draw_from_palette = asset_palette_info.get("image") # This is the palette thumbnail
            override_color = obj.get("override_color")
            final_image_for_map = None

            is_colorable = asset_palette_info.get("colorable", False)
            current_color = override_color if is_colorable and override_color else None

            if asset_palette_info.get("render_mode") == "half_tile":
                # Use current_color or fallback to base_color_tuple from palette definition
                color_to_use = current_color if current_color else asset_palette_info.get("base_color_tuple")
                if color_to_use:
                    temp_half_surf = pygame.Surface((ts, ts), pygame.SRCALPHA); temp_half_surf.fill((0,0,0,0))
                    half_type = asset_palette_info.get("half_type", "left")
                    rect_to_draw = pygame.Rect(0,0,0,0) # Initialize
                    if half_type == "left": rect_to_draw = pygame.Rect(0, 0, ts // 2, ts)
                    elif half_type == "right": rect_to_draw = pygame.Rect(ts // 2, 0, ts // 2, ts)
                    elif half_type == "top": rect_to_draw = pygame.Rect(0, 0, ts, ts // 2)
                    elif half_type == "bottom": rect_to_draw = pygame.Rect(0, ts // 2, ts, ts // 2)
                    pygame.draw.rect(temp_half_surf, color_to_use, rect_to_draw)
                    final_image_for_map = temp_half_surf
            elif asset_palette_info.get("surface_params_dims_color"):
                w, h, default_color_from_def = asset_palette_info["surface_params_dims_color"]
                color_to_use = current_color if current_color else default_color_from_def
                temp_param_surf = pygame.Surface((w,h)); temp_param_surf.fill(color_to_use) # type: ignore
                final_image_for_map = temp_param_surf
            elif image_to_draw_from_palette : # For GIFs or other image based assets
                if current_color: # If colorable and color is overridden
                    # Simple tint: create a colored surface and blit original image with special flags
                    # This is a basic tint, more advanced might be needed for good looks
                    tinted_surf = image_to_draw_from_palette.copy()
                    color_surface = pygame.Surface(tinted_surf.get_size(), pygame.SRCALPHA)
                    color_surface.fill((*current_color, 128)) # Fill with semi-transparent override color
                    tinted_surf.blit(color_surface, (0,0), special_flags=pygame.BLEND_RGBA_MULT) # type: ignore
                    final_image_for_map = tinted_surf
                else:
                    final_image_for_map = image_to_draw_from_palette # Use original palette image
            
            if final_image_for_map:
                editor_state.map_content_surface.blit(final_image_for_map, (world_x, world_y))
            else: # Fallback if no image could be determined
                 pygame.draw.rect(editor_state.map_content_surface, getattr(ED_CONFIG.C, 'MAGENTA', (255,0,255)), (world_x,world_y,ts,ts),1)

        if editor_state.show_grid:
            draw_grid_on_map_surface(editor_state.map_content_surface, editor_state)

        surface.blit(editor_state.map_content_surface, map_view_rect.topleft, (int(editor_state.camera_offset_x), int(editor_state.camera_offset_y), map_view_rect.width, map_view_rect.height))
        pygame.draw.rect(surface, ED_CONFIG.MAP_VIEW_BORDER_COLOR, map_view_rect, 2)

        if editor_state.selected_asset_image_for_cursor and editor_state.selected_asset_editor_key != "tool_color_change":
            img = editor_state.selected_asset_image_for_cursor
            pos_on_screen = img.get_rect(center=mouse_pos).topleft # Default if not over map
            if map_view_rect.collidepoint(mouse_pos):
                world_mx = mouse_pos[0]-map_view_rect.left+editor_state.camera_offset_x
                world_my = mouse_pos[1]-map_view_rect.top+editor_state.camera_offset_y
                grid_wx = (world_mx//editor_state.grid_size)*editor_state.grid_size
                grid_wy = (world_my//editor_state.grid_size)*editor_state.grid_size
                pos_on_screen = (grid_wx-int(editor_state.camera_offset_x)+map_view_rect.left, grid_wy-int(editor_state.camera_offset_y)+map_view_rect.top)
            
            clip_orig = surface.get_clip(); surface.set_clip(map_view_rect) # Clip to map view
            surface.blit(img,pos_on_screen); surface.set_clip(clip_orig)

        _draw_map_view_info_text(surface, editor_state, map_view_rect, fonts, mouse_pos)
    except Exception as e:
        print(f"ERROR DRAW: draw_map_view_ui: {e}")
        traceback.print_exc()

def _draw_map_view_info_text(surface: pygame.Surface, editor_state: EditorState, map_view_rect: pygame.Rect,
                             fonts: Dict[str, Optional[pygame.font.Font]], general_mouse_pos: Tuple[int, int]):
    info_font = fonts.get("small") or ED_CONFIG.FONT_CONFIG.get("small")
    if not info_font: return
    lines = ["LMB Drag: Paint, RMB Drag: Erase", "WASD (Hold): Pan, G: Grid, ESC: Deselect/Menu", "Shift+RMB(Map): Save All", "Ctrl+S: Save All"]
    if editor_state.selected_asset_editor_key == "tool_color_change":
        lines[0] = "LMB Click (Map): Pick tile to color flood fill."
    line_h = info_font.get_height()+3
    y_start = map_view_rect.bottom+7
    for i,line_text in enumerate(lines):
        txt_surf = info_font.render(line_text,True,getattr(ED_CONFIG.C, 'YELLOW', (255,255,0)))
        y_draw = y_start + i*line_h
        if y_draw + line_h > surface.get_height()-5: y_draw = surface.get_height()-5 - line_h*(len(lines)-i)
        if i==0: y_draw = max(5, y_draw)
        surface.blit(txt_surf, (map_view_rect.left+5, y_draw))
    coords_text_str = f"Cam:({int(editor_state.camera_offset_x)},{int(editor_state.camera_offset_y)})"
    if map_view_rect.collidepoint(general_mouse_pos):
        world_mx = general_mouse_pos[0]-map_view_rect.left+editor_state.camera_offset_x
        world_my = general_mouse_pos[1]-map_view_rect.top+editor_state.camera_offset_y
        tx,ty = world_mx//editor_state.grid_size, world_my//editor_state.grid_size
        coords_text_str += f" MouseW:({int(world_mx)},{int(world_my)}) Tile:({tx},{ty})"
    coords_surf = info_font.render(coords_text_str,True,getattr(ED_CONFIG.C, 'WHITE', (255,255,255)))
    coords_y_pos = map_view_rect.top-coords_surf.get_height()-4
    coords_x_pos = map_view_rect.left+5
    if coords_y_pos < 5:
        coords_y_pos = y_start + len(lines)*line_h + 5
        if coords_y_pos + coords_surf.get_height() > surface.get_height()-5:
             coords_y_pos = surface.get_height()-5-coords_surf.get_height()
    surface.blit(coords_surf, (coords_x_pos, coords_y_pos))

def draw_grid_on_map_surface(map_content_surface: pygame.Surface, editor_state: EditorState):
    if not (editor_state.show_grid and editor_state.map_content_surface and editor_state.grid_size > 0): return
    w,h,gs = editor_state.get_map_pixel_width(), editor_state.get_map_pixel_height(), editor_state.grid_size
    gc = getattr(ED_CONFIG, 'MAP_VIEW_GRID_COLOR', (128,128,128))
    try:
        for x_coord in range(0, w + gs, gs):
            pygame.draw.line(map_content_surface,gc,(x_coord,0),(x_coord,h))
        for y_coord in range(0, h + gs, gs):
            pygame.draw.line(map_content_surface,gc,(0,y_coord),(w,y_coord))
    except Exception as e:
        print(f"ERROR DRAW: draw_grid_on_map_surface: {e}")
        traceback.print_exc()

########## START OF FILE: editor_event_handlers.py ##########

# editor_event_handlers.py
# -*- coding: utf-8 -*-
"""
## version 1.0.0.21 (Logging for color tool, ensure it's not placed)
Handles Pygame events for different modes and UI elements
of the Platformer Level Editor.
"""
import pygame
import os
from typing import Optional, Dict, Tuple, Any, Callable, List
import traceback
import collections
import logging

import editor_config as ED_CONFIG
from editor_state import EditorState
from editor_ui import start_text_input_dialog, start_color_picker_dialog, start_file_load_dialog
from editor_map_utils import (init_new_map_state, save_map_to_json,
                              load_map_from_json, export_map_to_game_python_script)

logger = logging.getLogger(__name__)

def handle_global_events(event: pygame.event.Event, editor_state: EditorState, main_screen: pygame.Surface) -> bool:
    if event.type == pygame.QUIT:
        logger.info("pygame.QUIT event received.")
        if editor_state.unsaved_changes:
            if not getattr(editor_state, '_quit_attempted_with_unsaved_changes', False):
                editor_state.set_status_message("Unsaved changes! Quit again to exit without saving, or save your map.", 5.0)
                setattr(editor_state, '_quit_attempted_with_unsaved_changes', True)
                return True
            else:
                logger.info("Second quit attempt with unsaved changes. Proceeding to quit.")
                if hasattr(editor_state, '_quit_attempted_with_unsaved_changes'):
                    delattr(editor_state, '_quit_attempted_with_unsaved_changes')
                return False
        else:
            if hasattr(editor_state, '_quit_attempted_with_unsaved_changes'):
                delattr(editor_state, '_quit_attempted_with_unsaved_changes')
            return False
    if event.type == pygame.VIDEORESIZE:
        logger.info(f"pygame.VIDEORESIZE to {event.w}x{event.h}")
        editor_state.set_status_message(f"Resized to {event.w}x{event.h}", 2.0)
        editor_state.minimap_needs_regeneration = True
    if event.type != pygame.QUIT and hasattr(editor_state, '_quit_attempted_with_unsaved_changes'):
        delattr(editor_state, '_quit_attempted_with_unsaved_changes')
    return True

def handle_dialog_events(event: pygame.event.Event, editor_state: EditorState):
    if not editor_state.active_dialog_type: return
    confirmed, cancelled, selected_value = False, False, None
    dialog_type = editor_state.active_dialog_type
    if event.type == pygame.KEYDOWN:
        if event.key == pygame.K_ESCAPE: cancelled = True
        elif event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
            if dialog_type=="text_input": confirmed=True; selected_value=editor_state.dialog_input_text
            elif dialog_type=="file_load" and -1!=editor_state.dialog_selected_file_index < len(editor_state.dialog_file_list): # type: ignore
                confirmed=True; selected_value=os.path.join(ED_CONFIG.MAPS_DIRECTORY, editor_state.dialog_file_list[editor_state.dialog_selected_file_index]) # type: ignore
            elif dialog_type=="file_load": editor_state.set_status_message("No file selected.", 2.5)
        if dialog_type=="text_input":
            if event.key==pygame.K_BACKSPACE: editor_state.dialog_input_text=editor_state.dialog_input_text[:-1]
            elif event.unicode.isprintable()and(event.unicode.isalnum()or event.unicode in ['.','_','-',' ',',','/','\\']): editor_state.dialog_input_text+=event.unicode
        elif dialog_type=="file_load" and editor_state.dialog_file_list:
            ll=len(editor_state.dialog_file_list)
            if ll>0:
                if event.key==pygame.K_UP: editor_state.dialog_selected_file_index=(editor_state.dialog_selected_file_index-1+ll)%ll
                elif event.key==pygame.K_DOWN: editor_state.dialog_selected_file_index=(editor_state.dialog_selected_file_index+1)%ll
            else: editor_state.dialog_selected_file_index=-1
            editor_state.dialog_input_text = editor_state.dialog_file_list[editor_state.dialog_selected_file_index] if editor_state.dialog_selected_file_index!=-1 else "" # type: ignore
    elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
        if editor_state.dialog_rect and editor_state.dialog_rect.collidepoint(event.pos):
            if dialog_type=="color_picker":
                for name,rect in editor_state.color_picker_rects.items():
                    abs_rect=rect.move(editor_state.dialog_rect.left,editor_state.dialog_rect.top)
                    if abs_rect.collidepoint(event.pos): selected_value=ED_CONFIG.COLOR_PICKER_PRESETS.get(name); confirmed=bool(selected_value); break
            elif dialog_type=="file_load":
                ok,cancel=editor_state.ui_elements_rects.get("dialog_file_load_ok"), editor_state.ui_elements_rects.get("dialog_file_load_cancel")
                if ok and ok.collidepoint(event.pos)and editor_state.dialog_selected_file_index!=-1:
                    confirmed=True; selected_value=os.path.join(ED_CONFIG.MAPS_DIRECTORY, editor_state.dialog_file_list[editor_state.dialog_selected_file_index]) # type: ignore
                elif cancel and cancel.collidepoint(event.pos): cancelled=True
                else:
                    for item in editor_state.ui_elements_rects.get('dialog_file_item_rects',[]): # type: ignore
                        if item["rect"].collidepoint(event.pos): editor_state.dialog_selected_file_index=item["index"]; editor_state.dialog_input_text=item["text"]; break
                    scroll_h=editor_state.ui_elements_rects.get('file_dialog_scrollbar_handle')
                    if scroll_h and scroll_h.collidepoint(event.pos): editor_state.is_dragging_scrollbar=True; editor_state.scrollbar_drag_mouse_offset_y=event.pos[1]-scroll_h.top
        elif dialog_type!="text_input":
            if not (editor_state.dialog_rect and editor_state.dialog_rect.collidepoint(event.pos)):
                 cancelled = True
    elif event.type == pygame.MOUSEBUTTONUP and event.button == 1: editor_state.is_dragging_scrollbar=False
    elif event.type == pygame.MOUSEMOTION and editor_state.is_dragging_scrollbar: # type: ignore
        area,handle=editor_state.ui_elements_rects.get('file_dialog_scrollbar_area'), editor_state.ui_elements_rects.get('file_dialog_scrollbar_handle')
        if area and handle and editor_state.dialog_file_list:
            my_area=event.pos[1]-area.top; h_pos_y=my_area-editor_state.scrollbar_drag_mouse_offset_y
            font=ED_CONFIG.FONT_CONFIG.get("small"); item_h=(font.get_height()+6)if font else 22 # type: ignore
            content_h=len(editor_state.dialog_file_list)*item_h; display_h=area.height # type: ignore
            track_h=max(1,display_h-handle.height); scroll_px=max(0,content_h-display_h) # type: ignore
            if track_h>0 and scroll_px>0: clamped_y=max(0,min(h_pos_y,track_h)); ratio=clamped_y/track_h; editor_state.dialog_file_scroll_y=ratio*scroll_px
    elif event.type == pygame.MOUSEWHEEL and dialog_type=="file_load" and editor_state.dialog_rect and editor_state.dialog_rect.collidepoint(pygame.mouse.get_pos()): # type: ignore
        font_s=ED_CONFIG.FONT_CONFIG.get("small");item_h=(font_s.get_height()+6)if font_s else 22 # type: ignore
        scroll_v=event.y*item_h;content_h=len(editor_state.dialog_file_list)*item_h # type: ignore
        font_m=ED_CONFIG.FONT_CONFIG.get("medium");prompt_h=(font_m.get_height()+25)if font_m else 55 # type: ignore
        btns_h=40;display_h=editor_state.dialog_rect.height-prompt_h-btns_h-10
        max_s=max(0,content_h-display_h);editor_state.dialog_file_scroll_y-=scroll_v;editor_state.dialog_file_scroll_y=max(0,min(editor_state.dialog_file_scroll_y,max_s))

    if confirmed or cancelled:
        logger.debug(f"Dialog '{dialog_type}' outcome: {'CONFIRMED' if confirmed else 'CANCELLED'}")
        cb_confirm, cb_cancel = editor_state.dialog_callback_confirm, editor_state.dialog_callback_cancel
        editor_state.active_dialog_type = None # Mark as no dialog active *before* calling callbacks
        
        if confirmed and cb_confirm:
            val_pass = selected_value
            logger.debug(f"Calling confirm_callback for '{dialog_type}' with value: '{val_pass}'")
            try: cb_confirm(val_pass)
            except Exception as e:logger.error(f"Err Confirm CB for {dialog_type}:{e}", exc_info=True)
        elif cancelled and cb_cancel:
            logger.debug(f"Calling cancel_callback for '{dialog_type}'.")
            try: cb_cancel()
            except Exception as e:logger.error(f"Err Cancel CB for {dialog_type}:{e}", exc_info=True)
        
        if editor_state.active_dialog_type is None:
            logger.debug("No new dialog active. Cleaning up dialog state.")
            editor_state.dialog_callback_confirm, editor_state.dialog_callback_cancel = None,None
            editor_state.dialog_input_text, editor_state.dialog_selected_file_index = "",-1
            editor_state.is_dragging_scrollbar = False
            if dialog_type == "color_picker": # Ensure target info is cleared for color picker
                 logger.debug("Clearing color_change_target_info as color_picker dialog is closing.")
                 editor_state.color_change_target_info = None


def handle_menu_events(event: pygame.event.Event, editor_state: EditorState, main_screen: pygame.Surface):
    if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
        mouse_pos = event.pos; ui_rects = editor_state.ui_elements_rects
        if ui_rects.get("menu_new_map",pygame.Rect(0,0,0,0)).collidepoint(mouse_pos):
            logger.info("Menu: 'New Map' button clicked.")
            def on_new_map_name(name:str):
                name=name.strip()
                if not name: editor_state.set_status_message("Map name empty.",3); start_text_input_dialog(editor_state,"Name:","",on_new_map_name,lambda:None); return
                editor_state.map_name_for_function_input=name
                def on_map_size(size_str:str):
                    try:
                        w,h=map(int,size_str.replace(" ","").split(','))
                        if not(w>0 and h>0): raise ValueError("Dims>0")
                        init_new_map_state(editor_state,editor_state.map_name_for_function_input,w,h)
                        if save_map_to_json(editor_state)and export_map_to_game_python_script(editor_state):
                            editor_state.set_status_message(f"Map '{editor_state.map_name_for_function}' auto-saved.",3);pygame.display.set_caption(f"Editor - {editor_state.map_name_for_function}.py")
                        else: editor_state.set_status_message(f"Auto-save fail for '{editor_state.map_name_for_function}'.",4);editor_state.unsaved_changes=True;pygame.display.set_caption(f"Editor - {editor_state.map_name_for_function}.py*")
                        editor_state.current_editor_mode="editing_map"
                    except Exception as e: editor_state.set_status_message(f"Invalid size:{e}",3.5);start_text_input_dialog(editor_state,"Size (W,H):",f"{ED_CONFIG.DEFAULT_MAP_WIDTH_TILES},{ED_CONFIG.DEFAULT_MAP_HEIGHT_TILES}",on_map_size,lambda:None)
                start_text_input_dialog(editor_state,"Size (W,H):",f"{ED_CONFIG.DEFAULT_MAP_WIDTH_TILES},{ED_CONFIG.DEFAULT_MAP_HEIGHT_TILES}",on_map_size,lambda:None)
            start_text_input_dialog(editor_state,"New Map Name:","my_map",on_new_map_name,lambda:None)
        elif ui_rects.get("menu_load_map",pygame.Rect(0,0,0,0)).collidepoint(mouse_pos):
            logger.info("Menu: 'Load Map' button clicked.")
            def on_file_sel(fp:str):
                if load_map_from_json(editor_state,fp): editor_state.current_editor_mode="editing_map";pygame.display.set_caption(f"Editor - {editor_state.map_name_for_function}.py")
            start_file_load_dialog(editor_state,on_confirm=on_file_sel,on_cancel=lambda:None)
        elif ui_rects.get("menu_quit",pygame.Rect(0,0,0,0)).collidepoint(mouse_pos):
            logger.info("Menu: 'Quit' button clicked.")
            pygame.event.post(pygame.event.Event(pygame.QUIT))


def _place_single_tile_at_grid(editor_state: EditorState, asset_key_to_place: str, grid_coords: Tuple[int, int]):
    logger.debug(f"_place_single_tile_at_grid: Placing '{asset_key_to_place}' at {grid_coords}")
    gx, gy = grid_coords; wx, wy = gx * editor_state.grid_size, gy * editor_state.grid_size
    asset_data = editor_state.assets_palette.get(asset_key_to_place)
    if not asset_data: logger.error(f"ERR PlaceSingle: No asset data for {asset_key_to_place}"); return
    game_id = asset_data["game_type_id"]; is_spawn = asset_data.get("category")=="spawn"
    if not is_spawn:
        for obj in editor_state.placed_objects:
            if obj.get("world_x")==wx and obj.get("world_y")==wy and obj.get("game_type_id")==game_id:
                logger.debug(f"Duplicate tile '{game_id}' at {grid_coords}, not placing.")
                return
    if is_spawn: editor_state.placed_objects = [o for o in editor_state.placed_objects if o.get("game_type_id")!=game_id]
    editor_state.placed_objects.append({"asset_editor_key":asset_key_to_place,"world_x":wx,"world_y":wy,"game_type_id":game_id})
    editor_state.unsaved_changes=True; editor_state.minimap_needs_regeneration=True
    pygame.display.set_caption(f"Editor - {editor_state.map_name_for_function}.py*")


def _place_tile_at_grid(editor_state: EditorState, grid_coords: Tuple[int, int]):
    sel_key = editor_state.selected_asset_editor_key
    logger.debug(f"_place_tile_at_grid: current selected_asset_editor_key = '{sel_key}'")

    if not sel_key or sel_key == "tool_color_change": # Explicitly prevent color tool from placing
        logger.debug(f"_place_tile_at_grid: Bailing out. sel_key is '{sel_key}'. Color tool should not place.")
        return

    sel_info = editor_state.assets_palette.get(sel_key)
    if not sel_info:
        logger.error(f"_place_tile_at_grid: No asset info for selected key '{sel_key}'")
        return

    if sel_key == "platform_wall_gray_2x2_placer": # Handle 2x2 placer
        base_key = sel_info.get("places_asset_key")
        if not base_key: logger.error("ERR PlaceTile: 2x2 placer no base key"); return
        logger.debug(f"_place_tile_at_grid: Handling 2x2 placer for base_key '{base_key}' at {grid_coords}")
        for ro in range(2):
            for co in range(2): _place_single_tile_at_grid(editor_state,base_key,(grid_coords[0]+co,grid_coords[1]+ro))
        return # Handled 2x2 placer
    
    logger.debug(f"_place_tile_at_grid: Proceeding to place single tile for '{sel_key}' at {grid_coords}")
    _place_single_tile_at_grid(editor_state, sel_key, grid_coords)


def _erase_tile_at_grid(editor_state: EditorState, grid_coords: Tuple[int, int]):
    wx,wy = grid_coords[0]*editor_state.grid_size, grid_coords[1]*editor_state.grid_size; erased=False
    for i in range(len(editor_state.placed_objects)-1,-1,-1):
        obj=editor_state.placed_objects[i]
        if obj.get("world_x")==wx and obj.get("world_y")==wy:
            logger.info(f"Erasing object at {grid_coords}: {obj}")
            editor_state.placed_objects.pop(i); erased=True
            editor_state.unsaved_changes=True; editor_state.minimap_needs_regeneration=True
            pygame.display.set_caption(f"Editor - {editor_state.map_name_for_function}.py*"); break
    if erased: editor_state.set_status_message(f"Erased @ ({grid_coords[0]},{grid_coords[1]})",1.5)

def _is_asset_colorable(editor_state: EditorState, asset_editor_key: Optional[str]) -> bool:
    if not asset_editor_key: return False
    props = editor_state.assets_palette.get(asset_editor_key)
    is_colorable = props.get("colorable",False) if props else False
    return is_colorable

def _perform_flood_fill_color_change(editor_state: EditorState, start_gx: int, start_gy: int,
                                     target_game_type_id: str, new_color: Tuple[int,int,int]):
    logger.info(f"Attempting flood fill. Start: ({start_gx},{start_gy}), Target Type: '{target_game_type_id}', New Color: {new_color}")
    if not editor_state.color_change_target_info: # Should be set before calling
        logger.warning("Flood fill called but color_change_target_info is None.")
        return
    
    initial_asset_key = editor_state.color_change_target_info.get("asset_editor_key")
    if not _is_asset_colorable(editor_state, initial_asset_key):
        logger.warning(f"Flood fill: Initial asset '{initial_asset_key}' at start point is not colorable according to palette info.")
        editor_state.set_status_message("Initial tile type not colorable.", 2.0)
        return

    queue = collections.deque([(start_gx, start_gy)]); visited = set([(start_gx,start_gy)]); colored_count = 0
    logger.debug(f"Flood fill queue initialized with: {list(queue)}")
    
    while queue:
        gx,gy=queue.popleft()
        logger.debug(f"Flood fill processing cell: ({gx},{gy})")
        cell_colored_this_iter=False
        for i, obj in enumerate(editor_state.placed_objects):
            obj_gx = obj.get("world_x")//editor_state.grid_size
            obj_gy = obj.get("world_y")//editor_state.grid_size
            current_obj_asset_key = obj.get("asset_editor_key")

            if obj_gx==gx and obj_gy==gy and \
               obj.get("game_type_id")==target_game_type_id and \
               _is_asset_colorable(editor_state, current_obj_asset_key):
                logger.debug(f"  Coloring object at index {i} (key: {current_obj_asset_key}, type: {obj.get('game_type_id')}) in cell ({gx},{gy})")
                editor_state.placed_objects[i]["override_color"] = new_color
                if not cell_colored_this_iter: colored_count+=1; cell_colored_this_iter=True
        
        for dx,dy in [(0,1),(0,-1),(1,0),(-1,0)]:
            next_gx,next_gy = gx+dx,gy+dy
            if (next_gx,next_gy) not in visited:
                neighbor_exists_and_colorable_and_same_type = False
                for obj_n in editor_state.placed_objects:
                    if obj_n.get("world_x")//editor_state.grid_size == next_gx and \
                       obj_n.get("world_y")//editor_state.grid_size == next_gy and \
                       obj_n.get("game_type_id")==target_game_type_id and \
                       _is_asset_colorable(editor_state, obj_n.get("asset_editor_key")):
                        neighbor_exists_and_colorable_and_same_type = True; break
                if neighbor_exists_and_colorable_and_same_type:
                    logger.debug(f"  Adding neighbor ({next_gx},{next_gy}) to flood fill queue.")
                    visited.add((next_gx,next_gy)); queue.append((next_gx,next_gy))
    
    if colored_count>0:
        logger.info(f"Flood fill completed. Colored {colored_count} '{target_game_type_id}' tiles.")
        editor_state.unsaved_changes=True; editor_state.minimap_needs_regeneration=True
        pygame.display.set_caption(f"Editor - {editor_state.map_name_for_function}.py*")
        editor_state.set_status_message(f"Colored {colored_count} '{target_game_type_id}' tiles.",3)
    else:
        logger.info("Flood fill completed. No applicable tiles were colored (or only initial tile if no matching neighbors).")


def _update_continuous_camera_pan(editor_state: EditorState, map_view_rect: pygame.Rect, mouse_pos: Tuple[int,int], dt: float):
    if editor_state.active_dialog_type: editor_state.camera_momentum_pan=(0,0); return
    keys = pygame.key.get_pressed(); pan_px_sec = ED_CONFIG.KEY_PAN_SPEED_PIXELS_PER_SECOND
    edge_pan_px_sec = ED_CONFIG.EDGE_SCROLL_SPEED_PIXELS_PER_SECOND
    pan_amount, edge_pan_amount = pan_px_sec * dt, edge_pan_px_sec * dt
    cam_moved_by_direct_input = False
    dx, dy = 0.0, 0.0
    if keys[pygame.K_a]: dx -= pan_amount; cam_moved_by_direct_input=True
    if keys[pygame.K_d]: dx += pan_amount; cam_moved_by_direct_input=True
    if keys[pygame.K_w]: dy -= pan_amount; cam_moved_by_direct_input=True
    if keys[pygame.K_s] and not (keys[pygame.K_LCTRL]or keys[pygame.K_RCTRL]): dy+=pan_amount; cam_moved_by_direct_input=True
    prev_is_mouse_over_map = editor_state.is_mouse_over_map_view
    editor_state.is_mouse_over_map_view = map_view_rect.collidepoint(mouse_pos)
    if editor_state.is_mouse_over_map_view:
        editor_state.camera_momentum_pan = (0.0, 0.0)
        if editor_state.last_mouse_pos_map_view and dt > 0.0001:
            vel_x = (mouse_pos[0] - editor_state.last_mouse_pos_map_view[0]) / dt
            vel_y = (mouse_pos[1] - editor_state.last_mouse_pos_map_view[1]) / dt
            editor_state.mouse_velocity_map_view = (vel_x, vel_y)
        else: editor_state.mouse_velocity_map_view = (0.0, 0.0)
        editor_state.last_mouse_pos_map_view = mouse_pos
        if not cam_moved_by_direct_input:
            zone=ED_CONFIG.EDGE_SCROLL_ZONE_THICKNESS
            if mouse_pos[0]<map_view_rect.left+zone: dx-=edge_pan_amount; cam_moved_by_direct_input=True
            elif mouse_pos[0]>map_view_rect.right-zone: dx+=edge_pan_amount; cam_moved_by_direct_input=True
            if mouse_pos[1]<map_view_rect.top+zone: dy-=edge_pan_amount; cam_moved_by_direct_input=True
            elif mouse_pos[1]>map_view_rect.bottom-zone: dy+=edge_pan_amount; cam_moved_by_direct_input=True
    elif prev_is_mouse_over_map and not editor_state.is_mouse_over_map_view:
        if not cam_moved_by_direct_input and (abs(editor_state.mouse_velocity_map_view[0]) > 1 or abs(editor_state.mouse_velocity_map_view[1]) > 1) :
            fling_vx = editor_state.mouse_velocity_map_view[0] * ED_CONFIG.CAMERA_MOMENTUM_INITIAL_MULTIPLIER
            fling_vy = editor_state.mouse_velocity_map_view[1] * ED_CONFIG.CAMERA_MOMENTUM_INITIAL_MULTIPLIER
            editor_state.camera_momentum_pan = (fling_vx, fling_vy)
            logger.debug(f"Mouse exited map view. Initiated fling with momentum: ({fling_vx:.2f}, {fling_vy:.2f}) based on mouse velocity {editor_state.mouse_velocity_map_view}")
        editor_state.last_mouse_pos_map_view = None
        editor_state.mouse_velocity_map_view = (0.0,0.0)
    if cam_moved_by_direct_input:
        editor_state.camera_momentum_pan = (0.0, 0.0)
        editor_state.camera_offset_x += dx
        editor_state.camera_offset_y += dy
    max_cam_x = max(0, editor_state.get_map_pixel_width() - map_view_rect.width)
    max_cam_y = max(0, editor_state.get_map_pixel_height() - map_view_rect.height)
    editor_state.camera_offset_x = max(0, min(editor_state.camera_offset_x, max_cam_x))
    editor_state.camera_offset_y = max(0, min(editor_state.camera_offset_y, max_cam_y))

def _pan_camera_via_minimap_click(editor_state: EditorState, screen_click_pos: Tuple[int,int],
                                  map_view_rect: pygame.Rect, asset_palette_rect: pygame.Rect):
    if not editor_state.minimap_rect_in_palette or not editor_state.minimap_surface: return
    click_x_rel = screen_click_pos[0] - editor_state.minimap_rect_in_palette.left
    click_y_rel = screen_click_pos[1] - editor_state.minimap_rect_in_palette.top
    minimap_w = editor_state.minimap_surface.get_width(); minimap_h = editor_state.minimap_surface.get_height()
    if minimap_w == 0 or minimap_h == 0: return
    click_x_rel = max(0, min(click_x_rel, minimap_w -1)); click_y_rel = max(0, min(click_y_rel, minimap_h -1))
    map_px_w, map_px_h = editor_state.get_map_pixel_width(), editor_state.get_map_pixel_height()
    target_world_x = (click_x_rel / minimap_w) * map_px_w; target_world_y = (click_y_rel / minimap_h) * map_px_h
    new_cam_x = target_world_x - map_view_rect.width / 2; new_cam_y = target_world_y - map_view_rect.height / 2
    max_cam_x = max(0, map_px_w - map_view_rect.width); max_cam_y = max(0, map_px_h - map_view_rect.height)
    editor_state.camera_offset_x = int(max(0, min(new_cam_x, max_cam_x)))
    editor_state.camera_offset_y = int(max(0, min(new_cam_y, max_cam_y)))
    editor_state.camera_momentum_pan = (0.0, 0.0)
    logger.debug(f"Minimap click: Panned camera to center around world ({target_world_x:.0f},{target_world_y:.0f}). New offset: ({editor_state.camera_offset_x},{editor_state.camera_offset_y})")


def handle_editing_map_events(event: pygame.event.Event, editor_state: EditorState,
                              palette_section_rect: pygame.Rect, map_view_rect: pygame.Rect,
                              main_screen: pygame.Surface):
    general_mouse_pos = pygame.mouse.get_pos()

    if event.type == pygame.MOUSEWHEEL:
        asset_list_rect = pygame.Rect(palette_section_rect.left, palette_section_rect.top + ED_CONFIG.MINIMAP_AREA_HEIGHT,
                                      palette_section_rect.width, palette_section_rect.height - ED_CONFIG.MINIMAP_AREA_HEIGHT - (ED_CONFIG.BUTTON_HEIGHT_STANDARD*0.8+ED_CONFIG.ASSET_PALETTE_ITEM_PADDING*2)) # type: ignore
        if asset_list_rect.collidepoint(general_mouse_pos):
            font_s = ED_CONFIG.FONT_CONFIG.get("small"); speed = (font_s.get_height()+ED_CONFIG.ASSET_PALETTE_ITEM_PADDING) if font_s else 20 # type: ignore
            editor_state.asset_palette_scroll_y -= event.y * speed
            max_scroll = max(0, editor_state.total_asset_palette_content_height - asset_list_rect.height)
            editor_state.asset_palette_scroll_y = max(0, min(editor_state.asset_palette_scroll_y, max_scroll))
    
    elif event.type == pygame.MOUSEBUTTONDOWN:
        mouse_pos_click = event.pos
        logger.debug(f"MOUSEBUTTONDOWN event.button={event.button} at {mouse_pos_click}. Selected asset: '{editor_state.selected_asset_editor_key}'")
        if event.button == 1: 
            if editor_state.minimap_rect_in_palette and editor_state.minimap_rect_in_palette.collidepoint(mouse_pos_click):
                logger.debug("Left click on minimap area.")
                editor_state.is_dragging_minimap_view = True
                _pan_camera_via_minimap_click(editor_state, mouse_pos_click, map_view_rect, palette_section_rect)
                return
            
            elif palette_section_rect.collidepoint(mouse_pos_click):
                logger.debug("Left click in asset palette section.")
                bg_btn = editor_state.ui_elements_rects.get("palette_bg_color_button")
                if bg_btn and bg_btn.collidepoint(mouse_pos_click):
                    logger.info("BG Color button clicked.")
                    def on_bg_sel(nc:Tuple[int,int,int]):
                        if nc: editor_state.background_color=nc; editor_state.unsaved_changes=True; editor_state.minimap_needs_regeneration=True; pygame.display.set_caption(f"Editor - {editor_state.map_name_for_function}.py*"); editor_state.set_status_message(f"BG:{nc}")
                    start_color_picker_dialog(editor_state,on_confirm=on_bg_sel,on_cancel=lambda:None); return
                
                for key,rect in editor_state.ui_elements_rects.get('asset_palette_items',{}).items():
                    if rect.collidepoint(mouse_pos_click):
                        logger.info(f"Asset palette item '{key}' clicked.")
                        editor_state.selected_asset_editor_key = key # This setter is now crucial for cursor
                        asset_data = editor_state.assets_palette.get(key) # Get data after setting key
                        if asset_data: # Check if asset_data is not None
                             editor_state.set_status_message(f"Selected: {asset_data['tooltip']}{'. Click tile on map.' if key=='tool_color_change' else ''}")
                        else:
                             logger.error(f"Could not find asset data for key '{key}' in palette after selection.")
                        return # IMPORTANT: Return after selecting an asset from the palette.
            
            elif map_view_rect.collidepoint(mouse_pos_click):
                logger.debug("Left click in map view section.")
                wx,wy=mouse_pos_click[0]-map_view_rect.left+editor_state.camera_offset_x, mouse_pos_click[1]-map_view_rect.top+editor_state.camera_offset_y
                tx,ty=wx//editor_state.grid_size, wy//editor_state.grid_size
                logger.debug(f"Map click at grid ({tx},{ty}). Current tool: '{editor_state.selected_asset_editor_key}'")

                if editor_state.selected_asset_editor_key=="tool_color_change":
                    logger.info("Color tool is active. Attempting to find colorable object.")
                    target_info_for_color_tool = None
                    for i, obj_iter in reversed(list(enumerate(editor_state.placed_objects))):
                        obj_asset_key = obj_iter.get("asset_editor_key")
                        if obj_iter.get("world_x")//editor_state.grid_size==tx and obj_iter.get("world_y")//editor_state.grid_size==ty and _is_asset_colorable(editor_state,obj_asset_key):
                            target_info_for_color_tool = {"asset_editor_key": obj_asset_key, "game_type_id": obj_iter["game_type_id"], "grid_x":tx, "grid_y":ty}
                            logger.debug(f"Found colorable object for color tool: {target_info_for_color_tool}")
                            break
                    if target_info_for_color_tool:
                        editor_state.color_change_target_info = target_info_for_color_tool
                        logger.info(f"Opening color picker for target: {target_info_for_color_tool}")
                        def on_color_selected_for_flood_fill(new_color:Tuple[int,int,int]):
                            t_info = editor_state.color_change_target_info
                            logger.debug(f"Color picker confirmed with color {new_color} for target {t_info}")
                            if t_info and new_color: _perform_flood_fill_color_change(editor_state, t_info["grid_x"],t_info["grid_y"],t_info["game_type_id"],new_color)
                        start_color_picker_dialog(editor_state,on_confirm=on_color_selected_for_flood_fill,on_cancel=lambda: [editor_state.set_status_message("Color change cancelled."), setattr(editor_state, 'color_change_target_info', None), logger.info("Color picker cancelled.")])
                    else:
                        logger.info("Color tool clicked on non-colorable or empty tile.")
                        editor_state.set_status_message("Clicked non-colorable or empty tile.",2);
                    return # Explicitly return after handling color tool logic on map click

                elif editor_state.selected_asset_editor_key:
                    logger.debug(f"Attempting to place asset '{editor_state.selected_asset_editor_key}'")
                    editor_state.is_painting_tiles=True; editor_state.last_painted_tile_coords=(tx,ty); _place_tile_at_grid(editor_state,(tx,ty))
                
                else:
                    logger.debug("No asset selected, attempting to drag object.")
                    editor_state.dragging_object_index=None
                    for i,obj in reversed(list(enumerate(editor_state.placed_objects))):
                        info=editor_state.assets_palette.get(obj.get("asset_editor_key"))
                        if info and "original_size_pixels" in info:
                            obj_w,obj_h=info["original_size_pixels"]; obj_r=pygame.Rect(obj["world_x"],obj["world_y"],obj_w,obj_h) # type: ignore
                            if obj_r.collidepoint(wx,wy):
                                editor_state.dragging_object_index=i;editor_state.drag_start_mouse_map_x=wx;editor_state.drag_start_mouse_map_y=wy
                                editor_state.drag_object_original_x=obj["world_x"];editor_state.drag_object_original_y=obj["world_y"];editor_state.set_status_message(f"Dragging {info['tooltip']}");break
        
        elif event.button == 3:
            if map_view_rect.collidepoint(mouse_pos_click):
                wx,wy=mouse_pos_click[0]-map_view_rect.left+editor_state.camera_offset_x, mouse_pos_click[1]-map_view_rect.top+editor_state.camera_offset_y
                tx,ty=wx//editor_state.grid_size, wy//editor_state.grid_size
                if pygame.key.get_mods()&(pygame.KMOD_LSHIFT|pygame.KMOD_RSHIFT):
                    logger.info("Shift+RMB click on map: Save All attempt.")
                    if editor_state.map_name_for_function and editor_state.map_name_for_function!="untitled_map":
                        if save_map_to_json(editor_state)and export_map_to_game_python_script(editor_state):pygame.display.set_caption(f"Editor - {editor_state.map_name_for_function}.py")
                    else: editor_state.set_status_message("Cannot save: Map not named.",4)
                else:
                    logger.info(f"RMB click on map at grid ({tx},{ty}): Erase attempt.")
                    editor_state.is_erasing_tiles=True;editor_state.last_erased_tile_coords=(tx,ty);_erase_tile_at_grid(editor_state,(tx,ty))

    elif event.type == pygame.MOUSEBUTTONUP:
        if event.button==1:
            editor_state.is_painting_tiles=False;editor_state.last_painted_tile_coords=None
            if editor_state.dragging_object_index is not None: editor_state.dragging_object_index=None;editor_state.set_status_message("Drag complete")
            if editor_state.is_dragging_minimap_view: logger.debug("Minimap drag released."); editor_state.is_dragging_minimap_view = False
        elif event.button==3: editor_state.is_erasing_tiles=False;editor_state.last_erased_tile_coords=None
        if editor_state.is_dragging_scrollbar:editor_state.is_dragging_scrollbar=False
    
    elif event.type == pygame.MOUSEMOTION:
        mouse_pos_motion = event.pos
        if editor_state.is_dragging_minimap_view:
            _pan_camera_via_minimap_click(editor_state, mouse_pos_motion, map_view_rect, palette_section_rect)
            return
        if editor_state.dragging_object_index is not None and 0<=editor_state.dragging_object_index<len(editor_state.placed_objects):
            obj_drag=editor_state.placed_objects[editor_state.dragging_object_index]
            map_mx,map_my = mouse_pos_motion[0]-map_view_rect.left+editor_state.camera_offset_x, mouse_pos_motion[1]-map_view_rect.top+editor_state.camera_offset_y
            new_x,new_y = editor_state.drag_object_original_x+(map_mx-editor_state.drag_start_mouse_map_x), editor_state.drag_object_original_y+(map_my-editor_state.drag_start_mouse_map_y)
            snap_x,snap_y=(new_x//editor_state.grid_size)*editor_state.grid_size, (new_y//editor_state.grid_size)*editor_state.grid_size
            if obj_drag["world_x"]!=snap_x or obj_drag["world_y"]!=snap_y:
                obj_drag["world_x"],obj_drag["world_y"]=snap_x,snap_y
                editor_state.unsaved_changes=True;editor_state.minimap_needs_regeneration=True;pygame.display.set_caption(f"Editor - {editor_state.map_name_for_function}.py*")
        elif map_view_rect.collidepoint(mouse_pos_motion):
            map_mx,map_my = mouse_pos_motion[0]-map_view_rect.left+editor_state.camera_offset_x, mouse_pos_motion[1]-map_view_rect.top+editor_state.camera_offset_y
            curr_tx,curr_ty=map_mx//editor_state.grid_size, map_my//editor_state.grid_size; curr_grid=(curr_tx,curr_ty)
            btns=pygame.mouse.get_pressed(); not_color_tool = editor_state.selected_asset_editor_key!="tool_color_change"
            if editor_state.is_painting_tiles and btns[0] and editor_state.selected_asset_editor_key and not_color_tool and curr_grid!=editor_state.last_painted_tile_coords:
                _place_tile_at_grid(editor_state,curr_grid); editor_state.last_painted_tile_coords=curr_grid
            elif editor_state.is_erasing_tiles and btns[2] and not_color_tool and curr_grid!=editor_state.last_erased_tile_coords:
                _erase_tile_at_grid(editor_state,curr_grid); editor_state.last_erased_tile_coords=curr_grid
        elif not map_view_rect.collidepoint(mouse_pos_motion):
            if editor_state.is_painting_tiles: editor_state.is_painting_tiles=False; editor_state.last_painted_tile_coords=None
            if editor_state.is_erasing_tiles: editor_state.is_erasing_tiles=False; editor_state.last_erased_tile_coords=None

    elif event.type == pygame.KEYDOWN:
        if event.key==pygame.K_ESCAPE:
            if editor_state.selected_asset_editor_key: logger.info("Escape pressed: Deselecting asset/tool."); editor_state.selected_asset_editor_key=None;editor_state.set_status_message("Asset/Tool deselected")
            else:
                logger.info("Escape pressed: No asset selected, attempting to go to menu.")
                if editor_state.unsaved_changes:
                    if not getattr(editor_state,'_esc_exit_attempted',False): editor_state.set_status_message("Unsaved! Esc again to discard.",4);setattr(editor_state,'_esc_exit_attempted',True)
                    else: editor_state.current_editor_mode="menu";editor_state.reset_map_context();pygame.display.set_caption("Editor - Menu");SicherDelAttr(editor_state,'_esc_exit_attempted')
                else: editor_state.current_editor_mode="menu";editor_state.reset_map_context();pygame.display.set_caption("Editor - Menu");SicherDelAttr(editor_state,'_esc_exit_attempted')
        elif event.key!=pygame.K_ESCAPE and hasattr(editor_state,'_esc_exit_attempted'): SicherDelAttr(editor_state,'_esc_exit_attempted')
        elif event.key==pygame.K_g: logger.info("G key pressed: Toggling grid."); editor_state.show_grid = not editor_state.show_grid; editor_state.minimap_needs_regeneration=True; editor_state.set_status_message(f"Grid {'ON'if editor_state.show_grid else 'OFF'}")
        elif event.key==pygame.K_s and (pygame.key.get_mods()&pygame.KMOD_CTRL):
            logger.info("Ctrl+S pressed: Save All attempt.")
            if editor_state.map_name_for_function and editor_state.map_name_for_function!="untitled_map":
                if save_map_to_json(editor_state)and export_map_to_game_python_script(editor_state):pygame.display.set_caption(f"Editor - {editor_state.map_name_for_function}.py")
            else:editor_state.set_status_message("Cannot save: Map not named.",4)


def SicherDelAttr(obj, name):
    if hasattr(obj, name): delattr(obj, name)

########## START OF FILE: editor_map_utils.py ##########

# editor_map_utils.py
# -*- coding: utf-8 -*-
"""
## version 1.0.0.6 (Handle override_color, half-tiles export)
Utility functions for map operations in the Level Editor,
including initializing new maps, saving/loading editor-specific
map data (JSON), and exporting maps to game-compatible Python scripts.
"""
import pygame
import sys
import os
import json
import traceback
from typing import Optional, Dict, List, Tuple, Any

import editor_config as ED_CONFIG
from editor_state import EditorState

import constants as C
from tiles import Platform, Ladder, Lava


def init_new_map_state(editor_state: EditorState, map_name_for_function: str,
                       map_width_tiles: int, map_height_tiles: int):
    print(f"DEBUG MAP_UTILS: init_new_map_state called. Map Name: '{map_name_for_function}', Size: {map_width_tiles}x{map_height_tiles}")

    clean_map_name = map_name_for_function.lower().replace(" ", "_").replace("-", "_")
    if not clean_map_name:
        clean_map_name = "untitled_map"
        print(f"DEBUG MAP_UTILS: map_name_for_function was empty after cleaning, defaulting to '{clean_map_name}'")

    editor_state.map_name_for_function = clean_map_name
    editor_state.map_width_tiles = map_width_tiles
    editor_state.map_height_tiles = map_height_tiles
    editor_state.placed_objects = []
    editor_state.background_color = ED_CONFIG.DEFAULT_BACKGROUND_COLOR
    editor_state.camera_offset_x = 0
    editor_state.camera_offset_y = 0
    editor_state.unsaved_changes = True
    editor_state.color_change_target_info = None # Reset color tool state

    py_filename = editor_state.map_name_for_function + ED_CONFIG.GAME_LEVEL_FILE_EXTENSION
    editor_state.current_map_filename = os.path.join(ED_CONFIG.MAPS_DIRECTORY, py_filename)

    editor_state.recreate_map_content_surface()

    print(f"DEBUG MAP_UTILS: Editor state initialized for new map. "
          f"map_name_for_function='{editor_state.map_name_for_function}', "
          f"current_map_filename='{editor_state.current_map_filename}', "
          f"unsaved_changes={editor_state.unsaved_changes}")

def ensure_maps_directory_exists() -> bool:
    maps_dir = ED_CONFIG.MAPS_DIRECTORY
    if not os.path.exists(maps_dir):
        print(f"DEBUG MAP_UTILS: Maps directory '{maps_dir}' does not exist. Attempting to create.")
        try:
            os.makedirs(maps_dir)
            print(f"DEBUG MAP_UTILS: Successfully created directory: {maps_dir}")
            return True
        except OSError as e:
            print(f"ERROR MAP_UTILS: Error creating directory {maps_dir}: {e}")
            traceback.print_exc()
            return False
    return True

def save_map_to_json(editor_state: EditorState) -> bool:
    print(f"DEBUG MAP_UTILS: save_map_to_json called. Map name func: '{editor_state.map_name_for_function}'")
    if not editor_state.map_name_for_function or editor_state.map_name_for_function == "untitled_map":
        msg = "Map name is not set or is 'untitled_map'. Cannot save JSON."
        editor_state.set_status_message(f"Error: {msg}", 3)
        print(f"ERROR MAP_UTILS: {msg}")
        return False

    if not ensure_maps_directory_exists():
        msg = "Could not create or access maps directory."
        editor_state.set_status_message(f"Error: {msg}", 3)
        print(f"ERROR MAP_UTILS: {msg} JSON save aborted.")
        return False

    json_filename = editor_state.map_name_for_function + ED_CONFIG.LEVEL_EDITOR_SAVE_FORMAT_EXTENSION
    json_filepath = os.path.join(ED_CONFIG.MAPS_DIRECTORY, json_filename)
    print(f"DEBUG MAP_UTILS: Attempting to save JSON to: '{json_filepath}'")

    serializable_objects = []
    for i, obj in enumerate(editor_state.placed_objects):
        asset_key = obj.get("asset_editor_key")
        game_id = obj.get("game_type_id")
        world_x = obj.get("world_x")
        world_y = obj.get("world_y")
        override_color = obj.get("override_color") # Get override_color

        if not all([asset_key, game_id is not None, world_x is not None, world_y is not None]):
             print(f"Warning MAP_UTILS: Object at index {i} has missing data, skipping for JSON: {obj}")
             continue

        s_obj = {
            "asset_editor_key": asset_key,
            "world_x": world_x,
            "world_y": world_y,
            "game_type_id": game_id
        }
        if override_color: # Only add if it exists
            s_obj["override_color"] = list(override_color) # Convert tuple to list for JSON

        serializable_objects.append(s_obj)

    data_to_save = {
        "map_name_for_function": editor_state.map_name_for_function,
        "map_width_tiles": editor_state.map_width_tiles,
        "map_height_tiles": editor_state.map_height_tiles,
        "grid_size": editor_state.grid_size,
        "background_color": list(editor_state.background_color),
        "placed_objects": serializable_objects,
        "camera_offset_x": editor_state.camera_offset_x,
        "camera_offset_y": editor_state.camera_offset_y,
        "show_grid": editor_state.show_grid
    }
    print(f"DEBUG MAP_UTILS: Data to save to JSON (first object example): {serializable_objects[0] if serializable_objects else 'No objects'}")

    try:
        with open(json_filepath, "w") as f:
            json.dump(data_to_save, f, indent=4)
        success_msg = f"Editor data saved to: {json_filename}"
        print(f"DEBUG MAP_UTILS: {success_msg}")
        editor_state.set_status_message(success_msg)
        # unsaved_changes set False by export_map_to_game_python_script
        return True
    except IOError as e:
        error_msg = f"IOError saving map to JSON '{json_filepath}': {e}"
    except Exception as e:
        error_msg = f"Unexpected error saving map to JSON '{json_filepath}': {e}"
        traceback.print_exc()

    print(f"ERROR MAP_UTILS: {error_msg}")
    editor_state.set_status_message(error_msg, 4)
    return False

def load_map_from_json(editor_state: EditorState, json_filepath: str) -> bool:
    print(f"DEBUG MAP_UTILS: load_map_from_json called. Filepath: '{json_filepath}'")
    if not os.path.exists(json_filepath) or not os.path.isfile(json_filepath):
        error_msg = f"JSON map file not found or is not a file: '{json_filepath}'"
        print(f"ERROR MAP_UTILS: {error_msg}")
        editor_state.set_status_message(error_msg, 3)
        return False

    try:
        with open(json_filepath, 'r') as f:
            data = json.load(f)
        print(f"DEBUG MAP_UTILS: Successfully read JSON data from '{json_filepath}'.")

        editor_state.map_name_for_function = data.get("map_name_for_function", "loaded_map_error_name")
        editor_state.map_width_tiles = data.get("map_width_tiles", ED_CONFIG.DEFAULT_MAP_WIDTH_TILES)
        editor_state.map_height_tiles = data.get("map_height_tiles", ED_CONFIG.DEFAULT_MAP_HEIGHT_TILES)
        editor_state.grid_size = data.get("grid_size", ED_CONFIG.DEFAULT_GRID_SIZE)

        bg_color_data = data.get("background_color", ED_CONFIG.DEFAULT_BACKGROUND_COLOR)
        if isinstance(bg_color_data, list) and len(bg_color_data) == 3:
            editor_state.background_color = tuple(bg_color_data) # type: ignore
        else:
            editor_state.background_color = ED_CONFIG.DEFAULT_BACKGROUND_COLOR
            print(f"Warning MAP_UTILS: Invalid background_color format in JSON, using default. Got: {bg_color_data}")


        editor_state.placed_objects = []
        loaded_placed_objects = data.get("placed_objects", [])
        print(f"DEBUG MAP_UTILS: Loading {len(loaded_placed_objects)} objects from JSON.")
        for i, obj_data in enumerate(loaded_placed_objects):
            asset_key = obj_data.get("asset_editor_key")
            game_type_id_from_json = obj_data.get("game_type_id")
            world_x = obj_data.get("world_x")
            world_y = obj_data.get("world_y")
            override_color_data = obj_data.get("override_color") # Get override_color

            if not all([asset_key, game_type_id_from_json is not None, world_x is not None, world_y is not None]):
                print(f"Warning MAP_UTILS: Loaded object at index {i} has missing core data, skipping: {obj_data}")
                continue

            if asset_key in ED_CONFIG.EDITOR_PALETTE_ASSETS: # Check against current config
                new_obj = {
                    "asset_editor_key": asset_key,
                    "world_x": world_x,
                    "world_y": world_y,
                    "game_type_id": game_type_id_from_json
                }
                if override_color_data and isinstance(override_color_data, list) and len(override_color_data) == 3:
                    new_obj["override_color"] = tuple(override_color_data) # type: ignore
                editor_state.placed_objects.append(new_obj)
            else:
                print(f"Warning MAP_UTILS: Asset key '{asset_key}' from loaded object (JSON type: '{game_type_id_from_json}') "
                      f"not found in current ED_CONFIG.EDITOR_PALETTE_ASSETS. Object at ({world_x},{world_y}) skipped.")

        editor_state.camera_offset_x = data.get("camera_offset_x", 0)
        editor_state.camera_offset_y = data.get("camera_offset_y", 0)
        editor_state.show_grid = data.get("show_grid", True)
        editor_state.color_change_target_info = None # Reset color tool state

        py_filename = editor_state.map_name_for_function + ED_CONFIG.GAME_LEVEL_FILE_EXTENSION
        editor_state.current_map_filename = os.path.join(ED_CONFIG.MAPS_DIRECTORY, py_filename)

        editor_state.recreate_map_content_surface()
        editor_state.unsaved_changes = False
        success_msg = f"Map '{editor_state.map_name_for_function}' loaded from {os.path.basename(json_filepath)}"
        print(f"DEBUG MAP_UTILS: {success_msg}. unsaved_changes={editor_state.unsaved_changes}, current_map_filename='{editor_state.current_map_filename}'")
        editor_state.set_status_message(success_msg)
        return True

    except json.JSONDecodeError as e:
        error_msg = f"Error: Could not decode JSON from map file '{json_filepath}': {e}"
    except Exception as e:
        error_msg = f"Unexpected error loading map from JSON '{json_filepath}': {e}"
        traceback.print_exc()

    print(f"ERROR MAP_UTILS: {error_msg}")
    editor_state.set_status_message(error_msg, 4)
    return False

def export_map_to_game_python_script(editor_state: EditorState) -> bool:
    print(f"DEBUG MAP_UTILS: export_map_to_game_python_script called. Map func name: '{editor_state.map_name_for_function}'")
    ts = editor_state.grid_size # Tile Size convenience

    if not editor_state.map_name_for_function or editor_state.map_name_for_function == "untitled_map":
        msg = "Map name not set or is 'untitled_map'. Cannot export .py."
        editor_state.set_status_message(f"Error: {msg}", 3)
        print(f"ERROR MAP_UTILS: {msg}")
        return False

    if not editor_state.current_map_filename:
        py_filename = editor_state.map_name_for_function + ED_CONFIG.GAME_LEVEL_FILE_EXTENSION
        editor_state.current_map_filename = os.path.join(ED_CONFIG.MAPS_DIRECTORY, py_filename)
        print(f"Warning MAP_UTILS: current_map_filename was not set, derived as '{editor_state.current_map_filename}' for export.")

    if not ensure_maps_directory_exists():
        msg = "Could not create or access maps directory for .py export."
        editor_state.set_status_message(f"Error: {msg}", 3)
        print(f"ERROR MAP_UTILS: {msg} PY export aborted.")
        return False

    function_name = f"load_map_{editor_state.map_name_for_function}"
    print(f"DEBUG MAP_UTILS: Exporting to function '{function_name}' in file '{editor_state.current_map_filename}'")

    platforms_code_lines = []
    ladders_code_lines = []
    hazards_code_lines = []
    enemy_spawns_code_lines = []
    collectible_spawns_code_lines = []

    default_spawn_tile_x = editor_state.map_width_tiles // 2
    default_spawn_tile_y = editor_state.map_height_tiles // 2
    default_spawn_world_x = default_spawn_tile_x * ts + ts // 2
    default_spawn_world_y = (default_spawn_tile_y + 1) * ts
    player1_spawn_str = f"player1_spawn = ({default_spawn_world_x}, {default_spawn_world_y}) # Default P1 Spawn"

    all_placed_world_rects_for_bounds: List[pygame.Rect] = []
    print(f"DEBUG MAP_UTILS: Processing {len(editor_state.placed_objects)} objects for .py export.")

    for i, obj_data in enumerate(editor_state.placed_objects):
        game_type_id = obj_data.get("game_type_id")
        world_x = obj_data.get("world_x")
        world_y = obj_data.get("world_y")
        asset_editor_key = obj_data.get("asset_editor_key")
        override_color = obj_data.get("override_color")

        if not all([game_type_id, world_x is not None, world_y is not None, asset_editor_key]):
            print(f"Warning MAP_UTILS: Export - Object at index {i} missing data, skipping: {obj_data}")
            continue

        asset_palette_entry = editor_state.assets_palette.get(asset_editor_key)
        if not asset_palette_entry:
            print(f"Warning MAP_UTILS: Asset key '{asset_editor_key}' not in palette. Skipping object export.")
            continue
        
        # Determine object size and default color for export
        obj_w_px, obj_h_px = ts, ts # Default to full tile
        default_color_tuple = getattr(C, 'MAGENTA', (255,0,255)) # Fallback color

        if asset_palette_entry.get("surface_params_dims_color"):
            w, h, c = asset_palette_entry["surface_params_dims_color"]
            obj_w_px, obj_h_px = w, h
            default_color_tuple = c
        elif asset_palette_entry.get("render_mode") == "half_tile":
            # Half tiles' palette image is full tsxts, but actual collision geom is half
            half_type = asset_palette_entry.get("half_type")
            default_color_tuple = asset_palette_entry.get("base_color_tuple", default_color_tuple)
            if half_type in ["left", "right"]: obj_w_px = ts // 2; obj_h_px = ts
            elif half_type in ["top", "bottom"]: obj_w_px = ts; obj_h_px = ts // 2
        elif asset_palette_entry.get("original_size_pixels"): # For GIFs etc.
             obj_w_px, obj_h_px = asset_palette_entry["original_size_pixels"]
        
        current_color_tuple = override_color if override_color else default_color_tuple
        current_color_str = f"({current_color_tuple[0]},{current_color_tuple[1]},{current_color_tuple[2]})" if isinstance(current_color_tuple, (list, tuple)) else str(current_color_tuple)


        # Adjust world_x/y for right_half and bottom_half for Platform constructor
        export_x, export_y = world_x, world_y
        if asset_palette_entry.get("render_mode") == "half_tile":
            half_type = asset_palette_entry.get("half_type")
            if half_type == "right": export_x = world_x + ts // 2
            elif half_type == "bottom": export_y = world_y + ts // 2
        
        current_obj_rect = pygame.Rect(export_x, export_y, obj_w_px, obj_h_px) # Use adjusted coords/dims for bounds
        all_placed_world_rects_for_bounds.append(current_obj_rect)

        # Object type to code generation
        if game_type_id == "platform_wall_gray" or "platform_wall_gray_" in game_type_id and "_half" in game_type_id:
            platforms_code_lines.append(f"    platforms.add(Platform({export_x}, {export_y}, {obj_w_px}, {obj_h_px}, {current_color_str}, platform_type='wall'))")
        elif game_type_id == "platform_ledge_green" or "platform_ledge_green_" in game_type_id and "_half" in game_type_id:
            # Original thin ledge was ts, ts // 4. Half-square ledges are blockier.
            if game_type_id == "platform_ledge_green": # Standard thin ledge
                 platforms_code_lines.append(f"    platforms.add(Platform({export_x}, {export_y}, {obj_w_px}, {obj_h_px}, {current_color_str}, platform_type='ledge'))")
            else: # Half-square blocky ledges
                 platforms_code_lines.append(f"    platforms.add(Platform({export_x}, {export_y}, {obj_w_px}, {obj_h_px}, {current_color_str}, platform_type='ledge'))")

        elif game_type_id == "hazard_lava":
            hazards_code_lines.append(f"    hazards.add(Lava({export_x}, {export_y}, {obj_w_px}, {obj_h_px}, {current_color_str}))")
        elif game_type_id == "player1_spawn":
            spawn_mid_x = world_x + obj_w_px // 2 # Original world_x for spawn point, not export_x
            spawn_bottom_y = world_y + obj_h_px
            player1_spawn_str = f"player1_spawn = ({spawn_mid_x}, {spawn_bottom_y})"
        elif "enemy" in game_type_id:
            specific_enemy_color_id = game_type_id.split('_')[-1] if '_' in game_type_id else "unknown_enemy_color"
            spawn_mid_x = world_x + obj_w_px // 2
            spawn_bottom_y = world_y + obj_h_px
            enemy_spawns_code_lines.append(f"    enemy_spawns_data.append({{'pos': ({spawn_mid_x}, {spawn_bottom_y}), 'patrol': None, 'enemy_color_id': '{specific_enemy_color_id}'}})")
        elif game_type_id == "chest":
            chest_spawn_x_midbottom = world_x + obj_w_px // 2
            chest_spawn_y_midbottom = world_y + obj_h_px
            collectible_spawns_code_lines.append(f"    collectible_spawns_data.append({{'type': 'chest', 'pos': ({chest_spawn_x_midbottom}, {chest_spawn_y_midbottom})}})")
        else:
            # Silently ignore unknown types or tool types for export to game script
            if not game_type_id.startswith("tool_"): # Don't warn for tools
                print(f"Warning MAP_UTILS: Unknown game_type_id '{game_type_id}' for object at ({world_x},{world_y}). Not exported to .py.")


    platforms_code_str = "\n".join(platforms_code_lines)
    ladders_code_str = "\n".join(ladders_code_lines)
    hazards_code_str = "\n".join(hazards_code_lines)
    enemy_spawns_code_str = "\n".join(enemy_spawns_code_lines)
    collectible_spawns_code_str = "\n".join(collectible_spawns_code_lines)
    print(f"DEBUG MAP_UTILS: Generated code lines - Platforms: {len(platforms_code_lines)}, Hazards: {len(hazards_code_lines)}, etc.")

    # Calculate Map Boundaries for Game
    if not all_placed_world_rects_for_bounds:
        print("DEBUG MAP_UTILS: No objects placed, using default map dimensions for export boundaries.")
        map_min_x_content, map_max_x_content = 0, editor_state.get_map_pixel_width()
        map_min_y_content, map_max_y_content = 0, editor_state.get_map_pixel_height()
    else:
        map_min_x_content = min(r.left for r in all_placed_world_rects_for_bounds)
        map_max_x_content = max(r.right for r in all_placed_world_rects_for_bounds)
        map_min_y_content = min(r.top for r in all_placed_world_rects_for_bounds)
        map_max_y_content = max(r.bottom for r in all_placed_world_rects_for_bounds)

    padding_px = C.TILE_SIZE * 2
    game_map_total_width_pixels = int(max(ED_CONFIG.EDITOR_SCREEN_INITIAL_WIDTH, (map_max_x_content - map_min_x_content) + 2 * padding_px))
    game_level_min_y_absolute = int(map_min_y_content - padding_px)
    game_level_max_y_absolute = int(map_max_y_content + padding_px)
    game_main_ground_y_reference = int(map_max_y_content)
    game_main_ground_height_reference = int(C.TILE_SIZE)

    if game_level_min_y_absolute >= game_level_max_y_absolute:
        print(f"Warning MAP_UTILS: Calculated min_y_abs ({game_level_min_y_absolute}) >= max_y_abs ({game_level_max_y_absolute}). Adjusting max_y_abs.")
        game_level_max_y_absolute = game_level_min_y_absolute + C.TILE_SIZE * 5

    print(f"DEBUG MAP_UTILS: Export boundaries - TotalWidthPx: {game_map_total_width_pixels}, MinYAbs: {game_level_min_y_absolute}, MaxYAbs: {game_level_max_y_absolute}")

    script_content = f"""# Level: {editor_state.map_name_for_function}
# Generated by Platformer Level Editor version X.Y.Z # Consider adding a version
import pygame
from tiles import Platform, Ladder, Lava # Ensure all used tile types are imported
import constants as C

LEVEL_SPECIFIC_BACKGROUND_COLOR = {editor_state.background_color}

def {function_name}(initial_screen_width, initial_screen_height):
    \"\"\"
    Loads the '{editor_state.map_name_for_function}' level.
    \"\"\"
    print(f"Loading map: {function_name}...")
    platforms = pygame.sprite.Group()
    ladders = pygame.sprite.Group() # Ensure ladders group is there if you add ladders
    hazards = pygame.sprite.Group()
    enemy_spawns_data = []
    collectible_spawns_data = []

    {player1_spawn_str}

    # --- Placed Objects ---
{platforms_code_str if platforms_code_str else "    # No platforms placed."}
{ladders_code_str if ladders_code_str else "    # No ladders placed."}
{hazards_code_str if hazards_code_str else "    # No hazards placed."}
{enemy_spawns_code_str if enemy_spawns_code_str else "    # No enemy spawns defined."}
{collectible_spawns_code_str if collectible_spawns_code_str else "    # No collectible spawns defined."}

    # --- Level Dimensions for Game Camera & Boundaries ---
    map_total_width_pixels = {game_map_total_width_pixels}
    level_min_y_absolute = {game_level_min_y_absolute}
    level_max_y_absolute = {game_level_max_y_absolute}
    main_ground_y_reference = {game_main_ground_y_reference}
    main_ground_height_reference = {game_main_ground_height_reference}

    # --- Auto-generated Boundary Walls ---
    _boundary_thickness = C.TILE_SIZE * 2
    _boundary_wall_height = level_max_y_absolute - level_min_y_absolute + (2 * _boundary_thickness)
    _boundary_color = getattr(C, 'DARK_GRAY', (50,50,50)) # Use a defined boundary color

    # Top boundary
    platforms.add(Platform(0, level_min_y_absolute - _boundary_thickness, map_total_width_pixels, _boundary_thickness, _boundary_color, platform_type="boundary_wall_top"))
    # Bottom boundary
    platforms.add(Platform(0, level_max_y_absolute, map_total_width_pixels, _boundary_thickness, _boundary_color, platform_type="boundary_wall_bottom"))
    # Left boundary
    platforms.add(Platform(-_boundary_thickness, level_min_y_absolute - _boundary_thickness, _boundary_thickness, _boundary_wall_height, _boundary_color, platform_type="boundary_wall_left"))
    # Right boundary
    platforms.add(Platform(map_total_width_pixels, level_min_y_absolute - _boundary_thickness, _boundary_thickness, _boundary_wall_height, _boundary_color, platform_type="boundary_wall_right"))

    print(f"Map '{function_name}' loaded with: {{len(platforms)}} platforms, {{len(ladders)}} ladders, {{len(hazards)}} hazards.")
    return (platforms, ladders, hazards, enemy_spawns_data, collectible_spawns_data,
            player1_spawn,
            map_total_width_pixels, level_min_y_absolute, level_max_y_absolute,
            main_ground_y_reference, main_ground_height_reference,
            LEVEL_SPECIFIC_BACKGROUND_COLOR)
"""
    py_filepath = editor_state.current_map_filename
    print(f"DEBUG MAP_UTILS: Final .py script content to write to '{py_filepath}' (first 500 chars):\n{script_content[:500]}...")

    try:
        with open(py_filepath, "w") as f:
            f.write(script_content)
        success_msg = f"Map exported to game script: {os.path.basename(py_filepath)}"
        print(f"DEBUG MAP_UTILS: {success_msg}")
        editor_state.set_status_message(success_msg)
        editor_state.unsaved_changes = False
        print(f"DEBUG MAP_UTILS: unsaved_changes set to False after .py export.")
        return True
    except IOError as e:
        error_msg = f"IOError exporting map to .py '{py_filepath}': {e}"
    except Exception as e:
        error_msg = f"Unexpected error during .py export to '{py_filepath}': {e}"
        traceback.print_exc()

    print(f"ERROR MAP_UTILS: {error_msg}")
    editor_state.set_status_message(error_msg, 4)
    return False

########## START OF FILE: editor_state.py ##########

# editor_state.py
# -*- coding: utf-8 -*-
"""
## version 1.0.0.13 (Corrected selected_asset_editor_key setter for color tool)
Defines the EditorState class, which holds all the dynamic state
and data for the level editor.
"""
import pygame
from typing import Optional, Dict, List, Tuple, Any, Callable
import traceback
import logging

import editor_config as ED_CONFIG

logger = logging.getLogger(__name__)

class EditorState:
    def __init__(self):
        logger.debug("Initializing EditorState...")
        self.current_map_data: Dict[str, Any] = {}
        self.current_map_filename: Optional[str] = None
        self.map_name_for_function: str = "untitled_map"
        self.map_width_tiles: int = ED_CONFIG.DEFAULT_MAP_WIDTH_TILES
        self.map_height_tiles: int = ED_CONFIG.DEFAULT_MAP_HEIGHT_TILES
        self.grid_size: int = ED_CONFIG.DEFAULT_GRID_SIZE
        self.background_color: Tuple[int, int, int] = ED_CONFIG.DEFAULT_BACKGROUND_COLOR
        self.map_content_surface: Optional[pygame.Surface] = None

        self.minimap_surface: Optional[pygame.Surface] = None
        self.minimap_needs_regeneration: bool = True
        self.minimap_rect_in_palette: Optional[pygame.Rect] = None
        self.is_dragging_minimap_view: bool = False

        self.placed_objects: List[Dict[str, Any]] = []
        self.assets_palette: Dict[str, Dict[str, Any]] = {}
        self._selected_asset_editor_key: Optional[str] = None
        self.selected_asset_image_for_cursor: Optional[pygame.Surface] = None # Controlled by setter
        self.asset_palette_scroll_y: int = 0
        self.total_asset_palette_content_height: int = 0

        self.camera_offset_x: int = 0
        self.camera_offset_y: int = 0
        self.show_grid: bool = True

        self.last_mouse_pos_map_view: Optional[Tuple[int, int]] = None
        self.mouse_velocity_map_view: Tuple[float, float] = (0.0, 0.0)
        self.camera_momentum_pan: Tuple[float, float] = (0.0, 0.0)
        self.is_mouse_over_map_view: bool = False

        self.dragging_object_index: Optional[int] = None
        self.drag_start_mouse_map_x: int = 0
        self.drag_start_mouse_map_y: int = 0
        self.drag_object_original_x: int = 0
        self.drag_object_original_y: int = 0
        self.is_painting_tiles: bool = False
        self.last_painted_tile_coords: Optional[Tuple[int, int]] = None
        self.is_erasing_tiles: bool = False
        self.last_erased_tile_coords: Optional[Tuple[int, int]] = None

        self.color_change_target_info: Optional[Dict[str, Any]] = None

        self._current_editor_mode: str = "menu"
        self.unsaved_changes: bool = False
        self.hovered_tooltip_text: Optional[str] = None
        self.hovered_tooltip_pos: Optional[Tuple[int, int]] = None
        self.ui_elements_rects: Dict[str, Any] = {}
        self._active_dialog_type: Optional[str] = None
        self.dialog_input_text: str = ""
        self.dialog_prompt_message: str = ""
        self.dialog_input_default: str = ""
        self.dialog_callback_confirm: Optional[Callable[..., None]] = None
        self.dialog_callback_cancel: Optional[Callable[[], None]] = None
        self.dialog_rect: Optional[pygame.Rect] = None
        self.color_picker_rects: Dict[str, pygame.Rect] = {}
        self.dialog_file_list: List[str] = []
        self.dialog_file_scroll_y: int = 0
        self.dialog_selected_file_index: int = -1
        self.is_dragging_scrollbar: bool = False
        self.scrollbar_drag_mouse_offset_y: int = 0
        self.map_name_for_function_input: str = ""
        self.status_message: Optional[str] = None
        self.status_message_timer: float = 0.0
        self.status_message_duration: float = 3.0
        self.recreate_map_content_surface()
        logger.debug("EditorState initialized.")


    @property
    def current_editor_mode(self) -> str:
        return self._current_editor_mode

    @current_editor_mode.setter
    def current_editor_mode(self, value: str):
        if self._current_editor_mode != value:
            logger.debug(f"Changing editor mode from '{self._current_editor_mode}' to '{value}'")
            self._current_editor_mode = value
            if value == "editing_map":
                self.minimap_needs_regeneration = True
                self.camera_momentum_pan = (0.0, 0.0)
                if self.selected_asset_editor_key == "tool_color_change":
                    logger.debug("Editor mode to editing_map, color tool was selected, ensuring no cursor image.")
                    self.selected_asset_image_for_cursor = None
            if value == "menu":
                self.camera_momentum_pan = (0.0, 0.0)


    @property
    def active_dialog_type(self) -> Optional[str]:
        return self._active_dialog_type

    @active_dialog_type.setter
    def active_dialog_type(self, value: Optional[str]):
        if self._active_dialog_type != value:
            logger.debug(f"Changing active_dialog_type from '{self._active_dialog_type}' to '{value}'")
            old_dialog_type = self._active_dialog_type
            self._active_dialog_type = value
            if value is not None:
                self.camera_momentum_pan = (0.0, 0.0)
            if value is None or (old_dialog_type is not None and old_dialog_type != value):
                keys_to_remove = []
                if old_dialog_type == "file_load":
                    keys_to_remove.extend(['dialog_file_item_rects', 'file_dialog_scrollbar_handle',
                                           'file_dialog_scrollbar_area', 'dialog_file_load_ok', 'dialog_file_load_cancel'])
                elif old_dialog_type == "color_picker": self.color_picker_rects.clear()
                for key in keys_to_remove:
                    if key in self.ui_elements_rects:
                        try: del self.ui_elements_rects[key]
                        except KeyError: pass
            if value is None: self.dialog_rect = None

    @property
    def selected_asset_editor_key(self) -> Optional[str]:
        return self._selected_asset_editor_key

    @selected_asset_editor_key.setter
    def selected_asset_editor_key(self, value: Optional[str]):
        logger.debug(f"Attempting to set selected_asset_editor_key from '{self._selected_asset_editor_key}' to '{value}'")
        # Only proceed if the value is actually different OR if it's a tool being re-asserted
        if self._selected_asset_editor_key != value or \
           (value == "tool_color_change" and self.selected_asset_image_for_cursor is not None) or \
           (value is not None and value != "tool_color_change" and value in self.assets_palette and self.selected_asset_image_for_cursor is None) :

            self._selected_asset_editor_key = value
            logger.info(f"selected_asset_editor_key changed to: '{value}'")

            if value == "tool_color_change":
                self.selected_asset_image_for_cursor = None
                logger.debug(f"Color tool ('{value}') selected/re-asserted. selected_asset_image_for_cursor explicitly set to None.")
            elif value is None:
                self.selected_asset_image_for_cursor = None
                logger.debug("No asset selected. selected_asset_image_for_cursor set to None.")
            elif value in self.assets_palette:
                asset_data = self.assets_palette[value]
                if "image" in asset_data and asset_data["image"] is not None:
                    self.selected_asset_image_for_cursor = asset_data["image"].copy()
                    logger.debug(f"Asset '{value}' selected. Cursor image set from palette.")
                else:
                    self.selected_asset_image_for_cursor = None
                    logger.warning(f"Asset '{value}' selected, but has no image in palette. Cursor image set to None.")
            else: # Asset key not in palette (should ideally not happen if selected from UI)
                self.selected_asset_image_for_cursor = None
                logger.warning(f"Asset key '{value}' not found in assets_palette during selection. Cursor image set to None.")
        else:
            logger.debug(f"selected_asset_editor_key already '{value}', no change needed for key or cursor state.")


    def recreate_map_content_surface(self):
        map_pixel_width = self.map_width_tiles * self.grid_size
        map_pixel_height = self.map_height_tiles * self.grid_size
        safe_width, safe_height = max(1, map_pixel_width), max(1, map_pixel_height)
        try:
            self.map_content_surface = pygame.Surface((safe_width, safe_height))
            self.minimap_needs_regeneration = True
            logger.debug(f"Recreated map_content_surface: {safe_width}x{safe_height}")
        except pygame.error as e:
            logger.error(f"Failed to create map_content_surface: {e}", exc_info=True)
            try: self.map_content_surface = pygame.Surface((ED_CONFIG.DEFAULT_GRID_SIZE, ED_CONFIG.DEFAULT_GRID_SIZE))
            except Exception as e_fallback: self.map_content_surface = None; logger.critical(f"Fallback surface failed: {e_fallback}", exc_info=True)


    def get_map_pixel_width(self) -> int: return self.map_width_tiles * self.grid_size
    def get_map_pixel_height(self) -> int: return self.map_height_tiles * self.grid_size

    def set_status_message(self, message: str, duration: float = 3.0):
        self.status_message, self.status_message_duration, self.status_message_timer = message, duration, duration
        logger.info(f"Status message set: '{message}' for {duration}s")

    def update_status_message(self, dt: float):
        if self.status_message and self.status_message_timer > 0:
            self.status_message_timer -= dt
            if self.status_message_timer <= 0: self.status_message, self.status_message_timer = None, 0.0

    def reset_map_context(self):
        logger.debug("Resetting map context.")
        self.map_name_for_function = "untitled_map"; self.current_map_filename = None
        self.placed_objects = []; self.map_width_tiles = ED_CONFIG.DEFAULT_MAP_WIDTH_TILES
        self.map_height_tiles = ED_CONFIG.DEFAULT_MAP_HEIGHT_TILES; self.background_color = ED_CONFIG.DEFAULT_BACKGROUND_COLOR
        self.camera_offset_x, self.camera_offset_y = 0, 0; self.unsaved_changes = False
        self.selected_asset_editor_key, self.selected_asset_image_for_cursor = None, None
        self.is_painting_tiles, self.last_painted_tile_coords = False, None
        self.is_erasing_tiles, self.last_erased_tile_coords = False, None
        self.color_change_target_info = None
        self.minimap_needs_regeneration = True
        self.last_mouse_pos_map_view = None
        self.mouse_velocity_map_view = (0.0, 0.0)
        self.camera_momentum_pan = (0.0, 0.0)
        self.is_mouse_over_map_view = False
        self.is_dragging_minimap_view = False
        logger.debug(f"Map context reset. Map name: '{self.map_name_for_function}'.")

########## START OF FILE: editor_ui.py ##########

# editor_ui.py
# -*- coding: utf-8 -*-
"""
## version 1.0.0.7 (Reduced verbose prints, added debug for MAGENTA issue)
Pygame-based UI functions for the Level Editor.
Includes buttons, input dialogs, color pickers, and tooltips.
"""
import pygame
import os
from typing import Optional, Dict, Tuple, Any, Callable, List
import traceback # ADDED for more detailed error reporting

import editor_config as ED_CONFIG
from editor_state import EditorState
# Assuming constants.py (referenced by ED_CONFIG.C) is accessible from the project root.
# This setup relies on editor.py correctly setting up sys.path.

# --- UI Drawing Helpers ---

def draw_button(surface: pygame.Surface,
                rect: pygame.Rect,
                text: str,
                font: Optional[pygame.font.Font],
                mouse_pos: Tuple[int, int],
                text_color: Tuple[int, int, int] = ED_CONFIG.BUTTON_TEXT_COLOR,
                button_color_normal: Tuple[int, int, int] = ED_CONFIG.BUTTON_COLOR_NORMAL,
                button_color_hover: Tuple[int, int, int] = ED_CONFIG.BUTTON_COLOR_HOVER,
                border_color: Tuple[int, int, int] = ED_CONFIG.BUTTON_COLOR_BORDER,
                border_width: int = ED_CONFIG.BUTTON_BORDER_WIDTH,
                is_active: bool = True) -> bool:
    # print(f"DEBUG UI_DRAW: draw_button called for '{text}' at {rect}, active={is_active}") # Kept commented: Can be verbose
    is_hovered = False
    if is_active and rect.collidepoint(mouse_pos):
        is_hovered = True

    current_button_color = button_color_normal
    current_text_color = text_color

    if not is_active:
        current_button_color = tuple(int(c * 0.67) for c in button_color_normal) # Darker shade
        current_text_color = tuple(int(c * 0.67) for c in text_color)
    elif is_hovered:
        current_button_color = button_color_hover

    try:
        pygame.draw.rect(surface, current_button_color, rect)
        if border_width > 0:
            pygame.draw.rect(surface, border_color, rect, border_width)

        if font:
            text_surf = font.render(text, True, current_text_color)
            text_rect = text_surf.get_rect(center=rect.center)
            surface.blit(text_surf, text_rect)
        else:
            print(f"Warning UI_DRAW: draw_button called with no font for text '{text}'")
    except Exception as e:
        print(f"ERROR UI_DRAW: Exception in draw_button for '{text}': {e}")
        traceback.print_exc()

    return is_hovered

def draw_tooltip(surface: pygame.Surface,
                 editor_state: EditorState,
                 font: Optional[pygame.font.Font]):
    if editor_state.hovered_tooltip_text and editor_state.hovered_tooltip_pos and font:
        # print(f"DEBUG UI_DRAW: Drawing tooltip: '{editor_state.hovered_tooltip_text}' at {editor_state.hovered_tooltip_pos}") # Kept commented: Verbose
        try:
            text_surf = font.render(editor_state.hovered_tooltip_text, True, ED_CONFIG.TOOLTIP_TEXT_COLOR)
            text_rect = text_surf.get_rect(
                topleft=(editor_state.hovered_tooltip_pos[0] + 15,
                         editor_state.hovered_tooltip_pos[1] + 15)
            )
            bg_rect = text_rect.inflate(ED_CONFIG.TOOLTIP_PADDING * 2, ED_CONFIG.TOOLTIP_PADDING * 2)

            bg_rect.clamp_ip(surface.get_rect()) # Ensure tooltip stays on screen
            text_rect.clamp_ip(bg_rect.inflate(-ED_CONFIG.TOOLTIP_PADDING, -ED_CONFIG.TOOLTIP_PADDING)) # And text within tooltip bg

            pygame.draw.rect(surface, ED_CONFIG.TOOLTIP_BG_COLOR, bg_rect, border_radius=3)
            pygame.draw.rect(surface, ED_CONFIG.BUTTON_COLOR_BORDER, bg_rect, 1, border_radius=3)
            surface.blit(text_surf, text_rect)
        except Exception as e:
            print(f"ERROR UI_DRAW: Exception in draw_tooltip for '{editor_state.hovered_tooltip_text}': {e}")
            traceback.print_exc()

def draw_status_message(surface: pygame.Surface, editor_state: EditorState, font: Optional[pygame.font.Font]):
    if editor_state.status_message and font:
        # print(f"DEBUG UI_DRAW: Drawing status message: '{editor_state.status_message}'") # Kept commented: Verbose
        try:
            message_surf = font.render(editor_state.status_message, True, getattr(ED_CONFIG.C, 'YELLOW', (255,255,0))) # Use getattr for safety
            message_rect = message_surf.get_rect(centerx=surface.get_width() // 2,
                                                  bottom=surface.get_height() - 10)
            bg_padding = 5
            bg_rect = message_rect.inflate(bg_padding * 2, bg_padding * 2)
            bg_rect.clamp_ip(surface.get_rect())
            message_rect.clamp_ip(bg_rect)

            s = pygame.Surface(bg_rect.size, pygame.SRCALPHA)
            s.fill((50, 50, 50, 180)) # Semi-transparent dark background
            surface.blit(s, bg_rect.topleft)
            surface.blit(message_surf, message_rect)
        except Exception as e:
            print(f"ERROR UI_DRAW: Exception in draw_status_message for '{editor_state.status_message}': {e}")
            traceback.print_exc()

# --- Pygame-based Dialogs ---

def start_text_input_dialog(editor_state: EditorState,
                            prompt: str,
                            default_text: str = "",
                            on_confirm: Optional[Callable[[str], None]] = None,
                            on_cancel: Optional[Callable[[], None]] = None):
    print(f"DEBUG UI_DIALOG: start_text_input_dialog. Prompt: '{prompt}', Default: '{default_text}'") # Removed cb presence for brevity
    editor_state.active_dialog_type = "text_input"
    editor_state.dialog_prompt_message = prompt
    editor_state.dialog_input_text = default_text
    editor_state.dialog_input_default = default_text # Store original default
    editor_state.dialog_callback_confirm = on_confirm
    editor_state.dialog_callback_cancel = on_cancel
    editor_state.dialog_rect = None # Will be set by draw_active_dialog

def start_color_picker_dialog(editor_state: EditorState,
                              on_confirm: Optional[Callable[[Tuple[int,int,int]], None]] = None,
                              on_cancel: Optional[Callable[[], None]] = None):
    print(f"DEBUG UI_DIALOG: start_color_picker_dialog.") # Removed cb presence for brevity
    editor_state.active_dialog_type = "color_picker"
    editor_state.dialog_prompt_message = "Select Background Color (Esc to Cancel)"
    editor_state.color_picker_rects.clear()

    cols = ED_CONFIG.COLOR_PICKER_COLS
    button_size = ED_CONFIG.COLOR_PICKER_BUTTON_SIZE
    padding = ED_CONFIG.COLOR_PICKER_PADDING

    start_x_in_dialog = padding * 2
    current_y_in_dialog = 50 # Initial Y offset for swatches below title
    current_x_in_dialog = start_x_in_dialog
    idx = 0
    for name in ED_CONFIG.COLOR_PICKER_PRESETS.keys():
        rect = pygame.Rect(current_x_in_dialog, current_y_in_dialog, button_size, button_size)
        editor_state.color_picker_rects[name] = rect
        current_x_in_dialog += button_size + padding
        idx += 1
        if idx % cols == 0:
            current_x_in_dialog = start_x_in_dialog
            current_y_in_dialog += button_size + padding

    editor_state.dialog_callback_confirm = on_confirm
    editor_state.dialog_callback_cancel = on_cancel
    editor_state.dialog_rect = None # Will be set by draw_active_dialog

def start_file_load_dialog(editor_state: EditorState,
                           on_confirm: Optional[Callable[[str], None]] = None,
                           on_cancel: Optional[Callable[[], None]] = None,
                           initial_path: str = ED_CONFIG.MAPS_DIRECTORY,
                           file_extension: str = ED_CONFIG.LEVEL_EDITOR_SAVE_FORMAT_EXTENSION):
    print(f"DEBUG UI_DIALOG: start_file_load_dialog. Path: '{initial_path}', Ext: '{file_extension}'") # Removed cb presence
    editor_state.active_dialog_type = "file_load"
    editor_state.dialog_prompt_message = f"Select Map to Load (from ./{initial_path})"
    editor_state.dialog_input_text = ""
    editor_state.dialog_file_list = []
    editor_state.dialog_file_scroll_y = 0
    editor_state.dialog_selected_file_index = -1
    editor_state.dialog_rect = None

    if 'dialog_file_item_rects' not in editor_state.ui_elements_rects:
        editor_state.ui_elements_rects['dialog_file_item_rects'] = []
    else:
        editor_state.ui_elements_rects['dialog_file_item_rects'].clear()

    if not os.path.exists(initial_path):
        try:
            os.makedirs(initial_path)
            # print(f"DEBUG UI_DIALOG: Created maps directory at '{initial_path}' during file_load_dialog start.") # Less frequent, so ok
            editor_state.set_status_message(f"Created maps dir '{initial_path}'. No files yet.", 2)
        except OSError as e:
            err_msg = f"Error creating dir '{initial_path}': {e}"
            editor_state.set_status_message(err_msg, 3)
            print(f"ERROR UI_DIALOG: {err_msg}")
            if on_cancel: on_cancel()
            editor_state.active_dialog_type = None
            return

    try:
        for item in os.listdir(initial_path):
            if item.endswith(file_extension) and os.path.isfile(os.path.join(initial_path, item)):
                editor_state.dialog_file_list.append(item)
        editor_state.dialog_file_list.sort()
        # print(f"DEBUG UI_DIALOG: Found files in '{initial_path}': {editor_state.dialog_file_list}") # Less frequent, so ok
    except OSError as e:
        err_msg = f"Error listing files in '{initial_path}': {e}"
        editor_state.set_status_message(err_msg, 3)
        print(f"ERROR UI_DIALOG: {err_msg}")
        if on_cancel: on_cancel()
        editor_state.active_dialog_type = None
        return

    if not editor_state.dialog_file_list:
        editor_state.set_status_message(f"No '{file_extension}' files found in ./{initial_path}", 2.5)

    editor_state.dialog_callback_confirm = on_confirm
    editor_state.dialog_callback_cancel = on_cancel


def draw_active_dialog(surface: pygame.Surface, editor_state: EditorState, fonts: Dict[str, Optional[pygame.font.Font]]):
    if not editor_state.active_dialog_type:
        return

    # print(f"DEBUG UI_DRAW_DIALOG: Drawing dialog type '{editor_state.active_dialog_type}'") # Kept commented: Can be verbose
    try:
        screen_center_x, screen_center_y = surface.get_rect().center
        dialog_width, dialog_height = 450, 350

        if editor_state.active_dialog_type == "text_input":
            dialog_width, dialog_height = 400, 200
        elif editor_state.active_dialog_type == "color_picker":
            num_colors = len(ED_CONFIG.COLOR_PICKER_PRESETS)
            cols = ED_CONFIG.COLOR_PICKER_COLS
            rows = (num_colors + cols - 1) // cols
            content_w = cols * ED_CONFIG.COLOR_PICKER_BUTTON_SIZE + (cols -1 if cols > 0 else 0) * ED_CONFIG.COLOR_PICKER_PADDING
            content_h = rows * ED_CONFIG.COLOR_PICKER_BUTTON_SIZE + (rows -1 if rows > 0 else 0) * ED_CONFIG.COLOR_PICKER_PADDING
            dialog_width = max(300, content_w + ED_CONFIG.COLOR_PICKER_PADDING * 4)
            title_space = 60
            dialog_height = max(200, content_h + title_space + ED_CONFIG.COLOR_PICKER_PADDING * 2)
        elif editor_state.active_dialog_type == "file_load":
            dialog_width, dialog_height = 400, 350

        current_dialog_rect = pygame.Rect(0, 0, dialog_width, dialog_height)
        current_dialog_rect.center = screen_center_x, screen_center_y
        editor_state.dialog_rect = current_dialog_rect

        pygame.draw.rect(surface, ED_CONFIG.DIALOG_BG_COLOR, current_dialog_rect, border_radius=5)
        pygame.draw.rect(surface, getattr(ED_CONFIG.C, 'BLACK', (0,0,0)), current_dialog_rect, 2, border_radius=5) # Use getattr

        prompt_font = fonts.get("medium") or ED_CONFIG.FONT_CONFIG.get("medium")
        if prompt_font and editor_state.dialog_prompt_message:
            prompt_surf = prompt_font.render(editor_state.dialog_prompt_message, True, ED_CONFIG.DIALOG_PROMPT_COLOR)
            prompt_draw_rect = prompt_surf.get_rect(midtop=(current_dialog_rect.centerx, current_dialog_rect.top + 15))
            surface.blit(prompt_surf, prompt_draw_rect)

        if editor_state.active_dialog_type == "text_input":
            _draw_text_input_content(surface, editor_state, current_dialog_rect, fonts)
        elif editor_state.active_dialog_type == "color_picker":
            _draw_color_picker_content(surface, editor_state, current_dialog_rect, fonts)
        elif editor_state.active_dialog_type == "file_load":
            _draw_file_load_content(surface, editor_state, current_dialog_rect, fonts)

    except Exception as e:
        print(f"ERROR UI_DRAW_DIALOG: Exception in draw_active_dialog for type '{editor_state.active_dialog_type}': {e}")
        traceback.print_exc()
        error_font = fonts.get("small")
        if error_font and editor_state.dialog_rect:
            err_surf = error_font.render(f"Dialog Error! See console.", True, getattr(ED_CONFIG.C, 'RED', (255,0,0))) # Use getattr
            surface.blit(err_surf, err_surf.get_rect(center=editor_state.dialog_rect.center))


def _draw_text_input_content(surface: pygame.Surface, editor_state: EditorState, dialog_rect: pygame.Rect, fonts: Dict[str, Optional[pygame.font.Font]]):
    input_box_rect = pygame.Rect(0, 0, dialog_rect.width - 40, 40)
    input_box_rect.center = dialog_rect.centerx, dialog_rect.centery + 10
    pygame.draw.rect(surface, ED_CONFIG.DIALOG_INPUT_BOX_COLOR, input_box_rect)
    pygame.draw.rect(surface, getattr(ED_CONFIG.C, 'BLACK', (0,0,0)), input_box_rect, 2) # Use getattr

    text_font = fonts.get("medium") or ED_CONFIG.FONT_CONFIG.get("medium")
    if text_font:
        current_text_to_render = str(editor_state.dialog_input_text) if editor_state.dialog_input_text is not None else ""
        input_text_surf = text_font.render(current_text_to_render, True, ED_CONFIG.DIALOG_INPUT_TEXT_COLOR)
        text_clip_area_rect = input_box_rect.inflate(-12, -12)
        text_surf_width = input_text_surf.get_width()
        blit_area = None
        text_draw_pos_on_surface_x = text_clip_area_rect.left

        if text_surf_width > text_clip_area_rect.width:
            text_draw_pos_on_surface_x = text_clip_area_rect.right - text_surf_width
            blit_source_x_offset = text_surf_width - text_clip_area_rect.width
            blit_area = pygame.Rect(blit_source_x_offset, 0, text_clip_area_rect.width, input_text_surf.get_height())

        blit_destination_topleft = (text_draw_pos_on_surface_x,
                                    text_clip_area_rect.top + (text_clip_area_rect.height - input_text_surf.get_height()) // 2)
        original_clip = surface.get_clip()
        surface.set_clip(text_clip_area_rect)
        surface.blit(input_text_surf, blit_destination_topleft, area=blit_area)
        surface.set_clip(original_clip)

        if blit_area:
            cursor_render_x = text_clip_area_rect.right -1
        else:
            cursor_render_x = text_clip_area_rect.left + input_text_surf.get_width() + 1
        cursor_render_x = max(text_clip_area_rect.left, min(cursor_render_x, text_clip_area_rect.right -1))

        if int(pygame.time.get_ticks() / 500) % 2 == 0:
             pygame.draw.line(surface, ED_CONFIG.DIALOG_CURSOR_COLOR,
                             (cursor_render_x, input_box_rect.top + 5),
                             (cursor_render_x, input_box_rect.bottom - 5), 2)

    info_font = fonts.get("small") or ED_CONFIG.FONT_CONFIG.get("small")
    if info_font:
        info_surf = info_font.render("Enter: Confirm, Esc: Cancel", True, getattr(ED_CONFIG.C, 'LIGHT_GRAY', (200,200,200))) # Use getattr
        surface.blit(info_surf, info_surf.get_rect(midbottom=(dialog_rect.centerx, dialog_rect.bottom - 10)))

def _draw_color_picker_content(surface: pygame.Surface, editor_state: EditorState, dialog_rect: pygame.Rect, fonts: Dict[str, Optional[pygame.font.Font]]):
    mouse_pos_dialog = pygame.mouse.get_pos()

    # --- TEMPORARY DEBUG for MAGENTA issue (Uncomment if still happening after restart) ---
    # print(f"DEBUG UI_COLOR_PICKER: In _draw_color_picker_content")
    # print(f"DEBUG UI_COLOR_PICKER: ED_CONFIG type: {type(ED_CONFIG)}")
    # print(f"DEBUG UI_COLOR_PICKER: ED_CONFIG.C type: {type(ED_CONFIG.C)}")
    # print(f"DEBUG UI_COLOR_PICKER: ED_CONFIG.C attributes: {dir(ED_CONFIG.C)}")
    # print(f"DEBUG UI_COLOR_PICKER: Has MAGENTA in ED_CONFIG.C? {hasattr(ED_CONFIG.C, 'MAGENTA')}")
    # if hasattr(ED_CONFIG.C, 'MAGENTA'):
    #     print(f"DEBUG UI_COLOR_PICKER: ED_CONFIG.C.MAGENTA value: {ED_CONFIG.C.MAGENTA}")
    # else:
    #     print(f"CRITICAL DEBUG UI_COLOR_PICKER: ED_CONFIG.C does NOT have MAGENTA attribute!")
    # print(f"DEBUG UI_COLOR_PICKER: COLOR_PICKER_PRESETS keys: {list(ED_CONFIG.COLOR_PICKER_PRESETS.keys())}")
    # --- END TEMPORARY DEBUG ---

    default_fallback_color = (255, 0, 255) # Define a literal magenta just in case C.MAGENTA access fails

    for name, swatch_rect_relative in editor_state.color_picker_rects.items():
        absolute_swatch_rect = swatch_rect_relative.move(dialog_rect.left, dialog_rect.top)
        
        # Safely get MAGENTA from ED_CONFIG.C, or use the literal default_fallback_color
        magenta_default = getattr(ED_CONFIG.C, 'MAGENTA', default_fallback_color)
        color_val = ED_CONFIG.COLOR_PICKER_PRESETS.get(name, magenta_default)

        pygame.draw.rect(surface, color_val, absolute_swatch_rect)
        border_col = getattr(ED_CONFIG.C, 'BLACK', (0,0,0)) # Use getattr
        border_w = 1
        if absolute_swatch_rect.collidepoint(mouse_pos_dialog):
            border_col = getattr(ED_CONFIG.COLOR_PICKER_HOVER_BORDER_COLOR, 'YELLOW', (255,255,0)) # Use getattr for this too
            border_w = 3
        pygame.draw.rect(surface, border_col, absolute_swatch_rect, border_w)

def _draw_file_load_content(surface: pygame.Surface, editor_state: EditorState, dialog_rect: pygame.Rect, fonts: Dict[str, Optional[pygame.font.Font]]):
    prompt_font = fonts.get("medium") or ED_CONFIG.FONT_CONFIG.get("medium")
    title_height = prompt_font.get_height() + 25 if prompt_font else 55
    buttons_panel_height = ED_CONFIG.BUTTON_HEIGHT_STANDARD // 2 + 20

    list_area_y_start = dialog_rect.top + title_height
    list_area_height = dialog_rect.height - title_height - buttons_panel_height

    list_area_rect = pygame.Rect(dialog_rect.left + 10, list_area_y_start, dialog_rect.width - 20, list_area_height)
    pygame.draw.rect(surface, ED_CONFIG.DIALOG_INPUT_BOX_COLOR, list_area_rect)
    pygame.draw.rect(surface, getattr(ED_CONFIG.C, 'BLACK', (0,0,0)), list_area_rect, 1) # Use getattr

    item_font = fonts.get("small") or ED_CONFIG.FONT_CONFIG.get("small")
    item_line_height = (item_font.get_height() + 6) if item_font else 22

    editor_state.ui_elements_rects['dialog_file_item_rects'] = []
    list_clip_rect = list_area_rect.inflate(-8, -8)
    total_content_height_pixels = len(editor_state.dialog_file_list) * item_line_height
    scrollbar_width_drawn = 0

    if total_content_height_pixels > list_clip_rect.height:
        scrollbar_width_drawn = 15
        scrollbar_track_rect = pygame.Rect(list_clip_rect.right + 2, list_clip_rect.top,
                                          scrollbar_width_drawn, list_clip_rect.height)
        pygame.draw.rect(surface, getattr(ED_CONFIG.C, 'DARK_GRAY', (50,50,50)), scrollbar_track_rect) # Use getattr
        handle_height_ratio = min(1.0, list_clip_rect.height / total_content_height_pixels if total_content_height_pixels > 0 else 1.0)
        handle_height = max(20, scrollbar_track_rect.height * handle_height_ratio)
        scrollable_content_outside_view = max(0, total_content_height_pixels - list_clip_rect.height)
        current_scroll_ratio_of_hidden = editor_state.dialog_file_scroll_y / scrollable_content_outside_view if scrollable_content_outside_view > 0 else 0
        handle_y_pos_on_track = (scrollbar_track_rect.height - handle_height) * current_scroll_ratio_of_hidden
        scrollbar_handle_rect = pygame.Rect(scrollbar_track_rect.left,
                                            scrollbar_track_rect.top + handle_y_pos_on_track,
                                            scrollbar_width_drawn, handle_height)
        pygame.draw.rect(surface, getattr(ED_CONFIG.C, 'GRAY', (128,128,128)), scrollbar_handle_rect, border_radius=3) # Use getattr
        editor_state.ui_elements_rects['file_dialog_scrollbar_handle'] = scrollbar_handle_rect
        editor_state.ui_elements_rects['file_dialog_scrollbar_area'] = scrollbar_track_rect

    list_item_text_render_width = list_clip_rect.width - (scrollbar_width_drawn + 2 if scrollbar_width_drawn > 0 else 0)
    original_clip_pygame = surface.get_clip()
    surface.set_clip(list_clip_rect)
    current_y_offset_in_clip_rect = 0

    for i, filename in enumerate(editor_state.dialog_file_list):
        item_draw_y_on_surface = list_clip_rect.top + current_y_offset_in_clip_rect - editor_state.dialog_file_scroll_y
        item_full_rect_on_screen = pygame.Rect(list_clip_rect.left, item_draw_y_on_surface,
                                           list_item_text_render_width, item_line_height)
        if list_clip_rect.colliderect(item_full_rect_on_screen):
            editor_state.ui_elements_rects['dialog_file_item_rects'].append(
                {"text": filename, "rect": item_full_rect_on_screen, "index": i}
            )
            if item_font:
                text_color = getattr(ED_CONFIG.C, 'BLACK', (0,0,0)) # Use getattr
                bg_color_item = ED_CONFIG.DIALOG_INPUT_BOX_COLOR
                if editor_state.dialog_selected_file_index == i:
                    bg_color_item = getattr(ED_CONFIG.C, 'BLUE', (0,0,255)) # Use getattr
                    text_color = getattr(ED_CONFIG.C, 'WHITE', (255,255,255)) # Use getattr
                pygame.draw.rect(surface, bg_color_item, item_full_rect_on_screen)
                text_surf = item_font.render(filename, True, text_color)
                text_draw_pos = (item_full_rect_on_screen.left + 5,
                                 item_full_rect_on_screen.centery - text_surf.get_height() // 2)
                surface.blit(text_surf, text_draw_pos)
        current_y_offset_in_clip_rect += item_line_height
    surface.set_clip(original_clip_pygame)

    button_font = fonts.get("small") or ED_CONFIG.FONT_CONFIG.get("small")
    if button_font:
        btn_width = ED_CONFIG.BUTTON_WIDTH_STANDARD // 2 - 15
        btn_height = ED_CONFIG.BUTTON_HEIGHT_STANDARD // 2 + 5
        buttons_y_pos = list_area_rect.bottom + 10
        ok_button_rect = pygame.Rect(dialog_rect.centerx - btn_width - 5, buttons_y_pos, btn_width, btn_height)
        cancel_button_rect = pygame.Rect(dialog_rect.centerx + 5, buttons_y_pos, btn_width, btn_height)
        mouse_pos = pygame.mouse.get_pos()
        ok_is_active = (editor_state.dialog_selected_file_index != -1 and
                        0 <= editor_state.dialog_selected_file_index < len(editor_state.dialog_file_list))
        draw_button(surface, ok_button_rect, "Load", button_font, mouse_pos, is_active=ok_is_active)
        draw_button(surface, cancel_button_rect, "Cancel", button_font, mouse_pos)
        editor_state.ui_elements_rects["dialog_file_load_ok"] = ok_button_rect
        editor_state.ui_elements_rects["dialog_file_load_cancel"] = cancel_button_rect