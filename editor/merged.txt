

########## START OF FILE: __init__.py ##########



########## START OF FILE: editor.py ##########

# editor/editor.py
# -*- coding: utf-8 -*-
"""
## version 1.0.0.10 (Refined debug logs, ensure C is from constants)
Level Editor for the Platformer Game (Pygame Only).
Allows creating, loading, and saving game levels visually.
"""
import pygame
import sys
import os
from typing import Tuple, Dict, Optional, Any, List, Callable
import traceback

# --- VERY EARLY DEBUGGING FOR IMPORTS ---
print("--- EDITOR.PY START ---")
print(f"Initial sys.path: {sys.path}")
print(f"Initial current working directory (CWD): {os.getcwd()}")

# --- Add parent directory to sys.path ---
current_script_path = os.path.dirname(os.path.abspath(__file__))
print(f"Current script path (__file__): {current_script_path}")
parent_directory = os.path.dirname(current_script_path) # This should be the project root
print(f"Calculated parent directory (project root attempt): {parent_directory}")

if parent_directory not in sys.path:
    sys.path.insert(0, parent_directory)
    print(f"Parent directory '{parent_directory}' was ADDED to sys.path.")
else:
    print(f"Parent directory '{parent_directory}' was ALREADY in sys.path.")

print(f"Modified sys.path (should contain project root at index 0 or 1): {sys.path}")
print(f"CWD after potential sys.path modification: {os.getcwd()}")

# Now try to import constants
try:
    import constants as C_imported # Use a different alias to avoid potential clashes
    print(f"Successfully imported 'constants as C_imported'. TILE_SIZE: {C_imported.TILE_SIZE}")
except ImportError as e:
    print(f"ERROR: Failed to import 'constants as C_imported'. ImportError: {e}")
    print("Please check:")
    print(f"1. Is '{parent_directory}' the correct project root where 'constants.py' is located?")
    print(f"2. Does '{os.path.join(parent_directory, 'constants.py')}' actually exist?")
    print(f"3. Is 'constants.py' a valid Python module (no syntax errors)?")
    sys.exit("ImportError for constants.py - exiting.")
except Exception as e_gen:
    print(f"ERROR: An unexpected error occurred during 'constants' import: {e_gen}")
    traceback.print_exc()
    sys.exit("Generic error importing constants.py - exiting.")
# --- END OF EARLY DEBUGGING FOR IMPORTS ---


import editor_config as ED_CONFIG # ED_CONFIG itself imports constants as C
from editor_state import EditorState
import editor_ui
import editor_assets
import editor_map_utils
import editor_drawing
import editor_event_handlers
# constants as C is imported by editor_config and other modules, ensure it's the correct one.
# We can use ED_CONFIG.C to be explicit that we're using the one constants resolved by editor_config.


def editor_main():
    print("DEBUG MAIN: editor_main() started.")
    try:
        pygame.init()
        print("DEBUG MAIN: pygame.init() called.")
        if not pygame.font.get_init(): # Check if font module is initialized
            print("DEBUG MAIN: pygame.font not initialized, calling pygame.font.init()")
            pygame.font.init()
        if not pygame.font.get_init():
             print("CRITICAL MAIN: pygame.font.init() failed after explicit call! Fonts will not work.")
        else:
            print("DEBUG MAIN: pygame.font.init() confirmed or already initialized.")


        if not editor_map_utils.ensure_maps_directory_exists():
            print("CRITICAL MAIN: Maps directory issue. Exiting.")
            pygame.quit(); sys.exit(1)
        print("DEBUG MAIN: Maps directory ensured.")

        editor_screen = pygame.display.set_mode(
            (ED_CONFIG.EDITOR_SCREEN_INITIAL_WIDTH, ED_CONFIG.EDITOR_SCREEN_INITIAL_HEIGHT),
            pygame.RESIZABLE
        )
        print(f"DEBUG MAIN: Editor screen created: {editor_screen.get_size()}")
        pygame.display.set_caption("Platformer Level Editor - Menu")
        editor_clock = pygame.time.Clock()
        editor_state = EditorState() # This initializes and prints its own debugs
        print("DEBUG MAIN: EditorState instance created.")
        editor_assets.load_editor_palette_assets(editor_state) # This also prints debugs
        print("DEBUG MAIN: load_editor_palette_assets called successfully.")

        fonts: Dict[str, Optional[pygame.font.Font]] = ED_CONFIG.FONT_CONFIG
        if not fonts.get("small") or not fonts.get("medium") or not fonts.get("large"):
            print("CRITICAL MAIN: Essential editor fonts (small, medium, or large) are None after ED_CONFIG load. Exiting.")
            pygame.quit(); sys.exit(1)
        print(f"DEBUG MAIN: Fonts from ED_CONFIG.FONT_CONFIG loaded: small={fonts['small'] is not None}, medium={fonts['medium'] is not None}, large={fonts['large'] is not None}, tooltip={fonts['tooltip'] is not None}")

        def calculate_layout_rects(screen_width: int, screen_height: int, current_mode: str) -> Tuple[pygame.Rect, pygame.Rect, pygame.Rect]:
            # print(f"DEBUG LAYOUT: calculate_layout_rects called. Screen: {screen_width}x{screen_height}, Mode: '{current_mode}'") # Verbose
            menu_rect = pygame.Rect(ED_CONFIG.SECTION_PADDING, ED_CONFIG.SECTION_PADDING,
                                     ED_CONFIG.MENU_SECTION_WIDTH, screen_height - (ED_CONFIG.SECTION_PADDING * 2))
            menu_rect.width = max(ED_CONFIG.BUTTON_WIDTH_STANDARD + ED_CONFIG.SECTION_PADDING * 2, menu_rect.width)
            menu_rect.height = max(menu_rect.height, ED_CONFIG.MENU_SECTION_HEIGHT) # Ensure min height

            asset_palette_rect = pygame.Rect(ED_CONFIG.SECTION_PADDING, ED_CONFIG.SECTION_PADDING,
                                            ED_CONFIG.ASSET_PALETTE_SECTION_WIDTH, screen_height - (ED_CONFIG.SECTION_PADDING * 2))
            
            map_view_x_start = ED_CONFIG.SECTION_PADDING 
            map_view_width_available = screen_width - (ED_CONFIG.SECTION_PADDING * 2)

            if current_mode == "menu":
                map_view_x_start = menu_rect.right + ED_CONFIG.SECTION_PADDING
                map_view_width_available = screen_width - map_view_x_start - ED_CONFIG.SECTION_PADDING
            elif current_mode == "editing_map":
                asset_palette_rect.left = ED_CONFIG.SECTION_PADDING
                map_view_x_start = asset_palette_rect.right + ED_CONFIG.SECTION_PADDING
                map_view_width_available = screen_width - map_view_x_start - ED_CONFIG.SECTION_PADDING
            
            map_view_rect = pygame.Rect(map_view_x_start, ED_CONFIG.SECTION_PADDING,
                                        map_view_width_available, screen_height - (ED_CONFIG.SECTION_PADDING * 2))
            map_view_rect.width = max(map_view_rect.width, ED_CONFIG.DEFAULT_GRID_SIZE * 10) # Min sensible width
            map_view_rect.height = max(map_view_rect.height, ED_CONFIG.DEFAULT_GRID_SIZE * 10) # Min sensible height
            
            # print(f"DEBUG LAYOUT: Calculated rects - Menu={menu_rect}, Assets={asset_palette_rect}, Map={map_view_rect}") # Verbose
            return menu_rect, asset_palette_rect, map_view_rect

        current_screen_width, current_screen_height = editor_screen.get_size()
        menu_section_rect, asset_palette_section_rect, map_view_section_rect = calculate_layout_rects(
            current_screen_width, current_screen_height, editor_state.current_editor_mode
        )
        print(f"DEBUG MAIN: Initial Layout - Menu={menu_section_rect}, Assets={asset_palette_section_rect}, Map={map_view_section_rect}")


        running = True
        print("DEBUG MAIN: Entering main loop.")
        loop_count = 0 
        while running:
            loop_count += 1
            dt = editor_clock.tick(ED_CONFIG.C.FPS if hasattr(ED_CONFIG.C, 'FPS') else 60) / 1000.0
            mouse_pos = pygame.mouse.get_pos()
            events = pygame.event.get()
            
            if loop_count % ( (ED_CONFIG.C.FPS if hasattr(ED_CONFIG.C, 'FPS') else 60) * 5) == 0: # Approx every 5 seconds
                print(f"\nDEBUG MAIN LOOP (Periodic Log @ frame {loop_count}, time ~{pygame.time.get_ticks()/1000:.1f}s): ----")
                print(f"  Mode: {editor_state.current_editor_mode}, Active Dialog: {editor_state.active_dialog_type}")
                print(f"  Unsaved Changes: {editor_state.unsaved_changes}, Map Name Func: '{editor_state.map_name_for_function}'")
                print(f"  Current Map File: '{editor_state.current_map_filename}'")
                print(f"  Selected Asset: '{editor_state.selected_asset_editor_key}'")
                print(f"  Num Placed Objects: {len(editor_state.placed_objects)}")
                print(f"  Camera: ({editor_state.camera_offset_x}, {editor_state.camera_offset_y})")
                print(f"  Screen: {current_screen_width}x{current_screen_height}")
                print(f"  Layout Rects: Menu={menu_section_rect}, Assets={asset_palette_section_rect}, Map={map_view_section_rect}")
                print(f"DEBUG MAIN LOOP ---- END ----\n")

            editor_state.update_status_message(dt)

            previous_mode = editor_state.current_editor_mode
            previous_dialog_type = editor_state.active_dialog_type # For detecting dialog closure
            layout_needs_recalc = False

            for event_idx, event in enumerate(events):
                if event.type == pygame.VIDEORESIZE:
                    print(f"DEBUG MAIN: VIDEORESIZE event to {event.w}x{event.h}")
                    current_screen_width, current_screen_height = event.w, event.h
                    try:
                        editor_screen = pygame.display.set_mode((current_screen_width, current_screen_height), pygame.RESIZABLE)
                        print(f"DEBUG MAIN: Screen resized to {editor_screen.get_size()}")
                    except pygame.error as e_resize:
                        print(f"ERROR MAIN: Pygame error on resize to {current_screen_width}x{current_screen_height}: {e_resize}")
                        # Potentially try to fall back to a default size or handle gracefully
                    layout_needs_recalc = True
                    editor_state.set_status_message(f"Resized to {event.w}x{event.h}", 2.0)
                
                if not editor_event_handlers.handle_global_events(event, editor_state, editor_screen):
                    print("DEBUG MAIN: handle_global_events returned False. Setting running=False.")
                    running = False; break
                if not running: break 

                # --- MODAL DIALOG EVENT PROCESSING ---
                if editor_state.active_dialog_type:
                    editor_event_handlers.handle_dialog_events(event, editor_state)
                    # If dialog was closed (active_dialog_type became None or changed)
                    if editor_state.active_dialog_type != previous_dialog_type:
                        print(f"DEBUG MAIN: Dialog type changed from '{previous_dialog_type}' to '{editor_state.active_dialog_type}' after handle_dialog_events.")
                        # If mode also changed, it was likely due to a dialog callback
                        if editor_state.current_editor_mode != previous_mode:
                            print(f"DEBUG MAIN: Mode changed (likely via dialog callback) from '{previous_mode}' to '{editor_state.current_editor_mode}'. Triggering layout recalc.")
                            layout_needs_recalc = True
                else: # No active dialog, process mode-specific events
                    if editor_state.current_editor_mode == "menu":
                        editor_event_handlers.handle_menu_events(event, editor_state, editor_screen)
                    elif editor_state.current_editor_mode == "editing_map":
                        editor_event_handlers.handle_editing_map_events(
                            event, editor_state,
                            asset_palette_section_rect, map_view_section_rect,
                            editor_screen
                        )
                
                # Check if mode changed from any event handler (dialog or mode-specific)
                if editor_state.current_editor_mode != previous_mode:
                    print(f"DEBUG MAIN: Mode changed from '{previous_mode}' to '{editor_state.current_editor_mode}' after specific event handlers. Triggering layout recalc.")
                    layout_needs_recalc = True
            if not running: break 
            
            if layout_needs_recalc:
                print(f"DEBUG MAIN: Recalculating layout. Current Mode: '{editor_state.current_editor_mode}', Screen: {current_screen_width}x{current_screen_height}")
                menu_section_rect, asset_palette_section_rect, map_view_section_rect = calculate_layout_rects(
                    current_screen_width, current_screen_height, editor_state.current_editor_mode
                )
                print(f"DEBUG MAIN: New Layout after recalc - Menu={menu_section_rect}, Assets={asset_palette_section_rect}, Map={map_view_section_rect}")
                
                # If in editing mode and map surface exists, adjust camera to new view bounds
                if editor_state.current_editor_mode == "editing_map" and editor_state.map_content_surface:
                    map_px_w = editor_state.get_map_pixel_width()
                    map_px_h = editor_state.get_map_pixel_height()
                    view_w = map_view_section_rect.width
                    view_h = map_view_section_rect.height
                    
                    if view_w > 0 and view_h > 0 : # Ensure view rect has positive dimensions
                        max_cam_x = max(0, map_px_w - view_w)
                        max_cam_y = max(0, map_px_h - view_h)
                        
                        prev_cam_x, prev_cam_y = editor_state.camera_offset_x, editor_state.camera_offset_y
                        editor_state.camera_offset_x = max(0, min(editor_state.camera_offset_x, max_cam_x))
                        editor_state.camera_offset_y = max(0, min(editor_state.camera_offset_y, max_cam_y))
                        if prev_cam_x != editor_state.camera_offset_x or prev_cam_y != editor_state.camera_offset_y:
                            print(f"DEBUG MAIN: Camera clamped after resize/layout change from ({prev_cam_x},{prev_cam_y}) to ({editor_state.camera_offset_x},{editor_state.camera_offset_y}). Max cam: ({max_cam_x},{max_cam_y})")
                    else:
                        print(f"Warning MAIN: Map view rect has zero or negative W/H ({view_w}x{view_h}) after layout recalc. Camera not adjusted.")


            # --- Drawing ---
            editor_screen.fill(ED_CONFIG.C.DARK_GRAY) # Use ED_CONFIG.C for constants

            if editor_state.current_editor_mode == "menu":
                editor_drawing.draw_menu_ui(editor_screen, editor_state, menu_section_rect, fonts, mouse_pos)
                # Draw placeholder for map area in menu mode
                placeholder_rect = pygame.Rect(
                    menu_section_rect.right + ED_CONFIG.SECTION_PADDING, 
                    ED_CONFIG.SECTION_PADDING,
                    current_screen_width - menu_section_rect.right - ED_CONFIG.SECTION_PADDING * 2,
                    current_screen_height - ED_CONFIG.SECTION_PADDING * 2
                )
                if placeholder_rect.width > 10 and placeholder_rect.height > 10: # Only draw if reasonably sized
                    pygame.draw.rect(editor_screen, (20,20,20), placeholder_rect) # Darker placeholder bg
                    font_large = fonts.get("large")
                    if font_large:
                        ph_text = font_large.render("Map Editor Area", True, (60,60,60)) # Dim text
                        editor_screen.blit(ph_text, ph_text.get_rect(center=placeholder_rect.center))

            elif editor_state.current_editor_mode == "editing_map":
                editor_drawing.draw_asset_palette_ui(editor_screen, editor_state, asset_palette_section_rect, fonts, mouse_pos)
                editor_drawing.draw_map_view_ui(editor_screen, editor_state, map_view_section_rect, fonts, mouse_pos)
            
            if editor_state.active_dialog_type: # Draw dialogs on top of everything else
                editor_ui.draw_active_dialog(editor_screen, editor_state, fonts)

            font_tooltip = fonts.get("tooltip") # Use specific tooltip font from ED_CONFIG
            if font_tooltip: editor_ui.draw_tooltip(editor_screen, editor_state, font_tooltip)
            
            font_small = fonts.get("small") # Use specific small font
            if font_small: editor_ui.draw_status_message(editor_screen, editor_state, font_small)

            pygame.display.flip()

    except Exception as e:
        print(f"CRITICAL ERROR in editor_main: {e}")
        traceback.print_exc()
    finally:
        print("DEBUG MAIN: Exiting editor_main. Calling pygame.quit() and sys.exit().")
        pygame.quit()
        sys.exit()

if __name__ == "__main__":
    print("DEBUG MAIN: Script execution started (__name__ == '__main__').")
    editor_main()

########## START OF FILE: editor_assets.py ##########

# editor_assets.py
# -*- coding: utf-8 -*-
"""
## version 1.0.0.2 (Added extensive debug prints and error handling for asset loading)
Handles loading and managing assets for the editor's palette.
"""
import pygame
import os
import sys
import traceback # ADDED for detailed error reporting
from typing import Optional # ADDED for type hinting

# --- Add parent directory to sys.path for assets module ---
# This assumes 'editor' is a subfolder of the project root where 'assets.py' resides.
current_dir = os.path.dirname(os.path.abspath(__file__)) # Should be /path/to/project/editor
parent_dir = os.path.dirname(current_dir)                 # Should be /path/to/project
print(f"DEBUG ASSETS: current_dir (editor_assets.py location): {current_dir}")
print(f"DEBUG ASSETS: parent_dir (project root attempt): {parent_dir}")

if parent_dir not in sys.path:
    sys.path.insert(0, parent_dir)
    print(f"DEBUG ASSETS: Added '{parent_dir}' to sys.path for 'assets' module import.")
else:
    print(f"DEBUG ASSETS: '{parent_dir}' already in sys.path for 'assets' module.")

try:
    from assets import load_gif_frames, resource_path
    print("DEBUG ASSETS: Successfully imported 'load_gif_frames' and 'resource_path' from assets.py")
except ImportError as e:
    print(f"CRITICAL ASSETS ERROR: Failed to import from 'assets.py' (expected in '{parent_dir}'). Error: {e}")
    # Define dummy functions if import fails, so editor can limp along with errors.
    def load_gif_frames(path: str) -> list:
        print(f"DUMMY load_gif_frames called for {path} due to import error.")
        return []
    def resource_path(relative_path: str) -> str:
        print(f"DUMMY resource_path called for {relative_path} due to import error.")
        # Attempt a basic join from current parent, might not be correct but better than nothing.
        return os.path.join(parent_dir, relative_path)
    print("CRITICAL ASSETS ERROR: Using dummy asset loading functions. Asset loading will likely fail.")
except Exception as e_gen:
    print(f"CRITICAL ASSETS ERROR: Unexpected error importing from 'assets.py': {e_gen}")
    traceback.print_exc()
    sys.exit("Failed to initialize assets module in editor_assets.py")

import editor_config as ED_CONFIG # Direct import, should work if editor_config.py is in the same 'editor' dir
from editor_state import EditorState


def load_editor_palette_assets(editor_state: EditorState):
    """
    Loads images for the asset palette based on EDITOR_PALETTE_ASSETS in config.
    Populates editor_state.assets_palette.
    Calculates editor_state.total_asset_palette_content_height.
    """
    editor_state.assets_palette.clear()
    print("DEBUG ASSETS: Starting load_editor_palette_assets...")
    successful_loads = 0
    failed_loads = 0

    for asset_key, asset_info in ED_CONFIG.EDITOR_PALETTE_ASSETS.items():
        print(f"\nDEBUG ASSETS: Processing asset_key: '{asset_key}', Info: {asset_info}")
        surf: Optional[pygame.Surface] = None # Changed to Optional[pygame.Surface]
        tooltip = asset_info.get("tooltip", asset_key)
        game_type_id = asset_info.get("game_type_id", asset_key)
        category = asset_info.get("category", "unknown")

        if "source_file" in asset_info:
            source_file_path = asset_info["source_file"]
            print(f"DEBUG ASSETS: Asset '{asset_key}' uses source_file: '{source_file_path}'")
            try:
                # resource_path should convert the relative path from project root
                # e.g., "characters/player1/__Idle.gif" to "C:/.../Project/characters/player1/__Idle.gif"
                full_path = resource_path(source_file_path)
                print(f"DEBUG ASSETS: Resolved path by resource_path for '{source_file_path}': '{full_path}'")
                
                if not os.path.exists(full_path):
                    print(f"Assets Error: File NOT FOUND at resolved path: '{full_path}' for asset '{asset_key}' (source: '{source_file_path}')")
                    # This is the error you were seeing, indicating `resource_path` or the base path for it is incorrect.
                    # `resource_path` in your game's assets.py might be using `os.path.join(os.path.dirname(__file__), relative_path)`
                    # which, if `assets.py` is in the project root, would correctly resolve `characters/...`
                    # However, if `resource_path` is called from `editor_assets.py` and uses `__file__` from `editor_assets.py`,
                    # it would look inside the `editor` folder.
                    # The current fix of adding parent_dir to sys.path and importing `resource_path` from the root `assets.py`
                    # should ensure `resource_path` uses its *own* `__file__` (from root `assets.py`) as its base if it's designed that way.
                
                frames = load_gif_frames(full_path)
                if frames:
                    surf = frames[0]
                    print(f"DEBUG ASSETS: Successfully loaded {len(frames)} frames for '{asset_key}' from '{full_path}'. Using first frame.")
                else:
                    print(f"Warning ASSETS: load_gif_frames returned empty list for '{asset_key}' from '{full_path}'.")
            except Exception as e:
                print(f"Error ASSETS: Exception loading palette asset '{asset_key}' (source: '{source_file_path}'): {e}")
                traceback.print_exc()

        elif "surface_params" in asset_info:
            print(f"DEBUG ASSETS: Asset '{asset_key}' uses surface_params: {asset_info['surface_params']}")
            try:
                w, h, color = asset_info["surface_params"]
                surf = pygame.Surface((max(1, w), max(1, h))) # Ensure min 1x1
                surf.fill(color)
                print(f"DEBUG ASSETS: Created surface for '{asset_key}' with params ({w},{h},{color}).")
            except Exception as e:
                print(f"Error ASSETS: Exception creating surface for palette asset '{asset_key}': {e}")
                traceback.print_exc()
        
        if not surf:
            print(f"Warning ASSETS: Surface for '{asset_key}' is None. Creating fallback placeholder.")
            surf = pygame.Surface((ED_CONFIG.DEFAULT_GRID_SIZE, ED_CONFIG.DEFAULT_GRID_SIZE))
            surf.fill(ED_CONFIG.C.RED)
            pygame.draw.line(surf, ED_CONFIG.C.BLACK, (0,0), surf.get_size(), 1)
            pygame.draw.line(surf, ED_CONFIG.C.BLACK, (0,surf.get_height()-1), (surf.get_width()-1,0), 1) # Adjusted line
            tooltip += " (Load Error)"
            failed_loads += 1
        else:
            successful_loads +=1


        original_w, original_h = surf.get_size()
        scaled_surf = surf
        if original_w > ED_CONFIG.ASSET_THUMBNAIL_MAX_WIDTH or original_h > ED_CONFIG.ASSET_THUMBNAIL_MAX_HEIGHT:
            print(f"DEBUG ASSETS: Asset '{asset_key}' original size ({original_w}x{original_h}) exceeds thumbnail max. Scaling...")
            ratio_w = ED_CONFIG.ASSET_THUMBNAIL_MAX_WIDTH / original_w if original_w > 0 else 1
            ratio_h = ED_CONFIG.ASSET_THUMBNAIL_MAX_HEIGHT / original_h if original_h > 0 else 1
            ratio = min(ratio_w, ratio_h)
            
            new_w = max(1, int(original_w * ratio))
            new_h = max(1, int(original_h * ratio))
            print(f"DEBUG ASSETS: Scaling '{asset_key}' to ({new_w}x{new_h}) with ratio {ratio:.2f}.")
            try:
                scaled_surf = pygame.transform.scale(surf, (new_w, new_h))
            except pygame.error as e:
                print(f"Error ASSETS: Pygame error scaling asset '{asset_key}': {e}. Using original.")
                scaled_surf = surf 
            except Exception as e_scale:
                print(f"Error ASSETS: Generic error scaling asset '{asset_key}': {e_scale}. Using original.")
                traceback.print_exc()
                scaled_surf = surf
        
        # Ensure surface is converted correctly for performance and alpha handling
        try:
            final_surf_to_store = scaled_surf.convert_alpha() if scaled_surf.get_flags() & pygame.SRCALPHA else scaled_surf.convert()
        except pygame.error as e_convert:
            print(f"Error ASSETS: Pygame error converting surface for '{asset_key}': {e_convert}. Storing as is.")
            final_surf_to_store = scaled_surf # Store unconverted if error

        editor_state.assets_palette[asset_key] = {
            "image": final_surf_to_store,
            "game_type_id": game_type_id,
            "tooltip": tooltip,
            "category": category,
            "original_size_pixels": (original_w, original_h)
        }
        print(f"DEBUG ASSETS: Stored asset '{asset_key}' in palette. Tooltip: '{tooltip}', Category: '{category}'.")
    
    print(f"DEBUG ASSETS: Finished loading palette. Successful: {successful_loads}, Failed/Fallback: {failed_loads}. Total in config: {len(ED_CONFIG.EDITOR_PALETTE_ASSETS)}")
    _calculate_asset_palette_total_height(editor_state)


def _calculate_asset_palette_total_height(editor_state: EditorState):
    """
    Calculates the total vertical space needed to display all assets in the palette.
    """
    print("DEBUG ASSETS: Starting _calculate_asset_palette_total_height...")
    total_height = ED_CONFIG.ASSET_PALETTE_ITEM_PADDING 

    font_category = ED_CONFIG.FONT_CONFIG.get("medium")
    font_tooltip = ED_CONFIG.FONT_CONFIG.get("small")

    if not font_category:
        print("Warning ASSETS: Medium font (for category titles) not available for palette height calculation. Using estimate.")
        font_category_height_estimate = 28 # Estimate
    else:
        font_category_height_estimate = font_category.get_height()

    if not font_tooltip:
        print("Warning ASSETS: Small font (for item tooltips) not available for palette height calculation. Using estimate.")
        font_tooltip_height_estimate = 20 # Estimate
    else:
        font_tooltip_height_estimate = font_tooltip.get_height()
    
    # Use the defined order from editor_config if available, otherwise a sensible default
    categories_in_order = getattr(ED_CONFIG, 'EDITOR_PALETTE_ASSETS_CATEGORIES_ORDER', 
                                  ["tile", "hazard", "item", "enemy", "spawn", "unknown"])
    print(f"DEBUG ASSETS: Calculating height using category order: {categories_in_order}")

    # Group assets by their category first
    categorized_assets_view = {}
    for cat_name in categories_in_order:
        categorized_assets_view[cat_name] = []
    
    for asset_key, data in editor_state.assets_palette.items():
        category_name = data.get("category", "unknown")
        if category_name not in categorized_assets_view: # Handle case where an asset has a category not in defined order
            if "unknown" not in categorized_assets_view: # Should be there from init
                 categorized_assets_view["unknown"] = []
            categorized_assets_view["unknown"].append(data)
            print(f"Warning ASSETS: Asset '{asset_key}' has category '{category_name}' not in defined order. Added to 'unknown'.")
        else:
            categorized_assets_view[category_name].append(data)


    for category_name in categories_in_order:
        assets_in_this_category = categorized_assets_view.get(category_name, [])
        if not assets_in_this_category:
            # print(f"DEBUG ASSETS: No assets in category '{category_name}' for height calculation.")
            continue

        print(f"DEBUG ASSETS: Calculating height for category '{category_name}' with {len(assets_in_this_category)} items.")
        total_height += font_category_height_estimate + ED_CONFIG.ASSET_PALETTE_ITEM_PADDING # Space for category title
        
        for asset_data in assets_in_this_category:
            asset_img = asset_data.get("image")
            if not asset_img:
                print(f"Warning ASSETS: Asset data missing 'image' in category '{category_name}' during height calc. Skipping item height.")
                continue
            
            total_height += asset_img.get_height() # Image height
            total_height += font_tooltip_height_estimate # Space for the tooltip text below image
            total_height += ED_CONFIG.ASSET_PALETTE_ITEM_PADDING # Padding below item text
        
        total_height += ED_CONFIG.ASSET_PALETTE_ITEM_PADDING # Extra padding after all items in a category

    editor_state.total_asset_palette_content_height = total_height + ED_CONFIG.ASSET_PALETTE_ITEM_PADDING # Final bottom padding
    print(f"DEBUG ASSETS: Calculated total_asset_palette_content_height: {editor_state.total_asset_palette_content_height}")

########## START OF FILE: editor_config.py ##########

# editor_config.py
# -*- coding: utf-8 -*-
"""
## version 1.0.0.4 (Added typing imports for Optional, Dict)
Configuration constants for the Platformer Level Editor.
"""
import pygame
import sys
import os
import traceback 
from typing import Dict, Optional, Tuple, Any # ADDED Optional, Dict, Tuple, Any for type hints

# --- Add parent directory to sys.path ---
# (sys.path manipulation and constants import remains the same)
current_dir = os.path.dirname(os.path.abspath(__file__)) 
parent_dir = os.path.dirname(current_dir)                 
print(f"DEBUG CONFIG: current_dir (editor_config.py location): {current_dir}")
print(f"DEBUG CONFIG: parent_dir (project root attempt): {parent_dir}")

if parent_dir not in sys.path:
    sys.path.insert(0, parent_dir)
    print(f"DEBUG CONFIG: Added '{parent_dir}' to sys.path for 'constants' import.")
else:
    print(f"DEBUG CONFIG: '{parent_dir}' already in sys.path.")

try:
    import constants as C 
    print(f"DEBUG CONFIG: Successfully imported 'constants as C'. TILE_SIZE: {C.TILE_SIZE if hasattr(C, 'TILE_SIZE') else 'NOT FOUND'}")
except ImportError as e:
    print(f"CRITICAL CONFIG ERROR: Failed to import 'constants as C' from '{parent_dir}'. Error: {e}")
    print(f"DEBUG CONFIG: sys.path was: {sys.path}")
    class FallbackConstants: 
        TILE_SIZE = 32; WHITE = (255,255,255); BLACK = (0,0,0); RED = (255,0,0); GREEN = (0,255,0)
        BLUE = (0,0,255); GRAY = (128,128,128); DARK_GRAY = (50,50,50); YELLOW = (255,255,0)
        LIGHT_BLUE = (173,216,230); DARK_GREEN = (0,100,0); ORANGE_RED = (255,69,0)
        LIGHT_GRAY = (200,200,200); FPS = 60
    C = FallbackConstants()
    print("CRITICAL CONFIG ERROR: Using fallback constants. Editor functionality will be impaired.")
except Exception as e_gen:
    print(f"CRITICAL CONFIG ERROR: Unexpected error importing 'constants': {e_gen}"); traceback.print_exc()
    sys.exit("Failed to initialize constants in editor_config.py")


# --- Editor Window Dimensions ---
EDITOR_SCREEN_INITIAL_WIDTH = 1280
EDITOR_SCREEN_INITIAL_HEIGHT = 720

MENU_SECTION_WIDTH = 280
MENU_SECTION_HEIGHT = 250 

ASSET_PALETTE_SECTION_WIDTH = 220

SECTION_PADDING = 10 

MAP_VIEW_SECTION_DEFAULT_WIDTH = EDITOR_SCREEN_INITIAL_WIDTH - MENU_SECTION_WIDTH - ASSET_PALETTE_SECTION_WIDTH - (SECTION_PADDING * 3) 
MAP_VIEW_SECTION_DEFAULT_HEIGHT = EDITOR_SCREEN_INITIAL_HEIGHT - (SECTION_PADDING * 2)

# --- UI Element Sizes & Colors ---
BUTTON_WIDTH_STANDARD = 200
BUTTON_HEIGHT_STANDARD = 50
BUTTON_TEXT_COLOR: Tuple[int,int,int] = getattr(C, 'WHITE', (255,255,255))
BUTTON_COLOR_NORMAL: Tuple[int,int,int] = getattr(C, 'BLUE', (0,0,255))
BUTTON_COLOR_HOVER: Tuple[int,int,int] = getattr(C, 'GREEN', (0,255,0))
BUTTON_COLOR_BORDER: Tuple[int,int,int] = getattr(C, 'BLACK', (0,0,0))
BUTTON_BORDER_WIDTH = 2

ASSET_THUMBNAIL_MAX_WIDTH = getattr(C, 'TILE_SIZE', 32) * 2
ASSET_THUMBNAIL_MAX_HEIGHT = getattr(C, 'TILE_SIZE', 32) * 2
ASSET_PALETTE_ITEM_PADDING = 5
ASSET_PALETTE_BG_COLOR: Tuple[int,int,int] = (30, 30, 30)
ASSET_PALETTE_CATEGORY_TEXT_COLOR: Tuple[int,int,int] = getattr(C, 'YELLOW', (255,255,0))
ASSET_PALETTE_TOOLTIP_COLOR: Tuple[int,int,int] = getattr(C, 'LIGHT_GRAY', (200,200,200))
ASSET_PALETTE_HOVER_BG_COLOR: Tuple[int,int,int] = (50, 80, 50)

MAP_VIEW_GRID_COLOR: Tuple[int,int,int] = getattr(C, 'GRAY', (128,128,128))
MAP_VIEW_BORDER_COLOR: Tuple[int,int,int] = getattr(C, 'GRAY', (128,128,128))
MAP_VIEW_CAMERA_PAN_SPEED: int = getattr(C, 'TILE_SIZE', 32) // 2

DIALOG_BG_COLOR: Tuple[int,int,int] = (60, 60, 70)
DIALOG_INPUT_BOX_COLOR: Tuple[int,int,int] = getattr(C, 'WHITE', (255,255,255))
DIALOG_INPUT_TEXT_COLOR: Tuple[int,int,int] = getattr(C, 'BLACK', (0,0,0))
DIALOG_PROMPT_COLOR: Tuple[int,int,int] = getattr(C, 'WHITE', (255,255,255))
DIALOG_CURSOR_COLOR: Tuple[int,int,int] = getattr(C, 'BLACK', (0,0,0))

COLOR_PICKER_BUTTON_SIZE = 40
COLOR_PICKER_PADDING = 8
COLOR_PICKER_COLS = 5
COLOR_PICKER_BG_COLOR: Tuple[int,int,int] = (40, 40, 50)
COLOR_PICKER_TITLE_COLOR: Tuple[int,int,int] = getattr(C, 'WHITE', (255,255,255))
COLOR_PICKER_HOVER_BORDER_COLOR: Tuple[int,int,int] = getattr(C, 'YELLOW', (255,255,0))

MAPS_DIRECTORY = "maps" 

# --- Asset Definitions for Editor Palette ---
EDITOR_PALETTE_ASSETS: Dict[str, Dict[str, Any]] = { # Added Any
    "player1_spawn": {
        "source_file": "characters/player1/__Idle.gif", "game_type_id": "player1_spawn",
        "tooltip": "P1 Spawn", "category": "spawn"
    },
    "player2_spawn": { 
        "source_file": "characters/player2/__Idle.gif", "game_type_id": "player2_spawn",
        "tooltip": "P2 Spawn", "category": "spawn"
    },
    "enemy_cyan": {
        "source_file": "characters/cyan/__Idle.gif", "game_type_id": "enemy_cyan",
        "tooltip": "Enemy (Cyan)", "category": "enemy"
    },
    "enemy_green": {
        "source_file": "characters/green/__Idle.gif", "game_type_id": "enemy_green",
        "tooltip": "Enemy (Green)", "category": "enemy"
    },
    "enemy_pink": {
        "source_file": "characters/pink/__Idle.gif", "game_type_id": "enemy_pink",
        "tooltip": "Enemy (Pink)", "category": "enemy"
    },
    "enemy_purple": {
        "source_file": "characters/purple/__Idle.gif", "game_type_id": "enemy_purple",
        "tooltip": "Enemy (Purple)", "category": "enemy"
    },
    "enemy_red": {
        "source_file": "characters/red/__Idle.gif", "game_type_id": "enemy_red",
        "tooltip": "Enemy (Red)", "category": "enemy"
    },
    "enemy_yellow": {
        "source_file": "characters/yellow/__Idle.gif", "game_type_id": "enemy_yellow",
        "tooltip": "Enemy (Yellow)", "category": "enemy"
    },
    "chest": {
        "source_file": "characters/items/chest.gif", "game_type_id": "chest",
        "tooltip": "Chest", "category": "item"
    },
    "platform_wall_gray": {
        "surface_params": (getattr(C, 'TILE_SIZE', 32), getattr(C, 'TILE_SIZE', 32), getattr(C, 'GRAY', (128,128,128))), 
        "game_type_id": "platform_wall_gray", "tooltip": "Wall (Gray)", "category": "tile"
    },
    "platform_ledge_green": {
        "surface_params": (getattr(C, 'TILE_SIZE', 32), getattr(C, 'TILE_SIZE', 32), getattr(C, 'DARK_GREEN', (0,100,0))), 
        "game_type_id": "platform_ledge_green", "tooltip": "Ledge (Green)", "category": "tile"
    },
    "hazard_lava_tile": {
        "surface_params": (getattr(C, 'TILE_SIZE', 32), getattr(C, 'TILE_SIZE', 32), getattr(C, 'ORANGE_RED', (255,69,0))), 
        "game_type_id": "hazard_lava", "tooltip": "Lava Tile", "category": "hazard"
    },
}

EDITOR_PALETTE_ASSETS_CATEGORIES_ORDER = ["tile", "hazard", "item", "enemy", "spawn", "unknown"]

DEFAULT_MAP_WIDTH_TILES = 30
DEFAULT_MAP_HEIGHT_TILES = 20
DEFAULT_GRID_SIZE = getattr(C, 'TILE_SIZE', 32)
DEFAULT_BACKGROUND_COLOR: Tuple[int,int,int] = getattr(C, 'LIGHT_BLUE', (173,216,230))

LEVEL_EDITOR_SAVE_FORMAT_EXTENSION = ".json"
GAME_LEVEL_FILE_EXTENSION = ".py"

TOOLTIP_FONT_SIZE = 18
TOOLTIP_TEXT_COLOR: Tuple[int,int,int] = getattr(C, 'BLACK', (0,0,0))
TOOLTIP_BG_COLOR: Tuple[int,int,int] = (240, 240, 210) 
TOOLTIP_PADDING = 5
TOOLTIP_OFFSET_Y = 25

COLOR_PICKER_PRESETS: Dict[str, Tuple[int,int,int]] = {
    "Light Blue": getattr(C, 'LIGHT_BLUE', (173,216,230)), "White": getattr(C, 'WHITE', (255,255,255)), 
    "Black": getattr(C, 'BLACK', (0,0,0)), "Gray": getattr(C, 'GRAY', (128,128,128)),
    "Dark Gray": getattr(C, 'DARK_GRAY', (50,50,50)), "Red": getattr(C, 'RED', (255,0,0)), 
    "Green": getattr(C, 'GREEN', (0,255,0)), "Blue": getattr(C, 'BLUE', (0,0,255)),
    "Yellow": getattr(C, 'YELLOW', (255,255,0)), "Orange": getattr(C, 'ORANGE_RED', (255,69,0)), 
    "Purple": (128, 0, 128), "Brown": (139, 69, 19), 
    "Dark Green": getattr(C, 'DARK_GREEN', (0,100,0)), "Sky Blue": (100, 150, 255),
    "Dark Purple": (75,0,130), "Sand": (244,164,96)
}

FONT_CONFIG: Dict[str, Optional[pygame.font.Font]] = {
    "small": None, "medium": None, "large": None, "tooltip": None
}
try:
    if not pygame.font.get_init(): 
        print("DEBUG CONFIG: pygame.font not initialized, calling pygame.font.init()")
        pygame.font.init()
    
    if pygame.font.get_init(): 
        FONT_CONFIG["small"] = pygame.font.Font(None, 22)
        FONT_CONFIG["medium"] = pygame.font.Font(None, 28)
        FONT_CONFIG["large"] = pygame.font.Font(None, 36)
        FONT_CONFIG["tooltip"] = pygame.font.Font(None, TOOLTIP_FONT_SIZE)
        print("DEBUG CONFIG: Successfully initialized fonts in FONT_CONFIG.")
    else:
        print("CRITICAL CONFIG ERROR: pygame.font.init() failed. Fonts will be None.")
except pygame.error as e:
    print(f"CRITICAL CONFIG ERROR: Pygame error initializing fonts in editor_config: {e}"); traceback.print_exc()
except Exception as e_font:
    print(f"CRITICAL CONFIG ERROR: Generic error initializing fonts in editor_config: {e_font}"); traceback.print_exc()

for font_name, font_obj in FONT_CONFIG.items():
    if font_obj is None:
        print(f"WARNING CONFIG: Font '{font_name}' is None. UI elements using it might not render text correctly.")

print("DEBUG CONFIG: editor_config.py loaded.")

########## START OF FILE: editor_drawing.py ##########

# editor_drawing.py
# -*- coding: utf-8 -*-
"""
## version 1.0.0.4 (Updated map view info text for WASD controls)
Contains functions for drawing the different sections and elements
of the Platformer Level Editor UI using Pygame.
"""
import pygame
from typing import Dict, Tuple, Any, Optional 
import traceback 

import editor_config as ED_CONFIG
from editor_state import EditorState
from editor_ui import draw_button


def draw_menu_ui(surface: pygame.Surface,
                 editor_state: EditorState,
                 menu_section_rect: pygame.Rect,
                 fonts: Dict[str, Optional[pygame.font.Font]], 
                 mouse_pos: Tuple[int, int]):
    try:
        pygame.draw.rect(surface, ED_CONFIG.C.BLACK, menu_section_rect) 

        title_font = fonts.get("large") or ED_CONFIG.FONT_CONFIG.get("large")
        button_font = fonts.get("medium") or ED_CONFIG.FONT_CONFIG.get("medium")

        if title_font:
            title_surf = title_font.render("Level Editor", True, ED_CONFIG.C.WHITE)
            title_rect = title_surf.get_rect(centerx=menu_section_rect.centerx, top=menu_section_rect.top + 20)
            surface.blit(title_surf, title_rect)
        else:
            print("Warning DRAW: Menu title font not available.")

        button_w, button_h, spacing = ED_CONFIG.BUTTON_WIDTH_STANDARD, ED_CONFIG.BUTTON_HEIGHT_STANDARD, 20
        num_buttons = 3 
        total_button_h = (num_buttons * button_h) + ((num_buttons - 1) * spacing)
        title_h_approx = title_font.get_height() if title_font else 40
        content_start_y = menu_section_rect.top + title_h_approx + 30
        remaining_h = menu_section_rect.height - (content_start_y - menu_section_rect.top)
        start_y = max(content_start_y + (remaining_h - total_button_h) // 2, content_start_y)

        if not hasattr(editor_state, 'ui_elements_rects') or editor_state.ui_elements_rects is None:
            editor_state.ui_elements_rects = {}
        
        for k in [k for k in editor_state.ui_elements_rects if k.startswith("menu_")]: del editor_state.ui_elements_rects[k]

        if button_font:
            rect_params = [(start_y, "menu_new_map", "New Map"),
                           (start_y + button_h + spacing, "menu_load_map", "Load Map (.json)"),
                           (start_y + 2 * (button_h + spacing), "menu_quit", "Quit Editor")]
            for top_y, key, text in rect_params:
                btn_rect = pygame.Rect(0, 0, button_w, button_h)
                btn_rect.centerx, btn_rect.top = menu_section_rect.centerx, top_y
                editor_state.ui_elements_rects[key] = btn_rect
                draw_button(surface, btn_rect, text, button_font, mouse_pos)
        else:
            print("Warning DRAW: Menu button font not available.")
    except Exception as e:
        print(f"ERROR DRAW: Exception in draw_menu_ui: {e}"); traceback.print_exc()


def draw_asset_palette_ui(surface: pygame.Surface,
                          editor_state: EditorState,
                          palette_section_rect: pygame.Rect,
                          fonts: Dict[str, Optional[pygame.font.Font]],
                          mouse_pos: Tuple[int, int]):
    try:
        pygame.draw.rect(surface, ED_CONFIG.ASSET_PALETTE_BG_COLOR, palette_section_rect)
        
        if editor_state.total_asset_palette_content_height <= 0:
            font_small = fonts.get("small") or ED_CONFIG.FONT_CONFIG.get("small")
            if font_small:
                surface.blit(font_small.render("Assets Loading/Error...", True, ED_CONFIG.C.WHITE),
                             font_small.render("Assets Loading/Error...", True, ED_CONFIG.C.WHITE).get_rect(center=palette_section_rect.center))
            return

        scroll_surf_w = palette_section_rect.width
        scroll_surf = pygame.Surface((scroll_surf_w, editor_state.total_asset_palette_content_height), pygame.SRCALPHA)
        scroll_surf.fill((0,0,0,0))

        current_y = ED_CONFIG.ASSET_PALETTE_ITEM_PADDING
        cat_font, tip_font = fonts.get("medium") or ED_CONFIG.FONT_CONFIG.get("medium"), fonts.get("small") or ED_CONFIG.FONT_CONFIG.get("small")
        editor_state.hovered_tooltip_text = None
        if not hasattr(editor_state, 'ui_elements_rects') or editor_state.ui_elements_rects is None: editor_state.ui_elements_rects = {}
        editor_state.ui_elements_rects['asset_palette_items'] = {}

        defined_categories_order = getattr(ED_CONFIG, 'EDITOR_PALETTE_ASSETS_CATEGORIES_ORDER', ["tile", "hazard", "item", "enemy", "spawn", "unknown"])

        for cat_name in defined_categories_order:
            assets_in_cat = [(k, d) for k, d in editor_state.assets_palette.items() if d.get("category", "unknown") == cat_name]
            if not assets_in_cat: continue

            if cat_font:
                cat_s = cat_font.render(cat_name.title(), True, ED_CONFIG.ASSET_PALETTE_CATEGORY_TEXT_COLOR)
                scroll_surf.blit(cat_s, (ED_CONFIG.ASSET_PALETTE_ITEM_PADDING, current_y))
                current_y += cat_s.get_height() + ED_CONFIG.ASSET_PALETTE_ITEM_PADDING

            for asset_key, asset_data in assets_in_cat:
                img = asset_data.get("image")
                if not img: continue
                item_x = ED_CONFIG.ASSET_PALETTE_ITEM_PADDING
                item_y_on_scroll = current_y
                
                item_rect_screen = pygame.Rect(palette_section_rect.left + item_x,
                                              palette_section_rect.top + item_y_on_scroll - editor_state.asset_palette_scroll_y,
                                              img.get_width(), img.get_height())
                editor_state.ui_elements_rects['asset_palette_items'][asset_key] = item_rect_screen

                hovered = item_rect_screen.collidepoint(mouse_pos) and palette_section_rect.collidepoint(mouse_pos)
                selected = editor_state.selected_asset_editor_key == asset_key

                if hovered:
                    editor_state.hovered_tooltip_text, editor_state.hovered_tooltip_pos = asset_data.get("tooltip", asset_key), mouse_pos
                    pygame.draw.rect(scroll_surf, ED_CONFIG.ASSET_PALETTE_HOVER_BG_COLOR, 
                                     pygame.Rect(item_x - 2, item_y_on_scroll - 2, img.get_width() + 4, img.get_height() + 4), border_radius=2)
                if selected:
                    pygame.draw.rect(scroll_surf, ED_CONFIG.C.YELLOW, 
                                     pygame.Rect(item_x - 3, item_y_on_scroll - 3, img.get_width() + 6, img.get_height() + 6), 2, border_radius=3)
                
                scroll_surf.blit(img, (item_x, item_y_on_scroll))
                current_y += img.get_height()
                
                if tip_font:
                    name_s = tip_font.render(asset_data.get("tooltip", asset_key), True, ED_CONFIG.ASSET_PALETTE_TOOLTIP_COLOR)
                    name_x = max(item_x, item_x + (img.get_width() - name_s.get_width()) // 2)
                    scroll_surf.blit(name_s, (name_x, current_y + 2))
                    current_y += name_s.get_height() + 2
                current_y += ED_CONFIG.ASSET_PALETTE_ITEM_PADDING
            current_y += ED_CONFIG.ASSET_PALETTE_ITEM_PADDING

        surface.blit(scroll_surf, palette_section_rect.topleft, (0, editor_state.asset_palette_scroll_y, palette_section_rect.width, palette_section_rect.height))
        pygame.draw.rect(surface, ED_CONFIG.C.GRAY, palette_section_rect, 2)

        btn_font = fonts.get("small") or ED_CONFIG.FONT_CONFIG.get("small")
        if btn_font:
            btn_h = ED_CONFIG.BUTTON_HEIGHT_STANDARD * 0.8
            cp_btn_rect = pygame.Rect(palette_section_rect.left + ED_CONFIG.ASSET_PALETTE_ITEM_PADDING,
                                      palette_section_rect.bottom - btn_h - ED_CONFIG.ASSET_PALETTE_ITEM_PADDING,
                                      palette_section_rect.width - ED_CONFIG.ASSET_PALETTE_ITEM_PADDING * 2, btn_h)
            editor_state.ui_elements_rects["palette_bg_color_button"] = cp_btn_rect
            bg_lum = sum(editor_state.background_color) / 3
            txt_col = ED_CONFIG.C.BLACK if bg_lum > 128 else ED_CONFIG.C.WHITE
            draw_button(surface, cp_btn_rect, "BG Color", btn_font, mouse_pos, text_color=txt_col,
                        button_color_normal=editor_state.background_color,
                        button_color_hover=pygame.Color(editor_state.background_color).lerp(ED_CONFIG.C.WHITE, 0.3), # type: ignore
                        border_color=ED_CONFIG.C.BLACK)
    except Exception as e:
        print(f"ERROR DRAW: Exception in draw_asset_palette_ui: {e}"); traceback.print_exc()


def draw_map_view_ui(surface: pygame.Surface,
                     editor_state: EditorState,
                     map_view_rect: pygame.Rect,
                     fonts: Dict[str, Optional[pygame.font.Font]],
                     mouse_pos: Tuple[int, int]):
    try:
        if not editor_state.map_content_surface:
            pygame.draw.rect(surface, getattr(ED_CONFIG.C, 'DARK_SLATE_GRAY', ED_CONFIG.C.DARK_GRAY), map_view_rect)
            ph_font = fonts.get("medium") or ED_CONFIG.FONT_CONFIG.get("medium")
            if ph_font:
                txt = ph_font.render("No Map/Surface Error", True, ED_CONFIG.C.WHITE)
                surface.blit(txt, txt.get_rect(center=map_view_rect.center))
            pygame.draw.rect(surface, ED_CONFIG.MAP_VIEW_BORDER_COLOR, map_view_rect, 2)
            return

        editor_state.map_content_surface.fill(editor_state.background_color)

        for i, obj_data in enumerate(editor_state.placed_objects):
            asset_key, world_x, world_y = obj_data.get("asset_editor_key"), obj_data.get("world_x"), obj_data.get("world_y")
            if world_x is None or world_y is None: continue
            asset_info = editor_state.assets_palette.get(asset_key) if asset_key else None
            if asset_info and asset_info.get("image"):
                editor_state.map_content_surface.blit(asset_info["image"], (world_x, world_y))
            else:
                pygame.draw.rect(editor_state.map_content_surface, ED_CONFIG.C.RED, (world_x, world_y, editor_state.grid_size, editor_state.grid_size), 1)

        if editor_state.show_grid:
            draw_grid_on_map_surface(editor_state.map_content_surface, editor_state)

        surface.blit(editor_state.map_content_surface, map_view_rect.topleft,
                     (editor_state.camera_offset_x, editor_state.camera_offset_y, map_view_rect.width, map_view_rect.height))
        pygame.draw.rect(surface, ED_CONFIG.MAP_VIEW_BORDER_COLOR, map_view_rect, 2)

        if editor_state.selected_asset_image_for_cursor:
            cursor_img = editor_state.selected_asset_image_for_cursor
            final_cursor_pos = cursor_img.get_rect(center=mouse_pos).topleft
            if map_view_rect.collidepoint(mouse_pos):
                map_world_mx = mouse_pos[0] - map_view_rect.left + editor_state.camera_offset_x
                map_world_my = mouse_pos[1] - map_view_rect.top + editor_state.camera_offset_y
                grid_wx = (map_world_mx // editor_state.grid_size) * editor_state.grid_size
                grid_wy = (map_world_my // editor_state.grid_size) * editor_state.grid_size
                screen_snap_x = grid_wx - editor_state.camera_offset_x + map_view_rect.left
                screen_snap_y = grid_wy - editor_state.camera_offset_y + map_view_rect.top
                final_cursor_pos = (screen_snap_x, screen_snap_y)
            
            original_clip = surface.get_clip()
            surface.set_clip(map_view_rect)
            surface.blit(cursor_img, final_cursor_pos)
            surface.set_clip(original_clip)

        _draw_map_view_info_text(surface, editor_state, map_view_rect, fonts, mouse_pos)
    except Exception as e:
        print(f"ERROR DRAW: Exception in draw_map_view_ui: {e}"); traceback.print_exc()


def _draw_map_view_info_text(surface: pygame.Surface, editor_state: EditorState,
                            map_view_rect: pygame.Rect, fonts: Dict[str, Optional[pygame.font.Font]],
                            general_mouse_pos: Tuple[int, int]): # Changed mouse_pos to general_mouse_pos
    info_font = fonts.get("small") or ED_CONFIG.FONT_CONFIG.get("small")
    if not info_font: return

    instr_lines = [
        "LMB Drag: Paint Tile, RMB Drag: Erase Tile", # Updated
        "G: Toggle Grid, ESC: Deselect Asset / Menu",
        "WASD: Pan Camera View", # Updated
        "Shift+RMB (on map): Save All (JSON & .py)",
        "Ctrl+S: Save All (JSON & .py)"
    ]
    line_h = info_font.get_height() + 2
    instr_y_start = map_view_rect.bottom + 5

    for i, line in enumerate(instr_lines):
        surf = info_font.render(line, True, ED_CONFIG.C.YELLOW)
        draw_y = instr_y_start + i * line_h
        if draw_y + line_h > surface.get_height() - 5 : # Adjust if running off screen
            draw_y = surface.get_height() - 5 - line_h * (len(instr_lines) - i)
        surface.blit(surf, (map_view_rect.left + 5, draw_y))

    coords_txt = f"Cam:({editor_state.camera_offset_x},{editor_state.camera_offset_y})"
    if map_view_rect.collidepoint(general_mouse_pos): # Use general_mouse_pos here
        map_world_mx = general_mouse_pos[0] - map_view_rect.left + editor_state.camera_offset_x
        map_world_my = general_mouse_pos[1] - map_view_rect.top + editor_state.camera_offset_y
        tile_x, tile_y = map_world_mx // editor_state.grid_size, map_world_my // editor_state.grid_size
        coords_txt += f" MouseW:({map_world_mx},{map_world_my}) Tile:({tile_x},{tile_y})"
    
    coords_surf = info_font.render(coords_txt, True, ED_CONFIG.C.WHITE)
    coords_y = map_view_rect.top - coords_surf.get_height() - 3
    if coords_y < 5: coords_y = 5 # Keep on screen
    surface.blit(coords_surf, (map_view_rect.left + 5, coords_y))


def draw_grid_on_map_surface(map_content_surface: pygame.Surface, editor_state: EditorState):
    if not editor_state.show_grid or not editor_state.map_content_surface: return
    
    w, h = editor_state.get_map_pixel_width(), editor_state.get_map_pixel_height()
    grid_s = editor_state.grid_size
    if grid_s <= 0: return

    grid_col = ED_CONFIG.MAP_VIEW_GRID_COLOR
    try:
        for x in range(0, w + 1, grid_s): pygame.draw.line(map_content_surface, grid_col, (x, 0), (x, h))
        for y in range(0, h + 1, grid_s): pygame.draw.line(map_content_surface, grid_col, (0, y), (w, y))
    except Exception as e:
        print(f"ERROR DRAW: Exception in draw_grid_on_map_surface: {e}"); traceback.print_exc()

########## START OF FILE: editor_event_handlers.py ##########

# editor_event_handlers.py
# -*- coding: utf-8 -*-
"""
## version 1.0.0.13 (WASD camera, drag-to-paint/erase tiles)
Handles Pygame events for different modes and UI elements
of the Platformer Level Editor.
"""
import pygame
import os
from typing import Optional, Dict, Tuple, Any, Callable, List
import traceback

import editor_config as ED_CONFIG
from editor_state import EditorState
from editor_ui import start_text_input_dialog, start_color_picker_dialog, start_file_load_dialog
from editor_map_utils import (init_new_map_state, save_map_to_json,
                              load_map_from_json, export_map_to_game_python_script)

# (handle_global_events and handle_dialog_events remain unchanged from your last correct version)
def handle_global_events(event: pygame.event.Event, editor_state: EditorState, main_screen: pygame.Surface) -> bool:
    if event.type == pygame.QUIT:
        print("DEBUG GLOBAL_EVENT: pygame.QUIT event received.")
        if editor_state.unsaved_changes:
            if not getattr(editor_state, '_quit_attempted_with_unsaved_changes', False):
                editor_state.set_status_message("Unsaved changes! Quit again to exit without saving, or save your map.", 5.0)
                editor_state._quit_attempted_with_unsaved_changes = True
                return True 
            else: # Second attempt
                print("DEBUG GLOBAL_EVENT: Second quit attempt with unsaved changes. Proceeding to quit.")
                if hasattr(editor_state, '_quit_attempted_with_unsaved_changes'):
                    del editor_state._quit_attempted_with_unsaved_changes
                return False # Quit now
        else: # No unsaved changes
            if hasattr(editor_state, '_quit_attempted_with_unsaved_changes'):
                del editor_state._quit_attempted_with_unsaved_changes
            return False # Quit

    if event.type == pygame.VIDEORESIZE:
        print(f"DEBUG GLOBAL_EVENT: pygame.VIDEORESIZE to {event.w}x{event.h}")
        editor_state.set_status_message(f"Resized to {event.w}x{event.h}", 2.0)
    
    if event.type != pygame.QUIT and hasattr(editor_state, '_quit_attempted_with_unsaved_changes'):
        # If any other event occurs, reset the quit attempt flag
        del editor_state._quit_attempted_with_unsaved_changes
        
    return True


def handle_dialog_events(event: pygame.event.Event, editor_state: EditorState):
    if not editor_state.active_dialog_type:
        return

    confirmed = False
    cancelled = False
    selected_value_from_dialog: Any = None
    dialog_type_being_processed = editor_state.active_dialog_type

    if event.type == pygame.KEYDOWN:
        if event.key == pygame.K_ESCAPE: cancelled = True
        elif event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
            if dialog_type_being_processed == "text_input":
                confirmed = True; selected_value_from_dialog = editor_state.dialog_input_text
            elif dialog_type_being_processed == "file_load" and editor_state.dialog_selected_file_index != -1 and \
                 0 <= editor_state.dialog_selected_file_index < len(editor_state.dialog_file_list):
                confirmed = True; selected_value_from_dialog = os.path.join(ED_CONFIG.MAPS_DIRECTORY, editor_state.dialog_file_list[editor_state.dialog_selected_file_index])
            elif dialog_type_being_processed == "file_load": editor_state.set_status_message("No file selected.", 2.5)
        if dialog_type_being_processed == "text_input":
            if event.key == pygame.K_BACKSPACE: editor_state.dialog_input_text = editor_state.dialog_input_text[:-1]
            elif event.unicode.isprintable() and (event.unicode.isalnum() or event.unicode in ['.', '_', '-', ' ', ',', '/', '\\']): editor_state.dialog_input_text += event.unicode
        elif dialog_type_being_processed == "file_load" and editor_state.dialog_file_list:
            list_len = len(editor_state.dialog_file_list)
            if list_len > 0:
                if event.key == pygame.K_UP: editor_state.dialog_selected_file_index = (editor_state.dialog_selected_file_index - 1 + list_len) % list_len
                elif event.key == pygame.K_DOWN: editor_state.dialog_selected_file_index = (editor_state.dialog_selected_file_index + 1) % list_len
            else: editor_state.dialog_selected_file_index = -1
            if editor_state.dialog_selected_file_index != -1: editor_state.dialog_input_text = editor_state.dialog_file_list[editor_state.dialog_selected_file_index]
            else: editor_state.dialog_input_text = ""
    elif event.type == pygame.MOUSEBUTTONDOWN:
        if editor_state.dialog_rect and editor_state.dialog_rect.collidepoint(event.pos) and event.button == 1:
            if dialog_type_being_processed == "color_picker":
                for color_name, swatch_rect_relative in editor_state.color_picker_rects.items():
                    absolute_swatch_rect = swatch_rect_relative.move(editor_state.dialog_rect.left, editor_state.dialog_rect.top)
                    if absolute_swatch_rect.collidepoint(event.pos):
                        selected_value_from_dialog = ED_CONFIG.COLOR_PICKER_PRESETS.get(color_name);
                        if selected_value_from_dialog: confirmed = True
                        break
            elif dialog_type_being_processed == "file_load":
                ok_rect, cancel_rect = editor_state.ui_elements_rects.get("dialog_file_load_ok"), editor_state.ui_elements_rects.get("dialog_file_load_cancel")
                if ok_rect and ok_rect.collidepoint(event.pos) and editor_state.dialog_selected_file_index != -1:
                    confirmed = True; selected_value_from_dialog = os.path.join(ED_CONFIG.MAPS_DIRECTORY, editor_state.dialog_file_list[editor_state.dialog_selected_file_index])
                elif cancel_rect and cancel_rect.collidepoint(event.pos): cancelled = True
                else:
                    for item_info in editor_state.ui_elements_rects.get('dialog_file_item_rects', []):
                        if item_info["rect"].collidepoint(event.pos): editor_state.dialog_selected_file_index = item_info["index"]; editor_state.dialog_input_text = item_info["text"]; break
                    scrollbar_handle_rect = editor_state.ui_elements_rects.get('file_dialog_scrollbar_handle')
                    if scrollbar_handle_rect and scrollbar_handle_rect.collidepoint(event.pos): editor_state.is_dragging_scrollbar = True; editor_state.scrollbar_drag_mouse_offset_y = event.pos[1] - scrollbar_handle_rect.top
        elif dialog_type_being_processed != "text_input": cancelled = True
    elif event.type == pygame.MOUSEBUTTONUP and event.button == 1 and editor_state.is_dragging_scrollbar: editor_state.is_dragging_scrollbar = False
    elif event.type == pygame.MOUSEMOTION and editor_state.is_dragging_scrollbar:
        scrollbar_area = editor_state.ui_elements_rects.get('file_dialog_scrollbar_area'); scrollbar_handle = editor_state.ui_elements_rects.get('file_dialog_scrollbar_handle')
        if scrollbar_area and scrollbar_handle and editor_state.dialog_file_list:
            mouse_y_in_area = event.pos[1] - scrollbar_area.top; handle_pos_y = mouse_y_in_area - editor_state.scrollbar_drag_mouse_offset_y
            item_font = ED_CONFIG.FONT_CONFIG.get("small"); item_h = (item_font.get_height() + 6) if item_font else 22
            content_h = len(editor_state.dialog_file_list) * item_h; display_h = scrollbar_area.height
            track_h = max(1, display_h - scrollbar_handle.height); scroll_px = max(0, content_h - display_h)
            if track_h > 0 and scroll_px > 0: clamped_y = max(0, min(handle_pos_y, track_h)); ratio = clamped_y / track_h; editor_state.dialog_file_scroll_y = ratio * scroll_px
    elif event.type == pygame.MOUSEWHEEL and dialog_type_being_processed == "file_load" and editor_state.dialog_rect and editor_state.dialog_rect.collidepoint(pygame.mouse.get_pos()):
        font_small = ED_CONFIG.FONT_CONFIG.get("small"); item_h = (font_small.get_height() + 6) if font_small else 22
        scroll_val = event.y * item_h; content_h = len(editor_state.dialog_file_list) * item_h
        font_medium = ED_CONFIG.FONT_CONFIG.get("medium"); prompt_h = (font_medium.get_height() + 25) if font_medium else 55
        buttons_h = 40; display_h = editor_state.dialog_rect.height - prompt_h - buttons_h - 10
        max_s = max(0, content_h - display_h); editor_state.dialog_file_scroll_y -= scroll_val; editor_state.dialog_file_scroll_y = max(0, min(editor_state.dialog_file_scroll_y, max_s))

    if confirmed:
        active_dialog_type_before_cb = editor_state.active_dialog_type
        original_confirm_cb, original_cancel_cb, original_prompt = editor_state.dialog_callback_confirm, editor_state.dialog_callback_cancel, editor_state.dialog_prompt_message
        if editor_state.dialog_callback_confirm:
            try:
                value_to_pass = selected_value_from_dialog if selected_value_from_dialog is not None else editor_state.dialog_input_text
                editor_state.dialog_callback_confirm(value_to_pass) 
            except Exception as e: print(f"ERROR: Confirm CB: {e}"); traceback.print_exc()
        
        new_dialog_started = False
        if editor_state.active_dialog_type is not None and (editor_state.active_dialog_type != active_dialog_type_before_cb or 
                                                            editor_state.dialog_callback_confirm != original_confirm_cb or 
                                                            editor_state.dialog_callback_cancel != original_cancel_cb or 
                                                            editor_state.dialog_prompt_message != original_prompt):
            new_dialog_started = True
        
        if not new_dialog_started:
            editor_state.active_dialog_type = None 
            editor_state.dialog_callback_confirm = None; editor_state.dialog_callback_cancel = None
            editor_state.dialog_input_text = ""; editor_state.dialog_selected_file_index = -1
            editor_state.is_dragging_scrollbar = False
    elif cancelled:
        active_dialog_type_before_cb = editor_state.active_dialog_type
        original_confirm_cb, original_cancel_cb, original_prompt = editor_state.dialog_callback_confirm, editor_state.dialog_callback_cancel, editor_state.dialog_prompt_message
        if editor_state.dialog_callback_cancel:
            try: editor_state.dialog_callback_cancel()
            except Exception as e: print(f"ERROR: Cancel CB: {e}"); traceback.print_exc()

        new_dialog_started = False
        if editor_state.active_dialog_type is not None and (editor_state.active_dialog_type != active_dialog_type_before_cb or
                                                            editor_state.dialog_callback_confirm != original_confirm_cb or
                                                            editor_state.dialog_callback_cancel != original_cancel_cb or
                                                            editor_state.dialog_prompt_message != original_prompt):
            new_dialog_started = True

        if not new_dialog_started:
            editor_state.active_dialog_type = None
            editor_state.dialog_callback_confirm = None; editor_state.dialog_callback_cancel = None
            editor_state.dialog_input_text = ""; editor_state.dialog_selected_file_index = -1
            editor_state.is_dragging_scrollbar = False


def handle_menu_events(event: pygame.event.Event, editor_state: EditorState, main_screen: pygame.Surface):
    if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
        mouse_pos = event.pos
        ui_rects = editor_state.ui_elements_rects 
        if ui_rects.get("menu_new_map") and ui_rects["menu_new_map"].collidepoint(mouse_pos):
            def on_new_map_name_confirm(map_name: str):
                map_name = map_name.strip()
                if not map_name:
                    editor_state.set_status_message("Map name cannot be empty.", 3)
                    start_text_input_dialog(editor_state, "Name:", "", on_new_map_name_confirm, lambda: None)
                    return
                editor_state.map_name_for_function_input = map_name
                def on_map_size_confirm(size_str: str):
                    try:
                        w_str, h_str = [s.strip() for s in size_str.split(',')]
                        if not (w_str.isdigit() and h_str.isdigit()): raise ValueError("Non-digit size")
                        w, h = int(w_str), int(h_str)
                        if not (w > 0 and h > 0): raise ValueError("Non-positive size")
                        init_new_map_state(editor_state, editor_state.map_name_for_function_input, w, h)
                        if save_map_to_json(editor_state) and export_map_to_game_python_script(editor_state):
                            editor_state.set_status_message(f"Map '{editor_state.map_name_for_function}' auto-saved.", 3)
                            pygame.display.set_caption(f"Editor - {editor_state.map_name_for_function}.py")
                        else:
                            editor_state.set_status_message(f"Auto-save failed for '{editor_state.map_name_for_function}'.", 4)
                            pygame.display.set_caption(f"Editor - {editor_state.map_name_for_function}.py*")
                        editor_state.current_editor_mode = "editing_map"
                    except Exception as e:
                        editor_state.set_status_message(f"Invalid size: {e}. Use W,H (e.g. 30,20)", 3.5)
                        start_text_input_dialog(editor_state, "Size (W,H):", f"{ED_CONFIG.DEFAULT_MAP_WIDTH_TILES},{ED_CONFIG.DEFAULT_MAP_HEIGHT_TILES}", on_map_size_confirm, lambda: None)
                start_text_input_dialog(editor_state, "Size (W,H):", f"{ED_CONFIG.DEFAULT_MAP_WIDTH_TILES},{ED_CONFIG.DEFAULT_MAP_HEIGHT_TILES}", on_map_size_confirm, lambda: None)
            start_text_input_dialog(editor_state, "New Map Name:", "my_map", on_new_map_name_confirm, lambda: None)
        elif ui_rects.get("menu_load_map") and ui_rects["menu_load_map"].collidepoint(mouse_pos):
            def on_file_selected(fp: str):
                if load_map_from_json(editor_state, fp):
                    editor_state.current_editor_mode = "editing_map"; pygame.display.set_caption(f"Editor - {editor_state.map_name_for_function}.py")
            start_file_load_dialog(editor_state, on_confirm=on_file_selected, on_cancel=lambda: None)
        elif ui_rects.get("menu_quit") and ui_rects["menu_quit"].collidepoint(mouse_pos):
            pygame.event.post(pygame.event.Event(pygame.QUIT))


def _place_tile_at_grid(editor_state: EditorState, grid_coords: Tuple[int, int]):
    """Helper function to place a tile, avoiding duplicates for non-spawn items."""
    if not editor_state.selected_asset_editor_key:
        return

    grid_world_x, grid_world_y = grid_coords[0] * editor_state.grid_size, grid_coords[1] * editor_state.grid_size
    asset_data = editor_state.assets_palette[editor_state.selected_asset_editor_key]
    new_obj_game_type_id = asset_data["game_type_id"]
    is_spawn_item = asset_data.get("category") == "spawn"

    # Check for existing non-spawn items at the same grid location
    if not is_spawn_item:
        for existing_obj in editor_state.placed_objects:
            if existing_obj.get("world_x") == grid_world_x and \
               existing_obj.get("world_y") == grid_world_y and \
               existing_obj.get("game_type_id") == new_obj_game_type_id: # Only prevent exact same type
                # print(f"DEBUG EDIT_MAP_EVENT: Tile '{new_obj_game_type_id}' already at ({grid_world_x},{grid_world_y}). Skipping paint.")
                return # Already exists, don't place again

    if is_spawn_item: # Remove existing of same spawn type anywhere on map
        editor_state.placed_objects = [obj for obj in editor_state.placed_objects if obj.get("game_type_id") != new_obj_game_type_id]

    new_obj = {
        "asset_editor_key": editor_state.selected_asset_editor_key,
        "world_x": grid_world_x, "world_y": grid_world_y,
        "game_type_id": new_obj_game_type_id
    }
    editor_state.placed_objects.append(new_obj)
    editor_state.unsaved_changes = True
    pygame.display.set_caption(f"Editor - {editor_state.map_name_for_function}.py*")
    print(f"DEBUG EDIT_MAP_EVENT: Placed '{new_obj_game_type_id}' at grid ({grid_coords[0]},{grid_coords[1]}). Unsaved: True.")


def _erase_tile_at_grid(editor_state: EditorState, grid_coords: Tuple[int, int]):
    """Helper function to erase a tile at specific grid coordinates."""
    grid_world_x, grid_world_y = grid_coords[0] * editor_state.grid_size, grid_coords[1] * editor_state.grid_size
    
    original_len = len(editor_state.placed_objects)
    # Iterate backwards for safe removal
    for i in range(len(editor_state.placed_objects) - 1, -1, -1):
        obj_data = editor_state.placed_objects[i]
        # Check if the object's top-left corner matches the grid cell
        if obj_data.get("world_x") == grid_world_x and obj_data.get("world_y") == grid_world_y:
            asset_info = editor_state.assets_palette.get(obj_data.get("asset_editor_key"))
            tooltip = asset_info['tooltip'] if asset_info else "Unknown Object"
            print(f"DEBUG EDIT_MAP_EVENT: Erasing '{tooltip}' at grid ({grid_coords[0]},{grid_coords[1]}).")
            editor_state.placed_objects.pop(i)
            editor_state.unsaved_changes = True
            pygame.display.set_caption(f"Editor - {editor_state.map_name_for_function}.py*")
            # For now, erase only the first found object in a cell during a drag-erase motion.
            # If multiple objects could stack, this logic might need refinement.
            break 
    if len(editor_state.placed_objects) < original_len:
        editor_state.set_status_message(f"Erased tile at ({grid_coords[0]},{grid_coords[1]})", 1.5)


def handle_editing_map_events(event: pygame.event.Event, editor_state: EditorState,
                              palette_section_rect: pygame.Rect, map_view_rect: pygame.Rect,
                              main_screen: pygame.Surface):
    general_mouse_pos = pygame.mouse.get_pos() 

    if event.type == pygame.MOUSEWHEEL:
        if palette_section_rect.collidepoint(general_mouse_pos):
            font_small = ED_CONFIG.FONT_CONFIG.get("small"); scroll_speed = (font_small.get_height() + ED_CONFIG.ASSET_PALETTE_ITEM_PADDING) if font_small else 20
            editor_state.asset_palette_scroll_y -= event.y * scroll_speed 
            max_scroll = max(0, editor_state.total_asset_palette_content_height - palette_section_rect.height)
            editor_state.asset_palette_scroll_y = max(0, min(editor_state.asset_palette_scroll_y, max_scroll))
    
    elif event.type == pygame.MOUSEBUTTONDOWN:
        mouse_pos_for_click = event.pos
        if palette_section_rect.collidepoint(mouse_pos_for_click) and event.button == 1: # LMB in Palette
            bg_color_btn_rect = editor_state.ui_elements_rects.get("palette_bg_color_button")
            if bg_color_btn_rect and bg_color_btn_rect.collidepoint(mouse_pos_for_click):
                def on_bg_color_selected(new_color: Tuple[int,int,int]):
                    if new_color: editor_state.background_color = new_color; editor_state.unsaved_changes = True; pygame.display.set_caption(f"Editor - {editor_state.map_name_for_function}.py*"); editor_state.set_status_message(f"BG set to {new_color}")
                start_color_picker_dialog(editor_state, on_confirm=on_bg_color_selected, on_cancel=lambda: None)
                return
            for asset_key, item_screen_rect in editor_state.ui_elements_rects.get('asset_palette_items', {}).items():
                if item_screen_rect.collidepoint(mouse_pos_for_click):
                    asset_data = editor_state.assets_palette[asset_key]; editor_state.selected_asset_editor_key = asset_key
                    editor_state.selected_asset_image_for_cursor = asset_data["image"].copy(); editor_state.set_status_message(f"Selected: {asset_data['tooltip']}")
                    return
        elif map_view_rect.collidepoint(mouse_pos_for_click): # Click in Map View
            map_world_mouse_x = mouse_pos_for_click[0] - map_view_rect.left + editor_state.camera_offset_x
            map_world_mouse_y = mouse_pos_for_click[1] - map_view_rect.top + editor_state.camera_offset_y
            tile_x = map_world_mouse_x // editor_state.grid_size
            tile_y = map_world_mouse_y // editor_state.grid_size
            
            if event.button == 1: # LMB on Map
                if editor_state.selected_asset_editor_key: # Start painting
                    editor_state.is_painting_tiles = True
                    editor_state.last_painted_tile_coords = (tile_x, tile_y)
                    _place_tile_at_grid(editor_state, (tile_x, tile_y))
                else: # Try to drag existing object (no asset selected)
                    for i, obj in reversed(list(enumerate(editor_state.placed_objects))):
                        asset_info = editor_state.assets_palette.get(obj.get("asset_editor_key"));
                        if asset_info and "original_size_pixels" in asset_info:
                            obj_w, obj_h = asset_info["original_size_pixels"]; obj_r = pygame.Rect(obj["world_x"], obj["world_y"], obj_w, obj_h)
                            if obj_r.collidepoint(map_world_mouse_x, map_world_mouse_y):
                                editor_state.dragging_object_index = i; editor_state.drag_start_mouse_map_x = map_world_mouse_x; editor_state.drag_start_mouse_map_y = map_world_mouse_y
                                editor_state.drag_object_original_x = obj["world_x"]; editor_state.drag_object_original_y = obj["world_y"]; editor_state.set_status_message(f"Dragging {asset_info['tooltip']}")
                                break
            elif event.button == 3: # RMB on Map
                keys = pygame.key.get_pressed()
                if keys[pygame.K_LSHIFT] or keys[pygame.K_RSHIFT]: # Save All
                    if editor_state.map_name_for_function and editor_state.map_name_for_function != "untitled_map":
                        if save_map_to_json(editor_state) and export_map_to_game_python_script(editor_state):
                            pygame.display.set_caption(f"Editor - {editor_state.map_name_for_function}.py")
                    else: editor_state.set_status_message("Cannot save: Map not named.", 4)
                else: # Start erasing
                    editor_state.is_erasing_tiles = True
                    editor_state.last_erased_tile_coords = (tile_x, tile_y)
                    _erase_tile_at_grid(editor_state, (tile_x, tile_y))

    elif event.type == pygame.MOUSEBUTTONUP:
        if event.button == 1: # LMB Up
            editor_state.is_painting_tiles = False
            editor_state.last_painted_tile_coords = None
            if editor_state.dragging_object_index is not None:
                editor_state.dragging_object_index = None; editor_state.set_status_message("Drag complete")
        elif event.button == 3: # RMB Up
            editor_state.is_erasing_tiles = False
            editor_state.last_erased_tile_coords = None
        if editor_state.is_dragging_scrollbar: editor_state.is_dragging_scrollbar = False
    
    elif event.type == pygame.MOUSEMOTION:
        mouse_pos_for_motion = event.pos
        if map_view_rect.collidepoint(mouse_pos_for_motion):
            map_world_mouse_x = mouse_pos_for_motion[0] - map_view_rect.left + editor_state.camera_offset_x
            map_world_mouse_y = mouse_pos_for_motion[1] - map_view_rect.top + editor_state.camera_offset_y
            current_tile_x = map_world_mouse_x // editor_state.grid_size
            current_tile_y = map_world_mouse_y // editor_state.grid_size
            current_grid_coords = (current_tile_x, current_tile_y)

            if editor_state.is_painting_tiles and editor_state.selected_asset_editor_key:
                if current_grid_coords != editor_state.last_painted_tile_coords:
                    _place_tile_at_grid(editor_state, current_grid_coords)
                    editor_state.last_painted_tile_coords = current_grid_coords
            elif editor_state.is_erasing_tiles: # Check if right mouse button is held (buttons[2])
                # MOUSEMOTION events don't have 'button' attribute, check pygame.mouse.get_pressed()
                if pygame.mouse.get_pressed()[2]: # RMB is held
                    if current_grid_coords != editor_state.last_erased_tile_coords:
                        _erase_tile_at_grid(editor_state, current_grid_coords)
                        editor_state.last_erased_tile_coords = current_grid_coords
                else: # RMB was released elsewhere
                    editor_state.is_erasing_tiles = False
                    editor_state.last_erased_tile_coords = None

            elif editor_state.dragging_object_index is not None and 0 <= editor_state.dragging_object_index < len(editor_state.placed_objects):
                obj = editor_state.placed_objects[editor_state.dragging_object_index]
                new_x = editor_state.drag_object_original_x + (map_world_mouse_x - editor_state.drag_start_mouse_map_x)
                new_y = editor_state.drag_object_original_y + (map_world_mouse_y - editor_state.drag_start_mouse_map_y)
                snapped_x, snapped_y = (new_x // editor_state.grid_size) * editor_state.grid_size, (new_y // editor_state.grid_size) * editor_state.grid_size
                if obj["world_x"] != snapped_x or obj["world_y"] != snapped_y:
                    obj["world_x"], obj["world_y"] = snapped_x, snapped_y; editor_state.unsaved_changes = True; pygame.display.set_caption(f"Editor - {editor_state.map_name_for_function}.py*")

    elif event.type == pygame.KEYDOWN:
        if event.key == pygame.K_ESCAPE:
            if editor_state.selected_asset_editor_key:
                editor_state.selected_asset_editor_key = None; editor_state.selected_asset_image_for_cursor = None; editor_state.set_status_message("Asset deselected")
            else:
                if editor_state.unsaved_changes:
                    if not getattr(editor_state, '_esc_exit_attempted', False):
                        editor_state.set_status_message("Unsaved changes! Save or Esc again to discard.", 4); editor_state._esc_exit_attempted = True
                    else:
                        editor_state.current_editor_mode = "menu"; editor_state.reset_map_context(); pygame.display.set_caption("Platformer Level Editor - Menu"); del editor_state._esc_exit_attempted
                else: editor_state.current_editor_mode = "menu"; editor_state.reset_map_context(); pygame.display.set_caption("Platformer Level Editor - Menu")
        elif event.key != pygame.K_ESCAPE and hasattr(editor_state, '_esc_exit_attempted'): del editor_state._esc_exit_attempted
        elif event.key == pygame.K_g: editor_state.show_grid = not editor_state.show_grid; editor_state.set_status_message(f"Grid {'ON' if editor_state.show_grid else 'OFF'}")
        
        # --- WASD Camera Panning ---
        pan = ED_CONFIG.MAP_VIEW_CAMERA_PAN_SPEED
        if map_view_rect.width > 0 and map_view_rect.height > 0:
            map_w, map_h = editor_state.get_map_pixel_width(), editor_state.get_map_pixel_height()
            if event.key == pygame.K_a: # LEFT
                editor_state.camera_offset_x = max(0, editor_state.camera_offset_x - pan)
            elif event.key == pygame.K_d: # RIGHT
                editor_state.camera_offset_x = min(max(0, map_w - map_view_rect.width), editor_state.camera_offset_x + pan)
            elif event.key == pygame.K_w: # UP
                editor_state.camera_offset_y = max(0, editor_state.camera_offset_y - pan)
            elif event.key == pygame.K_s and not (pygame.key.get_mods() & pygame.KMOD_CTRL): # DOWN (ensure not Ctrl+S)
                editor_state.camera_offset_y = min(max(0, map_h - map_view_rect.height), editor_state.camera_offset_y + pan)
        
        if event.key == pygame.K_s and (pygame.key.get_mods() & pygame.KMOD_CTRL): # Ctrl+S Save
            if editor_state.map_name_for_function and editor_state.map_name_for_function != "untitled_map":
                if save_map_to_json(editor_state) and export_map_to_game_python_script(editor_state): 
                     pygame.display.set_caption(f"Editor - {editor_state.map_name_for_function}.py")
            else: editor_state.set_status_message("Cannot save: Map not named.", 4)

########## START OF FILE: editor_map_utils.py ##########

# editor_map_utils.py
# -*- coding: utf-8 -*-
"""
## version 1.0.0.5 (Added extensive debug prints for saving/loading and export)
Utility functions for map operations in the Level Editor,
including initializing new maps, saving/loading editor-specific
map data (JSON), and exporting maps to game-compatible Python scripts.
"""
import pygame
import sys
import os
import json
import traceback # For detailed error reporting
from typing import Optional, Dict, List, Tuple, Any

# --- Add parent directory to sys.path for editor_config & editor_state if this file is run standalone (unlikely here) ---
# This is more robustly handled in the main editor.py script.
# current_script_path_map_utils = os.path.dirname(os.path.abspath(__file__))
# parent_directory_map_utils = os.path.dirname(current_script_path_map_utils) # This should be 'editor'
# project_root_map_utils = os.path.dirname(parent_directory_map_utils) # This should be 'Platformer'
# if project_root_map_utils not in sys.path:
#     sys.path.insert(0, project_root_map_utils)
# if parent_directory_map_utils not in sys.path: # If editor_config is in 'editor' not project root
#    sys.path.insert(0, parent_directory_map_utils)

import editor_config as ED_CONFIG
from editor_state import EditorState

# constants.py and tiles.py should be accessible from the project root.
# This setup relies on editor.py correctly setting up sys.path.
import constants as C
from tiles import Platform, Ladder, Lava # Assuming these are used in export


def init_new_map_state(editor_state: EditorState, map_name_for_function: str,
                       map_width_tiles: int, map_height_tiles: int):
    """
    Initializes the editor_state for a new, empty map.
    Sets up dimensions, clears objects, prepares the map_content_surface.
    """
    print(f"DEBUG MAP_UTILS: init_new_map_state called. Map Name: '{map_name_for_function}', Size: {map_width_tiles}x{map_height_tiles}")
    
    clean_map_name = map_name_for_function.lower().replace(" ", "_").replace("-", "_")
    if not clean_map_name:
        clean_map_name = "untitled_map" # Fallback if name becomes empty
        print(f"DEBUG MAP_UTILS: map_name_for_function was empty after cleaning, defaulting to '{clean_map_name}'")
    
    editor_state.map_name_for_function = clean_map_name
    editor_state.map_width_tiles = map_width_tiles
    editor_state.map_height_tiles = map_height_tiles
    editor_state.placed_objects = []
    editor_state.background_color = ED_CONFIG.DEFAULT_BACKGROUND_COLOR
    editor_state.camera_offset_x = 0
    editor_state.camera_offset_y = 0
    editor_state.unsaved_changes = True # A new map inherently has unsaved changes until first save
    
    py_filename = editor_state.map_name_for_function + ED_CONFIG.GAME_LEVEL_FILE_EXTENSION
    editor_state.current_map_filename = os.path.join(ED_CONFIG.MAPS_DIRECTORY, py_filename)
    
    editor_state.recreate_map_content_surface() # This also prints a debug message
    
    print(f"DEBUG MAP_UTILS: Editor state initialized for new map. "
          f"map_name_for_function='{editor_state.map_name_for_function}', "
          f"current_map_filename='{editor_state.current_map_filename}', "
          f"unsaved_changes={editor_state.unsaved_changes}")

def ensure_maps_directory_exists() -> bool:
    """Checks if the MAPS_DIRECTORY exists, creates it if not. Returns success."""
    maps_dir = ED_CONFIG.MAPS_DIRECTORY
    # print(f"DEBUG MAP_UTILS: Checking if maps directory '{maps_dir}' exists.") # Can be verbose
    if not os.path.exists(maps_dir):
        print(f"DEBUG MAP_UTILS: Maps directory '{maps_dir}' does not exist. Attempting to create.")
        try:
            os.makedirs(maps_dir)
            print(f"DEBUG MAP_UTILS: Successfully created directory: {maps_dir}")
            return True
        except OSError as e:
            print(f"ERROR MAP_UTILS: Error creating directory {maps_dir}: {e}")
            traceback.print_exc()
            return False
    # print(f"DEBUG MAP_UTILS: Maps directory '{maps_dir}' already exists.")
    return True

def save_map_to_json(editor_state: EditorState) -> bool:
    """
    Saves the current editor state to a JSON file for editor reloading.
    Returns True on success, False on failure.
    """
    print(f"DEBUG MAP_UTILS: save_map_to_json called. Map name func: '{editor_state.map_name_for_function}'")
    if not editor_state.map_name_for_function or editor_state.map_name_for_function == "untitled_map":
        msg = "Map name is not set or is 'untitled_map'. Cannot save JSON."
        editor_state.set_status_message(f"Error: {msg}", 3)
        print(f"ERROR MAP_UTILS: {msg}")
        return False

    if not ensure_maps_directory_exists():
        msg = "Could not create or access maps directory."
        editor_state.set_status_message(f"Error: {msg}", 3)
        print(f"ERROR MAP_UTILS: {msg} JSON save aborted.")
        return False

    json_filename = editor_state.map_name_for_function + ED_CONFIG.LEVEL_EDITOR_SAVE_FORMAT_EXTENSION
    json_filepath = os.path.join(ED_CONFIG.MAPS_DIRECTORY, json_filename)
    print(f"DEBUG MAP_UTILS: Attempting to save JSON to: '{json_filepath}'")

    serializable_objects = []
    for i, obj in enumerate(editor_state.placed_objects):
        asset_key = obj.get("asset_editor_key")
        game_id = obj.get("game_type_id")
        world_x = obj.get("world_x")
        world_y = obj.get("world_y")

        if not all([asset_key, game_id is not None, world_x is not None, world_y is not None]):
             print(f"Warning MAP_UTILS: Object at index {i} has missing data, skipping for JSON: {obj}")
             continue

        s_obj = {
            "asset_editor_key": asset_key,
            "world_x": world_x,
            "world_y": world_y,
            "game_type_id": game_id
        }
        serializable_objects.append(s_obj)

    data_to_save = {
        "map_name_for_function": editor_state.map_name_for_function,
        "map_width_tiles": editor_state.map_width_tiles,
        "map_height_tiles": editor_state.map_height_tiles,
        "grid_size": editor_state.grid_size,
        "background_color": list(editor_state.background_color), # Convert tuple to list for JSON
        "placed_objects": serializable_objects,
        "camera_offset_x": editor_state.camera_offset_x,
        "camera_offset_y": editor_state.camera_offset_y,
        "show_grid": editor_state.show_grid
    }
    print(f"DEBUG MAP_UTILS: Data to save to JSON: {json.dumps(data_to_save, indent=2)}") # Log the data

    try:
        with open(json_filepath, "w") as f:
            json.dump(data_to_save, f, indent=4)
        success_msg = f"Editor data saved to: {json_filename}"
        print(f"DEBUG MAP_UTILS: {success_msg}")
        editor_state.set_status_message(success_msg)
        # editor_state.unsaved_changes = False # This should be set False AFTER .py export if successful
        return True
    except IOError as e:
        error_msg = f"IOError saving map to JSON '{json_filepath}': {e}"
    except Exception as e:
        error_msg = f"Unexpected error saving map to JSON '{json_filepath}': {e}"
        traceback.print_exc()
    
    print(f"ERROR MAP_UTILS: {error_msg}")
    editor_state.set_status_message(error_msg, 4)
    return False

def load_map_from_json(editor_state: EditorState, json_filepath: str) -> bool:
    """
    Loads map data from a JSON file into the editor_state.
    Returns True on success, False on failure.
    """
    print(f"DEBUG MAP_UTILS: load_map_from_json called. Filepath: '{json_filepath}'")
    if not os.path.exists(json_filepath) or not os.path.isfile(json_filepath):
        error_msg = f"JSON map file not found or is not a file: '{json_filepath}'"
        print(f"ERROR MAP_UTILS: {error_msg}")
        editor_state.set_status_message(error_msg, 3)
        return False
        
    try:
        with open(json_filepath, 'r') as f:
            data = json.load(f)
        print(f"DEBUG MAP_UTILS: Successfully read JSON data from '{json_filepath}'. Content snapshot: { {k: (type(v) if k != 'placed_objects' else f'{len(v)} items') for k,v in data.items()} }")
        
        editor_state.map_name_for_function = data.get("map_name_for_function", "loaded_map_error_name")
        editor_state.map_width_tiles = data.get("map_width_tiles", ED_CONFIG.DEFAULT_MAP_WIDTH_TILES)
        editor_state.map_height_tiles = data.get("map_height_tiles", ED_CONFIG.DEFAULT_MAP_HEIGHT_TILES)
        editor_state.grid_size = data.get("grid_size", ED_CONFIG.DEFAULT_GRID_SIZE)
        
        bg_color_data = data.get("background_color", ED_CONFIG.DEFAULT_BACKGROUND_COLOR)
        if isinstance(bg_color_data, list) and len(bg_color_data) == 3:
            editor_state.background_color = tuple(bg_color_data) # type: ignore
        else:
            editor_state.background_color = ED_CONFIG.DEFAULT_BACKGROUND_COLOR
            print(f"Warning MAP_UTILS: Invalid background_color format in JSON, using default. Got: {bg_color_data}")


        editor_state.placed_objects = []
        loaded_placed_objects = data.get("placed_objects", [])
        print(f"DEBUG MAP_UTILS: Loading {len(loaded_placed_objects)} objects from JSON.")
        for i, obj_data in enumerate(loaded_placed_objects):
            asset_key = obj_data.get("asset_editor_key")
            game_type_id_from_json = obj_data.get("game_type_id") # Get game_type_id from JSON
            world_x = obj_data.get("world_x")
            world_y = obj_data.get("world_y")

            if not all([asset_key, game_type_id_from_json is not None, world_x is not None, world_y is not None]):
                print(f"Warning MAP_UTILS: Loaded object at index {i} has missing core data, skipping: {obj_data}")
                continue

            if asset_key in ED_CONFIG.EDITOR_PALETTE_ASSETS:
                # It's generally safer to trust the game_type_id from the JSON file if it exists,
                # as the config might change. However, for consistency if asset_key is primary link:
                # game_type_id_from_config = ED_CONFIG.EDITOR_PALETTE_ASSETS[asset_key].get("game_type_id", asset_key)
                editor_state.placed_objects.append({
                    "asset_editor_key": asset_key,
                    "world_x": world_x,
                    "world_y": world_y,
                    "game_type_id": game_type_id_from_json # Use the one from the file
                })
            else:
                print(f"Warning MAP_UTILS: Asset key '{asset_key}' from loaded object (JSON type: '{game_type_id_from_json}') "
                      f"not found in current ED_CONFIG.EDITOR_PALETTE_ASSETS. Object at ({world_x},{world_y}) skipped.")

        editor_state.camera_offset_x = data.get("camera_offset_x", 0)
        editor_state.camera_offset_y = data.get("camera_offset_y", 0)
        editor_state.show_grid = data.get("show_grid", True)
        
        py_filename = editor_state.map_name_for_function + ED_CONFIG.GAME_LEVEL_FILE_EXTENSION
        editor_state.current_map_filename = os.path.join(ED_CONFIG.MAPS_DIRECTORY, py_filename)
        
        editor_state.recreate_map_content_surface()
        editor_state.unsaved_changes = False # Freshly loaded map has no unsaved changes
        
        success_msg = f"Map '{editor_state.map_name_for_function}' loaded from {os.path.basename(json_filepath)}"
        print(f"DEBUG MAP_UTILS: {success_msg}. unsaved_changes={editor_state.unsaved_changes}, current_map_filename='{editor_state.current_map_filename}'")
        editor_state.set_status_message(success_msg)
        return True
        
    except json.JSONDecodeError as e:
        error_msg = f"Error: Could not decode JSON from map file '{json_filepath}': {e}"
    except Exception as e:
        error_msg = f"Unexpected error loading map from JSON '{json_filepath}': {e}"
        traceback.print_exc()
    
    print(f"ERROR MAP_UTILS: {error_msg}")
    editor_state.set_status_message(error_msg, 4)
    return False

def export_map_to_game_python_script(editor_state: EditorState) -> bool:
    """
    Generates and saves the Python level script compatible with the main game.
    Returns True on success, False on failure.
    """
    print(f"DEBUG MAP_UTILS: export_map_to_game_python_script called. Map func name: '{editor_state.map_name_for_function}'")
    
    if not editor_state.map_name_for_function or editor_state.map_name_for_function == "untitled_map":
        msg = "Map name not set or is 'untitled_map'. Cannot export .py."
        editor_state.set_status_message(f"Error: {msg}", 3)
        print(f"ERROR MAP_UTILS: {msg}")
        return False
        
    if not editor_state.current_map_filename: # Should be set by init_new_map or load_map
        py_filename = editor_state.map_name_for_function + ED_CONFIG.GAME_LEVEL_FILE_EXTENSION
        editor_state.current_map_filename = os.path.join(ED_CONFIG.MAPS_DIRECTORY, py_filename)
        print(f"Warning MAP_UTILS: current_map_filename was not set, derived as '{editor_state.current_map_filename}' for export.")

    if not ensure_maps_directory_exists():
        msg = "Could not create or access maps directory for .py export."
        editor_state.set_status_message(f"Error: {msg}", 3)
        print(f"ERROR MAP_UTILS: {msg} PY export aborted.")
        return False

    function_name = f"load_map_{editor_state.map_name_for_function}"
    print(f"DEBUG MAP_UTILS: Exporting to function '{function_name}' in file '{editor_state.current_map_filename}'")

    platforms_code_lines = []
    ladders_code_lines = [] # Ensure ladders are handled if you add them
    hazards_code_lines = []
    enemy_spawns_code_lines = []
    collectible_spawns_code_lines = []

    # Default player spawn - will be overridden if a player spawn object is placed
    default_spawn_tile_x = editor_state.map_width_tiles // 2
    default_spawn_tile_y = editor_state.map_height_tiles // 2 
    default_spawn_world_x = default_spawn_tile_x * editor_state.grid_size + editor_state.grid_size // 2 # Mid of tile
    default_spawn_world_y = (default_spawn_tile_y + 1) * editor_state.grid_size # Bottom of tile
    player1_spawn_str = f"player1_spawn = ({default_spawn_world_x}, {default_spawn_world_y}) # Default P1 Spawn (midbottom of tile {default_spawn_tile_x},{default_spawn_tile_y})"

    all_placed_world_rects_for_bounds: List[pygame.Rect] = []
    print(f"DEBUG MAP_UTILS: Processing {len(editor_state.placed_objects)} objects for .py export.")

    for i, obj_data in enumerate(editor_state.placed_objects):
        game_type_id = obj_data.get("game_type_id")
        world_x = obj_data.get("world_x")
        world_y = obj_data.get("world_y")
        asset_editor_key = obj_data.get("asset_editor_key")

        if not all([game_type_id, world_x is not None, world_y is not None, asset_editor_key]):
            print(f"Warning MAP_UTILS: Export - Object at index {i} missing data, skipping: {obj_data}")
            continue
        
        asset_config = ED_CONFIG.EDITOR_PALETTE_ASSETS.get(asset_editor_key)
        
        # Determine object size for bounds calculation and export
        obj_width_px = editor_state.grid_size # Default
        obj_height_px = editor_state.grid_size # Default

        if asset_config:
            if "surface_params" in asset_config: # For simple colored rects
                obj_width_px = asset_config["surface_params"][0]
                obj_height_px = asset_config["surface_params"][1]
            elif asset_editor_key in editor_state.assets_palette: # For image-based assets
                palette_asset_data = editor_state.assets_palette[asset_editor_key]
                original_size = palette_asset_data.get("original_size_pixels")
                if original_size and len(original_size) == 2:
                    obj_width_px, obj_height_px = original_size
                else:
                    print(f"Warning MAP_UTILS: Asset '{asset_editor_key}' missing valid 'original_size_pixels' in assets_palette. Using grid_size for export bounds.")
        else:
             print(f"Warning MAP_UTILS: Asset key '{asset_editor_key}' for object (type '{game_type_id}') not in ED_CONFIG. Using grid_size for export bounds.")
        
        current_obj_rect = pygame.Rect(world_x, world_y, obj_width_px, obj_height_px)
        all_placed_world_rects_for_bounds.append(current_obj_rect)

        # --- Object type to code generation ---
        if game_type_id == "platform_wall_gray":
            platforms_code_lines.append(f"    platforms.add(Platform({world_x}, {world_y}, {obj_width_px}, {obj_height_px}, C.GRAY, platform_type='wall'))")
        elif game_type_id == "platform_ledge_green":
            platforms_code_lines.append(f"    platforms.add(Platform({world_x}, {world_y}, {obj_width_px}, {obj_height_px}, C.DARK_GREEN, platform_type='ledge'))")
        elif game_type_id == "hazard_lava": # Assuming Lava takes full tile size (or its original pixel size)
            hazards_code_lines.append(f"    hazards.add(Lava({world_x}, {world_y}, {obj_width_px}, {obj_height_px}, C.ORANGE_RED))")
        elif game_type_id == "player1_spawn":
            # Player spawn point is usually midbottom of the visual representation
            spawn_mid_x = world_x + obj_width_px // 2
            spawn_bottom_y = world_y + obj_height_px 
            player1_spawn_str = f"player1_spawn = ({spawn_mid_x}, {spawn_bottom_y})"
        elif "enemy" in game_type_id: # Generic enemy handling
            specific_enemy_color_id = game_type_id.split('_')[-1] if '_' in game_type_id else "unknown_enemy_color"
            # Enemy spawn point is usually midbottom
            spawn_mid_x = world_x + obj_width_px // 2
            spawn_bottom_y = world_y + obj_height_px
            enemy_spawns_code_lines.append(f"    enemy_spawns_data.append({{'pos': ({spawn_mid_x}, {spawn_bottom_y}), 'patrol': None, 'enemy_color_id': '{specific_enemy_color_id}'}})")
        elif game_type_id == "chest":
            # Chest spawn point is usually midbottom
            chest_spawn_x_midbottom = world_x + obj_width_px // 2
            chest_spawn_y_midbottom = world_y + obj_height_px
            collectible_spawns_code_lines.append(f"    collectible_spawns_data.append({{'type': 'chest', 'pos': ({chest_spawn_x_midbottom}, {chest_spawn_y_midbottom})}})")
        # Add other object types here (e.g., ladders)
        # elif game_type_id == "ladder":
        #     ladders_code_lines.append(f"    ladders.add(Ladder({world_x}, {world_y}, {obj_width_px}, {obj_height_px}))")
        else:
            print(f"Warning MAP_UTILS: Unknown game_type_id '{game_type_id}' for object at ({world_x},{world_y}). Not exported to .py.")


    platforms_code_str = "\n".join(platforms_code_lines)
    ladders_code_str = "\n".join(ladders_code_lines)
    hazards_code_str = "\n".join(hazards_code_lines)
    enemy_spawns_code_str = "\n".join(enemy_spawns_code_lines)
    collectible_spawns_code_str = "\n".join(collectible_spawns_code_lines)
    print(f"DEBUG MAP_UTILS: Generated code lines - Platforms: {len(platforms_code_lines)}, Ladders: {len(ladders_code_lines)}, etc.")

    # --- Calculate Map Boundaries for Game ---
    if not all_placed_world_rects_for_bounds: # Empty map
        print("DEBUG MAP_UTILS: No objects placed, using default map dimensions for export boundaries.")
        map_min_x_content = 0
        map_max_x_content = editor_state.get_map_pixel_width()
        map_min_y_content = 0
        map_max_y_content = editor_state.get_map_pixel_height()
    else:
        map_min_x_content = min(r.left for r in all_placed_world_rects_for_bounds)
        map_max_x_content = max(r.right for r in all_placed_world_rects_for_bounds)
        map_min_y_content = min(r.top for r in all_placed_world_rects_for_bounds)
        map_max_y_content = max(r.bottom for r in all_placed_world_rects_for_bounds)
    
    # Add padding around content for camera movement and player safety
    padding_px = C.TILE_SIZE * 2 
    game_map_total_width_pixels = int(max(ED_CONFIG.EDITOR_SCREEN_INITIAL_WIDTH, (map_max_x_content - map_min_x_content) + 2 * padding_px))
    # Ensure total width covers at least the editor's view of the map or the content width + padding

    # Absolute Y coordinates for the game camera system and boundaries
    game_level_min_y_absolute = int(map_min_y_content - padding_px) 
    game_level_max_y_absolute = int(map_max_y_content + padding_px) 
    
    # Reference for ground, typically where player stands or bottom of lowest platform
    game_main_ground_y_reference = int(map_max_y_content) 
    game_main_ground_height_reference = int(C.TILE_SIZE) # Typical tile height

    if game_level_min_y_absolute >= game_level_max_y_absolute :
        print(f"Warning MAP_UTILS: Calculated min_y_abs ({game_level_min_y_absolute}) >= max_y_abs ({game_level_max_y_absolute}) for map '{editor_state.map_name_for_function}'. Adjusting max_y_abs.")
        game_level_max_y_absolute = game_level_min_y_absolute + C.TILE_SIZE * 5 # Ensure some height

    print(f"DEBUG MAP_UTILS: Export boundaries - TotalWidthPx: {game_map_total_width_pixels}, MinYAbs: {game_level_min_y_absolute}, MaxYAbs: {game_level_max_y_absolute}")

    script_content = f"""# Level: {editor_state.map_name_for_function}
# Generated by Platformer Level Editor on {pygame.time.get_ticks()}
import pygame
from tiles import Platform, Ladder, Lava # Ensure all used tile types are imported by game
import constants as C

# Optional: Define level-specific background color if your game supports it
LEVEL_SPECIFIC_BACKGROUND_COLOR = {editor_state.background_color}

def {function_name}(initial_screen_width, initial_screen_height):
    \"\"\"
    Loads the '{editor_state.map_name_for_function}' level.
    Generated by the level editor.
    \"\"\"
    print(f"Loading map: {function_name}...") # Game-side log
    platforms = pygame.sprite.Group()
    ladders = pygame.sprite.Group()
    hazards = pygame.sprite.Group()
    enemy_spawns_data = []
    collectible_spawns_data = []

    {player1_spawn_str}
    
    # --- Placed Objects ---
{platforms_code_str if platforms_code_str else "    # No platforms placed."}
{ladders_code_str if ladders_code_str else "    # No ladders placed."}
{hazards_code_str if hazards_code_str else "    # No hazards placed."}
{enemy_spawns_code_str if enemy_spawns_code_str else "    # No enemy spawns defined."}
{collectible_spawns_code_str if collectible_spawns_code_str else "    # No collectible spawns defined."}

    # --- Level Dimensions for Game Camera & Boundaries ---
    map_total_width_pixels = {game_map_total_width_pixels}
    level_min_y_absolute = {game_level_min_y_absolute} # Top-most Y coordinate for camera/content
    level_max_y_absolute = {game_level_max_y_absolute} # Bottom-most Y coordinate for camera/content (e.g., death plane below this)
    
    main_ground_y_reference = {game_main_ground_y_reference} # Y-value of the main 'floor' surface
    main_ground_height_reference = {game_main_ground_height_reference} # Height of typical ground tiles

    # --- Auto-generated Boundary Walls (Invisible in game unless styled) ---
    # These ensure entities cannot go outside the defined level space.
    _boundary_thickness = C.TILE_SIZE * 2 # Make them thick enough
    _boundary_wall_height = level_max_y_absolute - level_min_y_absolute + (2 * _boundary_thickness) # Span slightly beyond min/max_y

    # Top boundary (ceiling) - place its bottom edge at level_min_y_absolute
    platforms.add(Platform(0, level_min_y_absolute - _boundary_thickness, map_total_width_pixels, _boundary_thickness, C.DARK_GRAY, platform_type="boundary_wall_top"))
    # Bottom boundary (floor/kill plane) - place its top edge at level_max_y_absolute
    platforms.add(Platform(0, level_max_y_absolute, map_total_width_pixels, _boundary_thickness, C.DARK_GRAY, platform_type="boundary_wall_bottom"))
    # Left boundary wall
    platforms.add(Platform(-_boundary_thickness, level_min_y_absolute - _boundary_thickness, _boundary_thickness, _boundary_wall_height, C.DARK_GRAY, platform_type="boundary_wall_left"))
    # Right boundary wall
    platforms.add(Platform(map_total_width_pixels, level_min_y_absolute - _boundary_thickness, _boundary_thickness, _boundary_wall_height, C.DARK_GRAY, platform_type="boundary_wall_right"))

    print(f"Map '{function_name}' loaded with: {{len(platforms)}} platforms, {{len(ladders)}} ladders, {{len(hazards)}} hazards.") # Game-side log
    return (platforms, ladders, hazards, enemy_spawns_data, collectible_spawns_data,
            player1_spawn,
            map_total_width_pixels, level_min_y_absolute, level_max_y_absolute,
            main_ground_y_reference, main_ground_height_reference,
            LEVEL_SPECIFIC_BACKGROUND_COLOR) # Return background color
"""
    py_filepath = editor_state.current_map_filename 
    print(f"DEBUG MAP_UTILS: Final .py script content to write to '{py_filepath}':\n{script_content[:500]}...") # Log start of content

    try:
        with open(py_filepath, "w") as f:
            f.write(script_content)
        success_msg = f"Map exported to game script: {os.path.basename(py_filepath)}"
        print(f"DEBUG MAP_UTILS: {success_msg}")
        editor_state.set_status_message(success_msg)
        editor_state.unsaved_changes = False # Crucial: set unsaved to false AFTER successful .py export
        print(f"DEBUG MAP_UTILS: unsaved_changes set to False after .py export.")
        return True
    except IOError as e:
        error_msg = f"IOError exporting map to .py '{py_filepath}': {e}"
    except Exception as e:
        error_msg = f"Unexpected error during .py export to '{py_filepath}': {e}"
        traceback.print_exc()
        
    print(f"ERROR MAP_UTILS: {error_msg}")
    editor_state.set_status_message(error_msg, 4)
    return False

########## START OF FILE: editor_state.py ##########

# editor_state.py
# -*- coding: utf-8 -*-
"""
## version 1.0.0.6 (Added painting/erasing state attributes)
Defines the EditorState class, which holds all the dynamic state
and data for the level editor.
"""

import pygame
from typing import Optional, Dict, List, Tuple, Any, Callable 
import traceback 

import editor_config as ED_CONFIG

class EditorState:
    """
    Manages the current state of the level editor, including map data,
    UI selections, and editor modes.
    """
    def __init__(self):
        print("DEBUG STATE: Initializing EditorState...")
        # --- Map Data & File ---
        self.current_map_data: Dict[str, Any] = {}
        self.current_map_filename: Optional[str] = None
        self.map_name_for_function: str = "untitled_map"

        self.map_width_tiles: int = ED_CONFIG.DEFAULT_MAP_WIDTH_TILES
        self.map_height_tiles: int = ED_CONFIG.DEFAULT_MAP_HEIGHT_TILES
        self.grid_size: int = ED_CONFIG.DEFAULT_GRID_SIZE
        self.background_color: Tuple[int, int, int] = ED_CONFIG.DEFAULT_BACKGROUND_COLOR

        self.map_content_surface: Optional[pygame.Surface] = None

        # --- Placed Objects ---
        self.placed_objects: List[Dict[str, Any]] = []

        # --- Asset Palette & Selection ---
        self.assets_palette: Dict[str, Dict[str, Any]] = {}
        self._selected_asset_editor_key: Optional[str] = None
        self.selected_asset_image_for_cursor: Optional[pygame.Surface] = None
        self.asset_palette_scroll_y: int = 0
        self.total_asset_palette_content_height: int = 0

        # --- Map View & Camera ---
        self.camera_offset_x: int = 0
        self.camera_offset_y: int = 0
        self.show_grid: bool = True

        # --- Object Interaction ---
        self.dragging_object_index: Optional[int] = None
        self.drag_start_mouse_map_x: int = 0
        self.drag_start_mouse_map_y: int = 0
        self.drag_object_original_x: int = 0
        self.drag_object_original_y: int = 0

        # --- Tile Painting/Erasing State --- # ENSURE THESE ARE PRESENT
        self.is_painting_tiles: bool = False
        self.last_painted_tile_coords: Optional[Tuple[int, int]] = None
        self.is_erasing_tiles: bool = False 
        self.last_erased_tile_coords: Optional[Tuple[int, int]] = None
        # --- End Tile Painting/Erasing State ---

        # --- UI State ---
        self._current_editor_mode: str = "menu"
        self.unsaved_changes: bool = False
        self.hovered_tooltip_text: Optional[str] = None
        self.hovered_tooltip_pos: Optional[Tuple[int, int]] = None
        self.ui_elements_rects: Dict[str, Any] = {} 

        # --- Dialogs and Input Fields ---
        self._active_dialog_type: Optional[str] = None
        self.dialog_input_text: str = ""
        self.dialog_prompt_message: str = ""
        self.dialog_input_default: str = ""
        self.dialog_callback_confirm: Optional[Callable[..., None]] = None
        self.dialog_callback_cancel: Optional[Callable[[], None]] = None
        self.dialog_rect: Optional[pygame.Rect] = None 

        self.color_picker_rects: Dict[str, pygame.Rect] = {} 
        self.dialog_file_list: List[str] = []
        self.dialog_file_scroll_y: int = 0
        self.dialog_selected_file_index: int = -1
        self.is_dragging_scrollbar: bool = False
        self.scrollbar_drag_mouse_offset_y: int = 0

        self.map_name_for_function_input: str = "" 

        # --- Status Messages ---
        self.status_message: Optional[str] = None
        self.status_message_timer: float = 0.0
        self.status_message_duration: float = 3.0 

        # --- Final Initialization Steps ---
        self.recreate_map_content_surface() 
        print("DEBUG STATE: EditorState initialization complete.")

    @property
    def current_editor_mode(self) -> str:
        return self._current_editor_mode

    @current_editor_mode.setter
    def current_editor_mode(self, value: str):
        if self._current_editor_mode != value:
            print(f"DEBUG STATE: current_editor_mode changed from '{self._current_editor_mode}' to '{value}'")
            self._current_editor_mode = value

    @property
    def active_dialog_type(self) -> Optional[str]:
        return self._active_dialog_type

    @active_dialog_type.setter
    def active_dialog_type(self, value: Optional[str]):
        if self._active_dialog_type != value:
            old_dialog_type = self._active_dialog_type 
            print(f"DEBUG STATE: active_dialog_type changed from '{old_dialog_type}' to '{value}'")
            self._active_dialog_type = value
            if value is None or (old_dialog_type is not None and old_dialog_type != value):
                keys_to_remove = []
                if old_dialog_type == "file_load":
                    keys_to_remove.extend(['dialog_file_item_rects', 'file_dialog_scrollbar_handle',
                                           'file_dialog_scrollbar_area', 'dialog_file_load_ok', 'dialog_file_load_cancel'])
                elif old_dialog_type == "color_picker": self.color_picker_rects.clear()
                removed_count = 0
                for key in keys_to_remove:
                    if key in self.ui_elements_rects:
                        try: del self.ui_elements_rects[key]; removed_count +=1
                        except KeyError: pass 
                if removed_count > 0: print(f"DEBUG STATE: Cleared {removed_count} UI rect(s) for dialog '{old_dialog_type}'.")
            if value is None: self.dialog_rect = None

    @property
    def selected_asset_editor_key(self) -> Optional[str]:
        return self._selected_asset_editor_key

    @selected_asset_editor_key.setter
    def selected_asset_editor_key(self, value: Optional[str]):
        if self._selected_asset_editor_key != value:
            print(f"DEBUG STATE: selected_asset_editor_key changed from '{self._selected_asset_editor_key}' to '{value}'")
            self._selected_asset_editor_key = value

    def recreate_map_content_surface(self):
        map_pixel_width = self.map_width_tiles * self.grid_size
        map_pixel_height = self.map_height_tiles * self.grid_size
        safe_width, safe_height = max(1, map_pixel_width), max(1, map_pixel_height)
        try:
            self.map_content_surface = pygame.Surface((safe_width, safe_height))
            print(f"DEBUG STATE: Recreated map_content_surface: {safe_width}x{safe_height}")
        except pygame.error as e:
            print(f"ERROR STATE: Failed to create map_content_surface: {e}"); traceback.print_exc()
            try: self.map_content_surface = pygame.Surface((ED_CONFIG.DEFAULT_GRID_SIZE, ED_CONFIG.DEFAULT_GRID_SIZE))
            except Exception as e_fallback: self.map_content_surface = None; print(f"CRITICAL STATE: Fallback surface failed: {e_fallback}")

    def get_map_pixel_width(self) -> int: return self.map_width_tiles * self.grid_size
    def get_map_pixel_height(self) -> int: return self.map_height_tiles * self.grid_size
    def set_status_message(self, message: str, duration: float = 3.0):
        self.status_message, self.status_message_duration, self.status_message_timer = message, duration, duration
        print(f"STATUS MSG: {message} (duration: {duration:.1f}s)")

    def update_status_message(self, dt: float):
        if self.status_message and self.status_message_timer > 0:
            self.status_message_timer -= dt
            if self.status_message_timer <= 0: self.status_message, self.status_message_timer = None, 0.0

    def reset_map_context(self):
        print("DEBUG STATE: reset_map_context called.")
        self.map_name_for_function = "untitled_map"; self.current_map_filename = None
        self.placed_objects = []; self.map_width_tiles = ED_CONFIG.DEFAULT_MAP_WIDTH_TILES
        self.map_height_tiles = ED_CONFIG.DEFAULT_MAP_HEIGHT_TILES; self.background_color = ED_CONFIG.DEFAULT_BACKGROUND_COLOR
        self.camera_offset_x, self.camera_offset_y = 0, 0; self.unsaved_changes = False
        self.selected_asset_editor_key, self.selected_asset_image_for_cursor = None, None
        self.is_painting_tiles, self.last_painted_tile_coords = False, None # Reset painting state
        self.is_erasing_tiles, self.last_erased_tile_coords = False, None   # Reset erasing state
        # self.recreate_map_content_surface() # Typically called by init_new_map or load_map
        print(f"DEBUG STATE: Map context reset. Map name: '{self.map_name_for_function}'.")

########## START OF FILE: editor_ui.py ##########

# editor_ui.py
# -*- coding: utf-8 -*-
"""
## version 1.0.0.6 (Added more debug prints for dialog start and drawing)
Pygame-based UI functions for the Level Editor.
Includes buttons, input dialogs, color pickers, and tooltips.
"""
import pygame
import os
from typing import Optional, Dict, Tuple, Any, Callable, List
import traceback # ADDED for more detailed error reporting

# --- Add parent directory to sys.path for editor_config & editor_state if this file is run standalone (unlikely here) ---
# This is more robustly handled in the main editor.py script.
# current_script_path_ui = os.path.dirname(os.path.abspath(__file__))
# parent_directory_ui = os.path.dirname(current_script_path_ui) # This should be 'editor'
# project_root_ui = os.path.dirname(parent_directory_ui) # This should be 'Platformer'
# if project_root_ui not in sys.path:
#     sys.path.insert(0, project_root_ui)
# if parent_directory_ui not in sys.path: # If editor_config is in 'editor' not project root
#    sys.path.insert(0, parent_directory_ui)


import editor_config as ED_CONFIG
from editor_state import EditorState
# Assuming constants.py (referenced by ED_CONFIG.C) is accessible from the project root.
# This setup relies on editor.py correctly setting up sys.path.

# --- UI Drawing Helpers ---

def draw_button(surface: pygame.Surface,
                rect: pygame.Rect,
                text: str,
                font: Optional[pygame.font.Font],
                mouse_pos: Tuple[int, int],
                text_color: Tuple[int, int, int] = ED_CONFIG.BUTTON_TEXT_COLOR,
                button_color_normal: Tuple[int, int, int] = ED_CONFIG.BUTTON_COLOR_NORMAL,
                button_color_hover: Tuple[int, int, int] = ED_CONFIG.BUTTON_COLOR_HOVER,
                border_color: Tuple[int, int, int] = ED_CONFIG.BUTTON_COLOR_BORDER,
                border_width: int = ED_CONFIG.BUTTON_BORDER_WIDTH,
                is_active: bool = True) -> bool:
    # print(f"DEBUG UI_DRAW: draw_button called for '{text}' at {rect}, active={is_active}") # Can be verbose
    is_hovered = False
    if is_active and rect.collidepoint(mouse_pos):
        is_hovered = True

    current_button_color = button_color_normal
    current_text_color = text_color

    if not is_active:
        current_button_color = tuple(int(c * 0.67) for c in button_color_normal) # Darker shade
        current_text_color = tuple(int(c * 0.67) for c in text_color)
    elif is_hovered:
        current_button_color = button_color_hover

    try:
        pygame.draw.rect(surface, current_button_color, rect)
        if border_width > 0:
            pygame.draw.rect(surface, border_color, rect, border_width)
        
        if font:
            text_surf = font.render(text, True, current_text_color)
            text_rect = text_surf.get_rect(center=rect.center)
            surface.blit(text_surf, text_rect)
        else:
            print(f"Warning UI_DRAW: draw_button called with no font for text '{text}'")
    except Exception as e:
        print(f"ERROR UI_DRAW: Exception in draw_button for '{text}': {e}")
        traceback.print_exc()
        
    return is_hovered

def draw_tooltip(surface: pygame.Surface,
                 editor_state: EditorState,
                 font: Optional[pygame.font.Font]):
    if editor_state.hovered_tooltip_text and editor_state.hovered_tooltip_pos and font:
        # print(f"DEBUG UI_DRAW: Drawing tooltip: '{editor_state.hovered_tooltip_text}' at {editor_state.hovered_tooltip_pos}") # Verbose
        try:
            text_surf = font.render(editor_state.hovered_tooltip_text, True, ED_CONFIG.TOOLTIP_TEXT_COLOR)
            text_rect = text_surf.get_rect(
                topleft=(editor_state.hovered_tooltip_pos[0] + 15,
                         editor_state.hovered_tooltip_pos[1] + 15)
            )
            bg_rect = text_rect.inflate(ED_CONFIG.TOOLTIP_PADDING * 2, ED_CONFIG.TOOLTIP_PADDING * 2)

            bg_rect.clamp_ip(surface.get_rect()) # Ensure tooltip stays on screen
            text_rect.clamp_ip(bg_rect.inflate(-ED_CONFIG.TOOLTIP_PADDING, -ED_CONFIG.TOOLTIP_PADDING)) # And text within tooltip bg

            pygame.draw.rect(surface, ED_CONFIG.TOOLTIP_BG_COLOR, bg_rect, border_radius=3)
            pygame.draw.rect(surface, ED_CONFIG.BUTTON_COLOR_BORDER, bg_rect, 1, border_radius=3)
            surface.blit(text_surf, text_rect)
        except Exception as e:
            print(f"ERROR UI_DRAW: Exception in draw_tooltip for '{editor_state.hovered_tooltip_text}': {e}")
            traceback.print_exc()

def draw_status_message(surface: pygame.Surface, editor_state: EditorState, font: Optional[pygame.font.Font]):
    if editor_state.status_message and font:
        # print(f"DEBUG UI_DRAW: Drawing status message: '{editor_state.status_message}'") # Verbose
        try:
            message_surf = font.render(editor_state.status_message, True, ED_CONFIG.C.YELLOW)
            message_rect = message_surf.get_rect(centerx=surface.get_width() // 2,
                                                  bottom=surface.get_height() - 10)
            bg_padding = 5
            bg_rect = message_rect.inflate(bg_padding * 2, bg_padding * 2)
            bg_rect.clamp_ip(surface.get_rect())
            message_rect.clamp_ip(bg_rect)

            s = pygame.Surface(bg_rect.size, pygame.SRCALPHA)
            s.fill((50, 50, 50, 180)) # Semi-transparent dark background
            surface.blit(s, bg_rect.topleft)
            surface.blit(message_surf, message_rect)
        except Exception as e:
            print(f"ERROR UI_DRAW: Exception in draw_status_message for '{editor_state.status_message}': {e}")
            traceback.print_exc()

# --- Pygame-based Dialogs ---

def start_text_input_dialog(editor_state: EditorState,
                            prompt: str,
                            default_text: str = "",
                            on_confirm: Optional[Callable[[str], None]] = None,
                            on_cancel: Optional[Callable[[], None]] = None):
    print(f"DEBUG UI_DIALOG: start_text_input_dialog. Prompt: '{prompt}', Default: '{default_text}', HasConfirm: {on_confirm is not None}, HasCancel: {on_cancel is not None}")
    editor_state.active_dialog_type = "text_input"
    editor_state.dialog_prompt_message = prompt
    editor_state.dialog_input_text = default_text
    editor_state.dialog_input_default = default_text # Store original default
    editor_state.dialog_callback_confirm = on_confirm
    editor_state.dialog_callback_cancel = on_cancel
    editor_state.dialog_rect = None # Will be set by draw_active_dialog

def start_color_picker_dialog(editor_state: EditorState,
                              on_confirm: Optional[Callable[[Tuple[int,int,int]], None]] = None,
                              on_cancel: Optional[Callable[[], None]] = None):
    print(f"DEBUG UI_DIALOG: start_color_picker_dialog. HasConfirm: {on_confirm is not None}, HasCancel: {on_cancel is not None}")
    editor_state.active_dialog_type = "color_picker"
    editor_state.dialog_prompt_message = "Select Background Color (Esc to Cancel)"
    editor_state.color_picker_rects.clear() 
    
    cols = ED_CONFIG.COLOR_PICKER_COLS
    button_size = ED_CONFIG.COLOR_PICKER_BUTTON_SIZE
    padding = ED_CONFIG.COLOR_PICKER_PADDING
    
    start_x_in_dialog = padding * 2 
    current_y_in_dialog = 50 
    current_x_in_dialog = start_x_in_dialog
    idx = 0
    for name in ED_CONFIG.COLOR_PICKER_PRESETS.keys():
        rect = pygame.Rect(current_x_in_dialog, current_y_in_dialog, button_size, button_size)
        editor_state.color_picker_rects[name] = rect 
        current_x_in_dialog += button_size + padding
        idx += 1
        if idx % cols == 0:
            current_x_in_dialog = start_x_in_dialog
            current_y_in_dialog += button_size + padding
            
    editor_state.dialog_callback_confirm = on_confirm
    editor_state.dialog_callback_cancel = on_cancel
    editor_state.dialog_rect = None

def start_file_load_dialog(editor_state: EditorState,
                           on_confirm: Optional[Callable[[str], None]] = None,
                           on_cancel: Optional[Callable[[], None]] = None,
                           initial_path: str = ED_CONFIG.MAPS_DIRECTORY,
                           file_extension: str = ED_CONFIG.LEVEL_EDITOR_SAVE_FORMAT_EXTENSION):
    print(f"DEBUG UI_DIALOG: start_file_load_dialog. Path: '{initial_path}', Ext: '{file_extension}', HasConfirm: {on_confirm is not None}, HasCancel: {on_cancel is not None}")
    editor_state.active_dialog_type = "file_load"
    editor_state.dialog_prompt_message = f"Select Map to Load (from ./{initial_path})"
    editor_state.dialog_input_text = "" 
    editor_state.dialog_file_list = []
    editor_state.dialog_file_scroll_y = 0
    editor_state.dialog_selected_file_index = -1 
    editor_state.dialog_rect = None

    # Ensure ui_elements_rects key for file items exists and is cleared
    if 'dialog_file_item_rects' not in editor_state.ui_elements_rects:
        editor_state.ui_elements_rects['dialog_file_item_rects'] = []
    else:
        editor_state.ui_elements_rects['dialog_file_item_rects'].clear()

    if not os.path.exists(initial_path):
        try:
            os.makedirs(initial_path)
            print(f"DEBUG UI_DIALOG: Created maps directory at '{initial_path}' during file_load_dialog start.")
            editor_state.set_status_message(f"Created maps dir '{initial_path}'. No files yet.", 2)
        except OSError as e:
            err_msg = f"Error creating dir '{initial_path}': {e}"
            editor_state.set_status_message(err_msg, 3)
            print(f"ERROR UI_DIALOG: {err_msg}")
            if on_cancel: on_cancel()
            editor_state.active_dialog_type = None # Critical error, abort dialog
            return

    try:
        for item in os.listdir(initial_path):
            if item.endswith(file_extension) and os.path.isfile(os.path.join(initial_path, item)): # Check if it's a file
                editor_state.dialog_file_list.append(item)
        editor_state.dialog_file_list.sort()
        print(f"DEBUG UI_DIALOG: Found files in '{initial_path}': {editor_state.dialog_file_list}")
    except OSError as e:
        err_msg = f"Error listing files in '{initial_path}': {e}"
        editor_state.set_status_message(err_msg, 3)
        print(f"ERROR UI_DIALOG: {err_msg}")
        if on_cancel: on_cancel()
        editor_state.active_dialog_type = None # Critical error, abort dialog
        return
    
    if not editor_state.dialog_file_list:
        editor_state.set_status_message(f"No '{file_extension}' files found in ./{initial_path}", 2.5)

    editor_state.dialog_callback_confirm = on_confirm
    editor_state.dialog_callback_cancel = on_cancel


def draw_active_dialog(surface: pygame.Surface, editor_state: EditorState, fonts: Dict[str, Optional[pygame.font.Font]]):
    if not editor_state.active_dialog_type:
        return
    
    # print(f"DEBUG UI_DRAW_DIALOG: Drawing dialog type '{editor_state.active_dialog_type}'") # Can be verbose

    try:
        screen_center_x, screen_center_y = surface.get_rect().center
        dialog_width, dialog_height = 450, 350 # Default size

        if editor_state.active_dialog_type == "text_input":
            dialog_width, dialog_height = 400, 200
        elif editor_state.active_dialog_type == "color_picker":
            num_colors = len(ED_CONFIG.COLOR_PICKER_PRESETS)
            cols = ED_CONFIG.COLOR_PICKER_COLS
            rows = (num_colors + cols - 1) // cols
            content_w = cols * ED_CONFIG.COLOR_PICKER_BUTTON_SIZE + (cols -1 if cols > 0 else 0) * ED_CONFIG.COLOR_PICKER_PADDING
            content_h = rows * ED_CONFIG.COLOR_PICKER_BUTTON_SIZE + (rows -1 if rows > 0 else 0) * ED_CONFIG.COLOR_PICKER_PADDING
            dialog_width = max(300, content_w + ED_CONFIG.COLOR_PICKER_PADDING * 4) # Padding around content
            title_space = 60 # Approx space for title and margin
            dialog_height = max(200, content_h + title_space + ED_CONFIG.COLOR_PICKER_PADDING * 2) 
        elif editor_state.active_dialog_type == "file_load":
            dialog_width, dialog_height = 400, 350

        # Calculate dialog_rect and store it in editor_state (critical for event handling)
        current_dialog_rect = pygame.Rect(0, 0, dialog_width, dialog_height)
        current_dialog_rect.center = screen_center_x, screen_center_y
        editor_state.dialog_rect = current_dialog_rect # Update state

        pygame.draw.rect(surface, ED_CONFIG.DIALOG_BG_COLOR, current_dialog_rect, border_radius=5)
        pygame.draw.rect(surface, ED_CONFIG.C.BLACK, current_dialog_rect, 2, border_radius=5)

        prompt_font = fonts.get("medium") or ED_CONFIG.FONT_CONFIG.get("medium")
        if prompt_font and editor_state.dialog_prompt_message:
            prompt_surf = prompt_font.render(editor_state.dialog_prompt_message, True, ED_CONFIG.DIALOG_PROMPT_COLOR)
            prompt_draw_rect = prompt_surf.get_rect(midtop=(current_dialog_rect.centerx, current_dialog_rect.top + 15))
            surface.blit(prompt_surf, prompt_draw_rect)

        # --- Specific Dialog Content ---
        if editor_state.active_dialog_type == "text_input":
            _draw_text_input_content(surface, editor_state, current_dialog_rect, fonts)
        elif editor_state.active_dialog_type == "color_picker":
            _draw_color_picker_content(surface, editor_state, current_dialog_rect, fonts)
        elif editor_state.active_dialog_type == "file_load":
            _draw_file_load_content(surface, editor_state, current_dialog_rect, fonts)

    except Exception as e:
        print(f"ERROR UI_DRAW_DIALOG: Exception in draw_active_dialog for type '{editor_state.active_dialog_type}': {e}")
        traceback.print_exc()
        # Optionally, draw an error message on the dialog itself
        error_font = fonts.get("small")
        if error_font and editor_state.dialog_rect:
            err_surf = error_font.render(f"Dialog Error! See console.", True, ED_CONFIG.C.RED)
            surface.blit(err_surf, err_surf.get_rect(center=editor_state.dialog_rect.center))


def _draw_text_input_content(surface: pygame.Surface, editor_state: EditorState, dialog_rect: pygame.Rect, fonts: Dict[str, Optional[pygame.font.Font]]):
    input_box_rect = pygame.Rect(0, 0, dialog_rect.width - 40, 40)
    input_box_rect.center = dialog_rect.centerx, dialog_rect.centery + 10 # Position below prompt
    
    pygame.draw.rect(surface, ED_CONFIG.DIALOG_INPUT_BOX_COLOR, input_box_rect)
    pygame.draw.rect(surface, ED_CONFIG.C.BLACK, input_box_rect, 2)

    text_font = fonts.get("medium") or ED_CONFIG.FONT_CONFIG.get("medium")
    if text_font:
        current_text_to_render = str(editor_state.dialog_input_text) if editor_state.dialog_input_text is not None else ""
        input_text_surf = text_font.render(current_text_to_render, True, ED_CONFIG.DIALOG_INPUT_TEXT_COLOR)
        
        text_clip_area_rect = input_box_rect.inflate(-12, -12) # Padding inside input box
        
        text_surf_width = input_text_surf.get_width()
        blit_area = None # Part of the input_text_surf to blit (for scrolling)
        
        # Default: text fits or is empty, draw from its left
        text_draw_pos_on_surface_x = text_clip_area_rect.left 

        if text_surf_width > text_clip_area_rect.width:
            # Text is wider than clip area, show the end part (cursor is at the end)
            # Blit the source surface such that its right edge aligns with clip_area's right
            text_draw_pos_on_surface_x = text_clip_area_rect.right - text_surf_width
            # Define the part of the source text surface to actually draw
            blit_source_x_offset = text_surf_width - text_clip_area_rect.width
            blit_area = pygame.Rect(blit_source_x_offset, 0, text_clip_area_rect.width, input_text_surf.get_height())
        
        blit_destination_topleft = (text_draw_pos_on_surface_x, 
                                    text_clip_area_rect.top + (text_clip_area_rect.height - input_text_surf.get_height()) // 2)

        original_clip = surface.get_clip()
        surface.set_clip(text_clip_area_rect)
        surface.blit(input_text_surf, blit_destination_topleft, area=blit_area)
        surface.set_clip(original_clip)

        # Cursor positioning: cursor should be at the end of the *rendered* text within the clip_area
        # If text was scrolled (blit_area is set), cursor is at the right of clip_area.
        # Otherwise, it's at the end of the un-scrolled text.
        if blit_area: # Text was wider than field
            cursor_render_x = text_clip_area_rect.right -1 # Slightly inside the box
        else: # Text fits
            cursor_render_x = text_clip_area_rect.left + input_text_surf.get_width() + 1
        
        # Clamp cursor to be visible within the input box's drawable area
        cursor_render_x = max(text_clip_area_rect.left, min(cursor_render_x, text_clip_area_rect.right -1))

        if int(pygame.time.get_ticks() / 500) % 2 == 0: # Blinking cursor
             pygame.draw.line(surface, ED_CONFIG.DIALOG_CURSOR_COLOR,
                             (cursor_render_x, input_box_rect.top + 5),
                             (cursor_render_x, input_box_rect.bottom - 5), 2)
    
    info_font = fonts.get("small") or ED_CONFIG.FONT_CONFIG.get("small")
    if info_font:
        info_surf = info_font.render("Enter: Confirm, Esc: Cancel", True, ED_CONFIG.C.LIGHT_GRAY)
        surface.blit(info_surf, info_surf.get_rect(midbottom=(dialog_rect.centerx, dialog_rect.bottom - 10)))

def _draw_color_picker_content(surface: pygame.Surface, editor_state: EditorState, dialog_rect: pygame.Rect, fonts: Dict[str, Optional[pygame.font.Font]]):
    mouse_pos_dialog = pygame.mouse.get_pos() 
    for name, swatch_rect_relative in editor_state.color_picker_rects.items():
        # swatch_rect_relative is relative to dialog content area, not dialog_rect.topleft directly.
        # It was calculated based on current_x_in_dialog, current_y_in_dialog from start_color_picker_dialog.
        absolute_swatch_rect = swatch_rect_relative.move(dialog_rect.left, dialog_rect.top)
        color_val = ED_CONFIG.COLOR_PICKER_PRESETS.get(name, ED_CONFIG.C.MAGENTA)
        
        pygame.draw.rect(surface, color_val, absolute_swatch_rect)
        border_col = ED_CONFIG.C.BLACK
        border_w = 1
        if absolute_swatch_rect.collidepoint(mouse_pos_dialog):
            border_col = ED_CONFIG.COLOR_PICKER_HOVER_BORDER_COLOR
            border_w = 3
        pygame.draw.rect(surface, border_col, absolute_swatch_rect, border_w)

def _draw_file_load_content(surface: pygame.Surface, editor_state: EditorState, dialog_rect: pygame.Rect, fonts: Dict[str, Optional[pygame.font.Font]]):
    prompt_font = fonts.get("medium") or ED_CONFIG.FONT_CONFIG.get("medium")
    title_height = prompt_font.get_height() + 25 if prompt_font else 55 # Space for prompt + padding
    buttons_panel_height = ED_CONFIG.BUTTON_HEIGHT_STANDARD // 2 + 20 # Approx for OK/Cancel + padding
    
    list_area_y_start = dialog_rect.top + title_height
    list_area_height = dialog_rect.height - title_height - buttons_panel_height
    
    # Main area for the file list itself
    list_area_rect = pygame.Rect(dialog_rect.left + 10, list_area_y_start, dialog_rect.width - 20, list_area_height)
    pygame.draw.rect(surface, ED_CONFIG.DIALOG_INPUT_BOX_COLOR, list_area_rect) # Background for list
    pygame.draw.rect(surface, ED_CONFIG.C.BLACK, list_area_rect, 1) # Border for list area

    item_font = fonts.get("small") or ED_CONFIG.FONT_CONFIG.get("small")
    item_line_height = (item_font.get_height() + 6) if item_font else 22 # Height of one file item row
    
    # Clear previous item rects for hit detection
    editor_state.ui_elements_rects['dialog_file_item_rects'] = [] 

    # Clipping rect for drawing list items, slightly smaller than list_area_rect
    list_clip_rect = list_area_rect.inflate(-8, -8) # Content area for text, inside list_area_rect border

    total_content_height_pixels = len(editor_state.dialog_file_list) * item_line_height
    
    scrollbar_width_drawn = 0 # Actual width taken by scrollbar if drawn
    if total_content_height_pixels > list_clip_rect.height: # Content taller than visible area, need scrollbar
        scrollbar_width_drawn = 15 # Desired width of scrollbar
        # Scrollbar track is to the right of the list_clip_rect
        scrollbar_track_rect = pygame.Rect(list_clip_rect.right + 2, list_clip_rect.top,
                                          scrollbar_width_drawn, list_clip_rect.height)
        pygame.draw.rect(surface, ED_CONFIG.C.DARK_GRAY, scrollbar_track_rect) # Scrollbar background
        
        handle_height_ratio = min(1.0, list_clip_rect.height / total_content_height_pixels if total_content_height_pixels > 0 else 1.0)
        handle_height = max(20, scrollbar_track_rect.height * handle_height_ratio) # Min handle height
        
        scrollable_content_outside_view = max(0, total_content_height_pixels - list_clip_rect.height)
        current_scroll_ratio_of_hidden = editor_state.dialog_file_scroll_y / scrollable_content_outside_view if scrollable_content_outside_view > 0 else 0
        
        # Position handle within the track based on scroll ratio
        handle_y_pos_on_track = (scrollbar_track_rect.height - handle_height) * current_scroll_ratio_of_hidden
        
        scrollbar_handle_rect = pygame.Rect(scrollbar_track_rect.left, 
                                            scrollbar_track_rect.top + handle_y_pos_on_track, 
                                            scrollbar_width_drawn, handle_height)
        pygame.draw.rect(surface, ED_CONFIG.C.GRAY, scrollbar_handle_rect, border_radius=3) # Scrollbar handle
        
        # Store rects for event handling
        editor_state.ui_elements_rects['file_dialog_scrollbar_handle'] = scrollbar_handle_rect
        editor_state.ui_elements_rects['file_dialog_scrollbar_area'] = scrollbar_track_rect # The whole track area
    
    # Adjust width available for list item text if scrollbar is present
    list_item_text_render_width = list_clip_rect.width - (scrollbar_width_drawn + 2 if scrollbar_width_drawn > 0 else 0)

    original_clip_pygame = surface.get_clip() # Save Pygame's current clip region
    surface.set_clip(list_clip_rect) # Clip drawing to the content area of the list

    current_y_offset_in_clip_rect = 0 # Relative Y for drawing items inside list_clip_rect
    for i, filename in enumerate(editor_state.dialog_file_list):
        # Calculate actual screen Y position for this item, considering scroll
        item_draw_y_on_surface = list_clip_rect.top + current_y_offset_in_clip_rect - editor_state.dialog_file_scroll_y
        
        # This is the rect on the main surface where this item *would* be drawn if fully visible
        item_full_rect_on_screen = pygame.Rect(list_clip_rect.left, item_draw_y_on_surface, 
                                           list_item_text_render_width, item_line_height)
        
        # Only process/draw if this item is (at least partially) visible within the list_clip_rect
        if list_clip_rect.colliderect(item_full_rect_on_screen):
            # Store this on-screen rect for mouse collision detection
            editor_state.ui_elements_rects['dialog_file_item_rects'].append(
                {"text": filename, "rect": item_full_rect_on_screen, "index": i}
            )
            if item_font:
                text_color = ED_CONFIG.C.BLACK
                bg_color_item = ED_CONFIG.DIALOG_INPUT_BOX_COLOR # Default item background
                if editor_state.dialog_selected_file_index == i:
                    bg_color_item = ED_CONFIG.C.BLUE # Highlight selected item
                    text_color = ED_CONFIG.C.WHITE
                
                # Draw the item background (will be clipped by surface.set_clip)
                pygame.draw.rect(surface, bg_color_item, item_full_rect_on_screen)
                
                text_surf = item_font.render(filename, True, text_color)
                # Center text vertically in the item_full_rect_on_screen
                text_draw_pos = (item_full_rect_on_screen.left + 5, 
                                 item_full_rect_on_screen.centery - text_surf.get_height() // 2)
                surface.blit(text_surf, text_draw_pos)
        
        current_y_offset_in_clip_rect += item_line_height # Move to next item position

    surface.set_clip(original_clip_pygame) # Restore Pygame's original clip region

    # --- Draw OK/Cancel Buttons ---
    button_font = fonts.get("small") or ED_CONFIG.FONT_CONFIG.get("small")
    if button_font:
        btn_width = ED_CONFIG.BUTTON_WIDTH_STANDARD // 2 - 15 # Slightly smaller buttons for dialog
        btn_height = ED_CONFIG.BUTTON_HEIGHT_STANDARD // 2 + 5 # Slimmer buttons
        
        # Position buttons below the list_area_rect
        buttons_y_pos = list_area_rect.bottom + 10 
        
        ok_button_rect = pygame.Rect(dialog_rect.centerx - btn_width - 5, buttons_y_pos, btn_width, btn_height)
        cancel_button_rect = pygame.Rect(dialog_rect.centerx + 5, buttons_y_pos, btn_width, btn_height)
        
        mouse_pos = pygame.mouse.get_pos() # Get current mouse pos for button hover state
        
        # OK button is active only if a file is selected
        ok_is_active = (editor_state.dialog_selected_file_index != -1 and 
                        0 <= editor_state.dialog_selected_file_index < len(editor_state.dialog_file_list))

        draw_button(surface, ok_button_rect, "Load", button_font, mouse_pos, is_active=ok_is_active)
        draw_button(surface, cancel_button_rect, "Cancel", button_font, mouse_pos)
        
        # Store button rects for event handling
        editor_state.ui_elements_rects["dialog_file_load_ok"] = ok_button_rect
        editor_state.ui_elements_rects["dialog_file_load_cancel"] = cancel_button_rect