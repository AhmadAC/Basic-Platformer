

########## START OF FILE: assets.py ##########

# -*- coding: utf-8 -*-
"""
Handles loading game assets, primarily animations.
Uses a helper function `resource_path` to work correctly
both locally and when packaged by PyInstaller (--onedir).
"""
# version 1.00000.1
import pygame
import os
import sys
from PIL import Image
import numpy as np # Pillow might use this

# Import constants (specifically colors for placeholders)
try:
    from constants import RED, BLACK, BLUE
except ImportError:
    # Provide fallback colors if constants cannot be imported (e.g., during spec generation)
    print("Warning: Failed to import constants. Using fallback colors.")
    RED = (255, 0, 0)
    BLACK = (0, 0, 0)
    BLUE = (0, 0, 255)

# --- Helper Function for PyInstaller Compatibility ---
def resource_path(relative_path):
    """ Get absolute path to resource, works for dev and for PyInstaller """
    try:
        # PyInstaller creates a temp folder and stores path in _MEIPASS
        # For --onedir, _MEIPASS usually points to the executable's directory
        base_path = sys._MEIPASS
        # print(f"Running from PyInstaller bundle: _MEIPASS={base_path}") # Debug print
    except AttributeError:
        # _MEIPASS attribute not found, running in normal Python environment
        # Assume assets are relative to the main script or project root.
        # Using os.path.abspath(".") assumes you run your script from the project root.
        # If assets.py is not in the root, adjust accordingly, e.g.:
        # base_path = os.path.abspath(os.path.join(os.path.dirname(__file__), "..")) # If assets.py is in a 'src' subdir
        base_path = os.path.abspath(".")
        # print(f"Running locally: base_path={base_path}") # Debug print

    full_path = os.path.join(base_path, relative_path)
    # print(f"Resolved path for '{relative_path}': {full_path}") # Debug print
    return full_path
# ----------------------------------------------------

# Asset Loading (Modified to use resource_path implicitly via load_all_player_animations)
def load_gif_frames(full_path_filename):
    """Loads frames from a GIF file using Pillow and converts them to Pygame Surfaces.
       Expects the *full, resolved path* to the file."""
    frames = []
    try:
        # Use Pillow to open the GIF using the provided full path
        pil_gif = Image.open(full_path_filename)
        frame_num = 0
        while True:
            try:
                # Seek to the next frame
                pil_gif.seek(frame_num)
                current_pil_frame = pil_gif.copy()
                rgba_frame = current_pil_frame.convert('RGBA') # Ensure RGBA for transparency
                frame_data = rgba_frame.tobytes()
                frame_size = rgba_frame.size
                frame_mode = rgba_frame.mode # Should be RGBA now

                # Create Pygame surface from RGBA data
                surface = pygame.image.frombuffer(frame_data, frame_size, "RGBA")
                surface = surface.convert_alpha() # Ensure optimal format for Pygame

                frames.append(surface)
                frame_num += 1

            except EOFError:
                # Reached the end of the GIF frames
                break
            except Exception as e:
                print(f"Error processing frame {frame_num} in {full_path_filename}: {e}")
                frame_num += 1 # Try next frame even if one fails

        if not frames:
             print(f"Error: No frames loaded from {full_path_filename}. Creating placeholder.")
             placeholder = pygame.Surface((30, 40)).convert_alpha()
             placeholder.fill(RED)
             pygame.draw.rect(placeholder, BLACK, placeholder.get_rect(), 1)
             return [placeholder]
        return frames

    except FileNotFoundError:
        print(f"Error: GIF file not found at resolved path: {full_path_filename}")
        placeholder = pygame.Surface((30, 40)).convert_alpha()
        placeholder.fill(RED)
        pygame.draw.rect(placeholder, BLACK, placeholder.get_rect(), 1)
        return [placeholder]
    except Exception as e:
        print(f"Error loading GIF {full_path_filename} with Pillow: {e}")
        placeholder = pygame.Surface((30, 40)).convert_alpha()
        placeholder.fill(RED)
        pygame.draw.rect(placeholder, BLACK, placeholder.get_rect(), 2)
        return [placeholder]

# --- Modified function to use resource_path ---
def load_all_player_animations(relative_asset_folder='characters/player1'):
    """Loads all animations for the player/enemy using the defined map.
       Uses resource_path to find the assets correctly."""
    animations = {}
    # Define the animation mapping (can be reused by Enemy if needed)
    anim_files_map = {
        'attack': '__Attack.gif', 'attack2': '__Attack2.gif', 'attack_combo': '__AttackCombo2hit.gif',
        'attack_nm': '__AttackNoMovement.gif', 'attack2_nm': '__Attack2NoMovement.gif',
        'attack_combo_nm': '__AttackComboNoMovement.gif', 'crouch': '__Crouch.gif',
        'crouch_trans': '__CrouchTransition.gif', 'crouch_walk': '__CrouchWalk.gif',
        'crouch_attack': '__CrouchAttack.gif', 'dash': '__Dash.gif', 'death': '__Death.gif',
        'death_nm': '__DeathNoMovement.gif', 'fall': '__Fall.gif', 'hit': '__Hit.gif',
        'idle': '__Idle.gif', 'jump': '__Jump.gif', 'jump_fall_trans': '__JumpFallInbetween.gif',
        'roll': '__Roll.gif', 'run': '__Run.gif', 'slide': '__SlideAll.gif',
        'slide_trans_start': '__SlideTransitionStart.gif', 'slide_trans_end': '__SlideTransitionEnd.gif',
        'turn': '__TurnAround.gif', 'wall_climb': '__WallClimb.gif',
        'wall_climb_nm': '__WallClimbNoMovement.gif', 'wall_hang': '__WallHang.gif',
        'wall_slide': '__WallSlide.gif',
        # Add 'ladder_idle' and 'ladder_climb' if you have those GIFs (currently not used)
    }

    print(f"Attempting to load animations from relative folder: '{relative_asset_folder}'")
    missing_files_details = [] # Store tuples of (name, expected_relative_path, resolved_path)

    # Determine the base path once
    try:
        base_path = sys._MEIPASS
    except AttributeError:
        base_path = os.path.abspath(".") # Or adjust as needed for your local structure

    print(f"Using base path for assets: {base_path}")

    for name, filename in anim_files_map.items():
         # Construct the relative path first (for reporting)
         relative_path_to_file = os.path.join(relative_asset_folder, filename)
         # Use resource_path to get the full, absolute path
         full_path = resource_path(relative_path_to_file)

         # Check existence using the *full* path
         if not os.path.exists(full_path):
             missing_files_details.append((name, relative_path_to_file, full_path))
             animations[name] = [] # Mark as missing
             continue # Skip loading if file doesn't exist

         # Load using the full path
         loaded_frames = load_gif_frames(full_path)
         animations[name] = loaded_frames

         if not animations[name]: # load_gif_frames returns placeholder on failure
             print(f"Warning: Failed to load frames for state '{name}' from existing file '{full_path}'. Placeholder used.")
             # Placeholder already created by load_gif_frames if loading failed after finding file
         #else:
             # print(f"Successfully loaded {len(animations[name])} frames for '{name}' from '{full_path}'") # Verbose success

    if missing_files_details:
        print("\n--- Missing Animation Files ---")
        for name, rel_path, res_path in missing_files_details:
            print(f"- State '{name}': Expected relative path: '{rel_path}', Resolved path checked: '{res_path}'")
        print(f"(Base path used: {base_path})")
        print("-----------------------------\n")
        print("Ensure these files exist relative to your script/executable OR")
        print("Ensure PyInstaller's '--add-data' or spec file 'datas' includes the asset folder correctly.")

    # Critical check for idle animation (using the placeholder if it failed)
    if 'idle' not in animations or not animations['idle'] or animations['idle'][0].get_size() == (30, 40): # Check if it's a placeholder
        is_missing = 'idle' not in animations or not animations['idle']
        is_placeholder = not is_missing and animations['idle'][0].get_size() == (30, 40) # Basic placeholder check

        if is_missing:
            print("CRITICAL ERROR: Idle animation state not found in map or file missing entirely.")
        elif is_placeholder:
             print(f"CRITICAL ERROR: Idle animation failed to load from '{resource_path(os.path.join(relative_asset_folder, anim_files_map['idle']))}'. Using placeholder.")

        # Create a minimal dummy animation to prevent crashes during init elsewhere ONLY if it's truly absent
        if is_missing:
            placeholder = pygame.Surface((30, 40)).convert_alpha(); placeholder.fill(RED)
            animations['idle'] = [placeholder] # Ensure 'idle' key exists
        # The calling function should still check for this failure state
        # Returning None might be too drastic if only idle failed but others loaded
        # Let's return the animations dict but signal the caller to check idle specifically.
        # Or, make it return None to force a halt. Let's return None for safety.
        print("Returning None due to critical idle animation failure.")
        return None # Indicate critical failure

    # Provide placeholders for any *other* missing/failed animations AFTER checking idle
    for name in anim_files_map:
        if name == 'idle': continue # Already handled

        if name not in animations or not animations[name] or animations[name][0].get_size() == (30, 40):
            if name not in animations or not animations[name]:
                 print(f"Warning: Animation state '{name}' was missing. Providing placeholder.")
            else: # It exists but must be a placeholder from load_gif_frames
                 print(f"Warning: Animation state '{name}' failed during loading. Using placeholder.")

            # Create a different placeholder for non-idle missing animations
            placeholder = pygame.Surface((30, 40)).convert_alpha(); placeholder.fill(BLUE)
            pygame.draw.line(placeholder, RED, (0,0), (30,40), 2); pygame.draw.line(placeholder, RED, (0,40), (30,0), 2)
            animations[name] = [placeholder] # Ensure the key exists with the placeholder

    print(f"Finished loading animations. {len(animations)} animation states processed.")
    return animations
# ------------------------------------------

# Example Usage (if you run this file directly for testing)
if __name__ == "__main__":
    print("Running asset loader directly for testing...")
    pygame.init() # Pygame needed for surface creation

    # --- Determine where the script thinks the 'characters' folder should be ---
    # This assumes your project structure is like:
    # project_root/
    #   assets.py
    #   constants.py
    #   main.py (or similar)
    #   characters/
    #     player1/
    #       __Idle.gif
    #       ...
    # If assets.py is in a subdirectory, adjust the relative path passed.
    test_asset_folder = 'characters/player1'
    print(f"\nTesting load_all_player_animations with relative folder: '{test_asset_folder}'")
    loaded_animations = load_all_player_animations(test_asset_folder)

    if loaded_animations:
        print(f"\nSuccessfully loaded animation data.")
        # print("Loaded states:", list(loaded_animations.keys()))
        # Example: Check frames for 'idle'
        if 'idle' in loaded_animations and loaded_animations['idle']:
            print(f"Idle animation loaded with {len(loaded_animations['idle'])} frames.")
            # Check if it's a placeholder
            if loaded_animations['idle'][0].get_width() == 30 and loaded_animations['idle'][0].get_height() == 40:
                 if loaded_animations['idle'][0].get_at((0,0)) == RED:
                     print("WARNING: Idle animation appears to be a RED placeholder!")
                 elif loaded_animations['idle'][0].get_at((0,0)) == BLUE:
                     print("WARNING: Idle animation appears to be a BLUE placeholder!")

        else:
            print("Idle animation missing or empty in returned dictionary.")
    else:
        print("\nAnimation loading failed (returned None), likely due to critical idle animation issue.")

    pygame.quit()

########## START OF FILE: camera.py ##########

# -*- coding: utf-8 -*-
"""
camera.py
Defines the Camera class for managing the game's viewport.
"""
# version 1.00000.1
import pygame

class Camera:
    def __init__(self, level_width, level_height, screen_width, screen_height):
        """
        Initializes the camera.

        Args:
            level_width (int): The total width of the game level.
            level_height (int): The total effective height of the game level (from highest reachable to lowest point).
            screen_width (int): The width of the game screen/window.
            screen_height (int): The height of the game screen/window.
        """
        self.camera_rect = pygame.Rect(0, 0, screen_width, screen_height)
        self.level_width = level_width
        self.level_height = level_height # This should represent the full scrollable height of the level
        self.screen_width = screen_width
        self.screen_height = screen_height
        # print(f"Camera Initialized: Level WxH: {level_width}x{level_height}, Screen WxH: {screen_width}x{screen_height}")

    def apply(self, target):
        """
        Applies the camera offset to a target sprite or rect.

        Args:
            target (pygame.sprite.Sprite or pygame.Rect): The sprite or rect to offset.

        Returns:
            pygame.Rect: A new Rect representing the target's position on the screen.
        """
        if isinstance(target, pygame.sprite.Sprite):
            return target.rect.move(self.camera_rect.topleft)
        elif isinstance(target, pygame.Rect):
            return target.move(self.camera_rect.topleft)
        else:
            raise TypeError("Camera.apply() target must be a Sprite or Rect.")


    def update(self, target_sprite):
        """
        Updates the camera's position to follow the target_sprite.
        The camera attempts to keep the target_sprite centered on the screen,
        while respecting the level boundaries.

        Args:
            target_sprite (pygame.sprite.Sprite): The sprite the camera should follow.
                                                 Expected to have a 'rect' attribute.
        """
        if not target_sprite or not hasattr(target_sprite, 'rect'):
            self.static_update() 
            return

        # Desired camera topleft x to center target: screen_center_x - target_center_x
        # Since camera_rect.x is the offset added to world coords, it's negative.
        x = -target_sprite.rect.centerx + int(self.screen_width / 2)
        y = -target_sprite.rect.centery + int(self.screen_height / 2)

        # Clamp scrolling to level boundaries

        # Horizontal clamping:
        # Don't scroll left past the beginning of the level (x should not be > 0)
        x = min(0, x)
        # Don't scroll right past the end of the level.
        # max_camera_x is -(level_width - screen_width). If level is smaller than screen, this is positive.
        # We want camera_x to be AT LEAST this value.
        # If level_width < screen_width, we want x to be 0 to keep level fixed.
        if self.level_width > self.screen_width:
            x = max(-(self.level_width - self.screen_width), x)
        else: # Level is narrower than or equal to the screen, so no horizontal scrolling needed
            x = 0 

        # Vertical clamping:
        # Don't scroll up past the "top" of the level (y should not be > 0)
        y = min(0, y)
        # Don't scroll down past the "bottom" of the level.
        # max_camera_y is -(level_height - screen_height)
        if self.level_height > self.screen_height:
            y = max(-(self.level_height - self.screen_height), y)
        else: # Level is shorter than or equal to the screen, so no vertical scrolling needed
            y = 0
            
        self.camera_rect.x = x
        self.camera_rect.y = y
        # print(f"Camera Updated: Target ({target_sprite.rect.centerx},{target_sprite.rect.centery}), CamRect ({self.camera_rect.x},{self.camera_rect.y})")


    def static_update(self):
        """
        Called when there's no target to follow or if static camera behavior is desired.
        The camera remains in its current position.
        """
        pass 

    def get_pos(self):
        """ Returns the camera's current topleft offset (usually negative or zero values). """
        return (self.camera_rect.x, self.camera_rect.y)

    def set_pos(self, x, y):
        """ Manually sets the camera's topleft offset. """
        self.camera_rect.x = x
        self.camera_rect.y = y
        # print(f"Camera Position Manually Set: ({x},{y})")

    def set_level_dimensions(self, level_width, level_height):
        """
        Updates the camera's knowledge of the level dimensions.
        Useful if the level changes or its boundaries are redefined.
        """
        self.level_width = level_width
        self.level_height = level_height
        # print(f"Camera Level Dimensions Updated: Level WxH: {level_width}x{level_height}")
        # Optionally, re-clamp camera position immediately if needed:
        # self.update(None) # Or pass the current target if available

########## START OF FILE: constants.py ##########

# -*- coding: utf-8 -*-
"""
Stores constant values used throughout the game.
"""
# version 1.00000.1 # (Assuming this version comment is for the file itself)

# --- Gameplay / Physics ---
FPS = 60
PLAYER_ACCEL = 0.5
PLAYER_FRICTION = -0.15  # Negative value!
PLAYER_GRAVITY = 0.7
PLAYER_JUMP_STRENGTH = -15
PLAYER_RUN_SPEED_LIMIT = 7
PLAYER_DASH_SPEED = 15
PLAYER_ROLL_SPEED = 9
PLAYER_WALL_SLIDE_SPEED = 2
PLAYER_WALL_CLIMB_SPEED = -4
PLAYER_LADDER_CLIMB_SPEED = 3
PLAYER_MAX_HEALTH = 100
CHARACTER_BOUNCE_VELOCITY = 2.5 # Pixels per frame push back on collision

# Player Attack Specifics
# PLAYER_ATTACK_DAMAGE = 15 # Old generic player attack damage, replaced by specific types
PLAYER_ATTACK1_DAMAGE = 10
PLAYER_ATTACK2_DAMAGE = 20
PLAYER_COMBO_ATTACK_DAMAGE = 20  # Damage for the third attack in a combo sequence
PLAYER_CROUCH_ATTACK_DAMAGE = 5   # Damage for an attack performed while crouching
PLAYER_ATTACK2_FRAME_DURATION_MULTIPLIER = 1.5 # Attack 2 frames last 50% longer, making it slower

# --- Enemy Constants ---
ENEMY_MAX_HEALTH = 80
ENEMY_RUN_SPEED_LIMIT = 5 # Give enemy its own speed limit
ENEMY_ACCEL = 0.4         # Give enemy its own acceleration
ENEMY_FRICTION = -0.12    # Give enemy its own friction
ENEMY_DETECTION_RANGE = 350
ENEMY_ATTACK_RANGE = 60
ENEMY_ATTACK_DAMAGE = 10  # Damage dealt by enemies
ENEMY_ATTACK_COOLDOWN = 1500 # ms
ENEMY_PATROL_DIST = 150 # How far to move before turning in patrol

# --- Colors ---
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
RED = (255, 0, 0)
DARK_RED = (139, 0, 0)
GREEN = (0, 255, 0)
DARK_GREEN = (0, 100, 0)
BLUE = (0, 0, 255)
GRAY = (128, 128, 128)
DARK_GRAY = (50, 50, 50)
LIGHT_BLUE = (173, 216, 230)
ORANGE_RED = (255, 69, 0) # For Lava

# --- Animation ---
ANIM_FRAME_DURATION = 80 # ms per frame for most animations

# --- UI ---
HEALTH_BAR_WIDTH = 50
HEALTH_BAR_HEIGHT = 8
HEALTH_BAR_OFFSET_ABOVE = 5 # Distance enemy health bar is drawn above enemy

# --- Map ---
TILE_SIZE = 40 # Example, if you use a grid later
LAVA_PATCH_HEIGHT = 20 # How tall lava patches/wells rects are for collision (can be diff from visual depth)
LAVA_DAMAGE = 50 # Damage per hit/tick from lava

# --- Other ---
PLAYER_SELF_DAMAGE = 10 # Damage player inflicts on self with debug key

########## START OF FILE: enemy.py ##########

# -*- coding: utf-8 -*-
"""
Defines the Enemy class (CPU player clone).
Handles AI-driven movement, animations mirroring player, states, and interactions.
Each instance randomly selects a color variant for its animations.
"""
import pygame
import random
import math
import os # Needed for path joining
import time # For PrintLimiter

# Import necessary components
import constants as C # Use constants with C. prefix
from assets import load_all_player_animations # Reuse player animation loader
from tiles import Lava # Import Lava for type checking in hazard collision

# --- Print Limiter Utility ---
class PrintLimiter:
    def __init__(self, default_limit=5, default_period=2.0):
        self.counts = {}
        self.timestamps = {}
        self.default_limit = default_limit
        self.default_period = default_period
        self.globally_suppressed = {} # Tracks if the "suppressing further prints" message was shown

    def can_print(self, message_key, limit=None, period=None):
        limit = limit if limit is not None else self.default_limit
        period = period if period is not None else self.default_period
        current_time = time.time()
        
        if message_key not in self.timestamps:
            self.timestamps[message_key] = current_time
            self.counts[message_key] = 0
            self.globally_suppressed[message_key] = False

        if current_time - self.timestamps[message_key] > period:
            self.timestamps[message_key] = current_time
            self.counts[message_key] = 0
            self.globally_suppressed[message_key] = False # Reset suppression message flag

        if self.counts[message_key] < limit:
            self.counts[message_key] += 1
            return True
        elif not self.globally_suppressed[message_key]: # Only print suppression message once per period
            print(f"[PrintLimiter] Suppressing further prints for '{message_key}' for {period:.1f}s (limit: {limit})")
            self.globally_suppressed[message_key] = True
            return False
        return False

class Enemy(pygame.sprite.Sprite):
    print_limiter = PrintLimiter(default_limit=5, default_period=2.0) # Class-level limiter for shared messages

    def __init__(self, start_x, start_y, patrol_area=None, enemy_id=None):
        super().__init__()
        self.spawn_pos = pygame.math.Vector2(start_x, start_y)
        self.patrol_area = patrol_area
        self.enemy_id = enemy_id
        # self.instance_print_limiter = PrintLimiter(default_limit=3, default_period=1.5) # Per-instance limiter if needed

        character_base_folder = 'characters'
        available_colors = ['cyan', 'green', 'pink', 'purple', 'red', 'yellow']
        if not available_colors:
             # Use class-level limiter for this general warning
             if Enemy.print_limiter.can_print("enemy_init_no_colors"):
                print("ERROR: No enemy colors defined in Enemy.__init__!")
             available_colors = ['player1']
             character_base_folder = '.'

        chosen_color = random.choice(available_colors)
        self.color_name = chosen_color
        chosen_folder_path = os.path.join(character_base_folder, chosen_color)

        self.animations = load_all_player_animations(relative_asset_folder=chosen_folder_path)
        if self.animations is None:
            print(f"CRITICAL Enemy {self.enemy_id} ({self.color_name}) Init Error: Failed loading animations from {chosen_folder_path}.")
            self.image = pygame.Surface((30, 40)).convert_alpha(); self.image.fill(C.BLUE)
            self.rect = self.image.get_rect(midbottom=(start_x, start_y))
            self._valid_init = False; self.is_dead = True; return
        else: self._valid_init = True

        self._last_facing = True; self._last_state_for_debug = "init"
        self.state = 'idle'; self.current_frame = 0; self.last_anim_update = pygame.time.get_ticks()
        initial_anim = self.animations.get('idle')
        if not initial_anim:
             if Enemy.print_limiter.can_print(f"enemy_{self.enemy_id}_idle_missing"):
                print(f"Warning Enemy {self.enemy_id} ({self.color_name}): Idle animation missing, using first available.")
             first_key = next(iter(self.animations), None)
             initial_anim = self.animations.get(first_key) if first_key else None
        self.image = initial_anim[0] if initial_anim else pygame.Surface((30, 40)).convert_alpha()
        if not initial_anim: self.image.fill(C.BLUE)

        self.rect = self.image.get_rect(midbottom=(start_x, start_y))
        self.pos = pygame.math.Vector2(start_x, start_y); self.vel = pygame.math.Vector2(0, 0)
        self.acc = pygame.math.Vector2(0, getattr(C, 'PLAYER_GRAVITY', 0.8)) # Enemies use same gravity as player for now
        self.facing_right = random.choice([True, False]); self.on_ground = False
        self.on_ladder = False; self.can_grab_ladder = False; self.touching_wall = 0
        self.is_crouching = False; self.is_dashing = False; self.is_rolling = False
        self.is_sliding = False; self.can_wall_jump = False; self.wall_climb_timer = 0
        self.is_attacking = False; self.attack_timer = 0; self.attack_duration = 300
        self.attack_type = 0; self.attack_cooldown_timer = 0
        self.is_taking_hit = False; self.hit_timer = 0; self.hit_duration = getattr(C, 'ENEMY_HIT_STUN_DURATION', 300)
        self.hit_cooldown = getattr(C, 'ENEMY_HIT_COOLDOWN', 500)
        self.is_dead = False; self.state_timer = 0
        self.max_health = getattr(C, 'ENEMY_MAX_HEALTH', 100); self.current_health = self.max_health
        self.ai_state = 'patrolling'; self.patrol_target_x = start_x
        self.set_new_patrol_target()
        self.attack_hitbox = pygame.Rect(0, 0, 50, 35) # Consider making size configurable via C
        try: self.standard_height = self.animations['idle'][0].get_height()
        except (KeyError, IndexError, TypeError):
            # if Enemy.print_limiter.can_print(f"enemy_{self.enemy_id}_idle_height_warn"):
            # print(f"Warning Enemy {self.enemy_id} ({self.color_name}): Could not get idle anim height, using default.")
            self.standard_height = 60

        self.death_animation_finished = False


    def set_new_patrol_target(self):
        if self.patrol_area and isinstance(self.patrol_area, pygame.Rect):
             min_x = self.patrol_area.left + self.rect.width / 2
             max_x = self.patrol_area.right - self.rect.width / 2
             if min_x < max_x: self.patrol_target_x = random.uniform(min_x, max_x)
             else: self.patrol_target_x = self.patrol_area.centerx
        else:
            direction = 1 if random.random() > 0.5 else -1
            self.patrol_target_x = self.pos.x + direction * getattr(C, 'ENEMY_PATROL_DIST', 150)

    def set_state(self, new_state):
        if not self._valid_init: return
        anim_state = new_state
        valid_anim_states = ['idle', 'run', 'attack', 'attack_nm', 'hit', 'death', 'death_nm', 'fall']
        if new_state not in valid_anim_states:
            if new_state in ['chasing', 'patrolling']: anim_state = 'run' if abs(self.vel.x) > 0.1 else 'idle'
            elif 'attack' in new_state: anim_state = new_state
            else: anim_state = 'idle'

        if anim_state not in self.animations or not self.animations[anim_state]:
             if Enemy.print_limiter.can_print(f"enemy_{self.enemy_id}_anim_missing_{anim_state}"):
                print(f"DEBUG Enemy {self.enemy_id} ({self.color_name}): Animation for state '{anim_state}' (orig: {new_state}) missing. Falling back to idle.")
             anim_state = 'idle'
             if 'idle' not in self.animations or not self.animations['idle']:
                 if Enemy.print_limiter.can_print(f"enemy_{self.enemy_id}_critical_idle_missing"):
                    print(f"DEBUG CRITICAL Enemy {self.enemy_id} ({self.color_name}): Cannot find valid idle animation.")
                 return

        if (self.state != new_state or new_state == 'death') and \
           not (self.is_dead and not self.death_animation_finished and new_state != 'death'):
            if Enemy.print_limiter.can_print(f"enemy_{self.enemy_id}_set_state", limit=20, period=5.0): # Allow more state changes to be printed
                print(f"DEBUG Enemy {self.enemy_id} ({self.color_name}): Set State from '{self.state}' to '{new_state}'")
            self._last_state_for_debug = new_state
            if 'attack' not in new_state: self.is_attacking = False; self.attack_type = 0
            if new_state != 'hit': self.is_taking_hit = False

            self.state = new_state
            self.current_frame = 0; self.last_anim_update = pygame.time.get_ticks(); self.state_timer = pygame.time.get_ticks()

            if 'attack' in new_state:
                self.is_attacking = True; self.attack_type = 1 # Default, can be overridden by specific attack logic
                anim = self.animations.get(anim_state)
                self.attack_duration = len(anim) * getattr(C, 'ANIM_FRAME_DURATION', 100) if anim else 400
                self.vel.x = 0
            elif new_state == 'hit':
                 self.is_taking_hit = True; self.hit_timer = self.state_timer
                 self.vel.x *= -0.5 # Dampen horizontal
                 self.vel.y = getattr(C, 'ENEMY_HIT_BOUNCE_Y', getattr(C, 'PLAYER_JUMP_STRENGTH', -10) * 0.3) # configurable bounce
                 self.is_attacking = False
            elif new_state == 'death':
                 if Enemy.print_limiter.can_print(f"enemy_{self.enemy_id}_entering_death_state"):
                    print(f"DEBUG Enemy {self.enemy_id} ({self.color_name}): In set_state('death'). is_dead=True, current_health={self.current_health}")
                 self.is_dead = True; self.vel.x = 0; self.vel.y = 0 # Stop movement
                 self.acc.xy = 0, 0 # Stop all acceleration including gravity
                 self.death_animation_finished = False
            
            if self.alive() or new_state == 'death': self.animate()
        elif not self.is_dead: self._last_state_for_debug = self.state


    def animate(self):
        if not self._valid_init or not hasattr(self, 'animations') or not self.animations: return
        if not self.alive(): return

        now = pygame.time.get_ticks()
        anim_frame_duration = getattr(C, 'ANIM_FRAME_DURATION', 100)

        state_key = self.state
        if self.is_dead:
            state_key = 'death_nm' if abs(self.vel.x) < 0.1 and abs(self.vel.y) < 0.1 and 'death_nm' in self.animations and self.animations['death_nm'] else 'death'
            if state_key not in self.animations or not self.animations[state_key]: state_key = 'death' # Fallback if death_nm is missing
            # if not self.death_animation_finished and Enemy.print_limiter.can_print(f"enemy_{self.enemy_id}_anim_dead", limit=60, period=1.0): # Print frequently during death anim
            #      print(f"DEBUG Enemy {self.enemy_id} ({self.color_name}): Animate - IS DEAD. Key: {state_key}, Finished: {self.death_animation_finished}, Frame: {self.current_frame}")
        elif self.state == 'patrolling' or self.state == 'chasing':
             state_key = 'run' if abs(self.vel.x) > 0.5 else 'idle'
        elif self.is_attacking: state_key = 'attack_nm' if 'attack_nm' in self.animations and self.animations['attack_nm'] else 'attack'
        elif self.is_taking_hit: state_key = 'hit'
        elif not self.on_ground: state_key = 'fall' if 'fall' in self.animations and self.animations['fall'] else 'idle'
        else: state_key = 'idle'

        if state_key not in self.animations or not self.animations[state_key]: state_key = 'idle'
        animation = self.animations.get(state_key)
        if not animation:
             if hasattr(self, 'image') and self.image: self.image.fill(C.BLUE); return

        if not self.death_animation_finished:
            if now - self.last_anim_update > anim_frame_duration:
                self.last_anim_update = now
                self.current_frame = (self.current_frame + 1)
                if self.current_frame >= len(animation):
                    if self.is_dead:
                        # if Enemy.print_limiter.can_print(f"enemy_{self.enemy_id}_death_anim_finish"):
                        #    print(f"DEBUG Enemy {self.enemy_id} ({self.color_name}): Death animation sequence FINISHED.")
                        self.current_frame = len(animation) - 1 
                        self.death_animation_finished = True    
                        base_image_of_frame = animation[self.current_frame] # Update to last frame before killing
                        image_to_render = base_image_of_frame.copy()
                        if not self.facing_right: image_to_render = pygame.transform.flip(image_to_render, True, False)
                        old_midbottom = self.rect.midbottom
                        self.image = image_to_render
                        self.rect = self.image.get_rect(midbottom=old_midbottom)
                        
                        # if Enemy.print_limiter.can_print(f"enemy_{self.enemy_id}_killing_sprite"):
                        #    print(f"DEBUG Enemy {self.enemy_id} ({self.color_name}): death_animation_finished set to True. Now killing.")
                        if self.alive(): self.kill()
                        # if Enemy.print_limiter.can_print(f"enemy_{self.enemy_id}_killed_status"):
                        #    print(f"DEBUG Enemy {self.enemy_id} ({self.color_name}): kill() called. Sprite alive status: {self.alive()}")
                        return 
                    elif self.state == 'hit':
                        self.set_state('idle'); return
                    else: self.current_frame = 0
                if self.current_frame >= len(animation) and not self.is_dead : self.current_frame = 0
        
        if not self.alive(): return

        if not animation or self.current_frame < 0 or self.current_frame >= len(animation):
            self.current_frame = 0
            if not animation:
                 if hasattr(self, 'image') and self.image: self.image.fill(C.BLUE); return

        base_image_of_frame = animation[self.current_frame]
        image_to_render = base_image_of_frame.copy()
        current_facing_is_right = self.facing_right
        if not current_facing_is_right: image_to_render = pygame.transform.flip(image_to_render, True, False)
        old_midbottom = self.rect.midbottom
        self.image = image_to_render
        self.rect = self.image.get_rect(midbottom=old_midbottom)
        self._last_facing = current_facing_is_right

    def ai_update(self, players_list):
        now = pygame.time.get_ticks()
        if not self._valid_init or self.is_dead or not self.alive() or \
           (self.is_taking_hit and now - self.hit_timer < self.hit_cooldown):
            self.acc.x = 0; return

        target_player_for_ai = None; min_dist_sq = float('inf')
        for p_candidate in players_list:
            is_targetable = p_candidate and p_candidate._valid_init and hasattr(p_candidate, 'pos') and hasattr(p_candidate, 'rect')
            if is_targetable:
                if hasattr(p_candidate, 'is_dead') and p_candidate.is_dead:
                    if hasattr(p_candidate, 'death_animation_finished') and p_candidate.death_animation_finished:
                        is_targetable = False # Player's death animation is done, not a target
                    # else: player is dying but animation not finished, could still be a "target" briefly if desired
                if is_targetable:
                    dist_sq = (p_candidate.pos.x - self.pos.x)**2 + (p_candidate.pos.y - self.pos.y)**2
                    if dist_sq < min_dist_sq:
                        min_dist_sq = dist_sq; target_player_for_ai = p_candidate
        
        if not target_player_for_ai:
            self.ai_state = 'patrolling'
            if self.state != 'patrolling': self.set_state('patrolling')
            if abs(self.pos.x - self.patrol_target_x) < 10: self.set_new_patrol_target()
            target_facing_right_patrol = (self.patrol_target_x > self.pos.x)
            enemy_accel_patrol = getattr(C, 'ENEMY_ACCEL', 0.4)
            self.acc.x = enemy_accel_patrol * 0.7 * (1 if target_facing_right_patrol else -1)
            if not self.is_attacking and self.facing_right != target_facing_right_patrol:
                self.facing_right = target_facing_right_patrol
            return

        dist_to_player = math.sqrt(min_dist_sq)
        enemy_attack_cooldown = getattr(C, 'ENEMY_ATTACK_COOLDOWN', 1500)
        enemy_attack_range = getattr(C, 'ENEMY_ATTACK_RANGE', 60)
        enemy_accel = getattr(C, 'ENEMY_ACCEL', 0.4)
        can_attack_now = now - self.attack_cooldown_timer > enemy_attack_cooldown
        y_diff = abs(target_player_for_ai.rect.centery - self.rect.centery)
        line_of_sight_vertical_check = y_diff < self.rect.height * 2.0
        player_in_range_for_attack = dist_to_player < enemy_attack_range and line_of_sight_vertical_check
        chase_detection_radius = self.rect.width * 3.0
        player_detected_for_chase = dist_to_player < chase_detection_radius

        if self.is_attacking and now - self.attack_timer > self.attack_duration:
             self.is_attacking = False; self.attack_type = 0
             self.attack_cooldown_timer = now; self.set_state('idle'); return

        if self.is_attacking: self.acc.x = 0; return

        target_acc_x = 0; target_facing_right = self.facing_right
        if player_in_range_for_attack and can_attack_now:
            self.ai_state = 'attacking'; target_facing_right = (target_player_for_ai.pos.x > self.pos.x)
            self.facing_right = target_facing_right
            self.set_state('attack_nm' if 'attack_nm' in self.animations else 'attack'); return
        elif player_detected_for_chase:
            self.ai_state = 'chasing'; target_facing_right = (target_player_for_ai.pos.x > self.pos.x)
            target_acc_x = enemy_accel * (1 if target_facing_right else -1)
            if self.state != 'chasing': self.set_state('chasing')
        else:
            self.ai_state = 'patrolling'
            if self.state != 'patrolling': self.set_state('patrolling')
            if abs(self.pos.x - self.patrol_target_x) < 10: self.set_new_patrol_target()
            target_facing_right = (self.patrol_target_x > self.pos.x)
            target_acc_x = enemy_accel * 0.7 * (1 if target_facing_right else -1)

        self.acc.x = target_acc_x
        if not self.is_attacking and self.facing_right != target_facing_right:
             self.facing_right = target_facing_right

    def update(self, dt, players_list, platforms, hazards):
        if not self._valid_init: return
        if self.is_dead and not self.alive(): return
        if self.is_dead and self.alive(): self.animate(); return

        now = pygame.time.get_ticks()
        if self.is_taking_hit and now - self.hit_timer > self.hit_cooldown:
            self.is_taking_hit = False

        self.ai_update(players_list)

        if not self.is_dead: 
            player_gravity = getattr(C, 'PLAYER_GRAVITY', 0.7)
            enemy_friction_constant = getattr(C, 'ENEMY_FRICTION', -0.12)
            enemy_run_speed_limit = getattr(C, 'ENEMY_RUN_SPEED_LIMIT', 5)
            terminal_velocity_y = getattr(C, 'TERMINAL_VELOCITY_Y', 18) 

            self.vel.y += player_gravity; self.vel.x += self.acc.x
            apply_friction_flag = self.on_ground and self.acc.x == 0
            if apply_friction_flag:
                friction_force = self.vel.x * enemy_friction_constant
                if abs(self.vel.x) > 0.1: self.vel.x += friction_force
                else: self.vel.x = 0

            self.vel.x = max(-enemy_run_speed_limit, min(enemy_run_speed_limit, self.vel.x))
            self.vel.y = min(self.vel.y, terminal_velocity_y); self.on_ground = False

            self.pos.x += self.vel.x; self.rect.centerx = round(self.pos.x)
            self.check_platform_collisions('x', platforms)
            
            collided_x_with_any_player = False
            for p_target in players_list:
                if p_target and p_target._valid_init and not p_target.is_dead and p_target.alive(): # Check alive for player
                    if self.check_character_collision('x', p_target): collided_x_with_any_player = True
            
            self.pos.y += self.vel.y; self.rect.bottom = round(self.pos.y)
            self.check_platform_collisions('y', platforms)

            if not collided_x_with_any_player:
                for p_target_y in players_list:
                    if p_target_y and p_target_y._valid_init and not p_target_y.is_dead and p_target_y.alive(): # Check alive for player
                        self.check_character_collision('y', p_target_y)

            self.pos.x = self.rect.centerx; self.pos.y = self.rect.bottom

            if self.is_attacking:
                for p_attack_target in players_list:
                    if p_attack_target and p_attack_target._valid_init and not p_attack_target.is_dead and p_attack_target.alive(): # Check alive
                        self.check_attack_collisions(p_attack_target)
            
            self.check_hazard_collisions(hazards)
        
        self.animate()


    def check_platform_collisions(self, direction, platforms):
        for plat in pygame.sprite.spritecollide(self, platforms, False):
            if direction == 'x':
                if self.vel.x > 0: self.rect.right = plat.rect.left
                elif self.vel.x < 0: self.rect.left = plat.rect.right
                self.vel.x = 0
                if self.ai_state == 'patrolling': self.set_new_patrol_target()
            elif direction == 'y':
                if self.vel.y > 0 and self.rect.bottom > plat.rect.top and (self.pos.y - self.vel.y) <= plat.rect.top + 1:
                     self.rect.bottom = plat.rect.top; self.on_ground = True; self.vel.y = 0
                elif self.vel.y < 0 and self.rect.top < plat.rect.bottom and (self.pos.y - self.rect.height - self.vel.y) >= plat.rect.bottom -1 :
                     self.rect.top = plat.rect.bottom; self.vel.y = 0

    def check_character_collision(self, direction, player_obj):
        if not (player_obj and player_obj._valid_init and not player_obj.is_dead and player_obj.alive()): return False
        if not self._valid_init or self.is_dead: return False
        collision_occurred = False
        if self.rect.colliderect(player_obj.rect):
            collision_occurred = True; bounce_vel = getattr(C, 'CHARACTER_BOUNCE_VELOCITY', 2.5)
            if direction == 'x':
                push_dir = -1 if self.rect.centerx < player_obj.rect.centerx else 1
                if push_dir == -1: self.rect.right = player_obj.rect.left
                else: self.rect.left = player_obj.rect.right
                self.vel.x = push_dir * bounce_vel
                if hasattr(player_obj, 'vel'): player_obj.vel.x = -push_dir * bounce_vel
                if hasattr(player_obj, 'pos'): player_obj.pos.x += -push_dir * 2; player_obj.rect.centerx = round(player_obj.pos.x)
                self.pos.x = self.rect.centerx
            elif direction == 'y':
                 if self.vel.y > 0 and self.rect.bottom > player_obj.rect.top and self.rect.centery < player_obj.rect.centery:
                    self.rect.bottom = player_obj.rect.top; self.on_ground = True; self.vel.y = 0
                 elif self.vel.y < 0 and self.rect.top < player_obj.rect.bottom and self.rect.centery > player_obj.rect.centery:
                    self.rect.top = player_obj.rect.bottom; self.vel.y = 0
                 self.pos.y = self.rect.bottom
        return collision_occurred

    def check_hazard_collisions(self, hazards):
        now = pygame.time.get_ticks()
        if not self._valid_init or self.is_dead or not self.alive() or \
           (self.is_taking_hit and now - self.hit_timer < self.hit_cooldown): return
        lava_damage = getattr(C, 'LAVA_DAMAGE', 50); player_jump_strength = getattr(C, 'PLAYER_JUMP_STRENGTH', -15)
        damaged_this_frame = False
        for hazard in pygame.sprite.spritecollide(self, hazards, False):
            check_point = (self.rect.centerx, self.rect.bottom - 1)
            if isinstance(hazard, Lava) and hazard.rect.collidepoint(check_point) and not damaged_this_frame:
                self.take_damage(lava_damage); damaged_this_frame = True
                if not self.is_dead:
                     self.vel.y = player_jump_strength * 0.3
                     self.vel.x = -(1 if self.rect.centerx < hazard.rect.centerx else -1) * 4
                     self.on_ground = False
                break

    def check_attack_collisions(self, player_obj):
        if not (player_obj and player_obj._valid_init and not player_obj.is_dead and player_obj.alive()): return
        if not self._valid_init or not self.is_attacking or self.is_dead or not self.alive(): return
        now = pygame.time.get_ticks(); player_invincible = False
        if hasattr(player_obj, 'is_taking_hit') and player_obj.is_taking_hit and \
           hasattr(player_obj, 'hit_timer') and hasattr(player_obj, 'hit_cooldown') and \
           now - player_obj.hit_timer < player_obj.hit_cooldown: player_invincible = True
        if player_invincible: return
        if self.facing_right: self.attack_hitbox.midleft = self.rect.midright
        else: self.attack_hitbox.midright = self.rect.midleft
        self.attack_hitbox.centery = self.rect.centery
        if self.attack_hitbox.colliderect(player_obj.rect) and hasattr(player_obj, 'take_damage'):
            player_obj.take_damage(getattr(C, 'ENEMY_ATTACK_DAMAGE', 10))

    def take_damage(self, amount):
        if Enemy.print_limiter.can_print(f"enemy_{self.enemy_id}_take_damage", limit=10, period=2.0):
            print(f"DEBUG Enemy {self.enemy_id} ({self.color_name}): take_damage({amount}) called. HP: {self.current_health}, is_dead: {self.is_dead}, alive: {self.alive()}")
        now = pygame.time.get_ticks()
        if not self._valid_init or self.is_dead or not self.alive() or \
           (self.is_taking_hit and now - self.hit_timer < self.hit_cooldown):
            if Enemy.print_limiter.can_print(f"enemy_{self.enemy_id}_damage_ignored", limit=3, period=2.0):
                print(f"DEBUG Enemy {self.enemy_id} ({self.color_name}): Take damage ignored. Conditions: is_dead={self.is_dead}, alive={self.alive()}, is_taking_hit={self.is_taking_hit}, cooldown_active={(self.is_taking_hit and now - self.hit_timer < self.hit_cooldown)}")
            return

        if Enemy.print_limiter.can_print(f"enemy_{self.enemy_id}_damage_details", limit=10, period=2.0):
            print(f"DEBUG Enemy {self.enemy_id} ({self.color_name}): Took {amount} damage. Old Health: {self.current_health}")
        self.current_health -= amount
        self.current_health = max(0, self.current_health)
        if Enemy.print_limiter.can_print(f"enemy_{self.enemy_id}_health_update", limit=10, period=2.0):
            print(f"DEBUG Enemy {self.enemy_id} ({self.color_name}): New Health: {self.current_health}/{self.max_health}")

        if self.current_health <= 0:
            if not self.is_dead:
                if Enemy.print_limiter.can_print(f"enemy_{self.enemy_id}_setting_death"):
                    print(f"DEBUG Enemy {self.enemy_id} ({self.color_name}): Health <= 0. Setting state to death.")
                self.set_state('death')
        else:
             if not (self.is_taking_hit and now - self.hit_timer < self.hit_duration): # Stun duration check
                if Enemy.print_limiter.can_print(f"enemy_{self.enemy_id}_setting_hit"):
                    print(f"DEBUG Enemy {self.enemy_id} ({self.color_name}): Setting state to hit.")
                self.set_state('hit')

    def reset(self):
        if not self._valid_init: return
        self.pos = self.spawn_pos.copy(); self.vel.xy = 0,0; self.acc.xy = 0, getattr(C, 'PLAYER_GRAVITY', 0.7)
        self.current_health = self.max_health; self.is_dead = False; self.is_taking_hit = False
        self.is_attacking = False; self.attack_type = 0; self.attack_cooldown_timer = 0
        self.facing_right = random.choice([True, False]); self.on_ground = False
        self.death_animation_finished = False
        self.rect.midbottom = (round(self.pos.x), round(self.pos.y))
        if hasattr(self.image, 'get_alpha') and self.image.get_alpha() is not None and self.image.get_alpha() < 255:
            self.image.set_alpha(255)
        self.set_state('idle'); self.ai_state = 'patrolling'; self.set_new_patrol_target()
        # print(f"DEBUG Enemy {self.enemy_id} ({self.color_name}): Reset complete. Alive: {self.alive()}")


    def get_network_data(self):
        return {
            'pos': (self.pos.x, self.pos.y), 'vel': (self.vel.x, self.vel.y), 'state': self.state,
            'current_frame': self.current_frame, 'last_anim_update': self.last_anim_update,
            'facing_right': self.facing_right, 'current_health': self.current_health,
            'is_dead': self.is_dead, 'is_attacking': self.is_attacking, 'attack_type': self.attack_type,
            'enemy_id': self.enemy_id, 'color_name': self.color_name,
            '_valid_init': self._valid_init,
            'death_animation_finished': self.death_animation_finished
        }

    def set_network_data(self, data):
        if data is None: return
        self._valid_init = data.get('_valid_init', self._valid_init)
        if not self._valid_init:
            if self.alive(): self.kill(); return
        self.pos.x, self.pos.y = data.get('pos', (self.pos.x, self.pos.y))
        self.vel.x, self.vel.y = data.get('vel', (self.vel.x, self.vel.y))
        new_state = data.get('state', self.state)
        self.is_attacking = data.get('is_attacking', self.is_attacking)
        self.attack_type = data.get('attack_type', self.attack_type)
        self.death_animation_finished = data.get('death_animation_finished', self.death_animation_finished)
        
        new_is_dead = data.get('is_dead', self.is_dead)
        if new_is_dead and not self.is_dead:
            self.is_dead = True; self.current_health = 0
            self.set_state('death')
        elif not new_is_dead and self.is_dead:
            self.is_dead = False; self.death_animation_finished = False
            if self.state in ['death', 'death_nm']: self.set_state('idle')
        else:
            self.is_dead = new_is_dead

        if self.state != new_state and not (self.is_dead and new_state in ['death', 'death_nm']):
             self.set_state(new_state)
        else:
            self.current_frame = data.get('current_frame', self.current_frame)
            self.last_anim_update = data.get('last_anim_update', self.last_anim_update)

        self.facing_right = data.get('facing_right', self.facing_right)
        new_health = data.get('current_health', self.current_health)
        if new_health < self.current_health and not self.is_taking_hit and not self.is_dead:
            if new_health > 0: self.set_state('hit')
        self.current_health = new_health
        
        self.rect.midbottom = (round(self.pos.x), round(self.pos.y))
        if self._valid_init and self.alive(): self.animate()

########## START OF FILE: items.py ##########

# items.py
# -*- coding: utf-8 -*-
"""
Defines collectible items like Chests.
Uses resource_path helper for PyInstaller compatibility.
"""
# version 1.00000.1
import pygame
import os
import sys # Needed for resource_path logic (imported via assets)
import random

# Import necessary components
import constants as C
# Import BOTH the loader AND the path helper from assets.py
from assets import load_gif_frames, resource_path

class Chest(pygame.sprite.Sprite):
    """
    A chest that restores player health when collected.
    """
    def __init__(self, x, y):
        super().__init__()

        # --- Define the relative path to the asset ---
        # This path is relative to the project root (or wherever resource_path resolves from)
        relative_chest_path = os.path.join('characters', 'items', 'chest.gif')

        # --- Use resource_path to get the correct full path ---
        # resource_path figures out if we're running bundled or locally
        full_chest_path = resource_path(relative_chest_path)
        print(f"Attempting to load chest GIF from resolved path: {full_chest_path}") # Debug print resolved path

        # --- Load frames using the full path ---
        self.frames = load_gif_frames(full_chest_path)

        # --- Error Handling and Placeholder ---
        # Check if loading failed OR if load_gif_frames returned its standard red placeholder
        # (assuming the standard placeholder size is 30x40 from assets.py)
        is_placeholder = False
        if self.frames and len(self.frames) == 1:
             placeholder_check_surf = self.frames[0]
             # Basic check based on size and maybe color (adjust size if your placeholder is different)
             if placeholder_check_surf.get_size() == (30, 40) and placeholder_check_surf.get_at((0,0)) == C.RED:
                 is_placeholder = True

        if not self.frames or is_placeholder:
            # Provide a specific fallback surface for the chest if loading fails OR returns default placeholder
            if not self.frames:
                print(f"Error: Failed to load chest from '{full_chest_path}'. Using placeholder.")
            else: # It returned a placeholder
                print(f"Warning: Chest loaded as a default placeholder from '{full_chest_path}'. Check file/path.")

            self.image = pygame.Surface((30, 30)).convert_alpha()
            self.image.fill(C.YELLOW) # Use a distinct placeholder color for chest issues
            pygame.draw.rect(self.image, C.BLACK, self.image.get_rect(), 1)
            pygame.draw.line(self.image, C.BLACK, (0, 0), (30, 30), 1) # Add cross to placeholder
            pygame.draw.line(self.image, C.BLACK, (0, 30), (30, 0), 1)
            self.frames = [self.image] # Make frames list contain the specific chest placeholder
            self._valid_init = False # Indicate potential issue, though it might still draw
        else:
            # Successfully loaded actual frames
            self.image = self.frames[0] # Use the first frame
            self._valid_init = True
            print(f"Successfully loaded {len(self.frames)} frame(s) for chest.")

        self.rect = self.image.get_rect(midbottom=(x, y))
        self.pos = pygame.math.Vector2(x, y) # Store position if needed later

        # Animation state
        self.current_frame = 0
        self.last_anim_update = pygame.time.get_ticks()
        self.is_collected = False # Flag to prevent multiple collections

    def update(self, dt):
        """ Handles animation if the GIF has multiple frames. dt is not used here yet. """
        # Don't animate if initialization potentially failed or only 1 frame (placeholder/static)
        if not self._valid_init or len(self.frames) <= 1:
            return

        now = pygame.time.get_ticks()
        # Adjust ANIM_FRAME_DURATION if chest animation speed should differ
        anim_speed_multiplier = 2 # Example: make chest animation slower than player/enemy
        if now - self.last_anim_update > C.ANIM_FRAME_DURATION * anim_speed_multiplier:
            self.last_anim_update = now
            self.current_frame = (self.current_frame + 1) % len(self.frames) # Loop animation
            current_midbottom = self.rect.midbottom # Store position anchor
            self.image = self.frames[self.current_frame]
            # Re-center rect if frame sizes change during animation (unlikely for simple items)
            self.rect = self.image.get_rect(midbottom=current_midbottom) # Re-anchor rect after getting new image

    def collect(self, player):
        """ Action when the player collects the chest. """
        # Only collect if properly initialized and not already collected
        if not self.is_collected and self._valid_init:
            print("Player collected chest!")
            # Ensure player has the heal_to_full method before calling it
            if hasattr(player, 'heal_to_full') and callable(player.heal_to_full):
                player.heal_to_full()
            else:
                print("Warning: Player object does not have 'heal_to_full' method.")
            self.is_collected = True
            self.kill() # Remove sprite from all groups it belongs to

########## START OF FILE: levels.py ##########

# -*- coding: utf-8 -*-
"""
levels.py
Returns sprite groups for platforms, ladders, hazards, spawns, level width, ground Y, and ground height.
"""
# version 1.00000.2 (updated for boundary improvements and test block fix)
import pygame
import random
from tiles import Platform, Ladder, Lava # Import tile classes
from constants import TILE_SIZE, GRAY, DARK_GREEN, ORANGE_RED, LAVA_PATCH_HEIGHT, LIGHT_BLUE

# Constants for fences (can be adjusted)
FENCE_WIDTH = 8
FENCE_HEIGHT = 15 # Short enough to jump over easily
FENCE_COLOR = GRAY # Match ground or use a distinct color like DARK_GRAY

# Define a very thick boundary to ensure no phasing
BOUNDARY_THICKNESS = TILE_SIZE * 2 # e.g., 80 pixels thick

def load_map_original(initial_width, initial_height):
    """ Creates the original level layout. """
    platforms = pygame.sprite.Group()
    ladders = pygame.sprite.Group()
    hazards = pygame.sprite.Group()
    enemy_spawns_data = []
    player_spawn = (100, initial_height - 41) 
    ground_width = initial_width * 2.5
    ground_y = initial_height - 40
    ground_height = 40 
    
    ground = Platform(0, ground_y, ground_width, ground_height, GRAY)
    platforms.add(ground)

    platforms.add(Platform(200, initial_height - 150, 250, 20, GRAY))
    platforms.add(Platform(450, initial_height - 300, 180, 20, GRAY))
    platforms.add(Platform(initial_width - 350, initial_height - 450, 200, 20, GRAY))
    platforms.add(Platform(initial_width + 150, initial_height - 250, 150, 20, GRAY))
    platforms.add(Platform(900, initial_height - 550, 100, 20, GRAY))

    platforms.add(Platform(-BOUNDARY_THICKNESS, -initial_height * 2, BOUNDARY_THICKNESS, initial_height * 4, GRAY))
    platforms.add(Platform(ground_width, -initial_height * 2, BOUNDARY_THICKNESS, initial_height * 4, GRAY))
    platforms.add(Platform(0, -initial_height * 2, ground_width, BOUNDARY_THICKNESS, GRAY))

    wall_mid = Platform(800, initial_height - 400, 30, 360, GRAY)
    platforms.add(wall_mid)

    ladder_width = 40; ladder_height = 250; ladder_x = initial_width - 500; ladder_y = ground_y - ladder_height
    ladders.add(Ladder(ladder_x, ladder_y, ladder_width, ladder_height))
    ladders.add(Ladder(350, initial_height - 250, ladder_width, 150))

    # Determine effective level height for camera (min_y will be very negative due to high ceiling)
    all_level_rects = [p.rect for p in platforms]
    min_y_coord = min(r.top for r in all_level_rects) if all_level_rects else -initial_height * 2
    max_y_coord = max(r.bottom for r in all_level_rects) if all_level_rects else ground_y + ground_height
    effective_level_height = max_y_coord - min_y_coord
    
    # The function now returns the effective level height and the y-coordinate of the highest platform (ceiling)
    # This might be useful for camera logic if you want the camera to be aware of the absolute top.
    # For now, the map functions return ground_y and ground_height, which refer to the main playable ground.
    # The camera will use level_width and the calculated effective_level_height.
    # The return signature is kept the same for compatibility with existing main.py:
    # platforms, ladders, hazards, enemy_spawns_data, player_spawn, level_width, ground_y, ground_height
    # `level_height` for the camera should be calculated in main.py based on all platforms.

    return platforms, ladders, hazards, enemy_spawns_data, player_spawn, ground_width, ground_y, ground_height

def load_map_lava(initial_width, initial_height):
    """ Creates a level with lava rivers/pools. """
    platforms = pygame.sprite.Group()
    ladders = pygame.sprite.Group()
    hazards = pygame.sprite.Group()
    enemy_spawns_data = []
    player_spawn = (80, initial_height - 150)
    level_width = initial_width * 2.8
    ground_level_y_ref = initial_height - 40 
    ground_platform_height = 0 

    platforms.add(Platform(50, initial_height - 120, 150, 20, DARK_GREEN))
    platforms.add(Platform(300, initial_height - 180, 120, 20, DARK_GREEN))
    platforms.add(Platform(500, initial_height - 150, 100, 20, DARK_GREEN))
    platforms.add(Platform(700, initial_height - 200, 130, 20, DARK_GREEN))
    platforms.add(Platform(900, initial_height - 250, 100, 20, DARK_GREEN))
    platforms.add(Platform(1100, initial_height - 400, 30, 400, GRAY))
    platforms.add(Platform(1250, initial_height - 350, 150, 20, DARK_GREEN))
    platforms.add(Platform(1450, initial_height - 500, 30, 500, GRAY)) 
    platforms.add(Platform(1600, initial_height - 480, 200, 20, DARK_GREEN))

    lava_y = ground_level_y_ref
    lava_height = 60 
    hazards.add(Lava(0, lava_y, 1100, lava_height, ORANGE_RED))
    hazards.add(Lava(1130, lava_y, 320, lava_height, ORANGE_RED))
    hazards.add(Lava(1550, lava_y, level_width - 1550, lava_height, ORANGE_RED))

    platforms.add(Platform(-BOUNDARY_THICKNESS, -initial_height * 2, BOUNDARY_THICKNESS, initial_height * 4, GRAY))
    platforms.add(Platform(level_width, -initial_height * 2, BOUNDARY_THICKNESS, initial_height * 4, GRAY))
    platforms.add(Platform(0, -initial_height * 2, level_width, BOUNDARY_THICKNESS, GRAY))
    
    # The return signature is kept the same for compatibility:
    # platforms, ladders, hazards, enemy_spawns_data, player_spawn, level_width, ground_y, ground_height
    # Note: ground_y and ground_height here refer to ground_level_y_ref and 0 respectively for this map.

    return platforms, ladders, hazards, enemy_spawns_data, player_spawn, level_width, ground_level_y_ref, ground_platform_height


def load_map_cpu_extended(initial_width, initial_height):
    """ Creates a larger level with CPU enemy and DEEP LAVA WELLS with fences. """
    platforms = pygame.sprite.Group()
    ladders = pygame.sprite.Group()
    hazards = pygame.sprite.Group()
    enemy_spawns_data = []
    player_spawn = (100, initial_height - 41 - FENCE_HEIGHT) 

    level_width = initial_width * 4.0 
    ground_y = initial_height - 40
    ground_height = 40
    lava_collision_height = LAVA_PATCH_HEIGHT

    gap_width = 120 
    segment_defs = [
        (0, 500), (500 + gap_width, 1100), (1100 + gap_width, 1700),
        (1700 + gap_width, 2300), (2300 + gap_width, level_width) 
    ]
    for start_x, end_x in segment_defs:
        width = end_x - start_x
        if width > 0: platforms.add(Platform(start_x, ground_y, width, ground_height, GRAY))

    for i in range(len(segment_defs) - 1):
        lava_start_x = segment_defs[i][1]; lava_end_x = segment_defs[i+1][0]
        lava_width = lava_end_x - lava_start_x
        if lava_width > 0:
            lava_collision_y = ground_y + 1 
            hazards.add(Lava(lava_start_x, lava_collision_y, lava_width, lava_collision_height, ORANGE_RED))
            fence_y = ground_y - FENCE_HEIGHT
            platforms.add(Platform(lava_start_x - FENCE_WIDTH, fence_y, FENCE_WIDTH, FENCE_HEIGHT, FENCE_COLOR))
            platforms.add(Platform(lava_end_x, fence_y, FENCE_WIDTH, FENCE_HEIGHT, FENCE_COLOR))

    platforms.add(Platform(300, initial_height - 160, 200, 20, DARK_GREEN))
    platforms.add(Platform(700, initial_height - 280, 150, 20, DARK_GREEN))
    platforms.add(Platform(1400, initial_height - 180, 250, 20, DARK_GREEN)) 
    platforms.add(Platform(2000, initial_height - 160, 150, 20, DARK_GREEN))
    platforms.add(Platform(level_width - 400, initial_height- 240, 180, 20, DARK_GREEN))

    boundary_y_start = -initial_height * 3 
    boundary_height_total = initial_height * 5 

    platforms.add(Platform(-BOUNDARY_THICKNESS, boundary_y_start, BOUNDARY_THICKNESS, boundary_height_total, GRAY))
    platforms.add(Platform(level_width, boundary_y_start, BOUNDARY_THICKNESS, boundary_height_total, GRAY))
    platforms.add(Platform(0, boundary_y_start, level_width, BOUNDARY_THICKNESS, GRAY)) 
    
    lowest_point_in_level = ground_y + lava_collision_height + 50 
    platforms.add(Platform(0, lowest_point_in_level, level_width, BOUNDARY_THICKNESS, GRAY))

    spawn_y_on_ground_fenced = ground_y - FENCE_HEIGHT - 1 
    enemy_spawns_data.append({'pos': (segment_defs[1][0] + 100, spawn_y_on_ground_fenced), 'patrol': None})
    enemy_spawns_data.append({'pos': (1450, initial_height - 181), 'patrol': None})
    patrol_rect = pygame.Rect(segment_defs[-1][0] + 50, ground_y - 100, 350, 100) 
    enemy_spawns_data.append({'pos': (segment_defs[-1][0] + 100, spawn_y_on_ground_fenced), 'patrol': patrol_rect})
    
    # The return signature is kept the same for compatibility:
    # platforms, ladders, hazards, enemy_spawns_data, player_spawn, level_width, ground_y, ground_height
    return platforms, ladders, hazards, enemy_spawns_data, player_spawn, level_width, ground_y, ground_height

load_map_cpu = load_map_cpu_extended

if __name__ == '__main__':
    pygame.init()
    # Define screen_width and screen_height for the test environment
    screen_width_test = 800  # Use a distinct name for test variable
    screen_height_test = 600 # This acts as 'initial_height' for the test call
    screen = pygame.display.set_mode((screen_width_test, screen_height_test))
    pygame.display.set_caption("Level Boundary Test")

    # Test the map with extended boundaries
    platforms, ladders, hazards, enemy_spawns, player_spawn_pos, level_w, ground_y_pos, ground_h_val = \
        load_map_cpu_extended(screen_width_test, screen_height_test) # Pass the defined screen dimensions

    all_draw_sprites = pygame.sprite.Group() 
    all_draw_sprites.add(platforms.sprites(), ladders.sprites()) # Use .sprites() to add individuals
    all_draw_sprites.add(hazards.sprites())

    class DummyPlayer(pygame.sprite.Sprite):
        def __init__(self, x, y):
            super().__init__()
            self.image = pygame.Surface((30,40))
            self.image.fill((0,255,0)) 
            self.rect = self.image.get_rect(midbottom=(x,y))
            self.vel = pygame.math.Vector2(0,0)
            self.on_ground_test = False 

        def update(self, plats):
            self.vel.y += 0.5 
            keys = pygame.key.get_pressed()
            if keys[pygame.K_LEFT]: self.vel.x = -5
            elif keys[pygame.K_RIGHT]: self.vel.x = 5
            else: self.vel.x = 0
            if keys[pygame.K_UP] and self.on_ground_test: self.vel.y = -12

            self.rect.x += self.vel.x
            self.collision_test('x', plats)
            self.rect.y += self.vel.y
            self.on_ground_test = False 
            self.collision_test('y', plats)
        
        def collision_test(self, direction, plats):
            for p in pygame.sprite.spritecollide(self, plats, False):
                if direction == 'x':
                    if self.vel.x > 0: self.rect.right = p.rect.left
                    if self.vel.x < 0: self.rect.left = p.rect.right
                    self.vel.x = 0
                if direction == 'y':
                    if self.vel.y > 0: self.rect.bottom = p.rect.top; self.on_ground_test = True
                    if self.vel.y < 0: self.rect.top = p.rect.bottom
                    self.vel.y = 0
    
    test_player = DummyPlayer(player_spawn_pos[0], player_spawn_pos[1])
    all_draw_sprites.add(test_player)

    running = True
    camera_offset_x = 0 
    camera_offset_y = 0 
    clock = pygame.time.Clock()

    # Calculate effective level height for camera clamping in the test
    min_y_test = 0
    max_y_test = screen_height_test # Default to screen height
    if platforms:
        all_test_rects = [p.rect for p in platforms]
        min_y_test = min(r.top for r in all_test_rects)
        max_y_test = max(r.bottom for r in all_test_rects)
    effective_level_h_test = max_y_test - min_y_test


    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
        
        test_player.update(platforms)

        camera_offset_x = -test_player.rect.centerx + screen_width_test // 2
        camera_offset_y = -test_player.rect.centery + screen_height_test // 2

        camera_offset_x = min(0, camera_offset_x)
        if level_w > screen_width_test:
            camera_offset_x = max(-(level_w - screen_width_test), camera_offset_x)
        else:
            camera_offset_x = 0
        
        camera_offset_y = min(0, camera_offset_y)
        # Use the calculated effective_level_h_test for vertical clamping in the test
        # The camera needs to know its own screen_height_test to clamp correctly.
        # The max negative offset is -(total_level_height - screen_height)
        if effective_level_h_test > screen_height_test:
             # The camera's top y is effectively min_y_test for the level content.
             # So, offset should not make min_y_test appear below 0 on screen.
             # And should not make max_y_test appear above screen_height_test.
             # camera_offset_y = max(-(max_y_test - screen_height_test - min_y_test), camera_offset_y) # This is tricky
             # Simpler: clamp based on the overall span
            camera_offset_y = max(-(effective_level_h_test - screen_height_test), camera_offset_y + min_y_test) - min_y_test

        else: # Level is shorter than screen
            camera_offset_y = 0 # Or center it: (screen_height_test - effective_level_h_test) / 2 - min_y_test
            # For simplicity, just fix at top if shorter.
            # A proper camera would handle centering levels smaller than the screen view.
            # The camera_offset_y should be such that the top of the level (min_y_test) is shown at y=0 on screen
            # if the level is shorter than the screen, or centered.
            # The current main camera code handles this better. This test block is simplified.

        screen.fill((135, 206, 235)) 

        for sprite in all_draw_sprites:
            # When applying camera offset, remember that platform coordinates are absolute world coordinates.
            # The camera_offset_y already includes the shift needed if min_y_test is negative.
            screen.blit(sprite.image, (sprite.rect.x + camera_offset_x, sprite.rect.y + camera_offset_y))

        pygame.display.flip()
        clock.tick(60)

    pygame.quit()

########## START OF FILE: main.py ##########

# main.py
# Run this code
# -*- coding: utf-8 -*-
import pygame
import sys
import os
import math # Keep math
import random
import socket
import threading
import time
import json
import traceback

# --- Pyperclip Check ---
PYPERCLIP_AVAILABLE = False
try:
    import pyperclip
    PYPERCLIP_AVAILABLE = True
    print("Pyperclip library found and imported successfully.")
except ImportError:
    print("Warning: Pyperclip library not found (pip install pyperclip).")

# --- Platformer Imports ---
try:
    import constants as C
    from player import Player 
    from enemy import Enemy
    from tiles import Platform, Ladder, Lava 
    from camera import Camera
    try:
        from items import Chest
    except ImportError:
        print("Warning: items.py or Chest class not found. Chests will not be available.")
        Chest = None
    import levels as LevelLoader
    import ui
    print("Platformer modules imported successfully.")
except ImportError as e:
    print(f"FATAL: Failed to import platformer module: {e}")
    print("Ensure player.py, enemy.py, tiles.py, levels.py, ui.py, camera.py, constants.py are present.")
    sys.exit(1)
except Exception as e:
    print(f"FATAL: Error during platformer module import: {e}")
    sys.exit(1)
    
os.environ['SDL_VIDEO_WINDOW_POS'] = '0,0'
# --- Pygame Init ---
pygame.init()
pygame.font.init()

# --- Pygame Scrap Init ---
SCRAP_INITIALIZED = False
try:
    pygame.scrap.init()
    SCRAP_INITIALIZED = pygame.scrap.get_init()
    if SCRAP_INITIALIZED: print("Clipboard (pygame.scrap) module initialized successfully.")
    else: print("Warning: pygame.scrap module initialized but status check failed.")
except pygame.error as e: print(f"Warning: pygame.scrap module could not be initialized: {e}")
except AttributeError: print(f"Warning: pygame.scrap module not found or available on this system.")
except Exception as e: print(f"Warning: An unexpected error occurred during pygame.scrap init: {e}")

# --- Constants & Globals ---
SERVER_IP_BIND = '0.0.0.0'
SERVER_PORT_TCP = 5555
DISCOVERY_PORT_UDP = 5556
BUFFER_SIZE = 4096
BROADCAST_INTERVAL_S = 1.0
CLIENT_SEARCH_TIMEOUT_S = 5.0
SERVICE_NAME = "platformer_adventure_lan_v1"

try:
    display_info = pygame.display.Info()
    monitor_width = display_info.current_w; monitor_height = display_info.current_h
    initial_width = max(800, min(1600, monitor_width * 3 // 4))
    initial_height = max(600, min(900, monitor_height * 3 // 4))
    WIDTH = initial_width; HEIGHT = initial_height
    flags = pygame.RESIZABLE | pygame.DOUBLEBUF
    screen = pygame.display.set_mode((WIDTH, HEIGHT), flags)
    print(f"Initial window: {WIDTH}x{HEIGHT}")
except Exception as e: print(f"Error setting up display: {e}"); pygame.quit(); sys.exit()

clock = None
font_small, font_medium, font_large, debug_font = None, None, None, None
app_running = True

server_tcp_socket, server_udp_socket, client_connection, client_address = None, None, None, None
client_input_buffer = {}; client_state_buffer = b""; client_lock = threading.Lock()
broadcast_thread, client_handler_thread = None, None
client_tcp_socket = None; server_state_buffer = b""

player1, player2, camera, current_chest = None, None, None, None
platform_sprites, ladder_sprites, hazard_sprites, enemy_sprites, collectible_sprites, all_sprites = \
    pygame.sprite.Group(), pygame.sprite.Group(), pygame.sprite.Group(), \
    pygame.sprite.Group(), pygame.sprite.Group(), pygame.sprite.Group()
enemy_list = [] 
level_pixel_width, level_pixel_height = WIDTH, HEIGHT
ground_level_y, ground_platform_height = HEIGHT - 40, 40
player1_spawn_pos, player2_spawn_pos = (100, HEIGHT - 80), (150, HEIGHT - 80)
enemy_spawns_data = [] 

# --- Helper Functions (Network) ---
def get_local_ip():
    best_ip = '127.0.0.1'
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM); s.connect(("8.8.8.8", 80))
        best_ip = s.getsockname()[0]; s.close()
    except Exception:
        try: best_ip = socket.gethostbyname(socket.gethostname())
        except Exception: best_ip = '127.0.0.1'
    return best_ip

def encode_data(data):
    try: return json.dumps(data).encode('utf-8') + b'\n'
    except TypeError as e: print(f"Encoding Error: {e} Data: {str(data)[:100]}"); return None
    except Exception as e: print(f"Unexpected Encoding Error: {e}"); return None

def decode_data_stream(byte_buffer):
    decoded_objects, remaining_buffer = [], byte_buffer
    while b'\n' in remaining_buffer:
        message, remaining_buffer = remaining_buffer.split(b'\n', 1)
        if not message: continue
        try: decoded_objects.append(json.loads(message.decode('utf-8')))
        except Exception: continue 
    return decoded_objects, remaining_buffer

# --- Platformer Specific Helper Functions ---
def initialize_platformer_elements(for_game_mode="unknown"):
    global platform_sprites, ladder_sprites, hazard_sprites, enemy_spawns_data, \
           player1_spawn_pos, player2_spawn_pos, level_pixel_width, level_pixel_height, ground_level_y, \
           ground_platform_height, all_sprites, enemy_sprites, \
           collectible_sprites, player1, player2, enemy_list, \
           current_chest, WIDTH, HEIGHT, camera

    print(f"Initializing platformer elements for mode: {for_game_mode}...")
    if player1: player1.kill(); player1 = None
    if player2: player2.kill(); player2 = None
    if current_chest: current_chest.kill(); current_chest = None
    for sprite in all_sprites: sprite.kill() 
    all_sprites.empty(); platform_sprites.empty(); ladder_sprites.empty(); hazard_sprites.empty()
    enemy_sprites.empty(); collectible_sprites.empty(); enemy_list.clear()

    print("Loading level data via LevelLoader...")
    try:
        platform_data_group, ladder_data_group, hazard_data_group, enemy_spawns_data_list, \
        p1_spawn_tuple, lvl_width_pixels, ground_y_coord, ground_h_pixels = \
            LevelLoader.load_map_cpu(WIDTH, HEIGHT) 
        
        enemy_spawns_data = enemy_spawns_data_list 
        
        platform_sprites.add(platform_data_group.sprites()) 
        ladder_sprites.add(ladder_data_group.sprites())
        hazard_sprites.add(hazard_data_group.sprites())
        player1_spawn_pos = p1_spawn_tuple
        player2_spawn_pos = (p1_spawn_tuple[0] + 60, p1_spawn_tuple[1]) 
        level_pixel_width = lvl_width_pixels; 
        level_pixel_height = HEIGHT 
        ground_level_y = ground_y_coord; ground_platform_height = ground_h_pixels
        print("Level geometry loaded.")
    except Exception as e: print(f"CRITICAL ERROR loading level: {e}"); traceback.print_exc(); return False

    all_sprites.add(platform_sprites.sprites(), ladder_sprites.sprites(), hazard_sprites.sprites())

    if for_game_mode in ["host", "couch_play", "single_player"]: 
        print("Initializing player 1..."); player1 = Player(player1_spawn_pos[0], player1_spawn_pos[1], player_id=1)
        if not player1._valid_init: print("CRITICAL: P1 init failed."); return False
        all_sprites.add(player1); print("P1 initialized.")
    
    if for_game_mode == "couch_play":
        print("Initializing player 2 (couch)..."); player2 = Player(player2_spawn_pos[0], player2_spawn_pos[1], player_id=2)
        if not player2._valid_init: print("CRITICAL: P2 (couch) init failed."); return False
        all_sprites.add(player2); print("P2 (couch) initialized.")
    elif for_game_mode == "host": 
        print("Initializing player 2 (remote placeholder)..."); player2 = Player(player2_spawn_pos[0], player2_spawn_pos[1], player_id=2)
        if not player2._valid_init: print("CRITICAL: P2 (remote) init failed."); return False
        all_sprites.add(player2); print("P2 (remote) initialized.")
    elif for_game_mode == "client": 
        print("Initializing player 1 (remote placeholder)..."); player1 = Player(player1_spawn_pos[0], player1_spawn_pos[1], player_id=1)
        if not player1._valid_init: print("CRITICAL: P1 (remote) init failed."); return False
        all_sprites.add(player1); print("P1 (remote) initialized.")
        print("Initializing player 2 (local client)..."); player2 = Player(player2_spawn_pos[0], player2_spawn_pos[1], player_id=2)
        if not player2._valid_init: print("CRITICAL: P2 (local client) init failed."); return False
        all_sprites.add(player2); print("P2 (local client) initialized.")

    enemy_list.clear() 
    print(f"Spawning {len(enemy_spawns_data)} enemies...") 
    for i, spawn_data in enumerate(enemy_spawns_data): 
        try:
            enemy = Enemy(spawn_data['pos'][0], spawn_data['pos'][1], spawn_data.get('patrol'), enemy_id=i)
            if enemy._valid_init: 
                all_sprites.add(enemy)
                enemy_sprites.add(enemy)
                enemy_list.append(enemy)
            else: print(f"Error: Enemy {i} at {spawn_data['pos']} init failed.")
        except Exception as e: print(f"Error spawning enemy {i} at {spawn_data['pos']}: {e}")
    print(f"Enemies spawned: {len(enemy_list)}")

    current_chest = spawn_chest_platformer() 
    if current_chest: 
        all_sprites.add(current_chest)
        collectible_sprites.add(current_chest)
    
    camera = Camera(level_pixel_width, level_pixel_height, WIDTH, HEIGHT)
    return True

def spawn_chest_platformer():
    global platform_sprites, collectible_sprites, all_sprites, ground_level_y, Chest
    if Chest is None: return None
    try:
        valid_plats = [p for p in platform_sprites if p.rect.top < ground_level_y - 50 and p.rect.width > 50]
        if not valid_plats: valid_plats = list(platform_sprites) 
        if not valid_plats: print("No valid platforms to spawn chest on."); return None
        
        chosen_platform = random.choice(valid_plats)
        cx = random.randint(chosen_platform.rect.left + 20, chosen_platform.rect.right - 20)
        cy = chosen_platform.rect.top 
        new_chest = Chest(cx, cy) 
        if hasattr(new_chest, '_valid_init') and new_chest._valid_init:
            print(f"Chest object created at ({int(new_chest.rect.centerx)}, {int(new_chest.rect.bottom)}).")
            return new_chest
        else: print("Failed to initialize new chest object (invalid init).")
    except Exception as e: print(f"Error creating new chest object: {e}")
    return None

def reset_platformer_game_state():
    global player1, player2, enemy_list, current_chest, player1_spawn_pos, player2_spawn_pos, all_sprites, enemy_sprites, collectible_sprites
    print("\n--- Resetting Platformer Game State ---")

    if player1 and hasattr(player1, 'reset_state'): 
        player1.reset_state(player1_spawn_pos)
        if not player1.alive() and player1._valid_init: all_sprites.add(player1)
        print("P1 Reset")
    if player2 and hasattr(player2, 'reset_state'): 
        player2.reset_state(player2_spawn_pos)
        if not player2.alive() and player2._valid_init: all_sprites.add(player2)
        print("P2 Reset")
    
    for enemy in enemy_list: 
        if hasattr(enemy, 'reset'): 
            enemy.reset()
            if enemy._valid_init:
                if not enemy.alive(): 
                    all_sprites.add(enemy)
                    enemy_sprites.add(enemy)
                else: 
                    all_sprites.add(enemy) 
                    enemy_sprites.add(enemy)
    print(f"{len(enemy_list)} enemies processed for reset.")
    
    if current_chest and current_chest.alive(): current_chest.kill()
    current_chest = spawn_chest_platformer() 
    if current_chest:
        all_sprites.add(current_chest) 
        collectible_sprites.add(current_chest) 
        print("Chest respawned.")
    else:
        print("Failed to respawn chest or Chest class not available.")
    print("--- Game State Reset Finished ---\n")

def get_platformer_network_state():
    global player1, player2, enemy_list, current_chest
    state = {'p1': None, 'p2': None, 'enemies': {}, 'chest': None, 'game_over': False}
    if player1 and hasattr(player1, 'get_network_data'): state['p1'] = player1.get_network_data()
    if player2 and hasattr(player2, 'get_network_data'): state['p2'] = player2.get_network_data()
    
    for enemy in enemy_list: 
        if hasattr(enemy, 'enemy_id') and hasattr(enemy, 'get_network_data') and enemy.alive():
            state['enemies'][str(enemy.enemy_id)] = enemy.get_network_data()
            
    if current_chest and current_chest.alive() and hasattr(current_chest, 'rect'):
        state['chest'] = {'pos': (current_chest.rect.centerx, current_chest.rect.centery), 
                          'is_collected': getattr(current_chest, 'is_collected', False)}
    
    p1_truly_gone = True 
    if player1 and player1._valid_init:
        if player1.alive(): 
            if hasattr(player1, 'is_dead') and player1.is_dead:
                if hasattr(player1, 'death_animation_finished') and not player1.death_animation_finished:
                    p1_truly_gone = False 
            else: 
                p1_truly_gone = False
        
    state['game_over'] = p1_truly_gone 
    return state

def set_platformer_network_state(network_state):
    global player1, player2, enemy_list, enemy_sprites, current_chest, all_sprites, collectible_sprites, Chest, enemy_spawns_data
    
    if player1 and 'p1' in network_state and network_state['p1'] and hasattr(player1, 'set_network_data'):
        player1.set_network_data(network_state['p1'])
        if player1._valid_init and not player1.alive(): all_sprites.add(player1) 
    if player2 and 'p2' in network_state and network_state['p2'] and hasattr(player2, 'set_network_data'):
        player2.set_network_data(network_state['p2'])
        if player2._valid_init and not player2.alive(): all_sprites.add(player2) 

    if 'enemies' in network_state:
        received_enemy_data_map = network_state['enemies']
        current_client_enemies_map = {str(enemy.enemy_id): enemy for enemy in enemy_list if hasattr(enemy, 'enemy_id')}

        for enemy_id_str, enemy_data_from_server in received_enemy_data_map.items():
            enemy_id_int = int(enemy_id_str) 
            if enemy_data_from_server.get('_valid_init', False): 
                if enemy_id_str in current_client_enemies_map: 
                    client_enemy = current_client_enemies_map[enemy_id_str]
                    if hasattr(client_enemy, 'set_network_data'): 
                        client_enemy.set_network_data(enemy_data_from_server)
                        if not client_enemy.alive() and client_enemy._valid_init : 
                            all_sprites.add(client_enemy)
                            enemy_sprites.add(client_enemy)
                else: 
                    print(f"Client: Creating new enemy {enemy_id_str} from server state.")
                    try:
                        spawn_pos_e = enemy_data_from_server.get('pos', (0,0)) 
                        patrol_area_e = None 
                        color_name_e = enemy_data_from_server.get('color_name') 
                        matching_spawn_data = next((sd for sd_idx, sd in enumerate(enemy_spawns_data) if sd_idx == enemy_id_int), None)
                        if matching_spawn_data: patrol_area_e = matching_spawn_data.get('patrol')
                        new_enemy = Enemy(spawn_pos_e[0], spawn_pos_e[1], 
                                          patrol_area=patrol_area_e, 
                                          enemy_id=enemy_id_int) 
                        if new_enemy._valid_init:
                            new_enemy.set_network_data(enemy_data_from_server) 
                            all_sprites.add(new_enemy); enemy_sprites.add(new_enemy); enemy_list.append(new_enemy)
                        else: print(f"Client: Failed to initialize new enemy {enemy_id_str} from server.")
                    except Exception as e: print(f"Client: Error creating new enemy {enemy_id_str}: {e}")
            elif enemy_id_str in current_client_enemies_map: 
                enemy_to_remove = current_client_enemies_map[enemy_id_str]
                if enemy_to_remove.alive(): enemy_to_remove.kill()
                if enemy_to_remove in enemy_list: enemy_list.remove(enemy_to_remove)

        server_enemy_ids = set(received_enemy_data_map.keys())
        client_enemy_ids_to_remove = set(current_client_enemies_map.keys()) - server_enemy_ids
        for removed_id_str in client_enemy_ids_to_remove:
            if removed_id_str in current_client_enemies_map:
                enemy_to_remove = current_client_enemies_map[removed_id_str]
                if enemy_to_remove.alive(): enemy_to_remove.kill()
                if enemy_to_remove in enemy_list: enemy_list.remove(enemy_to_remove)

    if 'chest' in network_state:
        chest_data = network_state['chest']
        if chest_data and Chest is not None: 
            chest_pos_center = chest_data.get('pos'); chest_is_collected = chest_data.get('is_collected', False)
            if chest_is_collected: 
                if current_chest and current_chest.alive(): current_chest.kill(); current_chest = None
            elif chest_pos_center: 
                if not current_chest or not current_chest.alive(): 
                    if current_chest: current_chest.kill() 
                    try:
                        temp_chest_height_approx = getattr(Chest(0,0).image, 'get_height', lambda: 30)() 
                        chest_spawn_x_mid = chest_pos_center[0]
                        chest_spawn_y_bottom = chest_pos_center[1] + temp_chest_height_approx / 2
                        new_chest = Chest(chest_spawn_x_mid, chest_spawn_y_bottom)
                        if hasattr(new_chest, '_valid_init') and new_chest._valid_init:
                             all_sprites.add(new_chest); collectible_sprites.add(new_chest)
                             current_chest = new_chest
                             if hasattr(current_chest, 'is_collected'): current_chest.is_collected = False 
                        else: current_chest = None; print("Client: Failed to init chest from net.")
                    except Exception as e: print(f"Client: Error creating chest from net: {e}"); current_chest = None
                elif current_chest: 
                    if hasattr(current_chest, 'is_collected'): current_chest.is_collected = False
        elif not network_state.get('chest'): 
            if current_chest and current_chest.alive(): current_chest.kill(); current_chest = None
    

def draw_platformer_scene(target_screen, current_time_ticks):
    global all_sprites, camera, player1, player2, screen, debug_font, WIDTH, HEIGHT, enemy_list
    target_screen.fill(getattr(C, 'LIGHT_BLUE', (135, 206, 235)))
    if camera:
        for entity in all_sprites: 
            if entity.alive() and hasattr(entity, 'image') and hasattr(entity, 'rect'): 
                 target_screen.blit(entity.image, camera.apply(entity.rect))
        
        for enemy in enemy_list: 
            if enemy.alive() and enemy._valid_init and not enemy.is_dead and hasattr(enemy, 'current_health') and hasattr(enemy, 'max_health'):
                enemy_screen_rect = camera.apply(enemy.rect)
                bar_w = getattr(C, 'HEALTH_BAR_WIDTH', 50); bar_h = getattr(C, 'HEALTH_BAR_HEIGHT', 8)
                bar_x = enemy_screen_rect.centerx - bar_w / 2
                bar_y = enemy_screen_rect.top - bar_h - getattr(C, 'HEALTH_BAR_OFFSET_ABOVE', 5)
                if hasattr(ui, 'draw_health_bar'):
                    ui.draw_health_bar(target_screen, bar_x, bar_y, bar_w, bar_h, enemy.current_health, enemy.max_health)
    else: 
        all_sprites.draw(target_screen) 

    if hasattr(ui, 'draw_player_hud'):
        if player1 and player1.alive() and hasattr(player1, '_valid_init') and player1._valid_init: 
            ui.draw_player_hud(target_screen, 10, 10, player1, 1)
        if player2 and player2.alive() and hasattr(player2, '_valid_init') and player2._valid_init: 
            p2_hud_x = WIDTH - (getattr(C, 'HEALTH_BAR_WIDTH', 50) * 2) - 120 
            ui.draw_player_hud(target_screen, p2_hud_x, 10, player2, 2)
            
def update_camera_platformer(target_focus=None, target2_focus=None):
    global camera
    if not camera: return
    actual_target = None
    if target_focus and target_focus.alive() and hasattr(target_focus, '_valid_init') and target_focus._valid_init and hasattr(target_focus, 'is_dead') and not target_focus.is_dead:
        actual_target = target_focus
    elif target2_focus and target2_focus.alive() and hasattr(target2_focus, '_valid_init') and target2_focus._valid_init and hasattr(target2_focus, 'is_dead') and not target2_focus.is_dead:
        actual_target = target2_focus
    
    if actual_target: camera.update(actual_target)
    else: camera.static_update() 

# --- Server Functions ---
def broadcast_presence(server_lan_ip):
    global app_running, server_udp_socket, SERVICE_NAME, SERVER_PORT_TCP, DISCOVERY_PORT_UDP, BROADCAST_INTERVAL_S
    broadcast_message_dict = {"service": SERVICE_NAME, "tcp_ip": server_lan_ip, "tcp_port": SERVER_PORT_TCP}
    broadcast_message_bytes = encode_data(broadcast_message_dict) 
    if not broadcast_message_bytes: print("Error: Could not encode broadcast message."); return
    try:
        server_udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
        server_udp_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        server_udp_socket.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1); server_udp_socket.settimeout(0.5)
    except socket.error as e: print(f"Error creating UDP broadcast socket: {e}"); server_udp_socket = None; return
    broadcast_address = ('<broadcast>', DISCOVERY_PORT_UDP)
    while app_running:
        try: server_udp_socket.sendto(broadcast_message_bytes[:-1], broadcast_address) 
        except socket.error: pass 
        except Exception as e: print(f"Unexpected error during broadcast send: {e}")
        time.sleep(BROADCAST_INTERVAL_S)
    if server_udp_socket: server_udp_socket.close(); server_udp_socket = None

def handle_client_connection(conn, addr):
    global client_input_buffer, app_running, client_lock, client_connection, BUFFER_SIZE
    print(f"Client connected via TCP: {addr}"); conn.settimeout(1.0) 
    partial_data_from_client = b""
    while app_running:
        with client_lock: 
            if client_connection is not conn: break
        try:
            chunk = conn.recv(BUFFER_SIZE)
            if not chunk: print(f"Client {addr} disconnected (received empty data)."); break
            partial_data_from_client += chunk
            decoded_inputs, partial_data_from_client = decode_data_stream(partial_data_from_client)
            if decoded_inputs:
                last_input_data = decoded_inputs[-1] 
                if "input" in last_input_data: 
                    with client_lock:
                        if client_connection is conn: client_input_buffer = last_input_data["input"]
        except socket.timeout: continue 
        except socket.error as e:
            if app_running: print(f"Socket error with client {addr}: {e}. Assuming disconnect."); break
        except Exception as e: 
             if app_running: print(f"Unexpected error handling client {addr}: {e}"); traceback.print_exc(); break
    
    with client_lock:
        if client_connection is conn: 
            client_connection = None
            client_input_buffer = {"disconnect": True} 
    try: conn.shutdown(socket.SHUT_RDWR) 
    except: pass 
    try: conn.close()
    except: pass

def run_server_mode():
    global app_running, screen, clock, camera, client_connection, client_address, client_input_buffer, player1, player2, enemy_list, server_tcp_socket, broadcast_thread, client_handler_thread, client_lock, WIDTH, HEIGHT, current_chest, platform_sprites, ladder_sprites, hazard_sprites, enemy_sprites, collectible_sprites

    if not initialize_platformer_elements(for_game_mode="host"):
        print("Server: Failed to initialize platformer elements.")
        return 
    
    pygame.display.set_caption("Platformer - HOST (P1: WASD+VB | Self-Harm: H | Heal: G | Reset: R)")
    server_lan_ip = get_local_ip()
    p1_key_map = {
        'left': pygame.K_a, 'right': pygame.K_d, 'up': pygame.K_w, 'down': pygame.K_s,
        'attack1': pygame.K_v, 'attack2': pygame.K_b, 'dash': pygame.K_LSHIFT,
        'roll': pygame.K_LCTRL, 'interact': pygame.K_e} 

    broadcast_thread = threading.Thread(target=broadcast_presence, args=(server_lan_ip,), daemon=True); broadcast_thread.start()
    server_tcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM); server_tcp_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    try:
        server_tcp_socket.bind((SERVER_IP_BIND, SERVER_PORT_TCP)); server_tcp_socket.listen(1)
        server_tcp_socket.settimeout(1.0); print(f"Server TCP listening on {SERVER_IP_BIND}:{SERVER_PORT_TCP}")
    except socket.error as e: print(f"FATAL: Failed to bind TCP socket: {e}"); app_running = False; return

    print("Waiting for Player 2 to connect..."); temp_client_conn = None
    while temp_client_conn is None and app_running: 
        try:
            events = pygame.event.get(); 
            for event in events:
                if event.type == pygame.QUIT: app_running = False; break
                if event.type == pygame.VIDEORESIZE: 
                     if not screen.get_flags() & pygame.FULLSCREEN: 
                        try:
                            WIDTH=max(320,event.w); HEIGHT=max(240,event.h)
                            screen=pygame.display.set_mode((WIDTH,HEIGHT), pygame.RESIZABLE|pygame.DOUBLEBUF)
                            if camera: camera.screen_width = WIDTH; camera.screen_height = HEIGHT 
                        except pygame.error as e: print(f"Resize error: {e}")
                if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE: app_running = False; break
            if not app_running: break 
            
            screen.fill(C.BLACK); wait_text = font_large.render("Waiting for P2...", True, C.WHITE)
            screen.blit(wait_text, wait_text.get_rect(center=(WIDTH//2, HEIGHT//2))); pygame.display.flip(); clock.tick(10)
            
            temp_client_conn, temp_client_addr = server_tcp_socket.accept()
            with client_lock: 
                 if client_connection: client_connection.close() 
                 client_connection = temp_client_conn; client_address = temp_client_addr; client_input_buffer = {}
        except socket.timeout: continue 
        except Exception as e: print(f"Error during client wait/accept: {e}"); app_running = False; break 
    
    if not app_running or client_connection is None: print("Exiting server (no client connected or app closed)."); return

    print(f"Client connected: {client_address}. Starting game...")
    client_handler_thread = threading.Thread(target=handle_client_connection, args=(client_connection, client_address), daemon=True)
    client_handler_thread.start()

    server_running_game = True
    while server_running_game and app_running:
        dt_sec = clock.tick(C.FPS) / 1000.0; now_ticks = pygame.time.get_ticks()
        p1_events = pygame.event.get(); keys_p1 = pygame.key.get_pressed()
        
        game_over_for_p2_reset_request = False 
        if player1 and player1._valid_init:
            if player1.is_dead and (not player1.alive() or (hasattr(player1, 'death_animation_finished') and player1.death_animation_finished)):
                game_over_for_p2_reset_request = True
        else: game_over_for_p2_reset_request = True
        
        reset_now = False

        for event in p1_events:
            if event.type == pygame.QUIT: server_running_game = False; app_running = False; break
            if event.type == pygame.VIDEORESIZE:
                if not screen.get_flags() & pygame.FULLSCREEN:
                    try:
                        WIDTH=max(320,event.w); HEIGHT=max(240,event.h)
                        screen=pygame.display.set_mode((WIDTH,HEIGHT), pygame.RESIZABLE|pygame.DOUBLEBUF)
                        if camera: camera.screen_width = WIDTH; camera.screen_height = HEIGHT
                    except pygame.error as e: print(f"Resize error: {e}")
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE: server_running_game = False 
                if event.key == pygame.K_r: # MODIFIED: Allow reset anytime by P1
                    print("DEBUG: 'R' key pressed (Server Mode) - unconditional P1 reset requested.")
                    reset_now = True
                if event.key == pygame.K_h and player1 and player1._valid_init and hasattr(player1, 'self_inflict_damage'):
                    player1.self_inflict_damage(getattr(C, 'PLAYER_SELF_DAMAGE', 10))
                if event.key == pygame.K_g and player1 and player1._valid_init and hasattr(player1, 'heal_to_full'):
                    player1.heal_to_full()

        if not app_running or not server_running_game: break
        
        if player1 and player1._valid_init and not player1.is_dead:
            player1.handle_mapped_input(keys_p1, p1_events, p1_key_map)

        remote_p2_input_copy, client_was_disconnected, reset_req_p2 = None, False, False
        with client_lock:
            if client_input_buffer:
                if client_input_buffer.get("disconnect"): client_was_disconnected = True
                elif client_input_buffer.get("action_reset", False): reset_req_p2 = True
                elif client_input_buffer.get("action_self_harm", False) and player2 and player2._valid_init: 
                    player2.self_inflict_damage(getattr(C, 'PLAYER_SELF_DAMAGE', 10))
                elif client_input_buffer.get("action_heal", False) and player2 and player2._valid_init: 
                    player2.heal_to_full()
                else: remote_p2_input_copy = client_input_buffer.copy()
                client_input_buffer = {} 
        
        if client_was_disconnected: print("Client disconnected signal received."); server_running_game = False; break 
        
        if player2 and player2._valid_init and remote_p2_input_copy and hasattr(player2, 'handle_network_input'):
            player2.handle_network_input(remote_p2_input_copy)

        # MODIFIED: P1 pressing 'R' always resets. P2 can request reset if P1 is game over.
        if reset_now or (reset_req_p2 and game_over_for_p2_reset_request): 
            print("DEBUG: Triggering reset_platformer_game_state() in Server Mode.")
            reset_platformer_game_state()
            if camera: camera.set_pos(0,0); 
            reset_req_p2 = False; reset_now = False
        
        if player1 and player1._valid_init: 
            other_players_for_p1 = [p for p in [player2] if p and p._valid_init and p.alive() and p is not player1]
            player1.update(dt_sec, platform_sprites, ladder_sprites, hazard_sprites, other_players_for_p1, enemy_list)
        
        if player2 and player2._valid_init: 
            other_players_for_p2 = [p for p in [player1] if p and p._valid_init and p.alive() and p is not player2]
            player2.update(dt_sec, platform_sprites, ladder_sprites, hazard_sprites, other_players_for_p2, enemy_list)
        
        active_players_for_enemies = [p for p in [player1, player2] if p and p._valid_init and not p.is_dead and p.alive()]
        for enemy_instance in enemy_list:
            if enemy_instance._valid_init: 
                enemy_instance.update(dt_sec, active_players_for_enemies, platform_sprites, hazard_sprites)
        
        collectible_sprites.update(dt_sec) 
        if Chest and current_chest and current_chest.alive():
            if player1 and player1._valid_init and not player1.is_dead and player1.alive() and pygame.sprite.collide_rect(player1, current_chest):
                 current_chest.collect(player1); current_chest = None 
            elif player2 and player2._valid_init and not player2.is_dead and player2.alive() and \
                 current_chest and current_chest.alive() and pygame.sprite.collide_rect(player2, current_chest):
                 current_chest.collect(player2); current_chest = None
        
        update_camera_platformer(player1, player2) 
        
        if client_connection: 
            net_state = get_platformer_network_state()
            encoded_state = encode_data(net_state)
            if encoded_state:
                try: client_connection.sendall(encoded_state)
                except socket.error as e: print(f"Send failed to client: {e}"); server_running_game = False; break
        
        try: draw_platformer_scene(screen, now_ticks)
        except Exception as e: print(f"Server draw error: {e}"); traceback.print_exc(); server_running_game=False; break
        pygame.display.flip()

    print("Exiting server game loop.")
    app_running = False 
    temp_conn_to_close = None
    with client_lock: 
        temp_conn_to_close = client_connection; client_connection = None 
    if temp_conn_to_close:
        try: temp_conn_to_close.shutdown(socket.SHUT_RDWR); temp_conn_to_close.close()
        except: pass 
    if server_tcp_socket: server_tcp_socket.close(); server_tcp_socket = None
    if broadcast_thread and broadcast_thread.is_alive(): broadcast_thread.join(0.2) 
    if client_handler_thread and client_handler_thread.is_alive(): client_handler_thread.join(0.2)
    print("Server mode finished.")

def run_client_mode(target_ip_port=None):
    global app_running, screen, clock, camera, client_tcp_socket, server_state_buffer, player1, player2, enemy_list, WIDTH, HEIGHT, current_chest, platform_sprites, ladder_sprites, hazard_sprites, enemy_sprites, collectible_sprites

    if not initialize_platformer_elements(for_game_mode="client"):
        print("Client: Failed to initialize platformer elements.")
        return
    
    server_ip_connect, server_port_connect = None, SERVER_PORT_TCP 
    if target_ip_port: 
        parts = target_ip_port.rsplit(':', 1); server_ip_connect = parts[0]
        if len(parts) > 1:
            try: server_port_connect = int(parts[1])
            except ValueError: print(f"Invalid port in '{target_ip_port}'. Using default {SERVER_PORT_TCP}.")
    else: 
        server_ip_connect, found_port = find_server(screen, font_small, font_large)
        if found_port: server_port_connect = found_port
    
    if not server_ip_connect: print("Exiting client (no server found/specified)."); return
    if not app_running: print("Exiting client (app closed before connection)."); return 
    
    p2_local_key_map_for_input_state = { 
        'left': pygame.K_a, 'right': pygame.K_d, 'up': pygame.K_w, 'down': pygame.K_s,
        'attack1': pygame.K_v, 'attack2': pygame.K_b, 'dash': pygame.K_LSHIFT,
        'roll': pygame.K_LCTRL, 'interact': pygame.K_e,
    }

    client_tcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    connection_successful, error_message = False, "Unknown Connection Error"
    try:
        print(f"Connecting to {server_ip_connect}:{server_port_connect}..."); pygame.display.set_caption(f"Platformer - Connecting...")
        screen.fill(C.BLACK); conn_text = font_large.render(f"Connecting...", True, C.WHITE)
        screen.blit(conn_text, conn_text.get_rect(center=(WIDTH//2, HEIGHT//2))); pygame.display.flip()
        client_tcp_socket.settimeout(10.0); client_tcp_socket.connect((server_ip_connect, server_port_connect))
        client_tcp_socket.settimeout(0.05); print("TCP Connection successful!"); connection_successful = True 
    except socket.error as e: error_message = f"Connection Error ({e.strerror if hasattr(e, 'strerror') else e})"
    except Exception as e: error_message = f"Unexpected Connection Error: {e}"
    
    if not connection_successful:
        print(f"Failed to connect: {error_message}")
        screen.fill(C.BLACK); fail_text = font_large.render(f"Connection Failed", True, C.RED)
        screen.blit(fail_text, fail_text.get_rect(center=(WIDTH//2, HEIGHT//2 - 30))); pygame.display.flip(); time.sleep(3)
        if client_tcp_socket: client_tcp_socket.close(); client_tcp_socket = None
        return

    pygame.display.set_caption("Platformer - CLIENT (You are P2: WASD+VB | Self-Harm: H | Heal: G | Reset: Enter)")
    server_state_buffer = b""; last_received_server_state = None; client_running_game = True
    
    while client_running_game and app_running:
        dt_sec = clock.tick(C.FPS) / 1000.0; now_ticks = pygame.time.get_ticks()
        
        client_input_actions = {'action_reset': False, 'action_self_harm': False, 'action_heal': False} 
        game_over_from_server = False
        if last_received_server_state and 'game_over' in last_received_server_state:
            game_over_from_server = last_received_server_state['game_over']
        
        client_events = pygame.event.get(); keys_client = pygame.key.get_pressed()
        for event in client_events:
            if event.type == pygame.QUIT: client_running_game = False; app_running = False; break
            if event.type == pygame.VIDEORESIZE:
                if not screen.get_flags() & pygame.FULLSCREEN:
                    try:
                        WIDTH=max(320,event.w); HEIGHT=max(240,event.h)
                        screen=pygame.display.set_mode((WIDTH,HEIGHT), pygame.RESIZABLE|pygame.DOUBLEBUF)
                        if camera: camera.screen_width = WIDTH; camera.screen_height = HEIGHT
                    except pygame.error as e: print(f"Resize error: {e}")
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE: client_running_game = False 
                if event.key == pygame.K_RETURN and game_over_from_server : # Client requests reset if server says game over
                    client_input_actions['action_reset'] = True
                if event.key == pygame.K_h: client_input_actions['action_self_harm'] = True 
                if event.key == pygame.K_g: client_input_actions['action_heal'] = True 

        if not app_running or not client_running_game: break
        
        p2_input_dict_to_send = {} 
        if player2 and hasattr(player2, 'get_input_state'): 
             p2_input_dict_to_send = player2.get_input_state(keys_client, client_events, p2_local_key_map_for_input_state)
        p2_input_dict_to_send.update(client_input_actions) 

        if client_tcp_socket: 
            client_payload = {"input": p2_input_dict_to_send}
            encoded_payload = encode_data(client_payload)
            if encoded_payload:
                try: client_tcp_socket.sendall(encoded_payload)
                except socket.error as e: print(f"Client send failed: {e}"); client_running_game=False; break 
        
        if client_tcp_socket:
            try:
                chunk = client_tcp_socket.recv(BUFFER_SIZE * 2) 
                if not chunk: print("Server disconnected."); client_running_game=False; break 
                server_state_buffer += chunk
                decoded_states, server_state_buffer = decode_data_stream(server_state_buffer)
                if decoded_states:
                    last_received_server_state = decoded_states[-1] 
                    set_platformer_network_state(last_received_server_state) 
            except socket.error as e: 
                if e.errno != 10035 and e.errno != 11: 
                    print(f"Client recv error: {e}"); client_running_game=False; break
            except Exception as e: print(f"Client data processing error: {e}"); traceback.print_exc(); client_running_game=False; break
        
        if player1 and player1.alive() and player1._valid_init: player1.animate() 
        if player2 and player2.alive() and player2._valid_init: player2.animate() 
        for enemy_instance in enemy_list: 
            if enemy_instance.alive() and enemy_instance._valid_init:
                enemy_instance.animate()

        collectible_sprites.update(dt_sec) 

        cam_target_client = None 
        if player2 and player2.alive() and player2._valid_init and not player2.is_dead :
            cam_target_client = player2
        elif player1 and player1.alive() and player1._valid_init and not player1.is_dead:
            cam_target_client = player1
        
        if cam_target_client: camera.update(cam_target_client)
        else: camera.static_update() 

        try: draw_platformer_scene(screen, now_ticks)
        except Exception as e: print(f"Client draw error: {e}"); traceback.print_exc(); client_running_game=False; break
        pygame.display.flip()

    print("Exiting client game loop.")
    if client_tcp_socket:
        try: client_tcp_socket.shutdown(socket.SHUT_RDWR); client_tcp_socket.close()
        except: pass
        client_tcp_socket = None
    print("Client mode finished.")


def run_couch_play_mode():
    global app_running, screen, clock, camera, player1, player2, enemy_list, WIDTH, HEIGHT, current_chest, platform_sprites, ladder_sprites, hazard_sprites, enemy_sprites, collectible_sprites, all_sprites

    print("Starting Couch Play mode...")
    pygame.display.set_caption("Platformer - Couch (P1:WASD+VB, P2:IJKL+OP | Harm:H,N | Heal:G,M | Reset:R)")

    if not initialize_platformer_elements(for_game_mode="couch_play"):
        print("Couch: Failed to initialize platformer elements.")
        return
    
    p1_key_map = {
        'left': pygame.K_a, 'right': pygame.K_d, 'up': pygame.K_w, 'down': pygame.K_s,
        'attack1': pygame.K_v, 'attack2': pygame.K_b, 'dash': pygame.K_LSHIFT,
        'roll': pygame.K_LCTRL, 'interact': pygame.K_e }
    p2_key_map = {
        'left': pygame.K_j, 'right': pygame.K_l, 'up': pygame.K_i, 'down': pygame.K_k,
        'attack1': pygame.K_o, 'attack2': pygame.K_p, 'dash': pygame.K_SEMICOLON, 
        'roll': pygame.K_QUOTE, 'interact': pygame.K_BACKSLASH } 

    couch_running_game = True
    while couch_running_game and app_running:
        dt_sec = clock.tick(getattr(C, 'FPS', 60)) / 1000.0; now_ticks = pygame.time.get_ticks()
        events = pygame.event.get(); keys = pygame.key.get_pressed()
        reset_now_couch = False
        
        for event in events:
            if event.type == pygame.QUIT: couch_running_game = False; app_running = False; break
            if event.type == pygame.VIDEORESIZE:
                if not screen.get_flags() & pygame.FULLSCREEN:
                    try:
                        WIDTH=max(320,event.w); HEIGHT=max(240,event.h)
                        screen=pygame.display.set_mode((WIDTH,HEIGHT), pygame.RESIZABLE|pygame.DOUBLEBUF)
                        if camera: camera.screen_width = WIDTH; camera.screen_height = HEIGHT
                    except pygame.error as e: print(f"Resize error: {e}")
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE: couch_running_game = False; break 
                
                if event.key == pygame.K_r: # MODIFIED: Allow reset anytime
                    print("DEBUG: 'R' key pressed (Couch Mode) - unconditional reset requested.")
                    reset_now_couch = True 
                
                if event.key == pygame.K_h and player1 and player1._valid_init and hasattr(player1, 'self_inflict_damage'):
                    player1.self_inflict_damage(getattr(C, 'PLAYER_SELF_DAMAGE', 10))
                if event.key == pygame.K_g and player1 and player1._valid_init and hasattr(player1, 'heal_to_full'):
                    player1.heal_to_full()
                
                if event.key == pygame.K_n and player2 and player2._valid_init and hasattr(player2, 'self_inflict_damage'):
                    player2.self_inflict_damage(getattr(C, 'PLAYER_SELF_DAMAGE', 10))
                if event.key == pygame.K_m and player2 and player2._valid_init and hasattr(player2, 'heal_to_full'):
                    player2.heal_to_full()

        if not app_running or not couch_running_game: break

        if player1 and player1._valid_init and not player1.is_dead:
            player1.handle_mapped_input(keys, events, p1_key_map)
        if player2 and player2._valid_init and not player2.is_dead:
            player2.handle_mapped_input(keys, events, p2_key_map)

        if reset_now_couch:
            print("DEBUG: Triggering reset_platformer_game_state() in Couch Mode.")
            reset_platformer_game_state()
            if camera: camera.set_pos(0,0); 
            reset_now_couch = False
        
        if player1 and player1._valid_init: 
            other_players_for_p1 = [p for p in [player2] if p and p._valid_init and p.alive() and p is not player1]
            player1.update(dt_sec, platform_sprites, ladder_sprites, hazard_sprites, other_players_for_p1, enemy_list)
        if player2 and player2._valid_init: 
            other_players_for_p2 = [p for p in [player1] if p and p._valid_init and p.alive() and p is not player2]
            player2.update(dt_sec, platform_sprites, ladder_sprites, hazard_sprites, other_players_for_p2, enemy_list)
        
        active_players_for_enemies = [p for p in [player1, player2] if p and p._valid_init and not p.is_dead and p.alive()]
        for enemy_instance in enemy_list: 
            if enemy_instance._valid_init: 
                enemy_instance.update(dt_sec, active_players_for_enemies, platform_sprites, hazard_sprites)
        
        collectible_sprites.update(dt_sec)
        if Chest and current_chest and current_chest.alive():
            if player1 and player1._valid_init and not player1.is_dead and player1.alive() and pygame.sprite.collide_rect(player1, current_chest):
                current_chest.collect(player1); current_chest = None
            elif player2 and player2._valid_init and not player2.is_dead and player2.alive() and \
                 current_chest and current_chest.alive() and pygame.sprite.collide_rect(player2, current_chest):
                current_chest.collect(player2); current_chest = None
        
        update_camera_platformer(player1, player2) 
        try: draw_platformer_scene(screen, now_ticks)
        except Exception as e: print(f"Couch draw error: {e}"); traceback.print_exc(); couch_running_game=False; break
        pygame.display.flip()
    print("Exiting Couch Play mode.")

def get_server_id_input(screen_surf, font_prompt, font_input, font_info, clock_obj):
    global app_running, SCRAP_INITIALIZED, PYPERCLIP_AVAILABLE, WIDTH, HEIGHT
    input_text = ""; input_active = True; cursor_visible = True; last_cursor_toggle = time.time()
    input_rect = pygame.Rect(WIDTH // 4, HEIGHT // 2 - 10, WIDTH // 2, 50)
    pygame.key.set_repeat(500, 50); paste_info_msg = None; paste_msg_start_time = 0
    while input_active and app_running:
        current_time = time.time()
        if current_time - last_cursor_toggle > 0.5: cursor_visible = not cursor_visible; last_cursor_toggle = current_time
        events = pygame.event.get()
        for event in events:
            if event.type == pygame.QUIT: app_running = False; input_active = False
            if event.type == pygame.VIDEORESIZE:
                 if not screen.get_flags() & pygame.FULLSCREEN:
                     try:
                         WIDTH=max(320,event.w); HEIGHT=max(240,event.h)
                         screen_surf=pygame.display.set_mode((WIDTH,HEIGHT), pygame.RESIZABLE|pygame.DOUBLEBUF)
                         input_rect = pygame.Rect(WIDTH // 4, HEIGHT // 2 - 10, WIDTH // 2, 50) 
                     except pygame.error as e: print(f"Resize error: {e}")
            if event.type == pygame.KEYDOWN:
                paste_info_msg = None 
                if event.key == pygame.K_ESCAPE: input_active = False; input_text = None 
                elif event.key == pygame.K_RETURN:
                    if input_text.strip(): input_active = False 
                    else: input_text = "" 
                elif event.key == pygame.K_BACKSPACE: input_text = input_text[:-1]
                elif event.key == pygame.K_v and (event.mod & pygame.KMOD_CTRL or event.mod & pygame.KMOD_META): 
                    pasted_content, paste_method_used = None, "None"
                    if SCRAP_INITIALIZED: 
                        try:
                            cb_data = pygame.scrap.get(pygame.SCRAP_TEXT) 
                            if cb_data: pasted_content = cb_data.decode('utf-8', errors='ignore').replace('\x00', '').strip()
                            if pasted_content: paste_method_used = "pygame.scrap"
                        except Exception as e_scrap: print(f"pygame.scrap paste error: {e_scrap}")
                    if not pasted_content and PYPERCLIP_AVAILABLE: 
                        try:
                            cb_data = pyperclip.paste()
                            if isinstance(cb_data, str): pasted_content = cb_data.replace('\x00', '').strip()
                            if pasted_content: paste_method_used = "pyperclip"
                        except Exception as e_pyperclip: print(f"pyperclip paste error: {e_pyperclip}")
                    if pasted_content: input_text += pasted_content
                    else: paste_info_msg = "Paste Failed/Empty"; paste_msg_start_time = current_time
                elif event.unicode.isalnum() or event.unicode in ['.', ':', '-']: input_text += event.unicode 
        
        screen_surf.fill(C.BLACK)
        prompt_surf = font_prompt.render("Enter Host IP Address or IP:Port", True, C.WHITE)
        screen_surf.blit(prompt_surf, prompt_surf.get_rect(center=(WIDTH // 2, HEIGHT // 2 - 60)))
        info_surf = font_info.render("(Enter=Confirm, Esc=Cancel, Ctrl+V=Paste)", True, C.GREY) 
        screen_surf.blit(info_surf, info_surf.get_rect(center=(WIDTH // 2, HEIGHT - 40)))
        pygame.draw.rect(screen_surf, C.GREY, input_rect, border_radius=5) 
        pygame.draw.rect(screen_surf, C.WHITE, input_rect, 2, border_radius=5) 
        text_surf = font_input.render(input_text, True, C.BLACK) 
        text_rect_render = text_surf.get_rect(midleft=(input_rect.left + 10, input_rect.centery))
        clip_render_area = input_rect.inflate(-12, -12) 
        if text_rect_render.right > clip_render_area.right : text_rect_render.right = clip_render_area.right 
        screen_surf.set_clip(clip_render_area); screen_surf.blit(text_surf, text_rect_render); screen_surf.set_clip(None) 
        if cursor_visible: 
            cursor_x_pos = text_rect_render.right + 2
            if cursor_x_pos < clip_render_area.left + 2: cursor_x_pos = clip_render_area.left + 2
            if cursor_x_pos > clip_render_area.right -1: cursor_x_pos = clip_render_area.right -1
            pygame.draw.line(screen_surf, C.BLACK, (cursor_x_pos, input_rect.top + 5), (cursor_x_pos, input_rect.bottom - 5), 2)
        if paste_info_msg and current_time - paste_msg_start_time < 2.0: 
            msg_s = font_info.render(paste_info_msg, True, C.RED); screen_surf.blit(msg_s, msg_s.get_rect(center=(WIDTH//2, input_rect.bottom+30)))
        elif paste_info_msg: paste_info_msg = None 
        pygame.display.flip(); clock_obj.tick(30)
    pygame.key.set_repeat(0,0) 
    return input_text.strip() if input_text is not None else None

def find_server(screen_surf, font_small_obj, font_large_obj):
    global app_running, clock, WIDTH, HEIGHT, SERVICE_NAME, DISCOVERY_PORT_UDP, CLIENT_SEARCH_TIMEOUT_S, BUFFER_SIZE
    pygame.display.set_caption("Platformer - Searching LAN...")
    search_text_surf = font_large_obj.render("Searching for server on LAN...", True, C.WHITE)
    listen_socket, found_server_ip, found_server_port = None, None, None
    try:
        listen_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
        listen_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        listen_socket.bind(('', DISCOVERY_PORT_UDP)); listen_socket.settimeout(0.5) 
    except socket.error as e:
        print(f"Error binding UDP listen socket {DISCOVERY_PORT_UDP}: {e}")
        screen_surf.fill(C.BLACK); err1 = font_small_obj.render(f"Error: Cannot listen on UDP {DISCOVERY_PORT_UDP}.", True, C.RED)
        screen_surf.blit(err1, err1.get_rect(center=(WIDTH//2, HEIGHT // 2))); pygame.display.flip(); time.sleep(4)
        return None, None 
    start_time, my_ip = time.time(), get_local_ip() 
    while time.time() - start_time < CLIENT_SEARCH_TIMEOUT_S and app_running:
        for event in pygame.event.get(): 
             if event.type == pygame.QUIT: app_running = False; break
             if event.type == pygame.VIDEORESIZE:
                if not screen.get_flags() & pygame.FULLSCREEN:
                    try:
                        WIDTH=max(320,event.w); HEIGHT=max(240,event.h)
                        screen_surf=pygame.display.set_mode((WIDTH,HEIGHT), pygame.RESIZABLE|pygame.DOUBLEBUF)
                    except pygame.error as e: print(f"Resize error: {e}")
             if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE: print("Search cancelled by user."); app_running = False; break 
        if not app_running: break
        screen_surf.fill(C.BLACK); screen_surf.blit(search_text_surf, search_text_surf.get_rect(center=(WIDTH//2, HEIGHT//2))); pygame.display.flip(); clock.tick(10)
        try:
            data, addr = listen_socket.recvfrom(BUFFER_SIZE)
            if addr[0] == my_ip: continue 
            decoded_msgs, _ = decode_data_stream(data + b'\n') 
            if not decoded_msgs: continue; message = decoded_msgs[0] 
            if (message and message.get("service") == SERVICE_NAME and 
                isinstance(message.get("tcp_ip"), str) and isinstance(message.get("tcp_port"), int)):
                ip, port = message["tcp_ip"], message["tcp_port"]
                print(f"Found server: {ip}:{port} from {addr[0]}"); found_server_ip, found_server_port = ip, port; break 
        except socket.timeout: continue 
        except Exception as e: print(f"Error processing UDP broadcast: {e}")
    if listen_socket: listen_socket.close() 
    if not found_server_ip and app_running: 
        print(f"No server found for '{SERVICE_NAME}'.")
        screen_surf.fill(C.BLACK); fail1 = font_large_obj.render("Server Not Found!", True, C.RED)
        screen_surf.blit(fail1, fail1.get_rect(center=(WIDTH//2, HEIGHT//2))); pygame.display.flip(); time.sleep(3)
    return found_server_ip, found_server_port

def show_main_menu():
    global screen, clock, font_small, font_medium, font_large, app_running, WIDTH, HEIGHT
    button_width, button_height, spacing = 350, 55, 20; title_button_gap = 60
    title_color = C.WHITE; btn_txt_color = C.WHITE; btn_color = C.BLUE; btn_hover = C.GREEN
    title_surf = font_large.render("Platformer Adventure LAN", True, title_color)
    buttons_data = { 
        "host": {"text": "Host Game (Online)", "action": "host"}, 
        "join_lan": {"text": "Join Game (LAN)", "action": "join_lan"},
        "join_internet": {"text": "Join Game (Internet)", "action": "join_internet"}, 
        "couch_play": {"text": "Couch Play (Local)", "action": "couch_play"},
        "quit": {"text": "Quit Game", "action": "quit"}}
    _title_rect_cache = None 
    def update_button_geometries_menu(): 
        nonlocal _title_rect_cache 
        _title_rect_cache = title_surf.get_rect(center=(WIDTH // 2, HEIGHT // 4))
        current_y_pos = _title_rect_cache.bottom + title_button_gap
        for key, props_dict in buttons_data.items():
            props_dict["rect"] = pygame.Rect(0,0,button_width,button_height); props_dict["rect"].centerx = WIDTH // 2
            props_dict["rect"].top = current_y_pos
            props_dict["text_surf"] = font_medium.render(props_dict["text"], True, btn_txt_color)
            props_dict["text_rect"] = props_dict["text_surf"].get_rect(center=props_dict["rect"].center)
            current_y_pos += button_height + spacing
    update_button_geometries_menu() 
    selected_option_menu = None
    while selected_option_menu is None and app_running:
        mouse_pos_menu = pygame.mouse.get_pos(); events_menu = pygame.event.get()
        for event_m in events_menu:
            if event_m.type == pygame.QUIT: app_running = False; selected_option_menu = "quit"
            if event_m.type == pygame.VIDEORESIZE:
                 if not screen.get_flags() & pygame.FULLSCREEN: 
                     try:
                         WIDTH=max(320,event_m.w); HEIGHT=max(240,event_m.h)
                         screen=pygame.display.set_mode((WIDTH,HEIGHT), pygame.RESIZABLE|pygame.DOUBLEBUF)
                         update_button_geometries_menu() 
                     except pygame.error as e: print(f"Menu resize error: {e}")
            if event_m.type == pygame.KEYDOWN and event_m.key == pygame.K_ESCAPE: app_running = False; selected_option_menu = "quit"
            if event_m.type == pygame.MOUSEBUTTONDOWN and event_m.button == 1: 
                for props_m in buttons_data.values(): 
                    if props_m["rect"].collidepoint(mouse_pos_menu): selected_option_menu = props_m["action"]; break 
        screen.fill(C.BLACK) 
        if _title_rect_cache: screen.blit(title_surf, _title_rect_cache) 
        for props_m in buttons_data.values(): 
            hover_m = props_m["rect"].collidepoint(mouse_pos_menu)
            pygame.draw.rect(screen, btn_hover if hover_m else btn_color, props_m["rect"], border_radius=8)
            screen.blit(props_m["text_surf"], props_m["text_rect"]) 
        pygame.display.flip(); clock.tick(30) 
    return selected_option_menu

# --- Main Execution ---
if __name__ == "__main__":
    clock = pygame.time.Clock()
    try:
        font_small = pygame.font.Font(None, 28); font_medium = pygame.font.Font(None, 36)
        font_large = pygame.font.Font(None, 72); debug_font = pygame.font.Font(None, 20)
    except Exception as e: print(f"FATAL: Font loading error: {e}"); pygame.quit(); sys.exit(1)

    while app_running:
        pygame.display.set_caption("Platformer Adventure - Main Menu")
        menu_choice = show_main_menu()
        
        if menu_choice == "quit": app_running = False; break 
        if not app_running: break 
        app_running = True 
        if menu_choice == "host": run_server_mode()
        elif menu_choice == "join_lan": run_client_mode() 
        elif menu_choice == "join_internet":
            target_ip = get_server_id_input(screen, font_medium, font_medium, font_small, clock)
            if target_ip and app_running: run_client_mode(target_ip_port=target_ip)
        elif menu_choice == "couch_play": run_couch_play_mode()
        
    print("Exiting application gracefully.")
    pygame.quit()
    try: 
        if SCRAP_INITIALIZED and pygame.scrap.get_init(): pygame.scrap.quit()
    except Exception: pass 
    sys.exit(0)

########## START OF FILE: player.py ##########

# player.py
# -*- coding: utf-8 -*-
"""
Defines the Player class, handling movement, animations, states, and interactions.
"""
# version 1.00000.6 (refining death physics, print limiter, lava freeze)
import pygame
import os
import sys
import math
import time # For PrintLimiter

# Import necessary components from other modules
import constants as C # Use constants with C. prefix
from assets import load_all_player_animations # Import the animation loader
from tiles import Lava # Import Lava for type checking in hazard collision

# --- Print Limiter Utility ---
class PrintLimiter:
    def __init__(self, default_limit=5, default_period=2.0):
        self.counts = {}
        self.timestamps = {}
        self.default_limit = default_limit
        self.default_period = default_period
        self.globally_suppressed = {}

    def can_print(self, message_key, limit=None, period=None):
        limit = limit if limit is not None else self.default_limit
        period = period if period is not None else self.default_period
        current_time = time.time()
        
        if message_key not in self.timestamps:
            self.timestamps[message_key] = current_time
            self.counts[message_key] = 0
            self.globally_suppressed[message_key] = False

        if current_time - self.timestamps[message_key] > period:
            self.timestamps[message_key] = current_time
            self.counts[message_key] = 0
            self.globally_suppressed[message_key] = False

        if self.counts[message_key] < limit:
            self.counts[message_key] += 1
            return True
        elif not self.globally_suppressed[message_key]:
            print(f"[PrintLimiter] Suppressing further prints for '{message_key}' for {period:.1f}s (limit: {limit})")
            self.globally_suppressed[message_key] = True
            return False
        return False

class Player(pygame.sprite.Sprite):
    # Class-level limiter for messages that might be common across instances or general warnings
    print_limiter = PrintLimiter(default_limit=3, default_period=5.0)

    def __init__(self, start_x, start_y, player_id=1):
        super().__init__()
        self.player_id = player_id
        self._valid_init = True 
        # self.instance_print_limiter = PrintLimiter(default_limit=5, default_period=2.0) # Per-instance if needed

        if self.player_id == 1: asset_folder = 'characters/player1'
        elif self.player_id == 2: asset_folder = 'characters/player2'
        else:
            asset_folder = 'characters/player1'
            if Player.print_limiter.can_print(f"player_unrecognized_id_{self.player_id}"):
                print(f"Warning: Player {self.player_id} has an unrecognized ID. Defaulting to player1 assets.")

        self.animations = load_all_player_animations(relative_asset_folder=asset_folder)

        if self.animations is None:
            print(f"CRITICAL Player {self.player_id} Init Error: Failed to load critical animations from {asset_folder}.")
            self.image = pygame.Surface((30, 40)).convert_alpha(); self.image.fill(C.RED)
            self.rect = self.image.get_rect(midbottom=(start_x, start_y))
            self.is_dead = True; self._valid_init = False; return

        try: self.standard_height = self.animations['idle'][0].get_height()
        except (KeyError, IndexError, TypeError):
            self.standard_height = 60
            if Player.print_limiter.can_print(f"player_{self.player_id}_idle_height_warning"):
                print(f"Warning Player {self.player_id}: Could not get player idle animation height, using default {self.standard_height}.")


        self._last_facing = True; self._last_state_for_debug = "init"
        self.state = 'idle'; self.current_frame = 0
        self.last_anim_update = pygame.time.get_ticks()

        idle_anim = self.animations.get('idle')
        if idle_anim and len(idle_anim) > 0: self.image = idle_anim[0]
        else:
            self.image = pygame.Surface((30,40)); self.image.fill(C.RED)
            print(f"CRITICAL Player {self.player_id}: Missing or empty 'idle' animation during init.")
            self._valid_init = False; return

        self.rect = self.image.get_rect(midbottom=(start_x, start_y))
        self.pos = pygame.math.Vector2(start_x, start_y)
        self.vel = pygame.math.Vector2(0, 0)
        self.acc = pygame.math.Vector2(0, C.PLAYER_GRAVITY)
        self.facing_right = True; self.on_ground = False; self.on_ladder = False
        self.can_grab_ladder = False; self.touching_wall = 0; self.is_crouching = False
        self.is_dashing = False; self.dash_timer = 0; self.dash_duration = getattr(C, 'PLAYER_DASH_DURATION', 150)
        self.is_rolling = False; self.roll_timer = 0; self.roll_duration = getattr(C, 'PLAYER_ROLL_DURATION', 300)
        self.is_sliding = False; self.slide_timer = 0; self.slide_duration = getattr(C, 'PLAYER_SLIDE_DURATION', 400)
        self.is_attacking = False; self.attack_timer = 0; self.attack_duration = 300; self.attack_type = 0
        self.can_combo = False; self.combo_window = getattr(C, 'PLAYER_COMBO_WINDOW', 150)
        self.wall_climb_timer = 0; self.wall_climb_duration = getattr(C, 'PLAYER_WALL_CLIMB_DURATION', 500)
        self.can_wall_jump = False
        self.is_taking_hit = False; self.hit_timer = 0
        self.hit_duration = getattr(C, 'PLAYER_HIT_STUN_DURATION', 300) 
        self.hit_cooldown = getattr(C, 'PLAYER_HIT_COOLDOWN', 600)   
        self.is_dead = False; self.state_timer = 0
        self.max_health = C.PLAYER_MAX_HEALTH; self.current_health = self.max_health
        self.attack_hitbox = pygame.Rect(0, 0, 45, 30) 

        self.is_trying_to_move_left = False; self.is_trying_to_move_right = False
        self.is_holding_climb_ability_key = False; self.is_holding_crouch_ability_key = False
        self.death_animation_finished = False


    def set_state(self, new_state):
        if not self._valid_init: return
        original_new_state_request = new_state

        anim_exists = new_state in self.animations and self.animations[new_state]
        if not anim_exists:
            fallback_state = 'fall' if not self.on_ground else 'idle'
            if fallback_state in self.animations and self.animations[fallback_state]: new_state = fallback_state
            else:
                first_available = next((key for key, anim in self.animations.items() if anim), None)
                if not first_available: self._valid_init = False; return
                new_state = first_available
        
        can_change_state = (self.state != new_state or new_state == 'death') and \
                           not (self.is_dead and not self.death_animation_finished and new_state != 'death')

        if can_change_state:
            if Player.print_limiter.can_print(f"player_{self.player_id}_set_state", limit=10, period=1.0):
                print(f"DEBUG Player {self.player_id}: Set State from '{self.state}' to '{new_state}' (Original req: '{original_new_state_request}')")
            self._last_state_for_debug = new_state
            if 'attack' not in new_state and self.is_attacking: self.is_attacking = False; self.attack_type = 0
            if new_state != 'hit': self.is_taking_hit = False
            if new_state != 'dash': self.is_dashing = False
            if new_state != 'roll': self.is_rolling = False
            if new_state not in ['slide', 'slide_trans_start', 'slide_trans_end']: self.is_sliding = False

            self.state = new_state
            self.current_frame = 0
            self.last_anim_update = pygame.time.get_ticks()
            self.state_timer = pygame.time.get_ticks()

            if new_state == 'dash':
                self.is_dashing = True; self.dash_timer = self.state_timer
                self.vel.x = C.PLAYER_DASH_SPEED * (1 if self.facing_right else -1); self.vel.y = 0
            elif new_state == 'roll':
                 self.is_rolling = True; self.roll_timer = self.state_timer
                 if abs(self.vel.x) < C.PLAYER_ROLL_SPEED / 2: self.vel.x = C.PLAYER_ROLL_SPEED * (1 if self.facing_right else -1)
                 elif abs(self.vel.x) < C.PLAYER_ROLL_SPEED: self.vel.x += (C.PLAYER_ROLL_SPEED / 3) * (1 if self.facing_right else -1)
                 self.vel.x = max(-C.PLAYER_ROLL_SPEED, min(C.PLAYER_ROLL_SPEED, self.vel.x))
            elif new_state == 'slide' or new_state == 'slide_trans_start':
                 self.is_sliding = True; self.slide_timer = self.state_timer
                 if abs(self.vel.x) < C.PLAYER_RUN_SPEED_LIMIT * 0.5: self.vel.x = C.PLAYER_RUN_SPEED_LIMIT * 0.6 * (1 if self.facing_right else -1)
            elif 'attack' in new_state: 
                self.is_attacking = True; self.attack_timer = self.state_timer
                anim = self.animations.get(new_state)
                num_frames = len(anim) if anim else 0
                base_frame_duration = C.ANIM_FRAME_DURATION
                if self.attack_type == 2 and hasattr(C, 'PLAYER_ATTACK2_FRAME_DURATION_MULTIPLIER'):
                    self.attack_duration = num_frames * int(base_frame_duration * C.PLAYER_ATTACK2_FRAME_DURATION_MULTIPLIER) if num_frames > 0 else 300
                else:
                    self.attack_duration = num_frames * base_frame_duration if num_frames > 0 else 300
                if new_state in ['attack_nm', 'attack2_nm', 'attack_combo_nm', 'crouch_attack']: self.vel.x = 0
            elif new_state == 'hit':
                 if Player.print_limiter.can_print(f"player_{self.player_id}_enter_hit_state"):
                    print(f"DEBUG Player {self.player_id}: Entering 'hit' state. Vel BEFORE modification: ({self.vel.x:.2f}, {self.vel.y:.2f})")
                 self.is_taking_hit = True; self.hit_timer = self.state_timer
                 if not self.on_ground and self.vel.y > -abs(C.PLAYER_JUMP_STRENGTH * 0.5): 
                    self.vel.x *= -0.3 
                    self.vel.y = C.PLAYER_JUMP_STRENGTH * 0.4 
                 self.is_attacking = False; self.attack_type = 0
                 # if Player.print_limiter.can_print(f"player_{self.player_id}_set_hit_state_vel"):
                 #    print(f"DEBUG Player {self.player_id}: Set state to 'hit'. Vel AFTER modification (if any): ({self.vel.x:.2f}, {self.vel.y:.2f})")
            elif new_state == 'death' or new_state == 'death_nm':
                 if Player.print_limiter.can_print(f"player_{self.player_id}_enter_death_state"):
                    print(f"DEBUG Player {self.player_id}: Entering 'death' state. Vel BEFORE: ({self.vel.x:.2f}, {self.vel.y:.2f})")
                 self.is_dead = True; self.vel.x = 0
                 if self.vel.y < -1: self.vel.y = 1 # Prevent flying up, start gentle fall
                 self.acc.x = 0
                 if not self.on_ground: self.acc.y = C.PLAYER_GRAVITY 
                 else: self.vel.y = 0; self.acc.y = 0 
                 self.death_animation_finished = False 
                 if Player.print_limiter.can_print(f"player_{self.player_id}_in_death_state_vel"):
                    print(f"DEBUG Player {self.player_id}: In 'death' state. Final vel: ({self.vel.x:.2f}, {self.vel.y:.2f}), Acc: ({self.acc.x:.2f}, {self.acc.y:.2f})")
            elif new_state == 'wall_climb':
                 self.wall_climb_timer = self.state_timer; self.vel.y = C.PLAYER_WALL_CLIMB_SPEED
            elif new_state == 'wall_slide' or new_state == 'wall_hang': self.wall_climb_timer = 0

            self.animate()
        elif not self.is_dead: self._last_state_for_debug = self.state

    def animate(self):
        if not self._valid_init or not hasattr(self, 'animations') or not self.animations: return
        if not self.alive(): return 

        now = pygame.time.get_ticks(); state_key = self.state
        moving_intended_by_input = self.is_trying_to_move_left or self.is_trying_to_move_right

        if self.is_dead: 
            state_key = 'death_nm' if abs(self.vel.x) < 0.5 and abs(self.vel.y) < 1.0 and 'death_nm' in self.animations else 'death'
            if state_key not in self.animations or not self.animations[state_key]: state_key = 'death'
        elif self.is_attacking:
            if self.attack_type == 1: state_key = 'attack' if moving_intended_by_input else 'attack_nm'
            elif self.attack_type == 2: state_key = 'attack2' if moving_intended_by_input else 'attack2_nm'
            elif self.attack_type == 3: state_key = 'attack_combo' if moving_intended_by_input else 'attack_combo_nm'
            elif self.attack_type == 4: state_key = 'crouch_attack'
            if state_key not in self.animations or not self.animations[state_key]:
                 base_state = state_key.replace('_nm', '')
                 state_key = base_state if base_state in self.animations and self.animations[base_state] else 'idle'
        elif self.state == 'wall_climb':
             is_actively_climbing = self.is_holding_climb_ability_key and abs(self.vel.y - C.PLAYER_WALL_CLIMB_SPEED) < 0.1
             state_key = 'wall_climb' if is_actively_climbing else 'wall_climb_nm'
             if state_key not in self.animations or not self.animations[state_key]: state_key = 'wall_climb'
        elif self.state == 'hit': state_key = 'hit'
        elif not self.on_ground and not self.on_ladder and self.touching_wall == 0 and self.state not in ['jump', 'jump_fall_trans'] and self.vel.y > 1:
             state_key = 'fall'
        elif self.on_ladder:
            state_key = 'ladder_climb' if abs(self.vel.y) > 0.1 else 'ladder_idle'
            if state_key not in self.animations or not self.animations[state_key]: state_key = 'idle'
        elif self.is_dashing: state_key = 'dash'
        elif self.is_rolling: state_key = 'roll'
        elif self.is_sliding: state_key = 'slide'
        elif self.state == 'slide_trans_start': state_key = 'slide_trans_start'
        elif self.state == 'slide_trans_end': state_key = 'slide_trans_end'
        elif self.state == 'crouch_trans': state_key = 'crouch_trans'
        elif self.state == 'turn': state_key = 'turn'
        elif self.state == 'jump': state_key = 'jump'
        elif self.state == 'jump_fall_trans': state_key = 'jump_fall_trans'
        elif self.state == 'wall_slide': state_key = 'wall_slide'
        elif self.state == 'wall_hang': state_key = 'wall_hang'
        elif self.on_ground: 
            if self.is_crouching: state_key = 'crouch_walk' if moving_intended_by_input else 'crouch'
            elif moving_intended_by_input: state_key = 'run'
            else: state_key = 'idle'
        
        if state_key not in self.animations or not self.animations[state_key]: state_key = 'idle'
        animation = self.animations.get(state_key)

        if not animation :
            if hasattr(self, 'image') and self.image: self.image.fill(C.RED); return

        current_anim_frame_duration = C.ANIM_FRAME_DURATION
        if self.is_attacking and self.attack_type == 2 and hasattr(C, 'PLAYER_ATTACK2_FRAME_DURATION_MULTIPLIER'):
            current_anim_frame_duration = int(C.ANIM_FRAME_DURATION * C.PLAYER_ATTACK2_FRAME_DURATION_MULTIPLIER)

        if not (self.is_dead and self.death_animation_finished):
            if now - self.last_anim_update > current_anim_frame_duration:
                self.last_anim_update = now; self.current_frame = (self.current_frame + 1)
                if self.current_frame >= len(animation):
                    if self.is_dead: 
                        if Player.print_limiter.can_print(f"player_{self.player_id}_death_anim_done"):
                            print(f"DEBUG Player {self.player_id}: Death Animation FINISHED.")
                        self.current_frame = len(animation) - 1 
                        self.death_animation_finished = True
                        # Player doesn't self.kill() here; main game loop handles game over/removal
                        return 
                    
                    non_looping_states = [
                        'attack','attack_nm','attack2','attack2_nm','attack_combo','attack_combo_nm',
                        'crouch_attack','dash','roll','slide','hit','turn','jump',
                        'jump_fall_trans','crouch_trans','slide_trans_start','slide_trans_end']
                    if self.state in non_looping_states:
                         next_s = None; current_s = self.state
                         is_input_moving = self.is_trying_to_move_left or self.is_trying_to_move_right
                         if current_s == 'jump': next_s = 'jump_fall_trans' if 'jump_fall_trans' in self.animations else 'fall'
                         elif current_s == 'jump_fall_trans': next_s = 'fall'
                         elif current_s == 'hit': 
                             next_s = 'fall' if not self.on_ground and not self.on_ladder else 'idle'
                             if Player.print_limiter.can_print(f"player_{self.player_id}_hit_anim_done"):
                                print(f"DEBUG Player {self.player_id}: 'hit' animation finished. Transitioning to: {next_s}. On_ground: {self.on_ground}, VelY: {self.vel.y:.2f}")
                         elif current_s == 'turn': next_s = 'run' if is_input_moving else 'idle'
                         elif 'attack' in current_s:
                              self.is_attacking = False; self.attack_type = 0
                              if self.on_ladder: pass 
                              elif self.is_crouching: next_s = 'crouch'
                              elif not self.on_ground: next_s = 'fall'
                              elif is_input_moving : next_s = 'run'
                              else: next_s = 'idle'
                         elif current_s == 'crouch_trans':
                             self.is_crouching = self.is_holding_crouch_ability_key
                             next_s = 'crouch' if self.is_crouching else 'idle'
                         elif current_s == 'slide_trans_start': next_s = 'slide'
                         elif current_s in ['slide_trans_end', 'slide']:
                             self.is_sliding = False; self.is_crouching = self.is_holding_crouch_ability_key
                             next_s = 'crouch' if self.is_crouching else 'idle'
                         else: 
                              if current_s == 'dash': self.is_dashing = False
                              if current_s == 'roll': self.is_rolling = False
                              if self.on_ladder: pass
                              elif self.is_crouching: next_s = 'crouch'
                              elif not self.on_ground: next_s = 'fall'
                              elif is_input_moving : next_s = 'run'
                              else: next_s = 'idle'
                         if next_s: self.set_state(next_s); return
                         else: self.current_frame = 0
                    else: 
                        self.current_frame = 0
                if self.current_frame >= len(animation): self.current_frame = 0

        if not animation or self.current_frame < 0 or self.current_frame >= len(animation):
            self.current_frame = 0
            if not animation:
                if hasattr(self, 'image') and self.image: self.image.fill(C.RED); return

        new_image = animation[self.current_frame]
        if not self.facing_right: new_image = pygame.transform.flip(new_image, True, False)
        if self.image is not new_image or self._last_facing != self.facing_right:
            old_midbottom = self.rect.midbottom; self.image = new_image
            self.rect = self.image.get_rect(midbottom=old_midbottom); self._last_facing = self.facing_right

    def _process_input_logic(self, keys, events, key_config):
        now = pygame.time.get_ticks()
        input_blocked_by_state = self.is_dead or \
                                 (self.is_taking_hit and now - self.hit_timer < self.hit_duration) 

        if not self._valid_init or input_blocked_by_state :
            self.acc.x = 0
            # if input_blocked_by_state and Player.print_limiter.can_print(f"player_{self.player_id}_input_skip"):
                # print(f"DEBUG Player {self.player_id}: Input processing SKIPPED. is_dead={self.is_dead}, is_taking_hit={self.is_taking_hit}, stun_active={(self.is_taking_hit and now - self.hit_timer < self.hit_duration)}")
            return

        self.is_trying_to_move_left = keys[key_config['left']]
        self.is_trying_to_move_right = keys[key_config['right']]
        self.is_holding_climb_ability_key = keys[key_config['up']]
        self.is_holding_crouch_ability_key = keys[key_config['down']]
        self.acc.x = 0; is_trying_to_move_lr_thistick = False

        can_control_horizontal = not (self.is_dashing or self.is_rolling or self.is_sliding or self.on_ladder or \
                                     (self.is_attacking and self.state in ['attack_nm','attack2_nm','attack_combo_nm','crouch_attack']) or \
                                      self.state in ['turn','hit','death','death_nm','wall_climb','wall_climb_nm','wall_hang'])
        if can_control_horizontal:
            if self.is_trying_to_move_left and not self.is_trying_to_move_right:
                self.acc.x = -C.PLAYER_ACCEL; is_trying_to_move_lr_thistick = True
                if self.facing_right and self.on_ground and not self.is_crouching and not self.is_attacking and self.state in ['idle','run']: self.set_state('turn')
                self.facing_right = False
            elif self.is_trying_to_move_right and not self.is_trying_to_move_left:
                self.acc.x = C.PLAYER_ACCEL; is_trying_to_move_lr_thistick = True
                if not self.facing_right and self.on_ground and not self.is_crouching and not self.is_attacking and self.state in ['idle','run']: self.set_state('turn')
                self.facing_right = True

        can_initiate_crouch = self.on_ground and not self.on_ladder and not (self.is_dashing or self.is_rolling or self.is_sliding or self.is_attacking or self.state in ['turn','hit','death'])
        if self.is_holding_crouch_ability_key and can_initiate_crouch:
            if not self.is_crouching:
                 self.is_crouching = True; self.is_sliding = False
                 if 'crouch_trans' in self.animations and self.animations['crouch_trans'] and self.state not in ['crouch','crouch_walk','crouch_trans']: self.set_state('crouch_trans')
        elif not self.is_holding_crouch_ability_key and self.is_crouching:
            self.is_crouching = False

        if self.on_ladder:
             self.vel.y = 0
             if self.is_holding_climb_ability_key: self.vel.y = -C.PLAYER_LADDER_CLIMB_SPEED
             elif self.is_holding_crouch_ability_key: self.vel.y = C.PLAYER_LADDER_CLIMB_SPEED

        for event in events:
            if event.type == pygame.KEYDOWN:
                 if event.key == key_config['up']:
                      can_jump_action = not self.is_crouching and not self.is_attacking and not self.is_rolling and not self.is_sliding and not self.is_dashing and self.state not in ['turn','hit']
                      if self.on_ground and can_jump_action:
                          self.vel.y = C.PLAYER_JUMP_STRENGTH; self.set_state('jump'); self.on_ground = False
                      elif self.on_ladder and can_jump_action:
                          self.vel.y = C.PLAYER_JUMP_STRENGTH * 0.8; self.vel.x = C.PLAYER_RUN_SPEED_LIMIT * 0.5 * (1 if self.facing_right else -1)
                          self.on_ladder = False; self.set_state('jump')
                      elif self.can_wall_jump and self.touching_wall != 0 and can_jump_action:
                          self.vel.y = C.PLAYER_JUMP_STRENGTH; self.vel.x = C.PLAYER_RUN_SPEED_LIMIT * 1.5 * (-self.touching_wall)
                          self.facing_right = not self.facing_right; self.set_state('jump'); self.can_wall_jump = False; self.touching_wall = 0; self.wall_climb_timer = 0
                 if event.key == key_config['attack1']:
                      can_attack_action = not self.is_attacking and not self.is_dashing and not self.is_rolling and not self.is_sliding and not self.on_ladder and self.state not in ['turn','hit']
                      if can_attack_action:
                           self.attack_type = 1 
                           is_moving_for_attack = (self.acc.x !=0 or abs(self.vel.x) > 1.0)
                           if self.is_crouching: self.attack_type = 4; self.set_state('crouch_attack')
                           else: self.set_state('attack' if is_moving_for_attack and 'attack' in self.animations else 'attack_nm')
                 if event.key == key_config['attack2']:
                      can_attack_action = not self.is_attacking and not self.is_dashing and not self.is_rolling and not self.is_sliding and not self.on_ladder and self.state not in ['turn','hit']
                      if can_attack_action:
                           is_moving_for_attack = (self.acc.x != 0 or abs(self.vel.x) > 1.0)
                           time_since_attack1_finished_approx = now - (self.attack_timer + self.attack_duration) 
                           is_in_combo_window = (self.attack_type == 1 and not self.is_attacking and 
                                                 time_since_attack1_finished_approx < self.combo_window)
                           if is_in_combo_window and 'attack_combo' in self.animations:
                               self.attack_type = 3 
                               self.set_state('attack_combo' if is_moving_for_attack and 'attack_combo' in self.animations else 'attack_combo_nm')
                           elif self.is_crouching and 'crouch_attack' in self.animations:
                               self.attack_type = 4 
                               self.set_state('crouch_attack')
                           elif 'attack2' in self.animations:
                               self.attack_type = 2 
                               self.set_state('attack2' if is_moving_for_attack and 'attack2' in self.animations else 'attack2_nm')
                           elif self.attack_type == 0: 
                               self.attack_type = 1; self.set_state('attack' if is_moving_for_attack and 'attack' in self.animations else 'attack_nm')
                 if event.key == key_config['dash']:
                      if self.on_ground and not self.is_dashing and not self.is_rolling and not self.is_attacking and not self.is_crouching and not self.on_ladder and self.state not in ['turn','hit']: self.set_state('dash')
                 if event.key == key_config['roll']:
                      if self.on_ground and not self.is_rolling and not self.is_dashing and not self.is_attacking and not self.is_crouching and not self.on_ladder and self.state not in ['turn','hit']: self.set_state('roll')
                 if event.key == key_config['down']:
                      can_slide_action = self.on_ground and self.state == 'run' and abs(self.vel.x) > C.PLAYER_RUN_SPEED_LIMIT * 0.6 and \
                                   not self.is_sliding and not self.is_crouching and not self.is_attacking and \
                                   not self.is_rolling and not self.is_dashing and not self.on_ladder and self.state not in ['turn','hit']
                      if can_slide_action:
                           start_slide_state = 'slide_trans_start' if 'slide_trans_start' in self.animations and self.animations['slide_trans_start'] else 'slide'
                           if start_slide_state in self.animations: self.set_state(start_slide_state)
                 if event.key == key_config['interact']:
                      if self.can_grab_ladder and not self.on_ladder:
                          self.on_ladder = True; self.vel.y=0; self.vel.x=0; self.on_ground=False; self.touching_wall=0; self.can_wall_jump=False; self.wall_climb_timer=0
                          self.set_state('ladder_idle')
                      elif self.on_ladder:
                          self.on_ladder = False; self.set_state('fall' if not self.on_ground else 'idle')

        is_in_manual_override_state = self.is_attacking or self.is_dashing or self.is_rolling or self.is_sliding or self.is_taking_hit or \
                                   self.state in ['jump','turn','death','death_nm','hit','jump_fall_trans',
                                                  'crouch_trans','slide_trans_start','slide_trans_end',
                                                  'wall_climb','wall_climb_nm','wall_hang','wall_slide',
                                                  'ladder_idle','ladder_climb']
        if not is_in_manual_override_state: 
            if self.on_ladder:
                if abs(self.vel.y) > 0.1 : self.set_state('ladder_climb')
                else: self.set_state('ladder_idle')
            elif self.on_ground:
                 if self.is_crouching:
                     target_crouch_state = 'crouch_walk' if is_trying_to_move_lr_thistick and 'crouch_walk' in self.animations else 'crouch'
                     self.set_state(target_crouch_state if target_crouch_state in self.animations else 'idle')
                 elif is_trying_to_move_lr_thistick: self.set_state('run' if 'run' in self.animations else 'idle')
                 else: self.set_state('idle')
            else: 
                 if self.touching_wall != 0:
                     now_wall_time = pygame.time.get_ticks()
                     wall_climb_expired = (self.wall_climb_duration > 0 and self.wall_climb_timer > 0 and
                                           now_wall_time - self.wall_climb_timer > self.wall_climb_duration)
                     if self.vel.y > C.PLAYER_WALL_SLIDE_SPEED * 0.5 or wall_climb_expired:
                         self.set_state('wall_slide'); self.can_wall_jump = True
                     elif self.is_holding_climb_ability_key and abs(self.vel.x) < 1.0 and not wall_climb_expired and 'wall_climb' in self.animations:
                         self.set_state('wall_climb'); self.can_wall_jump = False
                     else:
                         hang_state = 'wall_hang' if ('wall_hang' in self.animations and self.animations['wall_hang']) else 'wall_slide'
                         self.set_state(hang_state)
                         if self.state == hang_state: self.vel.y = C.PLAYER_WALL_SLIDE_SPEED * 0.1
                         self.can_wall_jump = True
                 elif self.vel.y > 1.0 and self.state not in ['jump','jump_fall_trans']: 
                      self.set_state('fall' if 'fall' in self.animations else 'idle')
                 elif self.state not in ['jump','jump_fall_trans','fall']: 
                      self.set_state('idle')

    def handle_input(self, keys, events):
        key_config = {'left':pygame.K_a,'right':pygame.K_d,'up':pygame.K_w,'down':pygame.K_s,
                      'attack1':pygame.K_v,'attack2':pygame.K_b,'dash':pygame.K_LSHIFT,
                      'roll':pygame.K_LCTRL,'interact':pygame.K_e}
        self._process_input_logic(keys, events, key_config)

    def handle_mapped_input(self, keys, events, key_map):
        self._process_input_logic(keys, events, key_map)

    def update(self, dt, platforms, ladders, hazards, other_players_list, enemies_list):
        if not self._valid_init: return
        
        if self.is_dead: 
            if self.alive() and hasattr(self, 'animate'): 
                if not self.death_animation_finished: 
                    if not self.on_ground: 
                        self.vel.y += self.acc.y 
                        self.vel.y = min(self.vel.y, getattr(C, 'TERMINAL_VELOCITY_Y', 18))
                        self.pos.y += self.vel.y
                        self.rect.bottom = round(self.pos.y)
                        self.on_ground = False 
                        for plat in pygame.sprite.spritecollide(self, platforms, False):
                            if self.vel.y > 0 and self.rect.bottom > plat.rect.top and (self.pos.y - self.vel.y) <= plat.rect.top + 1:
                                self.rect.bottom = plat.rect.top
                                self.on_ground = True; self.vel.y = 0; self.acc.y = 0 
                                self.pos.y = self.rect.bottom; break 
                self.animate() 
            return 

        now = pygame.time.get_ticks()
        if self.is_taking_hit and now - self.hit_timer > self.hit_cooldown:
            if self.state == 'hit': 
                if Player.print_limiter.can_print(f"player_{self.player_id}_hit_cooldown_end_in_hit"):
                    print(f"DEBUG Player {self.player_id}: Hit COOLDOWN ended during 'hit' state. Transitioning. VelY: {self.vel.y:.2f}")
                self.is_taking_hit = False 
                self.set_state('fall' if not self.on_ground else 'idle') 
            else: 
                self.is_taking_hit = False
        
        self.check_ladder_collisions(ladders)
        if self.on_ladder and not self.can_grab_ladder: 
            self.on_ladder = False; self.set_state('fall' if not self.on_ground else 'idle')

        apply_gravity = not (self.on_ladder or self.state == 'wall_hang' or \
                            (self.state == 'wall_climb' and self.vel.y <= C.PLAYER_WALL_CLIMB_SPEED + 0.1) or \
                             self.is_dashing)
        if apply_gravity: self.vel.y += C.PLAYER_GRAVITY

        apply_horizontal_physics = not (self.is_dashing or self.is_rolling or self.on_ladder or \
                                      (self.state == 'wall_climb' and self.vel.y <= C.PLAYER_WALL_CLIMB_SPEED + 0.1))
        if apply_horizontal_physics:
            self.vel.x += self.acc.x
            current_friction = 0
            if self.on_ground and self.acc.x == 0 and not self.is_sliding and self.state != 'slide': current_friction = C.PLAYER_FRICTION
            elif not self.on_ground and not self.is_attacking and self.state not in ['wall_slide','wall_hang','wall_climb','wall_climb_nm']: current_friction = C.PLAYER_FRICTION * 0.2
            elif self.is_sliding or self.state == 'slide': current_friction = C.PLAYER_FRICTION * 0.7
            if current_friction != 0:
                 friction_force = self.vel.x * current_friction
                 if abs(self.vel.x) > 0.1: self.vel.x += friction_force
                 else: self.vel.x = 0
                 if abs(self.vel.x) < 0.5 and (self.is_sliding or self.state == 'slide'):
                     self.is_sliding = False
                     end_slide_state = 'slide_trans_end' if 'slide_trans_end' in self.animations and self.animations['slide_trans_end'] else None
                     if end_slide_state: self.set_state(end_slide_state)
                     else: self.is_crouching = self.is_holding_crouch_ability_key; self.set_state('crouch' if self.is_crouching else 'idle')
            run_limit = C.PLAYER_RUN_SPEED_LIMIT * 0.6 if self.is_crouching and self.state == 'crouch_walk' else C.PLAYER_RUN_SPEED_LIMIT
            if not self.is_dashing and not self.is_rolling and not self.is_sliding and self.state != 'slide':
                self.vel.x = max(-run_limit, min(run_limit, self.vel.x))

        if self.vel.y > 0 and not self.on_ladder: 
            self.vel.y = min(self.vel.y, getattr(C, 'TERMINAL_VELOCITY_Y', 18))

        self.touching_wall = 0; self.on_ground = False
        self.pos.x += self.vel.x; self.rect.centerx = round(self.pos.x)
        self.check_platform_collisions('x', platforms)
        all_other_characters = [p for p in other_players_list if p and p._valid_init and p.alive() and p is not self] + \
                               [e for e in enemies_list if e and e._valid_init and e.alive()]
        collided_x_char = self.check_character_collisions('x', all_other_characters)
        self.pos.y += self.vel.y; self.rect.bottom = round(self.pos.y)
        self.check_platform_collisions('y', platforms)
        if not collided_x_char: 
            self.check_character_collisions('y', all_other_characters) 

        self.pos.x = self.rect.centerx; self.pos.y = self.rect.bottom
        self.check_hazard_collisions(hazards)
        if self.alive() and not self.is_dead:
            attack_targets = [p for p in other_players_list if p and p._valid_init and p.alive() and p is not self] + \
                             [e for e in enemies_list if e and e._valid_init and e.alive()]
            self.check_attack_collisions(attack_targets)
        self.animate()


    def check_platform_collisions(self, direction, platforms):
        collided_wall_side = 0 
        for plat in pygame.sprite.spritecollide(self, platforms, False):
            if direction == 'x':
                if self.vel.x > 0: 
                    self.rect.right = plat.rect.left
                    if not self.on_ground and not self.on_ladder and self.rect.bottom > plat.rect.top + 5: 
                        collided_wall_side = 1 
                elif self.vel.x < 0: 
                    self.rect.left = plat.rect.right
                    if not self.on_ground and not self.on_ladder and self.rect.bottom > plat.rect.top + 5:
                        collided_wall_side = -1
                self.vel.x = 0; self.pos.x = self.rect.centerx
            elif direction == 'y':
                if self.vel.y > 0: 
                    if self.rect.bottom > plat.rect.top and (self.pos.y - self.vel.y) <= plat.rect.top + 1: 
                        self.rect.bottom = plat.rect.top
                        if not self.on_ground: 
                            self.can_wall_jump=False; self.wall_climb_timer=0 
                            if not self.is_sliding and self.state != 'slide_trans_end': self.vel.x *= 0.8 
                        self.on_ground=True; self.vel.y=0
                elif self.vel.y < 0: 
                    if self.rect.top < plat.rect.bottom and ((self.pos.y - self.rect.height) - self.vel.y) >= plat.rect.bottom -1 :
                         if self.on_ladder: self.on_ladder = False 
                         self.rect.top = plat.rect.bottom; self.vel.y=0
                self.pos.y = self.rect.bottom 
        if direction == 'x' and collided_wall_side != 0 and not self.on_ground and not self.on_ladder:
             self.touching_wall = collided_wall_side
             self.can_wall_jump = not (self.state == 'wall_climb' and self.is_holding_climb_ability_key)


    def check_ladder_collisions(self, ladders):
        if not self._valid_init: return
        check_rect_ladder = self.rect.inflate(-self.rect.width * 0.6, -self.rect.height * 0.1) 
        self.can_grab_ladder = False
        for ladder in pygame.sprite.spritecollide(self, ladders, False, collided=lambda p,l: check_rect_ladder.colliderect(l.rect)):
            if abs(self.rect.centerx - ladder.rect.centerx) < ladder.rect.width * 0.7 and \
               ladder.rect.top < self.rect.centery < ladder.rect.bottom : 
                  self.can_grab_ladder = True; break


    def check_character_collisions(self, direction, characters_list):
        if not self._valid_init or self.is_dead or not self.alive(): return False
        collision_occurred_this_frame = False
        for char_other in characters_list:
            if char_other is self: continue 
            if not (char_other and hasattr(char_other, '_valid_init') and char_other._valid_init and \
                    hasattr(char_other, 'is_dead') and not char_other.is_dead and char_other.alive()):
                continue 

            if self.rect.colliderect(char_other.rect):
                collision_occurred_this_frame = True
                bounce_vel = getattr(C, 'CHARACTER_BOUNCE_VELOCITY', 2.5)
                if direction == 'x':
                    push_dir = -1 if self.rect.centerx < char_other.rect.centerx else 1
                    if push_dir == -1: self.rect.right = char_other.rect.left
                    else: self.rect.left = char_other.rect.right
                    self.vel.x = push_dir * bounce_vel
                    if hasattr(char_other, 'vel'): char_other.vel.x = -push_dir * bounce_vel
                    if hasattr(char_other, 'pos') and hasattr(char_other, 'rect'): 
                        char_other.pos.x += -push_dir 
                        char_other.rect.centerx = round(char_other.pos.x)
                    self.pos.x = self.rect.centerx
                elif direction == 'y':
                    if self.vel.y > 0 and self.rect.bottom > char_other.rect.top and self.rect.centery < char_other.rect.centery:
                        self.rect.bottom = char_other.rect.top; self.on_ground=True; self.vel.y=0
                    elif self.vel.y < 0 and self.rect.top < char_other.rect.bottom and self.rect.centery > char_other.rect.centery:
                        self.rect.top = char_other.rect.bottom; self.vel.y=0
                    self.pos.y = self.rect.bottom
        return collision_occurred_this_frame

    def check_hazard_collisions(self, hazards):
        now = pygame.time.get_ticks()
        if not self._valid_init or self.is_dead or not self.alive() or \
           (self.is_taking_hit and now - self.hit_timer < self.hit_cooldown): 
            return
            
        damaged_this_frame = False
        feet_check_point = (self.rect.centerx, self.rect.bottom - 2) 

        for hazard in hazards: 
            if isinstance(hazard, Lava) and hazard.rect.collidepoint(feet_check_point):
                if not damaged_this_frame: 
                    if Player.print_limiter.can_print(f"player_{self.player_id}_lava_touch"):
                        print(f"DEBUG Player {self.player_id}: Touched LAVA at {feet_check_point}. Player rect: {self.rect}, Lava rect: {hazard.rect}. Current state: {self.state}, VelY: {self.vel.y:.2f}")
                    self.take_damage(C.LAVA_DAMAGE) 
                    damaged_this_frame = True 
                    if not self.is_dead: 
                         self.vel.y = C.PLAYER_JUMP_STRENGTH * 0.75 
                         push_dir = 1 if self.rect.centerx < hazard.rect.centerx else -1
                         self.vel.x = -push_dir * getattr(C, 'PLAYER_RUN_SPEED_LIMIT', 7) * 0.5 
                         self.on_ground = False 
                         self.on_ladder = False 
                         if Player.print_limiter.can_print(f"player_{self.player_id}_lava_bounce"):
                            print(f"DEBUG Player {self.player_id}: Bounced from LAVA. New vel: ({self.vel.x:.2f}, {self.vel.y:.2f}). State after take_damage will be '{self.state}'")
                    break 

    def check_attack_collisions(self, targets_list):
        if not self._valid_init or not self.is_attacking or self.is_dead or not self.alive(): return
        if self.facing_right: self.attack_hitbox.midleft = self.rect.midright
        else: self.attack_hitbox.midright = self.rect.midleft
        self.attack_hitbox.centery = self.rect.centery + (-10 if self.is_crouching else 0)
        now = pygame.time.get_ticks()
        for target in targets_list:
            if target is self: continue
            if not (target and hasattr(target, '_valid_init') and target._valid_init and \
                    hasattr(target, 'is_dead') and not target.is_dead and target.alive()): continue
            can_be_damaged = True
            if hasattr(target, 'is_taking_hit') and hasattr(target, 'hit_timer') and hasattr(target, 'hit_cooldown'):
                if target.is_taking_hit and (now - target.hit_timer < target.hit_cooldown):
                    can_be_damaged = False
            if can_be_damaged and self.attack_hitbox.colliderect(target.rect):
                if hasattr(target, 'take_damage') and callable(target.take_damage):
                    damage_to_deal = C.PLAYER_ATTACK1_DAMAGE 
                    if self.attack_type == 1: damage_to_deal = C.PLAYER_ATTACK1_DAMAGE
                    elif self.attack_type == 2: damage_to_deal = C.PLAYER_ATTACK2_DAMAGE
                    elif self.attack_type == 3: damage_to_deal = C.PLAYER_COMBO_ATTACK_DAMAGE
                    elif self.attack_type == 4: damage_to_deal = C.PLAYER_CROUCH_ATTACK_DAMAGE
                    if damage_to_deal > 0: target.take_damage(damage_to_deal)

    def take_damage(self, amount):
        now = pygame.time.get_ticks()
        if Player.print_limiter.can_print(f"player_{self.player_id}_take_damage_call", limit=10, period=1.0):
            print(f"DEBUG Player {self.player_id}: take_damage({amount}) called. HP: {self.current_health}, is_dead: {self.is_dead}, alive: {self.alive()}, is_taking_hit: {self.is_taking_hit}")
        
        if not self._valid_init or self.is_dead or not self.alive() or \
           (self.is_taking_hit and now - self.hit_timer < self.hit_cooldown): 
            if Player.print_limiter.can_print(f"player_{self.player_id}_damage_ignored", limit=3, period=1.0):
                print(f"DEBUG Player {self.player_id}: Damage IGNORED. Conditions: is_dead={self.is_dead}, alive={self.alive()}, is_taking_hit={self.is_taking_hit}, cooldown_active={(self.is_taking_hit and now - self.hit_timer < self.hit_cooldown)}")
            return

        if Player.print_limiter.can_print(f"player_{self.player_id}_damage_details", limit=10, period=1.0):
            print(f"DEBUG Player {self.player_id}: Taking {amount} damage. Old HP: {self.current_health}")
        self.current_health -= amount
        self.current_health = max(0, self.current_health)
        if Player.print_limiter.can_print(f"player_{self.player_id}_health_update", limit=10, period=1.0):
            print(f"DEBUG Player {self.player_id}: New HP: {self.current_health}/{self.max_health}")

        if self.current_health <= 0:
            if not self.is_dead: 
                if Player.print_limiter.can_print(f"player_{self.player_id}_setting_death"):
                    print(f"DEBUG Player {self.player_id}: Health <= 0. Setting state to death.")
                self.set_state('death') 
        else: 
            if not (self.state == 'hit' and now - self.state_timer < self.hit_duration):
                 if Player.print_limiter.can_print(f"player_{self.player_id}_setting_hit_after_damage"):
                    print(f"DEBUG Player {self.player_id}: Setting state to 'hit' after taking damage.")
                 self.set_state('hit') 

    def self_inflict_damage(self, amount):
        if not self._valid_init or self.is_dead or not self.alive(): return
        print(f"Player {self.player_id} self-inflicted {amount} damage. HP before: {self.current_health}")
        self.take_damage(amount)
        print(f"Player {self.player_id} HP after self-inflict: {self.current_health}/{self.max_health}")

    def heal_to_full(self):
        if not self._valid_init: return
        if self.is_dead and self.current_health <=0 : return
        self.current_health = self.max_health
        print(f"Player {self.player_id} healed to full: {self.current_health}/{self.max_health}")
        if self.is_taking_hit: self.is_taking_hit = False 
        if self.state == 'hit': self.set_state('idle')

    def reset_state(self, spawn_pos):
        if not self._valid_init: 
            print(f"Player {self.player_id} cannot reset, _valid_init is False.")
            return
        print(f"Player {self.player_id}: RESETTING STATE to spawn {spawn_pos}")
        self.pos = pygame.math.Vector2(spawn_pos[0], spawn_pos[1])
        self.rect.midbottom = (round(self.pos.x), round(self.pos.y))
        self.vel = pygame.math.Vector2(0, 0)
        self.acc = pygame.math.Vector2(0, C.PLAYER_GRAVITY if hasattr(C, 'PLAYER_GRAVITY') else 0.7)
        self.current_health = self.max_health; self.is_dead = False; self.is_taking_hit = False
        self.is_attacking = False; self.attack_type = 0; self.is_dashing = False; self.is_rolling = False; self.is_sliding = False
        self.on_ladder = False; self.touching_wall = 0; self.facing_right = True
        self.death_animation_finished = False 
        if hasattr(self.image, 'set_alpha') and hasattr(self.image, 'get_alpha') and \
           self.image.get_alpha() is not None and self.image.get_alpha() < 255:
            self.image.set_alpha(255) 
        self.set_state('idle')

    def get_network_data(self):
        return {'pos': (self.pos.x, self.pos.y), 'vel': (self.vel.x, self.vel.y), 'state': self.state,
                'facing_right': self.facing_right, 'current_health': self.current_health, 'is_dead': self.is_dead,
                'is_attacking': self.is_attacking, 'attack_type': self.attack_type,
                'current_frame': self.current_frame, 'last_anim_update': self.last_anim_update,
                'player_id': self.player_id, '_valid_init': self._valid_init,
                'death_animation_finished': self.death_animation_finished
               }

    def set_network_data(self, data): 
        if data is None: return
        self._valid_init = data.get('_valid_init', self._valid_init)
        if not self._valid_init:
            if self.alive(): self.kill(); return
        self.pos.x, self.pos.y = data.get('pos', (self.pos.x, self.pos.y))
        self.vel.x, self.vel.y = data.get('vel', (self.vel.x, self.vel.y))
        new_state = data.get('state', self.state)
        self.is_attacking = data.get('is_attacking', self.is_attacking)
        self.attack_type = data.get('attack_type', self.attack_type)
        self.death_animation_finished = data.get('death_animation_finished', self.death_animation_finished)
        new_is_dead = data.get('is_dead', self.is_dead)
        if new_is_dead and not self.is_dead:
            self.is_dead = True; self.current_health = 0
            self.set_state('death')
        elif not new_is_dead and self.is_dead: 
            self.is_dead = False; self.death_animation_finished = False
            if self.state in ['death', 'death_nm']: self.set_state('idle')
        else: self.is_dead = new_is_dead
        if self.state != new_state and not (self.is_dead and new_state in ['death', 'death_nm']):
             self.set_state(new_state)
        else:
            self.current_frame = data.get('current_frame', self.current_frame)
            self.last_anim_update = data.get('last_anim_update', self.last_anim_update)
        self.facing_right = data.get('facing_right', self.facing_right)
        self.current_health = data.get('current_health', self.current_health) 
        self.rect.midbottom = (round(self.pos.x), round(self.pos.y))
        if self._valid_init and self.alive(): self.animate()

    def handle_network_input(self, input_data_dict): 
        if not self._valid_init or self.is_dead or not self.alive(): return
        self.acc.x = 0
        is_trying_to_move_left_net = input_data_dict.get('left_held', False)
        is_trying_to_move_right_net = input_data_dict.get('right_held', False)
        can_control_horizontal_net = not (self.is_dashing or self.is_rolling or self.is_sliding or self.on_ladder or \
                                     (self.is_attacking and self.state in ['attack_nm','attack2_nm','attack_combo_nm','crouch_attack']) or \
                                      self.state in ['turn','hit','death','death_nm','wall_climb','wall_climb_nm','wall_hang'])
        new_facing_right = self.facing_right
        if can_control_horizontal_net:
            if is_trying_to_move_left_net and not is_trying_to_move_right_net:
                self.acc.x = -C.PLAYER_ACCEL; new_facing_right = False
            elif is_trying_to_move_right_net and not is_trying_to_move_left_net:
                self.acc.x = C.PLAYER_ACCEL; new_facing_right = True
        if self.on_ground and self.state in ['idle', 'run'] and not self.is_attacking and self.facing_right != new_facing_right:
            self.facing_right = new_facing_right; self.set_state('turn')
        else: self.facing_right = new_facing_right
        now = pygame.time.get_ticks()
        can_act_net = not self.is_attacking and not self.is_dashing and not self.is_rolling and \
                      not self.is_sliding and not self.on_ladder and self.state not in ['turn','hit']
        if input_data_dict.get('attack1_pressed_event', False) and can_act_net:
            self.attack_type = 4 if self.is_crouching else 1
            self.set_state('crouch_attack' if self.is_crouching else ('attack' if (is_trying_to_move_left_net or is_trying_to_move_right_net) else 'attack_nm'))
        if input_data_dict.get('attack2_pressed_event', False) and can_act_net:
            self.attack_type = 4 if self.is_crouching else 2
            self.set_state('crouch_attack' if self.is_crouching else ('attack2' if (is_trying_to_move_left_net or is_trying_to_move_right_net) else 'attack2_nm'))
        if input_data_dict.get('jump_intent', False) and can_act_net and not self.is_crouching:
             if self.on_ground: self.vel.y = C.PLAYER_JUMP_STRENGTH; self.set_state('jump'); self.on_ground = False
        if input_data_dict.get('dash_pressed_event', False) and self.on_ground and can_act_net and not self.is_crouching: self.set_state('dash')
        if input_data_dict.get('roll_pressed_event', False) and self.on_ground and can_act_net and not self.is_crouching: self.set_state('roll')

    def get_input_state(self, current_keys, current_events, key_map_for_player=None):
        input_state = {'left_held': False, 'right_held': False, 'up_held': False, 'down_held': False,
                       'attack1_pressed_event': False, 'attack2_pressed_event': False,
                       'dash_pressed_event': False, 'roll_pressed_event': False,
                       'interact_pressed_event': False, 'jump_intent': False}
        active_key_map = key_map_for_player or \
                         {'left':pygame.K_a,'right':pygame.K_d,'up':pygame.K_w,'down':pygame.K_s,
                          'attack1':pygame.K_v,'attack2':pygame.K_b,'dash':pygame.K_LSHIFT,
                          'roll':pygame.K_LCTRL,'interact':pygame.K_e}
        input_state['left_held'] = current_keys[active_key_map['left']]
        input_state['right_held'] = current_keys[active_key_map['right']]
        input_state['up_held'] = current_keys[active_key_map['up']]
        input_state['down_held'] = current_keys[active_key_map['down']]
        for event in current_events:
            if event.type == pygame.KEYDOWN:
                if event.key == active_key_map.get('attack1'): input_state["attack1_pressed_event"] = True
                if event.key == active_key_map.get('attack2'): input_state["attack2_pressed_event"] = True
                if event.key == active_key_map.get('dash'): input_state["dash_pressed_event"] = True
                if event.key == active_key_map.get('roll'): input_state["roll_pressed_event"] = True
                if event.key == active_key_map.get('interact'): input_state["interact_pressed_event"] = True
                if event.key == active_key_map.get('up'): input_state["jump_intent"] = True
        return input_state

########## START OF FILE: tiles.py ##########

# -*- coding: utf-8 -*-
"""
Defines classes for static and interactive tiles in the game world.
"""
# version 1.00000.1
import pygame
from constants import GRAY, BLUE, ORANGE_RED # Import colors

class Platform(pygame.sprite.Sprite):
    """ Standard solid platform. """
    def __init__(self, x, y, width, height, color=GRAY):
        super().__init__()
        self.image = pygame.Surface((width, height))
        self.image.fill(color)
        # Prevent negative width/height which causes Surface errors
        self.rect = self.image.get_rect(topleft=(x, y))
        if width <= 0 or height <= 0:
            print(f"Warning: Platform created with non-positive dimensions: w={width}, h={height} at ({x},{y})")
            # Optionally create a minimal valid rect/image or handle error
            self.image = pygame.Surface((1, 1)) # Minimal surface
            self.image.fill(color)
            self.rect = self.image.get_rect(topleft=(x,y))


class Ladder(pygame.sprite.Sprite):
    """ Climbable ladder area. """
    def __init__(self, x, y, width, height):
        super().__init__()
        # Ensure valid dimensions
        width = max(1, width)
        height = max(1, height)
        self.image = pygame.Surface((width, height)).convert_alpha()
        self.image.set_alpha(100) # Make semi-transparent
        self.image.fill((0, 0, 0, 0)) # Fully transparent background

        # Draw visual cues (rungs, rails)
        rung_color = (40, 40, 180, 200) # Slightly transparent dark blue
        num_rungs = int(height / 15)
        if num_rungs > 0: # Avoid division by zero if height is too small
            rung_spacing = height / num_rungs
            for i in range(1, num_rungs):
                rung_y = i * rung_spacing
                pygame.draw.line(self.image, rung_color, (0, rung_y), (width, rung_y), 2)
        # Draw side rails (ensure lines are within surface bounds)
        pygame.draw.line(self.image, rung_color, (min(2, width-1), 0), (min(2, width-1), height), 3)
        pygame.draw.line(self.image, rung_color, (max(0, width - 3), 0), (max(0, width - 3), height), 3)

        self.rect = self.image.get_rect(topleft=(x, y))

class Lava(pygame.sprite.Sprite):
    """ Dangerous lava tile that damages characters. """
    def __init__(self, x, y, width, height, color=ORANGE_RED):
        super().__init__()
        # Ensure valid dimensions
        width = max(1, width)
        height = max(1, height)
        self.image = pygame.Surface((width, height))
        self.image.fill(color)
        # Optional: Add visual effect like simple noise/flicker
        # for _ in range(int(width*height*0.1)): # Add some darker spots
        #      px = random.randint(0, width-1)
        #      py = random.randint(0, height-1)
        #      dark_color = (max(0,color[0]-50), max(0,color[1]-20), color[2])
        #      self.image.set_at((px, py), dark_color)

# -*- coding: utf-8 -*-
"""
Defines classes for static and interactive tiles in the game world.
"""
import pygame
from constants import GRAY, BLUE, ORANGE_RED # Import colors

class Platform(pygame.sprite.Sprite):
    """ Standard solid platform. """
    def __init__(self, x, y, width, height, color=GRAY):
        super().__init__()
        self.image = pygame.Surface((width, height))
        self.image.fill(color)
        # Prevent negative width/height which causes Surface errors
        self.rect = self.image.get_rect(topleft=(x, y))
        if width <= 0 or height <= 0:
            print(f"Warning: Platform created with non-positive dimensions: w={width}, h={height} at ({x},{y})")
            # Optionally create a minimal valid rect/image or handle error
            self.image = pygame.Surface((1, 1)) # Minimal surface
            self.image.fill(color)
            self.rect = self.image.get_rect(topleft=(x,y))


class Ladder(pygame.sprite.Sprite):
    """ Climbable ladder area. """
    def __init__(self, x, y, width, height):
        super().__init__()
        # Ensure valid dimensions
        width = max(1, width)
        height = max(1, height)
        self.image = pygame.Surface((width, height)).convert_alpha()
        self.image.set_alpha(100) # Make semi-transparent
        self.image.fill((0, 0, 0, 0)) # Fully transparent background

        # Draw visual cues (rungs, rails)
        rung_color = (40, 40, 180, 200) # Slightly transparent dark blue
        num_rungs = int(height / 15)
        if num_rungs > 0: # Avoid division by zero if height is too small
            rung_spacing = height / num_rungs
            for i in range(1, num_rungs):
                rung_y = i * rung_spacing
                pygame.draw.line(self.image, rung_color, (0, rung_y), (width, rung_y), 2)
        # Draw side rails (ensure lines are within surface bounds)
        pygame.draw.line(self.image, rung_color, (min(2, width-1), 0), (min(2, width-1), height), 3)
        pygame.draw.line(self.image, rung_color, (max(0, width - 3), 0), (max(0, width - 3), height), 3)

        self.rect = self.image.get_rect(topleft=(x, y))

class Lava(pygame.sprite.Sprite):
    """ Dangerous lava tile that damages characters. """
    def __init__(self, x, y, width, height, color=ORANGE_RED):
        super().__init__()
        # Ensure valid dimensions
        width = max(1, width)
        height = max(1, height)
        self.image = pygame.Surface((width, height))
        self.image.fill(color)
        self.rect = self.image.get_rect(topleft=(x, y))

########## START OF FILE: ui.py ##########

# -*- coding: utf-8 -*-
"""
Functions for drawing User Interface elements like health bars and player HUDs.
"""
# version 1.00000.1
import pygame
import constants as C # Import constants with C. prefix

# --- Font Initialization (Initialize once) ---
# It's good practice to initialize fonts once, e.g., when the UI module is imported or in a setup function.
# For simplicity, we'll do it here. Handle font loading errors gracefully.
try:
    pygame.font.init() # Ensure the font module is initialized
    HUD_FONT_SIZE = 20
    HUD_FONT = pygame.font.Font(None, HUD_FONT_SIZE) # Use default system font
    # For a custom font: HUD_FONT = pygame.font.Font("path/to/your/font.ttf", HUD_FONT_SIZE)
except pygame.error as e:
    print(f"Warning: Could not initialize font: {e}. Using fallback.")
    HUD_FONT = None
except Exception as e: # Catch other potential errors during font loading
    print(f"Warning: An unexpected error occurred while initializing font: {e}. Using fallback.")
    HUD_FONT = None

if HUD_FONT is None: # Fallback if font loading failed
    try: # Try a very basic Pygame font if default failed
        HUD_FONT = pygame.font.SysFont("arial", HUD_FONT_SIZE) # Common system font
    except pygame.error: # If even SysFont fails
        print("Critical Warning: All font loading failed. Text HUD elements will not be drawn.")
        HUD_FONT = None # Ensure it's None so checks below work

# --- Existing Health Bar Function ---
def draw_health_bar(surface, x, y, width, height, current_hp, max_hp):
    """ Draws a health bar at the given position with color transition. """
    if max_hp <= 0: return

    current_hp = max(0, current_hp)
    width = max(1, width)
    height = max(1, height)
    hp_ratio = min(1, current_hp / max_hp)

    try:
        health_color = pygame.Color(C.RED).lerp(C.GREEN, hp_ratio)
    except AttributeError: # Manual lerp for older Pygame or if Color.lerp is missing
        r = int(C.RED[0] * (1 - hp_ratio) + C.GREEN[0] * hp_ratio)
        g = int(C.RED[1] * (1 - hp_ratio) + C.GREEN[1] * hp_ratio)
        b = int(C.RED[2] * (1 - hp_ratio) + C.GREEN[2] * hp_ratio)
        health_color = (max(0, min(255, r)), max(0, min(255, g)), max(0, min(255, b)))

    background_rect = pygame.Rect(x, y, width, height)
    pygame.draw.rect(surface, C.DARK_GRAY, background_rect)

    health_fill_width = int(width * hp_ratio)
    if health_fill_width > 0:
        health_rect = pygame.Rect(x, y, health_fill_width, height)
        pygame.draw.rect(surface, health_color, health_rect)
    pygame.draw.rect(surface, C.BLACK, background_rect, 1)


# --- NEW: Player HUD Function ---
def draw_player_hud(surface, x, y, player, player_number):
    """
    Draws the Heads-Up Display for a given player.
    Includes player label and health bar.

    Args:
        surface (pygame.Surface): The surface to draw on.
        x (int): The top-left x-coordinate for the HUD.
        y (int): The top-left y-coordinate for the HUD.
        player (Player): The player object, expected to have 'current_health' and 'max_health'.
        player_number (int): The number of the player (e.g., 1 or 2).
    """
    if not player or not hasattr(player, 'current_health') or not hasattr(player, 'max_health'):
        # print(f"Warning: Invalid player object or missing health attributes for HUD P{player_number}.")
        return

    # --- Player Label ---
    label_text = f"P{player_number}"
    if HUD_FONT:
        try:
            label_surface = HUD_FONT.render(label_text, True, C.WHITE)
            surface.blit(label_surface, (x, y))
            label_height = label_surface.get_height()
        except pygame.error as e: # Catch errors during rendering (e.g. font not loaded)
            print(f"Warning: Could not render HUD label for P{player_number}: {e}")
            label_height = HUD_FONT_SIZE # Estimate height
        except Exception as e:
            print(f"Warning: Unexpected error rendering HUD label for P{player_number}: {e}")
            label_height = HUD_FONT_SIZE
    else: # No font loaded
        label_height = 0 # No label to draw, so no height offset for health bar

    # --- Health Bar ---
    # Position health bar below the label
    health_bar_x = x
    health_bar_y = y + label_height + 5  # Add some padding
    health_bar_width = C.HEALTH_BAR_WIDTH * 2 # Make it a bit wider for HUD
    health_bar_height = C.HEALTH_BAR_HEIGHT + 4 # Make it a bit taller for HUD

    draw_health_bar(surface, health_bar_x, health_bar_y,
                    health_bar_width, health_bar_height,
                    player.current_health, player.max_health)

    # --- Optional: Draw Health Value Text ---
    if HUD_FONT:
        try:
            health_text = f"{int(player.current_health)}/{int(player.max_health)}"
            health_text_surface = HUD_FONT.render(health_text, True, C.WHITE)
            # Position text next to or on the health bar
            text_x = health_bar_x + health_bar_width + 10
            text_y = health_bar_y + (health_bar_height - health_text_surface.get_height()) / 2 # Center vertically
            surface.blit(health_text_surface, (text_x, text_y))
        except pygame.error as e:
            print(f"Warning: Could not render HUD health text for P{player_number}: {e}")
        except Exception as e:
            print(f"Warning: Unexpected error rendering HUD health text for P{player_number}: {e}")


# Example of how you might call this in your main loop (for testing ui.py directly)
if __name__ == '__main__':
    pygame.init()
    if not pygame.font.get_init(): # Ensure font module is initialized if running directly
        pygame.font.init()
        if HUD_FONT is None: # Re-attempt basic font loading if it failed at module level
            try:
                HUD_FONT = pygame.font.SysFont("arial", 20)
            except:
                print("Main test: Font loading failed.")


    screen_width = 300
    screen_height = 200
    screen = pygame.display.set_mode((screen_width, screen_height))
    pygame.display.set_caption("UI Test")

    # Dummy player object for testing
    class DummyPlayer:
        def __init__(self, current_hp, max_hp):
            self.current_health = current_hp
            self.max_health = max_hp

    player1_dummy = DummyPlayer(80, 100)
    player2_dummy = DummyPlayer(50, C.PLAYER_MAX_HEALTH)


    running = True
    clock = pygame.time.Clock()

    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            if event.type == pygame.KEYDOWN: # Simple test to change health
                if event.key == pygame.K_1:
                    player1_dummy.current_health = max(0, player1_dummy.current_health -10)
                if event.key == pygame.K_2:
                    player2_dummy.current_health = max(0, player2_dummy.current_health -10)


        screen.fill(C.LIGHT_BLUE) # Background

        # Test draw_player_hud
        if HUD_FONT: # Only draw if font is available
            draw_player_hud(screen, 10, 10, player1_dummy, 1)
            draw_player_hud(screen, 10, 70, player2_dummy, 2)
        else:
            # Fallback: just draw health bars if no font
            draw_health_bar(screen, 10, 10, C.HEALTH_BAR_WIDTH * 2, C.HEALTH_BAR_HEIGHT + 4, player1_dummy.current_health, player1_dummy.max_health)
            draw_health_bar(screen, 10, 70, C.HEALTH_BAR_WIDTH * 2, C.HEALTH_BAR_HEIGHT + 4, player2_dummy.current_health, player2_dummy.max_health)


        pygame.display.flip()
        clock.tick(C.FPS)

    pygame.quit()