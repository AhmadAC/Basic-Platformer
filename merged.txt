

########## START OF FILE: assets.py ##########

# assets.py
# -*- coding: utf-8 -*-
## version 1.0.0.3 (Changed constants import style for diagnostics)
"""
Handles loading game assets, primarily animations from GIF files.
Includes a helper function `resource_path` to ensure correct asset pathing
both during local development and when the game is packaged by PyInstaller (especially --onedir).
"""
import pygame
import os
import sys
from PIL import Image # Pillow library for GIF processing
from typing import Dict, List, Optional # For type hinting

# --- Import Constants (specifically colors for placeholder images) ---
# Attempting a different import style for diagnostics
try:
    import constants # Import the whole module
    RED = constants.RED
    BLACK = constants.BLACK
    BLUE = constants.BLUE
    YELLOW = constants.YELLOW
except ImportError:
    print("Assets Warning: Failed to import 'constants' (using 'import constants'). Using fallback colors.")
    RED = (255, 0, 0)
    BLACK = (0, 0, 0)
    BLUE = (0, 0, 255)
    YELLOW = (255, 255, 0)
except AttributeError as e:
    # This block will catch if 'constants' was imported but one of the specific color names is missing.
    print(f"Assets Warning: Imported 'constants' but an attribute is missing: {e}. Using fallback colors.")
    RED = (255, 0, 0)
    BLACK = (0, 0, 0)
    BLUE = (0, 0, 255)
    YELLOW = (255, 255, 0)
except Exception as e_general_import: # Catch any other unexpected error during constants import
    print(f"Assets CRITICAL: Unexpected error importing 'constants': {e_general_import}. Using fallback colors.")
    RED = (255, 0, 0)
    BLACK = (0, 0, 0)
    BLUE = (0, 0, 255)
    YELLOW = (255, 255, 0)


# --- Helper Function for PyInstaller Compatibility ---
def resource_path(relative_path: str) -> str:
    """ 
    Get the absolute path to a resource, works for development and for PyInstaller.
    When running as a PyInstaller bundle (especially --onedir or --onefile),
    assets are often bundled relative to sys._MEIPASS.

    Args:
        relative_path (str): The path to the resource relative to the project root
                             (or where assets are expected to be found).

    Returns:
        str: The absolute path to the resource.
    """
    try:
        base_path = sys._MEIPASS
    except AttributeError:
        base_path = os.path.abspath(".")
    full_asset_path = os.path.join(base_path, relative_path)
    return full_asset_path
# ----------------------------------------------------


# --- GIF Loading Function ---
def load_gif_frames(full_path_to_gif_file: str) -> List[pygame.Surface]:
    """
    Loads all frames from a GIF file using the Pillow library and converts them
    into a list of Pygame Surface objects. Handles transparency.
    """
    loaded_frames: List[pygame.Surface] = []
    try:
        pil_gif_image = Image.open(full_path_to_gif_file)
        frame_index = 0
        while True: 
            try:
                pil_gif_image.seek(frame_index) 
                current_pil_frame = pil_gif_image.copy()
                rgba_pil_frame = current_pil_frame.convert('RGBA') 
                frame_pixel_data = rgba_pil_frame.tobytes() 
                frame_dimensions = rgba_pil_frame.size     
                pygame_surface_frame = pygame.image.frombuffer(frame_pixel_data, frame_dimensions, "RGBA")
                pygame_surface_frame = pygame_surface_frame.convert_alpha() 
                loaded_frames.append(pygame_surface_frame)
                frame_index += 1
            except EOFError:
                break # End of frames
            except Exception as e_frame: 
                print(f"Assets Error: Processing frame {frame_index} in '{full_path_to_gif_file}': {e_frame}")
                frame_index += 1 # Try next frame

        if not loaded_frames: 
             print(f"Assets Error: No frames loaded from '{full_path_to_gif_file}'. Creating a RED placeholder.")
             placeholder_surface = pygame.Surface((30, 40)).convert_alpha()
             placeholder_surface.fill(RED) # Use RED from constants or fallback
             pygame.draw.rect(placeholder_surface, BLACK, placeholder_surface.get_rect(), 1) # Use BLACK
             return [placeholder_surface] 
        
        return loaded_frames

    except FileNotFoundError:
        print(f"Assets Error: GIF file not found at resolved path: '{full_path_to_gif_file}'")
    except Exception as e_load: 
        print(f"Assets Error: Loading GIF '{full_path_to_gif_file}' with Pillow: {e_load}")
    
    # Fallback placeholder if any error occurs during loading
    placeholder_surface_on_error = pygame.Surface((30, 40)).convert_alpha()
    placeholder_surface_on_error.fill(RED) # Use RED
    pygame.draw.rect(placeholder_surface_on_error, BLACK, placeholder_surface_on_error.get_rect(), 2) # Use BLACK
    return [placeholder_surface_on_error]


# --- Player/Enemy Animation Loading Function ---
def load_all_player_animations(relative_asset_folder: str = 'characters/player1') -> Optional[Dict[str, List[pygame.Surface]]]:
    """
    Loads all defined animations for a character.
    """
    animations_dict: Dict[str, List[pygame.Surface]] = {}
    animation_filenames_map = {
        'attack': '__Attack.gif', 'attack2': '__Attack2.gif', 'attack_combo': '__AttackCombo2hit.gif',
        'attack_nm': '__AttackNoMovement.gif', 'attack2_nm': '__Attack2NoMovement.gif',
        'attack_combo_nm': '__AttackComboNoMovement.gif', 
        'crouch': '__Crouch.gif', 'crouch_trans': '__CrouchTransition.gif', 
        'crouch_walk': '__CrouchWalk.gif', 'crouch_attack': '__CrouchAttack.gif', 
        'dash': '__Dash.gif', 
        'death': '__Death.gif', 'death_nm': '__DeathNoMovement.gif', 
        'fall': '__Fall.gif', 'hit': '__Hit.gif', 'idle': '__Idle.gif', 
        'jump': '__Jump.gif', 'jump_fall_trans': '__JumpFallInbetween.gif',
        'roll': '__Roll.gif', 'run': '__Run.gif', 
        'slide': '__SlideAll.gif', 'slide_trans_start': '__SlideTransitionStart.gif', 
        'slide_trans_end': '__SlideTransitionEnd.gif',
        'turn': '__TurnAround.gif', 
        'wall_climb': '__WallClimb.gif', 'wall_climb_nm': '__WallClimbNoMovement.gif', 
        'wall_hang': '__WallHang.gif', 'wall_slide': '__WallSlide.gif',
    }

    print(f"Assets Info: Attempting to load animations from relative folder: '{relative_asset_folder}'")
    missing_files_log: List[tuple[str, str, str]] = [] 

    for anim_state_name, gif_filename in animation_filenames_map.items():
         relative_path_to_gif = os.path.join(relative_asset_folder, gif_filename)
         absolute_gif_path = resource_path(relative_path_to_gif)

         if not os.path.exists(absolute_gif_path):
             missing_files_log.append(
                 (anim_state_name, relative_path_to_gif, absolute_gif_path)
             )
             animations_dict[anim_state_name] = [] # Mark as missing for later placeholder generation
             continue

         loaded_animation_frames = load_gif_frames(absolute_gif_path)
         animations_dict[anim_state_name] = loaded_animation_frames

         # Check if load_gif_frames returned its RED placeholder due to an internal error
         if not animations_dict[anim_state_name] or \
            (len(animations_dict[anim_state_name]) == 1 and \
             animations_dict[anim_state_name][0].get_size() == (30,40) and \
             animations_dict[anim_state_name][0].get_at((0,0)) == RED): # RED from constants/fallback
             print(f"Assets Warning: Failed to load frames for state '{anim_state_name}' from existing file '{absolute_gif_path}'. RED Placeholder used.")

    if missing_files_log:
        print("\n--- Assets: Missing Animation Files Detected ---")
        try: base_path_for_log = sys._MEIPASS
        except AttributeError: base_path_for_log = os.path.abspath(".")
        
        for name, rel_path, res_path in missing_files_log:
            print(f"- State '{name}': Expected relative path: '{rel_path}', Resolved path checked: '{res_path}'")
        print(f"(Asset loading base path used by resource_path: '{base_path_for_log}')")
        print("--------------------------------------------\n")

    # Check for critical 'idle' animation
    idle_anim_is_missing_or_placeholder = (
        'idle' not in animations_dict or 
        not animations_dict['idle'] or 
        (len(animations_dict['idle']) == 1 and 
         animations_dict['idle'][0].get_size() == (30,40) and 
         animations_dict['idle'][0].get_at((0,0)) == RED) # RED from constants/fallback
    )

    if idle_anim_is_missing_or_placeholder:
        idle_file_rel_path = os.path.join(relative_asset_folder, animation_filenames_map.get('idle', '__Idle.gif'))
        idle_file_abs_path_checked = resource_path(idle_file_rel_path)
        if 'idle' not in animations_dict or not animations_dict['idle']: 
            print(f"CRITICAL Assets Error: 'idle' animation file ('{idle_file_rel_path}') not found or empty. Checked: '{idle_file_abs_path_checked}'.")
        else: # It's the RED placeholder
            print(f"CRITICAL Assets Error: 'idle' animation failed to load correctly (is RED placeholder) from '{idle_file_abs_path_checked}'.")
        print("Assets: Returning None due to critical 'idle' animation failure.")
        return None

    # Provide blue placeholders for other missing/failed non-critical animations
    for anim_name_check in animation_filenames_map:
        if anim_name_check == 'idle': continue # Already handled

        animation_is_missing_or_placeholder = (
            anim_name_check not in animations_dict or 
            not animations_dict[anim_name_check] or 
            (len(animations_dict[anim_name_check]) == 1 and 
             animations_dict[anim_name_check][0].get_size() == (30,40) and 
             animations_dict[anim_name_check][0].get_at((0,0)) == RED) # RED from constants/fallback
        )

        if animation_is_missing_or_placeholder:
            if anim_name_check not in animations_dict or not animations_dict[anim_name_check]:
                 # This case means the file was missing (missing_files_log handled the print)
                 # and animations_dict[anim_name_check] was set to []
                 print(f"Assets Warning: Animation state '{anim_name_check}' (file missing). Providing a BLUE placeholder.")
            else: # This case means file existed but load_gif_frames returned the RED placeholder
                 print(f"Assets Warning: Animation state '{anim_name_check}' (load failed, is RED placeholder). Using a BLUE placeholder.")

            blue_placeholder = pygame.Surface((30, 40)).convert_alpha()
            blue_placeholder.fill(BLUE) # BLUE from constants/fallback
            pygame.draw.line(blue_placeholder, RED, (0,0), (30,40), 2) # RED for cross
            pygame.draw.line(blue_placeholder, RED, (0,40), (30,0), 2)
            animations_dict[anim_name_check] = [blue_placeholder]

    print(f"Assets Info: Finished loading animations. {len(animations_dict)} animation states processed for '{relative_asset_folder}'.")
    return animations_dict
# ------------------------------------------


# --- Example Usage (if assets.py is run directly for testing) ---
if __name__ == "__main__":
    print("Running assets.py directly for testing...")
    # Pygame init is needed for Surface creation, even for tests not drawing to screen
    pygame.init() 
    # Note: If constants.py is in the same dir, 'import constants' should work here.
    # If it fails here too, the problem is more fundamental with constants.py visibility.

    print("\n--- Testing resource_path ---")
    test_relative_path = 'characters/player1/__Idle.gif' 
    resolved_test_path = resource_path(test_relative_path)
    print(f"Resolved path for '{test_relative_path}': {resolved_test_path}")
    print(f"Does it exist? {os.path.exists(resolved_test_path)}")

    test_character_asset_folder = 'characters/player1' 
    print(f"\n--- Testing load_all_player_animations with relative folder: '{test_character_asset_folder}' ---")
    
    loaded_player_animations = load_all_player_animations(relative_asset_folder=test_character_asset_folder)

    if loaded_player_animations:
        print(f"\nAssets Test: Successfully loaded animation data dictionary.")
        if 'idle' in loaded_player_animations and loaded_player_animations['idle']:
            print(f"Idle animation loaded with {len(loaded_player_animations['idle'])} frames.")
            first_idle_frame = loaded_player_animations['idle'][0]
            if first_idle_frame.get_size() == (30, 40): # Standard placeholder size
                 # Check color using the RED defined at the top of this file (either from constants or fallback)
                 if first_idle_frame.get_at((0,0)) == RED: 
                     print("Assets Test WARNING: 'idle' animation appears to be the RED (load failure) placeholder!")
                 elif first_idle_frame.get_at((0,0)) == BLUE: # BLUE defined at top
                     print("Assets Test WARNING: 'idle' animation appears to be a BLUE (non-critical missing) placeholder! (This shouldn't happen for idle due to critical check)")
        else:
            print("Assets Test ERROR: 'idle' animation missing or empty in the returned dictionary (after critical check).")
    else:
        print("\nAssets Test: Animation loading failed (load_all_player_animations returned None). Likely due to critical 'idle' animation issue.")

    pygame.quit()

########## START OF FILE: camera.py ##########

# -*- coding: utf-8 -*-
"""
camera.py
Defines the Camera class for managing the game's viewport.
"""
# version 1.0.0.2 (Adapted to use absolute level Y boundaries)
import pygame

class Camera:
    def __init__(self, level_width: int, level_top_y_abs: int, level_bottom_y_abs: int, 
                 screen_width: int, screen_height: int):
        """
        Initializes the camera.

        Args:
            level_width (int): The total width of the game level.
            level_top_y_abs (int): The absolute Y coordinate of the top of the level (e.g., top of ceiling wall).
            level_bottom_y_abs (int): The absolute Y coordinate of the bottom of the level (e.g., bottom of floor wall).
            screen_width (int): The width of the game screen/window.
            screen_height (int): The height of the game screen/window.
        """
        self.camera_rect = pygame.Rect(0, 0, screen_width, screen_height)
        self.level_width = level_width
        self.level_top_y_abs = level_top_y_abs         # Absolute top Y of the entire level
        self.level_bottom_y_abs = level_bottom_y_abs   # Absolute bottom Y of the entire level
        self.screen_width = screen_width
        self.screen_height = screen_height
        
        # Calculate effective level height (the total scrollable span)
        self.effective_level_height = self.level_bottom_y_abs - self.level_top_y_abs

        # print(f"Camera Initialized: LvlW:{level_width}, LvlTopY:{level_top_y_abs}, LvlBotY:{level_bottom_y_abs} (EffH:{self.effective_level_height}), ScreenWH: {screen_width}x{screen_height}")


    def apply(self, target):
        """
        Applies the camera offset to a target sprite or rect.

        Args:
            target (pygame.sprite.Sprite or pygame.Rect): The sprite or rect to offset.

        Returns:
            pygame.Rect: A new Rect representing the target's position on the screen.
        """
        if isinstance(target, pygame.sprite.Sprite):
            return target.rect.move(self.camera_rect.topleft)
        elif isinstance(target, pygame.Rect):
            return target.move(self.camera_rect.topleft)
        else:
            raise TypeError("Camera.apply() target must be a Sprite or Rect.")


    def update(self, target_sprite):
        """
        Updates the camera's position to follow the target_sprite.
        The camera attempts to keep the target_sprite centered on the screen,
        while respecting the level boundaries defined by absolute coordinates.

        Args:
            target_sprite (pygame.sprite.Sprite): The sprite the camera should follow.
                                                 Expected to have a 'rect' attribute.
        """
        if not target_sprite or not hasattr(target_sprite, 'rect'):
            self.static_update() 
            return

        # Calculate desired camera top-left (x, y) to center the target_sprite.
        # The camera_rect.x and .y are negative offsets applied to world coordinates.
        x = -target_sprite.rect.centerx + int(self.screen_width / 2)
        y = -target_sprite.rect.centery + int(self.screen_height / 2)

        # --- Horizontal Clamping ---
        # Don't scroll left past the beginning of the level (camera_rect.x should not be > 0).
        x = min(0, x)
        # Don't scroll right past the end of the level.
        if self.level_width > self.screen_width:
            # max_camera_x ensures the right edge of the level aligns with the right edge of the screen.
            x = max(-(self.level_width - self.screen_width), x)
        else: 
            # Level is narrower than or same width as the screen, so no horizontal scrolling needed.
            # Camera x offset can be 0 to align level left, or centered if desired.
            # For now, align left by default (x=0).
            x = 0 

        # --- Vertical Clamping (using absolute level Y boundaries) ---
        if self.effective_level_height <= self.screen_height:
            # Level is shorter than or same height as the screen.
            # Center the level vertically within the screen.
            # The camera's y offset will be such that the level's visual center aligns with screen center.
            # camera_y = -(level_visual_center_y - screen_center_y)
            # level_visual_center_y = self.level_top_y_abs + self.effective_level_height / 2
            # screen_center_y = self.screen_height / 2
            y = -(self.level_top_y_abs + self.effective_level_height / 2 - self.screen_height / 2)
        else:
            # Level is taller than the screen, allow vertical scrolling.
            # Don't scroll above the level's absolute top (camera_rect.y = -level_top_y_abs).
            y = min(-self.level_top_y_abs, y)
            # Don't scroll below the level's absolute bottom.
            # The camera's y should be such that (level_bottom_y_abs + camera_rect.y) == screen_height.
            # So, camera_rect.y = screen_height - level_bottom_y_abs.
            # But since our 'y' is an offset, it's max(-(level_bottom_y_abs - screen_height), y).
            y = max(-(self.level_bottom_y_abs - self.screen_height), y)
            
        self.camera_rect.x = int(x) # Ensure integer positions for rect
        self.camera_rect.y = int(y)
        # print(f"Camera Updated: Target ({target_sprite.rect.centerx},{target_sprite.rect.centery}), CamRect ({self.camera_rect.x},{self.camera_rect.y})")


    def static_update(self):
        """
        Called when there's no target to follow or if static camera behavior is desired.
        The camera remains in its current position.
        """
        # If no target, we might want to ensure camera is still clamped,
        # especially if level dimensions changed.
        # For now, it just keeps its current position.
        # If clamping is needed even without a target, call update(None) or replicate clamping logic.
        pass 

    def get_pos(self):
        """ Returns the camera's current topleft offset (usually negative or zero values). """
        return (self.camera_rect.x, self.camera_rect.y)

    def set_pos(self, x, y):
        """ Manually sets the camera's topleft offset. """
        self.camera_rect.x = int(x)
        self.camera_rect.y = int(y)
        # print(f"Camera Position Manually Set: ({self.camera_rect.x},{self.camera_rect.y})")

    def set_level_dimensions(self, level_width: int, level_top_y_abs: int, level_bottom_y_abs: int):
        """
        Updates the camera's knowledge of the level dimensions.
        Useful if the level changes or its boundaries are redefined.

        Args:
            level_width (int): New total width of the level.
            level_top_y_abs (int): New absolute Y of the level's top.
            level_bottom_y_abs (int): New absolute Y of the level's bottom.
        """
        self.level_width = level_width
        self.level_top_y_abs = level_top_y_abs
        self.level_bottom_y_abs = level_bottom_y_abs
        self.effective_level_height = self.level_bottom_y_abs - self.level_top_y_abs
        # print(f"Camera Level Dimensions Updated: LvlW:{self.level_width}, LvlTopY:{self.level_top_y_abs}, LvlBotY:{self.level_bottom_y_abs} (EffH:{self.effective_level_height})")
        
        # Optionally, re-clamp camera position immediately if needed:
        # For example, if a target was being tracked:
        # if self.camera_rect.x != 0 or self.camera_rect.y != 0: # Or some other check if it needs update
        #    current_target = ... (if you store it)
        #    self.update(current_target if current_target else None) 
        # Or, if no target, ensure it's valid for the new boundaries (e.g., set to default 0,0 and then clamp)
        # self.set_pos(self.camera_rect.x, self.camera_rect.y) # Re-apply existing pos to trigger clamping via update
        # (This would require self.update to correctly handle a None target for clamping)
        # For now, manual re-clamping would be done by calling update() after set_level_dimensions.

    def set_screen_dimensions(self, screen_width: int, screen_height: int):
        """
        Updates the camera's knowledge of the screen dimensions.
        Important if the game window is resized.
        """
        self.screen_width = screen_width
        self.screen_height = screen_height
        self.camera_rect.width = screen_width
        self.camera_rect.height = screen_height
        # print(f"Camera Screen Dimensions Updated: {self.screen_width}x{self.screen_height}")
        # After screen resize, the camera position might need re-clamping.
        # This is typically handled by calling self.update(target_sprite) in the main loop's resize event.

########## START OF FILE: client_logic.py ##########

########## START OF FILE: client_logic.py ##########

# client_logic.py
# -*- coding: utf-8 -*-
"""
version 1.0000000.1
Handles client-side game logic, connection to server, and LAN discovery.
"""
import pygame
import socket
import time
import traceback
import constants as C
from network_comms import get_local_ip, encode_data, decode_data_stream
from game_state_manager import set_network_game_state
from enemy import Enemy # For print_limiter access if needed, or for type hinting
from game_ui import draw_platformer_scene_on_surface # For drawing client's view

class ClientState:
    """
    A simple class to hold client-specific state used by the client's
    main loop and helper functions.
    """
    def __init__(self):
        self.client_tcp_socket = None        # TCP socket for communication with the server
        self.server_state_buffer = b""       # Buffer for accumulating data from the server
        self.last_received_server_state = None # Stores the most recent complete game state from server
        self.app_running = True              # Global flag: True if the application is running (controlled by main.py)
        
        # Configuration for LAN discovery (can be loaded from constants.py)
        self.service_name = getattr(C, "SERVICE_NAME", "platformer_adventure_lan_v1")
        self.discovery_port_udp = getattr(C, "DISCOVERY_PORT_UDP", 5556)
        self.client_search_timeout_s = getattr(C, "CLIENT_SEARCH_TIMEOUT_S", 5.0)
        self.buffer_size = getattr(C, "BUFFER_SIZE", 8192)


def find_server_on_lan(screen: pygame.Surface, fonts: dict, 
                       clock_obj: pygame.time.Clock, client_state_obj: ClientState):
    """
    Searches for a game server on the LAN by listening for UDP broadcasts.
    Displays a "Searching..." message on the screen.
    Returns (found_server_ip, found_server_port) or (None, None) if not found or cancelled.
    """
    print("DEBUG Client (find_server_on_lan): Starting LAN server search.") # DEBUG
    pygame.display.set_caption("Platformer - Searching for Server on LAN...")
    current_width, current_height = screen.get_size()
    search_text_surf = fonts.get("large", pygame.font.Font(None, 30)).render( # Fallback font
        "Searching for server on LAN...", True, C.WHITE
    )
    
    listen_socket, found_server_ip, found_server_port = None, None, None

    try:
        # Create and configure the UDP socket for listening to broadcasts
        listen_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
        listen_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        # Bind to all available interfaces on the specified discovery port
        listen_socket.bind(('', client_state_obj.discovery_port_udp)) 
        listen_socket.settimeout(0.5) # Non-blocking recvfrom
        print(f"DEBUG Client (find_server_on_lan): UDP listen socket bound to port {client_state_obj.discovery_port_udp}.") # DEBUG
    except socket.error as e:
        print(f"Client Error: Failed to bind UDP listen socket on port {client_state_obj.discovery_port_udp}: {e}")
        screen.fill(C.BLACK)
        err_msg = f"Error: Cannot listen on UDP port {client_state_obj.discovery_port_udp}."
        if fonts.get("small"):
            err_surf = fonts["small"].render(err_msg, True, C.RED)
            screen.blit(err_surf, err_surf.get_rect(center=(current_width//2, current_height // 2)))
        pygame.display.flip(); time.sleep(4)
        return None, None

    start_search_time = time.time()
    client_local_ip = get_local_ip() 
    print(f"DEBUG Client (find_server_on_lan): Searching for LAN servers (Service: '{client_state_obj.service_name}'). My IP: {client_local_ip}. Timeout: {client_state_obj.client_search_timeout_s}s.") # DEBUG

    # Loop for the duration of the search timeout or until app quits/server found
    while time.time() - start_search_time < client_state_obj.client_search_timeout_s and \
          client_state_obj.app_running and not found_server_ip:
        
        # Handle Pygame events (Quit, Resize, Escape to cancel search)
        for event in pygame.event.get():
             if event.type == pygame.QUIT: client_state_obj.app_running = False; break
             if event.type == pygame.VIDEORESIZE:
                if not screen.get_flags() & pygame.FULLSCREEN:
                    current_width,current_height=max(320,event.w),max(240,event.h)
                    screen=pygame.display.set_mode((current_width,current_height), pygame.RESIZABLE|pygame.DOUBLEBUF)
                    search_text_surf = fonts.get("large", pygame.font.Font(None,30)).render(
                        "Searching for server on LAN...", True, C.WHITE) # Re-render if size changes
             if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
                 print("DEBUG Client (find_server_on_lan): LAN server search cancelled by user.");  # DEBUG
                 if listen_socket: listen_socket.close()
                 return None, None # Exit search and return to menu
        if not client_state_obj.app_running: break

        # Update "Searching..." display
        screen.fill(C.BLACK)
        screen.blit(search_text_surf, search_text_surf.get_rect(center=(current_width//2, current_height//2)))
        pygame.display.flip()
        clock_obj.tick(10) # Low FPS during search

        raw_udp_data, decoded_udp_message = None, None
        try:
            raw_udp_data, sender_address = listen_socket.recvfrom(client_state_obj.buffer_size)
            # print(f"DEBUG Client (find_server_on_lan): Received UDP data from {sender_address}: {raw_udp_data[:60]}...") # DEBUG - noisy
            decoded_messages_list, _ = decode_data_stream(raw_udp_data)
            if not decoded_messages_list: continue 
            
            decoded_udp_message = decoded_messages_list[0] 
            # print(f"DEBUG Client (find_server_on_lan): Decoded UDP message: {decoded_udp_message}") # DEBUG
            if (isinstance(decoded_udp_message, dict) and
                decoded_udp_message.get("service") == client_state_obj.service_name and
                isinstance(decoded_udp_message.get("tcp_ip"), str) and
                isinstance(decoded_udp_message.get("tcp_port"), int)):
                
                server_ip = decoded_udp_message["tcp_ip"]
                server_port = decoded_udp_message["tcp_port"]
                print(f"DEBUG Client (find_server_on_lan): Found server '{client_state_obj.service_name}' at {server_ip}:{server_port}") # DEBUG
                found_server_ip, found_server_port = server_ip, server_port
        except socket.timeout:
            continue 
        except Exception as e:
            print(f"Client: Error processing received UDP broadcast: {e}")
            traceback.print_exc()

    if listen_socket: listen_socket.close() 

    if not found_server_ip and client_state_obj.app_running: 
        print(f"DEBUG Client (find_server_on_lan): No server found for '{client_state_obj.service_name}' after timeout.") # DEBUG
        screen.fill(C.BLACK)
        if fonts.get("large"):
            fail_surf = fonts["large"].render("Server Not Found!", True, C.RED)
            screen.blit(fail_surf, fail_surf.get_rect(center=(current_width//2, current_height//2)))
        pygame.display.flip(); time.sleep(3) 
    elif not client_state_obj.app_running:
        print("DEBUG Client (find_server_on_lan): LAN server search aborted because application is quitting.") # DEBUG
        
    return found_server_ip, found_server_port


def run_client_mode(screen: pygame.Surface, clock: pygame.time.Clock, 
                    fonts: dict, game_elements_ref: dict, 
                    client_state_obj: ClientState, target_ip_port_str: str = None):
    """
    Main function to run the game in client mode.
    Connects to a server (either specified or found via LAN) and synchronizes game state.
    """
    print("DEBUG Client (run_client_mode): Entering client mode.") # DEBUG
    client_state_obj.app_running = True 
    current_width, current_height = screen.get_size()
    
    server_ip_to_connect, server_port_to_connect = None, C.SERVER_PORT_TCP 

    if target_ip_port_str: 
        print(f"DEBUG Client (run_client_mode): Direct IP specified: {target_ip_port_str}") # DEBUG
        ip_parts = target_ip_port_str.rsplit(':', 1)
        server_ip_to_connect = ip_parts[0]
        if len(ip_parts) > 1: 
            try: server_port_to_connect = int(ip_parts[1])
            except ValueError: 
                print(f"Client Warning: Invalid port in '{target_ip_port_str}'. Using default {C.SERVER_PORT_TCP}.")
    else: 
        print("DEBUG Client (run_client_mode): No direct IP, attempting LAN discovery.") # DEBUG
        server_ip_to_connect, found_server_port = find_server_on_lan(screen, fonts, clock, client_state_obj)
        if found_server_port: server_port_to_connect = found_server_port

    if not server_ip_to_connect: 
        print("DEBUG Client (run_client_mode): Exiting client mode (no server target).") # DEBUG
        return 
    if not client_state_obj.app_running: 
        print("DEBUG Client (run_client_mode): Exiting client mode (application closed).") # DEBUG
        return

    if client_state_obj.client_tcp_socket: 
        try: client_state_obj.client_tcp_socket.close()
        except: pass
    client_state_obj.client_tcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    
    connection_succeeded, connection_error_msg = False, "Unknown Connection Error"
    try:
        print(f"DEBUG Client (run_client_mode): Attempting to connect to server at {server_ip_to_connect}:{server_port_to_connect}...") # DEBUG
        pygame.display.set_caption(f"Platformer - Connecting to {server_ip_to_connect}...")
        screen.fill(C.BLACK) 
        if fonts.get("large"):
            conn_text_surf = fonts["large"].render(f"Connecting...", True, C.WHITE)
            screen.blit(conn_text_surf, conn_text_surf.get_rect(center=(current_width//2, current_height//2)))
        pygame.display.flip()

        client_state_obj.client_tcp_socket.settimeout(10.0) 
        client_state_obj.client_tcp_socket.connect((server_ip_to_connect, server_port_to_connect))
        client_state_obj.client_tcp_socket.settimeout(0.05) 
        print("DEBUG Client (run_client_mode): TCP Connection to server successful!") # DEBUG
        connection_succeeded = True
    except socket.timeout: connection_error_msg = "Connection Timed Out"
    except socket.error as e: connection_error_msg = f"Connection Error ({e.strerror if hasattr(e, 'strerror') else e})"
    except Exception as e: connection_error_msg = f"Unexpected Connection Error: {e}"

    if not connection_succeeded:
        print(f"DEBUG Client (run_client_mode): Failed to connect to server: {connection_error_msg}") # DEBUG
        screen.fill(C.BLACK) 
        if fonts.get("large"):
            fail_text_surf = fonts["large"].render(f"Connection Failed", True, C.RED)
            screen.blit(fail_text_surf, fail_text_surf.get_rect(center=(current_width//2, current_height//2 - 30)))
        if fonts.get("small"):
            reason_surf = fonts["small"].render(connection_error_msg, True, C.WHITE)
            screen.blit(reason_surf, reason_surf.get_rect(center=(current_width//2, current_height//2 + 30)))
        pygame.display.flip(); time.sleep(3)
        if client_state_obj.client_tcp_socket: client_state_obj.client_tcp_socket.close()
        client_state_obj.client_tcp_socket = None
        return 

    pygame.display.set_caption("Platformer - CLIENT (You are P2: WASD+VB | Self-Harm: H | Heal: G | Reset: Enter)")
    
    p2_controlled_by_client = game_elements_ref.get("player2") 
    p1_remote_on_client = game_elements_ref.get("player1")     
    print(f"DEBUG Client (run_client_mode): P1 (remote) instance: {p1_remote_on_client}, P2 (local) instance: {p2_controlled_by_client}") # DEBUG
    if p1_remote_on_client: print(f"DEBUG Client: P1 Valid: {p1_remote_on_client._valid_init}, P1 Pos: {p1_remote_on_client.pos if hasattr(p1_remote_on_client, 'pos') else 'N/A'}") # DEBUG
    if p2_controlled_by_client: print(f"DEBUG Client: P2 Valid: {p2_controlled_by_client._valid_init}, P2 Pos: {p2_controlled_by_client.pos if hasattr(p2_controlled_by_client, 'pos') else 'N/A'}") # DEBUG

    
    p2_client_key_map = { 
        'left': pygame.K_a, 'right': pygame.K_d, 'up': pygame.K_w, 'down': pygame.K_s,
        'attack1': pygame.K_v, 'attack2': pygame.K_b, 'dash': pygame.K_LSHIFT,
        'roll': pygame.K_LCTRL, 'interact': pygame.K_e,
    }

    client_game_active = True
    client_state_obj.server_state_buffer = b"" 
    client_state_obj.last_received_server_state = None 

    while client_game_active and client_state_obj.app_running:
        dt_sec = clock.tick(C.FPS) / 1000.0 
        now_ticks_client = pygame.time.get_ticks()

        client_initiated_actions = {'action_reset': False, 'action_self_harm': False, 'action_heal': False}
        server_indicated_game_over = False
        if client_state_obj.last_received_server_state and \
           'game_over' in client_state_obj.last_received_server_state:
            server_indicated_game_over = client_state_obj.last_received_server_state['game_over']

        pygame_events_client = pygame.event.get()
        keys_pressed_client = pygame.key.get_pressed()
        for event in pygame_events_client:
            if event.type == pygame.QUIT: client_game_active = False; client_state_obj.app_running = False; break
            if event.type == pygame.VIDEORESIZE:
                if not screen.get_flags() & pygame.FULLSCREEN:
                    current_width,current_height=max(320,event.w),max(240,event.h)
                    screen=pygame.display.set_mode((current_width,current_height), pygame.RESIZABLE|pygame.DOUBLEBUF)
                    if game_elements_ref.get("camera"): 
                        game_elements_ref["camera"].screen_width = current_width
                        game_elements_ref["camera"].screen_height = current_height
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE: client_game_active = False 
                if event.key == pygame.K_RETURN and server_indicated_game_over :
                    client_initiated_actions['action_reset'] = True
                if event.key == pygame.K_h: client_initiated_actions['action_self_harm'] = True
                if event.key == pygame.K_g: client_initiated_actions['action_heal'] = True
        
        if not client_state_obj.app_running or not client_game_active: break

        p2_input_state_for_server = {}
        if p2_controlled_by_client and hasattr(p2_controlled_by_client, 'get_input_state_for_network'):
             p2_input_state_for_server = p2_controlled_by_client.get_input_state_for_network(
                 keys_pressed_client, pygame_events_client, p2_client_key_map
             )
        p2_input_state_for_server.update(client_initiated_actions) 

        if client_state_obj.client_tcp_socket:
            client_input_payload = {"input": p2_input_state_for_server}
            encoded_client_payload = encode_data(client_input_payload)
            if encoded_client_payload:
                try:
                    # print(f"DEBUG Client: Sending input to server: {client_input_payload}") # DEBUG - noisy
                    client_state_obj.client_tcp_socket.sendall(encoded_client_payload)
                except socket.error as e:
                    print(f"Client: Send to server failed: {e}. Server might have disconnected.")
                    client_game_active = False; break 
        
        if client_state_obj.client_tcp_socket:
            try:
                server_data_chunk = client_state_obj.client_tcp_socket.recv(client_state_obj.buffer_size * 2) 
                if not server_data_chunk: 
                    print("DEBUG Client: Server disconnected (received empty data from recv).") # DEBUG
                    client_game_active = False; break
                
                # print(f"DEBUG Client: Received chunk from server: {server_data_chunk[:100]}...") # DEBUG - noisy
                client_state_obj.server_state_buffer += server_data_chunk
                decoded_server_states, client_state_obj.server_state_buffer = \
                    decode_data_stream(client_state_obj.server_state_buffer)
                
                if decoded_server_states: 
                    client_state_obj.last_received_server_state = decoded_server_states[-1] 
                    # print(f"DEBUG Client: Received new game state. P1 pos: {client_state_obj.last_received_server_state.get('p1', {}).get('pos')}, P2 pos: {client_state_obj.last_received_server_state.get('p2', {}).get('pos')}") # DEBUG
                    set_network_game_state(client_state_obj.last_received_server_state, game_elements_ref, client_player_id=2)
                    # After state update, verify player instances
                    # p1_after_update = game_elements_ref.get("player1")
                    # p2_after_update = game_elements_ref.get("player2")
                    # if p1_after_update: print(f"DEBUG Client: P1 after state update. Pos: {p1_after_update.pos if hasattr(p1_after_update, 'pos') else 'N/A'}, Valid: {p1_after_update._valid_init}, Alive: {p1_after_update.alive() if hasattr(p1_after_update, 'alive') else 'N/A'}") # DEBUG
                    # if p2_after_update: print(f"DEBUG Client: P2 after state update. Pos: {p2_after_update.pos if hasattr(p2_after_update, 'pos') else 'N/A'}, Valid: {p2_after_update._valid_init}, Alive: {p2_after_update.alive() if hasattr(p2_after_update, 'alive') else 'N/A'}") # DEBUG

            
            except socket.timeout: pass 
            except socket.error as e:
                print(f"Client: Recv error from server: {e}. Server might have disconnected.")
                client_game_active = False; break
            except Exception as e:
                print(f"Client: Error processing data from server: {e}"); traceback.print_exc()
                client_game_active = False; break

        if p1_remote_on_client and p1_remote_on_client.alive() and p1_remote_on_client._valid_init and \
           hasattr(p1_remote_on_client, 'animate'):
            p1_remote_on_client.animate() 

        if p2_controlled_by_client and p2_controlled_by_client.alive() and \
           p2_controlled_by_client._valid_init and hasattr(p2_controlled_by_client, 'animate'):
            p2_controlled_by_client.animate() 

        for enemy_client in game_elements_ref.get("enemy_list", []):
            if enemy_client.alive() and enemy_client._valid_init and hasattr(enemy_client, 'animate'):
                enemy_client.animate()
            if enemy_client.is_dead and hasattr(enemy_client, 'death_animation_finished') and \
               enemy_client.death_animation_finished and enemy_client.alive():
                if hasattr(Enemy, 'print_limiter') and Enemy.print_limiter.can_print(f"client_killing_enemy_{enemy_client.enemy_id}"):
                     print(f"Client: Visually removing enemy {enemy_client.enemy_id} as death anim finished.")
                enemy_client.kill() 

        for proj_client in game_elements_ref.get("projectile_sprites", pygame.sprite.Group()):
            if proj_client.alive() and hasattr(proj_client, 'animate'):
                proj_client.animate() 

        game_elements_ref.get("collectible_sprites", pygame.sprite.Group()).update(dt_sec)

        client_camera = game_elements_ref.get("camera")
        if client_camera:
            camera_focus_target_client = None
            if p2_controlled_by_client and p2_controlled_by_client.alive() and \
               p2_controlled_by_client._valid_init and not p2_controlled_by_client.is_dead :
                camera_focus_target_client = p2_controlled_by_client
            elif p1_remote_on_client and p1_remote_on_client.alive() and \
                 p1_remote_on_client._valid_init and not p1_remote_on_client.is_dead:
                camera_focus_target_client = p1_remote_on_client 
            
            if camera_focus_target_client: client_camera.update(camera_focus_target_client)
            else: client_camera.static_update() 
            
        try:
            draw_platformer_scene_on_surface(screen, game_elements_ref, fonts, now_ticks_client)
        except Exception as e:
            print(f"Client draw error: {e}"); traceback.print_exc()
            client_game_active=False; break
        pygame.display.flip()

    print("DEBUG Client: Exiting active game loop.") # DEBUG
    if client_state_obj.client_tcp_socket:
        print("DEBUG Client: Closing TCP socket to server.") # DEBUG
        try: client_state_obj.client_tcp_socket.shutdown(socket.SHUT_RDWR)
        except: pass
        try: client_state_obj.client_tcp_socket.close()
        except: pass
        client_state_obj.client_tcp_socket = None
    print("DEBUG Client: Client mode finished and returned to caller.") # DEBUG

########## END OF FILE: client_logic.py ##########

########## START OF FILE: constants.py ##########

# constants.py
# -*- coding: utf-8 -*-
"""
Stores constant values used throughout the game.
"""
# version 1.0.0.2 (Added Network Constants)

# --- Gameplay / Physics ---
FPS = 60
PLAYER_ACCEL = 0.5
PLAYER_FRICTION = -0.15  # Negative value!
PLAYER_GRAVITY = 0.7
PLAYER_JUMP_STRENGTH = -15
PLAYER_RUN_SPEED_LIMIT = 7
PLAYER_DASH_SPEED = 15
PLAYER_ROLL_SPEED = 9
PLAYER_WALL_SLIDE_SPEED = 2
PLAYER_WALL_CLIMB_SPEED = -4
PLAYER_LADDER_CLIMB_SPEED = 3
PLAYER_MAX_HEALTH = 100
CHARACTER_BOUNCE_VELOCITY = 2.5 # Pixels per frame push back on collision
PLAYER_STOMP_BOUNCE_STRENGTH = -8.0 # Upwards velocity after stomping an enemy
PLAYER_STOMP_LAND_ON_ENEMY_GRACE_PX = 8 # Pixel grace for landing on enemy's head for stomp <--- ADD THIS LINE (or ensure it exists)

# --- Animation ---
ANIM_FRAME_DURATION = 80 # ms per frame for most animations

# Player Attack Specifics
PLAYER_ATTACK1_DAMAGE = 10
PLAYER_ATTACK2_DAMAGE = 5
PLAYER_COMBO_ATTACK_DAMAGE = 20
PLAYER_CROUCH_ATTACK_DAMAGE = 5
PLAYER_ATTACK2_FRAME_DURATION_MULTIPLIER = 1.5

CHARACTER_ATTACK_STATE_DURATION = 480 # ms

# --- Projectile Constants ---
FIREBALL_DAMAGE = 50
FIREBALL_SPEED = 9
FIREBALL_COOLDOWN = 750
FIREBALL_LIFESPAN = 2500
FIREBALL_SPRITE_PATH = "characters/weapons/fire.gif"
FIREBALL_DIMENSIONS = (61, 58)

# --- Enemy Constants ---
ENEMY_MAX_HEALTH = 80
ENEMY_RUN_SPEED_LIMIT = 5
ENEMY_ACCEL = 0.4
ENEMY_FRICTION = -0.12
ENEMY_DETECTION_RANGE = 100
ENEMY_ATTACK_RANGE = 60
ENEMY_ATTACK_DAMAGE = 10
ENEMY_ATTACK_COOLDOWN = 1500
ENEMY_PATROL_DIST = 150
ENEMY_HIT_STUN_DURATION = 300
ENEMY_HIT_COOLDOWN = 500
ENEMY_HIT_BOUNCE_Y = PLAYER_JUMP_STRENGTH * 0.3

# --- Colors ---
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
RED = (255, 0, 0)
DARK_RED = (139, 0, 0)
GREEN = (0, 255, 0)
YELLOW = (255, 255, 0) 
DARK_GREEN = (0, 100, 0)
BLUE = (0, 0, 255)
GRAY = (128, 128, 128)
DARK_GRAY = (50, 50, 50)
LIGHT_GRAY = (200, 200, 200) 
LIGHT_BLUE = (173, 216, 230)
ORANGE_RED = (255, 69, 0)

# --- UI ---
HEALTH_BAR_WIDTH = 50
HEALTH_BAR_HEIGHT = 8
HEALTH_BAR_OFFSET_ABOVE = 5

# --- Map ---
TILE_SIZE = 40
LAVA_PATCH_HEIGHT = 20
LAVA_DAMAGE = 50

# --- Network Constants ---
SERVER_IP_BIND = '0.0.0.0'  # Listen on all available interfaces
SERVER_PORT_TCP = 5555      # Default TCP port for the game server
SERVICE_NAME = "platformer_adventure_lan_v1" # Name for LAN discovery
DISCOVERY_PORT_UDP = 5556   # UDP port for LAN discovery broadcasts
BUFFER_SIZE = 8192          # Network buffer size for send/recv
BROADCAST_INTERVAL_S = 1.0  # How often server broadcasts its presence (seconds)
CLIENT_SEARCH_TIMEOUT_S = 5.0 # How long client searches for LAN server (seconds)

# --- Other ---
PLAYER_SELF_DAMAGE = 10
TERMINAL_VELOCITY_Y = 18

########## START OF FILE: couch_play_logic.py ##########

# couch_play_logic.py
# -*- coding: utf-8 -*-
"""
version 1.0000000.1
Handles the game logic for the local couch co-op (two players on one machine) mode.
"""
import pygame
import traceback # For detailed error logging if needed
import constants as C
from game_state_manager import reset_game_state # For resetting the game
from enemy import Enemy # For potential type hinting or accessing Enemy.print_limiter
from items import Chest # For type checking if Chest is valid
from game_ui import draw_platformer_scene_on_surface # For drawing the game scene

def run_couch_play_mode(screen: pygame.Surface, clock: pygame.time.Clock, 
                        fonts: dict, game_elements_ref: dict, app_status_obj):
    """
    Main loop for the couch co-op game mode.
    Manages input for two local players and updates the game state.

    Args:
        screen: The main Pygame display surface.
        clock: The Pygame clock for managing FPS.
        fonts: A dictionary of loaded Pygame font objects.
        game_elements_ref: A dictionary containing references to game objects
                           (players, sprite groups, camera, etc.).
        app_status_obj: An object (like main's AppStatus) with an 'app_running' attribute
                        to signal if the whole application should quit.
    """
    pygame.display.set_caption("Platformer - Couch Co-op (P1:WASD+VB, P2:IJKL+OP | Harm:H,N | Heal:G,M | Reset:R)")
    current_width, current_height = screen.get_size()

    # Get player instances from the game_elements dictionary
    p1 = game_elements_ref.get("player1")
    p2 = game_elements_ref.get("player2")
    
    # Define key mappings for Player 1 and Player 2
    p1_key_map_config = {
        'left': pygame.K_a, 'right': pygame.K_d, 'up': pygame.K_w, 'down': pygame.K_s,
        'attack1': pygame.K_v, 'attack2': pygame.K_b, 'dash': pygame.K_LSHIFT,
        'roll': pygame.K_LCTRL, 'interact': pygame.K_e 
    }
    p2_key_map_config = {
        'left': pygame.K_j, 'right': pygame.K_l, 'up': pygame.K_i, 'down': pygame.K_k,
        'attack1': pygame.K_o, 'attack2': pygame.K_p, 
        'dash': pygame.K_SEMICOLON, # Example: often RSHIFT for P2, or a nearby key
        'roll': pygame.K_QUOTE,   # Example: often RCTRL for P2, or a nearby key
        'interact': pygame.K_BACKSLASH 
    }

    couch_game_active = True
    while couch_game_active and app_status_obj.app_running:
        dt_sec = clock.tick(C.FPS) / 1000.0 # Delta time for physics consistency
        now_ticks_couch = pygame.time.get_ticks() # For time-based logic if any
        
        pygame_events = pygame.event.get() # Get all events once per frame
        keys_pressed = pygame.key.get_pressed() # Get all held keys once per frame
        
        host_requested_reset_couch = False

        # Handle global events (Quit, Resize, Escape, Reset, Debug keys)
        for event in pygame_events:
            if event.type == pygame.QUIT:
                couch_game_active = False
                app_status_obj.app_running = False # Signal entire application to quit
                break
            if event.type == pygame.VIDEORESIZE:
                if not screen.get_flags() & pygame.FULLSCREEN: # Handle window resize
                    current_width, current_height = max(320,event.w), max(240,event.h)
                    screen = pygame.display.set_mode((current_width,current_height), pygame.RESIZABLE|pygame.DOUBLEBUF)
                    if game_elements_ref.get("camera"): # Update camera's screen dimensions
                        game_elements_ref["camera"].screen_width = current_width
                        game_elements_ref["camera"].screen_height = current_height
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    couch_game_active = False # Exit couch mode to main menu
                    break
                if event.key == pygame.K_r: # Reset game state
                    host_requested_reset_couch = True
                
                # Player 1 debug keys
                if p1 and p1._valid_init:
                    if event.key == pygame.K_h and hasattr(p1, 'self_inflict_damage'):
                        p1.self_inflict_damage(C.PLAYER_SELF_DAMAGE)
                    if event.key == pygame.K_g and hasattr(p1, 'heal_to_full'):
                        p1.heal_to_full()
                
                # Player 2 debug keys
                if p2 and p2._valid_init:
                    if event.key == pygame.K_n and hasattr(p2, 'self_inflict_damage'): # 'N' for P2 self-harm
                        p2.self_inflict_damage(C.PLAYER_SELF_DAMAGE)
                    if event.key == pygame.K_m and hasattr(p2, 'heal_to_full'): # 'M' for P2 heal
                        p2.heal_to_full()
        
        if not app_status_obj.app_running or not couch_game_active: break

        # Handle inputs for both local players
        if p1 and p1._valid_init and not p1.is_dead: # Only process input if P1 is valid and not dead
            if hasattr(p1, 'handle_mapped_input'):
                p1.handle_mapped_input(keys_pressed, pygame_events, p1_key_map_config)
        
        if p2 and p2._valid_init and not p2.is_dead: # Only process input if P2 is valid and not dead
            if hasattr(p2, 'handle_mapped_input'):
                p2.handle_mapped_input(keys_pressed, pygame_events, p2_key_map_config)

        # If reset was requested, trigger it
        if host_requested_reset_couch:
            print("Couch Play: Game state reset triggered.")
            # reset_game_state returns the new chest instance (or None)
            game_elements_ref["current_chest"] = reset_game_state(game_elements_ref)

        # --- Local Authoritative Game Logic Updates ---
        # Update Player 1
        if p1 and p1._valid_init:
            # List of other players for P1's collision/interaction checks
            other_players_for_p1_update = [char for char in [p2] if char and char._valid_init and char.alive() and char is not p1]
            p1.update(dt_sec, game_elements_ref["platform_sprites"], game_elements_ref["ladder_sprites"], 
                      game_elements_ref["hazard_sprites"], other_players_for_p1_update, game_elements_ref["enemy_list"])
        
        # Update Player 2
        if p2 and p2._valid_init:
            other_players_for_p2_update = [char for char in [p1] if char and char._valid_init and char.alive() and char is not p2]
            p2.update(dt_sec, game_elements_ref["platform_sprites"], game_elements_ref["ladder_sprites"], 
                      game_elements_ref["hazard_sprites"], other_players_for_p2_update, game_elements_ref["enemy_list"])

        # Update Enemies
        # Enemies target any active player
        active_players_for_enemy_ai_couch = [char for char in [p1, p2] if char and char._valid_init and not char.is_dead and char.alive()]
        for enemy_couch in list(game_elements_ref.get("enemy_list", [])): # Iterate copy for safe removal
            if enemy_couch._valid_init:
                enemy_couch.update(dt_sec, active_players_for_enemy_ai_couch, 
                                   game_elements_ref["platform_sprites"], game_elements_ref["hazard_sprites"])
                # If enemy's death animation finishes, remove it
                if enemy_couch.is_dead and hasattr(enemy_couch, 'death_animation_finished') and \
                   enemy_couch.death_animation_finished and enemy_couch.alive():
                    if hasattr(Enemy, 'print_limiter') and Enemy.print_limiter.can_print(f"couch_killing_enemy_{enemy_couch.enemy_id}"):
                         print(f"Couch Play: Auto-killing enemy {enemy_couch.enemy_id} as death anim finished.")
                    enemy_couch.kill() # Removes from all sprite groups it's in
            # else: if enemy_couch.alive(): enemy_couch.kill() # Should be handled by init checks

        # Update Projectiles (collision against players and enemies)
        hittable_characters_couch_group = pygame.sprite.Group()
        if p1 and p1.alive() and p1._valid_init: hittable_characters_couch_group.add(p1)
        if p2 and p2.alive() and p2._valid_init: hittable_characters_couch_group.add(p2)
        for enemy_inst_proj_couch in game_elements_ref.get("enemy_list", []):
            if enemy_inst_proj_couch and enemy_inst_proj_couch.alive() and enemy_inst_proj_couch._valid_init:
                hittable_characters_couch_group.add(enemy_inst_proj_couch)
        game_elements_ref.get("projectile_sprites", pygame.sprite.Group()).update(
            dt_sec, game_elements_ref["platform_sprites"], hittable_characters_couch_group
        )
        
        # Update Collectibles (e.g., Chest animations, and collection logic)
        game_elements_ref.get("collectible_sprites", pygame.sprite.Group()).update(dt_sec)
        couch_current_chest = game_elements_ref.get("current_chest")
        if Chest and couch_current_chest and couch_current_chest.alive(): # Check Chest class exists
            player_who_collected_chest_couch = None
            # Check P1 collision with chest
            if p1 and p1._valid_init and not p1.is_dead and p1.alive() and \
               pygame.sprite.collide_rect(p1, couch_current_chest):
                player_who_collected_chest_couch = p1
            # Check P2 collision with chest (only if P1 didn't collect it this frame)
            elif p2 and p2._valid_init and not p2.is_dead and p2.alive() and \
                 pygame.sprite.collide_rect(p2, couch_current_chest):
                player_who_collected_chest_couch = p2
            
            if player_who_collected_chest_couch:
                couch_current_chest.collect(player_who_collected_chest_couch) # collect() should call self.kill()
                game_elements_ref["current_chest"] = None # Mark as collected
        
        # Update Camera
        couch_camera = game_elements_ref.get("camera")
        if couch_camera:
            # Simple camera focus: prioritize P1, then P2 if P1 is dead/invalid, or static if both out.
            camera_focus_target_couch = None
            if p1 and p1.alive() and p1._valid_init and not p1.is_dead:
                camera_focus_target_couch = p1
            elif p2 and p2.alive() and p2._valid_init and not p2.is_dead:
                camera_focus_target_couch = p2
            
            if camera_focus_target_couch: couch_camera.update(camera_focus_target_couch)
            else: couch_camera.static_update() # No valid target, camera remains static

        # Draw the game scene
        try:
            draw_platformer_scene_on_surface(screen, game_elements_ref, fonts, now_ticks_couch)
        except Exception as e:
            print(f"Couch Play draw error: {e}"); traceback.print_exc()
            couch_game_active=False; break # Exit on critical draw error
        pygame.display.flip()

    # --- End of Couch Play Game Loop ---
    print("Exiting Couch Play mode.")
    # app_status_obj.app_running will be False if QUIT was pressed, otherwise True.
    # No network connections or threads to clean up in couch mode.

########## START OF FILE: editor\__init__.py ##########



########## START OF FILE: editor\editor.py ##########

# editor/editor.py
# -*- coding: utf-8 -*-
"""
## version 1.0.0.10 (Refined debug logs, ensure C is from constants)
Level Editor for the Platformer Game (Pygame Only).
Allows creating, loading, and saving game levels visually.
"""
import pygame
import sys
import os
from typing import Tuple, Dict, Optional, Any, List, Callable
import traceback

# --- VERY EARLY DEBUGGING FOR IMPORTS ---
print("--- EDITOR.PY START ---")
print(f"Initial sys.path: {sys.path}")
print(f"Initial current working directory (CWD): {os.getcwd()}")

# --- Add parent directory to sys.path ---
current_script_path = os.path.dirname(os.path.abspath(__file__))
print(f"Current script path (__file__): {current_script_path}")
parent_directory = os.path.dirname(current_script_path) # This should be the project root
print(f"Calculated parent directory (project root attempt): {parent_directory}")

if parent_directory not in sys.path:
    sys.path.insert(0, parent_directory)
    print(f"Parent directory '{parent_directory}' was ADDED to sys.path.")
else:
    print(f"Parent directory '{parent_directory}' was ALREADY in sys.path.")

print(f"Modified sys.path (should contain project root at index 0 or 1): {sys.path}")
print(f"CWD after potential sys.path modification: {os.getcwd()}")

# Now try to import constants
try:
    import constants as C_imported # Use a different alias to avoid potential clashes
    print(f"Successfully imported 'constants as C_imported'. TILE_SIZE: {C_imported.TILE_SIZE}")
except ImportError as e:
    print(f"ERROR: Failed to import 'constants as C_imported'. ImportError: {e}")
    print("Please check:")
    print(f"1. Is '{parent_directory}' the correct project root where 'constants.py' is located?")
    print(f"2. Does '{os.path.join(parent_directory, 'constants.py')}' actually exist?")
    print(f"3. Is 'constants.py' a valid Python module (no syntax errors)?")
    sys.exit("ImportError for constants.py - exiting.")
except Exception as e_gen:
    print(f"ERROR: An unexpected error occurred during 'constants' import: {e_gen}")
    traceback.print_exc()
    sys.exit("Generic error importing constants.py - exiting.")
# --- END OF EARLY DEBUGGING FOR IMPORTS ---


import editor_config as ED_CONFIG # ED_CONFIG itself imports constants as C
from editor_state import EditorState
import editor_ui
import editor_assets
import editor_map_utils
import editor_drawing
import editor_event_handlers
# constants as C is imported by editor_config and other modules, ensure it's the correct one.
# We can use ED_CONFIG.C to be explicit that we're using the one constants resolved by editor_config.


def editor_main():
    print("DEBUG MAIN: editor_main() started.")
    try:
        pygame.init()
        print("DEBUG MAIN: pygame.init() called.")
        if not pygame.font.get_init(): # Check if font module is initialized
            print("DEBUG MAIN: pygame.font not initialized, calling pygame.font.init()")
            pygame.font.init()
        if not pygame.font.get_init():
             print("CRITICAL MAIN: pygame.font.init() failed after explicit call! Fonts will not work.")
        else:
            print("DEBUG MAIN: pygame.font.init() confirmed or already initialized.")


        if not editor_map_utils.ensure_maps_directory_exists():
            print("CRITICAL MAIN: Maps directory issue. Exiting.")
            pygame.quit(); sys.exit(1)
        print("DEBUG MAIN: Maps directory ensured.")

        editor_screen = pygame.display.set_mode(
            (ED_CONFIG.EDITOR_SCREEN_INITIAL_WIDTH, ED_CONFIG.EDITOR_SCREEN_INITIAL_HEIGHT),
            pygame.RESIZABLE
        )
        print(f"DEBUG MAIN: Editor screen created: {editor_screen.get_size()}")
        pygame.display.set_caption("Platformer Level Editor - Menu")
        editor_clock = pygame.time.Clock()
        editor_state = EditorState() # This initializes and prints its own debugs
        print("DEBUG MAIN: EditorState instance created.")
        editor_assets.load_editor_palette_assets(editor_state) # This also prints debugs
        print("DEBUG MAIN: load_editor_palette_assets called successfully.")

        fonts: Dict[str, Optional[pygame.font.Font]] = ED_CONFIG.FONT_CONFIG
        if not fonts.get("small") or not fonts.get("medium") or not fonts.get("large"):
            print("CRITICAL MAIN: Essential editor fonts (small, medium, or large) are None after ED_CONFIG load. Exiting.")
            pygame.quit(); sys.exit(1)
        print(f"DEBUG MAIN: Fonts from ED_CONFIG.FONT_CONFIG loaded: small={fonts['small'] is not None}, medium={fonts['medium'] is not None}, large={fonts['large'] is not None}, tooltip={fonts['tooltip'] is not None}")

        def calculate_layout_rects(screen_width: int, screen_height: int, current_mode: str) -> Tuple[pygame.Rect, pygame.Rect, pygame.Rect]:
            # print(f"DEBUG LAYOUT: calculate_layout_rects called. Screen: {screen_width}x{screen_height}, Mode: '{current_mode}'") # Verbose
            menu_rect = pygame.Rect(ED_CONFIG.SECTION_PADDING, ED_CONFIG.SECTION_PADDING,
                                     ED_CONFIG.MENU_SECTION_WIDTH, screen_height - (ED_CONFIG.SECTION_PADDING * 2))
            menu_rect.width = max(ED_CONFIG.BUTTON_WIDTH_STANDARD + ED_CONFIG.SECTION_PADDING * 2, menu_rect.width)
            menu_rect.height = max(menu_rect.height, ED_CONFIG.MENU_SECTION_HEIGHT) # Ensure min height

            asset_palette_rect = pygame.Rect(ED_CONFIG.SECTION_PADDING, ED_CONFIG.SECTION_PADDING,
                                            ED_CONFIG.ASSET_PALETTE_SECTION_WIDTH, screen_height - (ED_CONFIG.SECTION_PADDING * 2))
            
            map_view_x_start = ED_CONFIG.SECTION_PADDING 
            map_view_width_available = screen_width - (ED_CONFIG.SECTION_PADDING * 2)

            if current_mode == "menu":
                map_view_x_start = menu_rect.right + ED_CONFIG.SECTION_PADDING
                map_view_width_available = screen_width - map_view_x_start - ED_CONFIG.SECTION_PADDING
            elif current_mode == "editing_map":
                asset_palette_rect.left = ED_CONFIG.SECTION_PADDING
                map_view_x_start = asset_palette_rect.right + ED_CONFIG.SECTION_PADDING
                map_view_width_available = screen_width - map_view_x_start - ED_CONFIG.SECTION_PADDING
            
            map_view_rect = pygame.Rect(map_view_x_start, ED_CONFIG.SECTION_PADDING,
                                        map_view_width_available, screen_height - (ED_CONFIG.SECTION_PADDING * 2))
            map_view_rect.width = max(map_view_rect.width, ED_CONFIG.DEFAULT_GRID_SIZE * 10) # Min sensible width
            map_view_rect.height = max(map_view_rect.height, ED_CONFIG.DEFAULT_GRID_SIZE * 10) # Min sensible height
            
            # print(f"DEBUG LAYOUT: Calculated rects - Menu={menu_rect}, Assets={asset_palette_rect}, Map={map_view_rect}") # Verbose
            return menu_rect, asset_palette_rect, map_view_rect

        current_screen_width, current_screen_height = editor_screen.get_size()
        menu_section_rect, asset_palette_section_rect, map_view_section_rect = calculate_layout_rects(
            current_screen_width, current_screen_height, editor_state.current_editor_mode
        )
        print(f"DEBUG MAIN: Initial Layout - Menu={menu_section_rect}, Assets={asset_palette_section_rect}, Map={map_view_section_rect}")


        running = True
        print("DEBUG MAIN: Entering main loop.")
        loop_count = 0 
        while running:
            loop_count += 1
            dt = editor_clock.tick(ED_CONFIG.C.FPS if hasattr(ED_CONFIG.C, 'FPS') else 60) / 1000.0
            mouse_pos = pygame.mouse.get_pos()
            events = pygame.event.get()
            
            if loop_count % ( (ED_CONFIG.C.FPS if hasattr(ED_CONFIG.C, 'FPS') else 60) * 5) == 0: # Approx every 5 seconds
                print(f"\nDEBUG MAIN LOOP (Periodic Log @ frame {loop_count}, time ~{pygame.time.get_ticks()/1000:.1f}s): ----")
                print(f"  Mode: {editor_state.current_editor_mode}, Active Dialog: {editor_state.active_dialog_type}")
                print(f"  Unsaved Changes: {editor_state.unsaved_changes}, Map Name Func: '{editor_state.map_name_for_function}'")
                print(f"  Current Map File: '{editor_state.current_map_filename}'")
                print(f"  Selected Asset: '{editor_state.selected_asset_editor_key}'")
                print(f"  Num Placed Objects: {len(editor_state.placed_objects)}")
                print(f"  Camera: ({editor_state.camera_offset_x}, {editor_state.camera_offset_y})")
                print(f"  Screen: {current_screen_width}x{current_screen_height}")
                print(f"  Layout Rects: Menu={menu_section_rect}, Assets={asset_palette_section_rect}, Map={map_view_section_rect}")
                print(f"DEBUG MAIN LOOP ---- END ----\n")

            editor_state.update_status_message(dt)

            previous_mode = editor_state.current_editor_mode
            previous_dialog_type = editor_state.active_dialog_type # For detecting dialog closure
            layout_needs_recalc = False

            for event_idx, event in enumerate(events):
                if event.type == pygame.VIDEORESIZE:
                    print(f"DEBUG MAIN: VIDEORESIZE event to {event.w}x{event.h}")
                    current_screen_width, current_screen_height = event.w, event.h
                    try:
                        editor_screen = pygame.display.set_mode((current_screen_width, current_screen_height), pygame.RESIZABLE)
                        print(f"DEBUG MAIN: Screen resized to {editor_screen.get_size()}")
                    except pygame.error as e_resize:
                        print(f"ERROR MAIN: Pygame error on resize to {current_screen_width}x{current_screen_height}: {e_resize}")
                        # Potentially try to fall back to a default size or handle gracefully
                    layout_needs_recalc = True
                    editor_state.set_status_message(f"Resized to {event.w}x{event.h}", 2.0)
                
                if not editor_event_handlers.handle_global_events(event, editor_state, editor_screen):
                    print("DEBUG MAIN: handle_global_events returned False. Setting running=False.")
                    running = False; break
                if not running: break 

                # --- MODAL DIALOG EVENT PROCESSING ---
                if editor_state.active_dialog_type:
                    editor_event_handlers.handle_dialog_events(event, editor_state)
                    # If dialog was closed (active_dialog_type became None or changed)
                    if editor_state.active_dialog_type != previous_dialog_type:
                        print(f"DEBUG MAIN: Dialog type changed from '{previous_dialog_type}' to '{editor_state.active_dialog_type}' after handle_dialog_events.")
                        # If mode also changed, it was likely due to a dialog callback
                        if editor_state.current_editor_mode != previous_mode:
                            print(f"DEBUG MAIN: Mode changed (likely via dialog callback) from '{previous_mode}' to '{editor_state.current_editor_mode}'. Triggering layout recalc.")
                            layout_needs_recalc = True
                else: # No active dialog, process mode-specific events
                    if editor_state.current_editor_mode == "menu":
                        editor_event_handlers.handle_menu_events(event, editor_state, editor_screen)
                    elif editor_state.current_editor_mode == "editing_map":
                        editor_event_handlers.handle_editing_map_events(
                            event, editor_state,
                            asset_palette_section_rect, map_view_section_rect,
                            editor_screen
                        )
                
                # Check if mode changed from any event handler (dialog or mode-specific)
                if editor_state.current_editor_mode != previous_mode:
                    print(f"DEBUG MAIN: Mode changed from '{previous_mode}' to '{editor_state.current_editor_mode}' after specific event handlers. Triggering layout recalc.")
                    layout_needs_recalc = True
            if not running: break 
            
            if layout_needs_recalc:
                print(f"DEBUG MAIN: Recalculating layout. Current Mode: '{editor_state.current_editor_mode}', Screen: {current_screen_width}x{current_screen_height}")
                menu_section_rect, asset_palette_section_rect, map_view_section_rect = calculate_layout_rects(
                    current_screen_width, current_screen_height, editor_state.current_editor_mode
                )
                print(f"DEBUG MAIN: New Layout after recalc - Menu={menu_section_rect}, Assets={asset_palette_section_rect}, Map={map_view_section_rect}")
                
                # If in editing mode and map surface exists, adjust camera to new view bounds
                if editor_state.current_editor_mode == "editing_map" and editor_state.map_content_surface:
                    map_px_w = editor_state.get_map_pixel_width()
                    map_px_h = editor_state.get_map_pixel_height()
                    view_w = map_view_section_rect.width
                    view_h = map_view_section_rect.height
                    
                    if view_w > 0 and view_h > 0 : # Ensure view rect has positive dimensions
                        max_cam_x = max(0, map_px_w - view_w)
                        max_cam_y = max(0, map_px_h - view_h)
                        
                        prev_cam_x, prev_cam_y = editor_state.camera_offset_x, editor_state.camera_offset_y
                        editor_state.camera_offset_x = max(0, min(editor_state.camera_offset_x, max_cam_x))
                        editor_state.camera_offset_y = max(0, min(editor_state.camera_offset_y, max_cam_y))
                        if prev_cam_x != editor_state.camera_offset_x or prev_cam_y != editor_state.camera_offset_y:
                            print(f"DEBUG MAIN: Camera clamped after resize/layout change from ({prev_cam_x},{prev_cam_y}) to ({editor_state.camera_offset_x},{editor_state.camera_offset_y}). Max cam: ({max_cam_x},{max_cam_y})")
                    else:
                        print(f"Warning MAIN: Map view rect has zero or negative W/H ({view_w}x{view_h}) after layout recalc. Camera not adjusted.")


            # --- Drawing ---
            editor_screen.fill(ED_CONFIG.C.DARK_GRAY) # Use ED_CONFIG.C for constants

            if editor_state.current_editor_mode == "menu":
                editor_drawing.draw_menu_ui(editor_screen, editor_state, menu_section_rect, fonts, mouse_pos)
                # Draw placeholder for map area in menu mode
                placeholder_rect = pygame.Rect(
                    menu_section_rect.right + ED_CONFIG.SECTION_PADDING, 
                    ED_CONFIG.SECTION_PADDING,
                    current_screen_width - menu_section_rect.right - ED_CONFIG.SECTION_PADDING * 2,
                    current_screen_height - ED_CONFIG.SECTION_PADDING * 2
                )
                if placeholder_rect.width > 10 and placeholder_rect.height > 10: # Only draw if reasonably sized
                    pygame.draw.rect(editor_screen, (20,20,20), placeholder_rect) # Darker placeholder bg
                    font_large = fonts.get("large")
                    if font_large:
                        ph_text = font_large.render("Map Editor Area", True, (60,60,60)) # Dim text
                        editor_screen.blit(ph_text, ph_text.get_rect(center=placeholder_rect.center))

            elif editor_state.current_editor_mode == "editing_map":
                editor_drawing.draw_asset_palette_ui(editor_screen, editor_state, asset_palette_section_rect, fonts, mouse_pos)
                editor_drawing.draw_map_view_ui(editor_screen, editor_state, map_view_section_rect, fonts, mouse_pos)
            
            if editor_state.active_dialog_type: # Draw dialogs on top of everything else
                editor_ui.draw_active_dialog(editor_screen, editor_state, fonts)

            font_tooltip = fonts.get("tooltip") # Use specific tooltip font from ED_CONFIG
            if font_tooltip: editor_ui.draw_tooltip(editor_screen, editor_state, font_tooltip)
            
            font_small = fonts.get("small") # Use specific small font
            if font_small: editor_ui.draw_status_message(editor_screen, editor_state, font_small)

            pygame.display.flip()

    except Exception as e:
        print(f"CRITICAL ERROR in editor_main: {e}")
        traceback.print_exc()
    finally:
        print("DEBUG MAIN: Exiting editor_main. Calling pygame.quit() and sys.exit().")
        pygame.quit()
        sys.exit()

if __name__ == "__main__":
    print("DEBUG MAIN: Script execution started (__name__ == '__main__').")
    editor_main()

########## START OF FILE: editor\editor_assets.py ##########

# editor_assets.py
# -*- coding: utf-8 -*-
"""
## version 1.0.0.5 (Added bottom overhang for palette, configurable text offset)
Handles loading and managing assets for the editor's palette.
"""
import pygame
import os
import sys
import traceback 
from typing import Optional, List, Dict, Any

# --- (Sys.path manipulation and assets import - keeping essential prints) ---
current_dir = os.path.dirname(os.path.abspath(__file__)) 
parent_dir = os.path.dirname(current_dir)                 
if parent_dir not in sys.path:
    sys.path.insert(0, parent_dir)
    print(f"INFO ASSETS: Added '{parent_dir}' to sys.path for 'assets' module import.")
try:
    from assets import load_gif_frames, resource_path
    print("INFO ASSETS: Imported 'load_gif_frames' and 'resource_path' from assets.py")
except ImportError as e:
    print(f"CRITICAL ASSETS ERROR: Failed to import from 'assets.py': {e}")
    # Provide dummy functions if import fails, to allow editor to potentially run with limited functionality
    def load_gif_frames(path: str) -> list: # Matches original type hint
        print(f"CRITICAL ASSETS ERROR: Using DUMMY load_gif_frames for path: {path}")
        return []
    def resource_path(relative_path: str) -> str: # Matches original type hint
        # This dummy might not be robust enough if used, but it's a fallback.
        resolved_path = os.path.join(parent_dir, relative_path)
        print(f"CRITICAL ASSETS ERROR: Using DUMMY resource_path. Input: '{relative_path}', Output: '{resolved_path}'")
        return resolved_path
    print("CRITICAL ASSETS ERROR: Using dummy asset loading functions.")
except Exception as e_gen:
    print(f"CRITICAL ASSETS ERROR: Unexpected error importing from 'assets.py': {e_gen}"); traceback.print_exc()
    sys.exit("Failed to initialize assets module in editor_assets.py")

import editor_config as ED_CONFIG 
from editor_state import EditorState


def load_editor_palette_assets(editor_state: EditorState):
    editor_state.assets_palette.clear()
    print("INFO ASSETS: Loading editor palette assets...")
    successful_loads = 0; failed_loads = 0

    for asset_key, asset_info in ED_CONFIG.EDITOR_PALETTE_ASSETS.items():
        surf: Optional[pygame.Surface] = None
        tooltip = asset_info.get("tooltip", asset_key)
        game_type_id = asset_info.get("game_type_id", asset_key)
        category = asset_info.get("category", "unknown")

        if "source_file" in asset_info:
            source_file_path = asset_info["source_file"]
            try:
                full_path = resource_path(source_file_path)
                if not os.path.exists(full_path):
                    print(f"Assets Error: File NOT FOUND at '{full_path}' for asset '{asset_key}'")
                    # Don't try to load if not found, surf will remain None
                else:
                    frames = load_gif_frames(full_path)
                    if frames: surf = frames[0]
                    else: print(f"Warning ASSETS: load_gif_frames returned empty list for '{asset_key}' from '{full_path}'.")
            except Exception as e: print(f"Error ASSETS: Loading '{asset_key}' from '{source_file_path}': {e}"); # traceback.print_exc() # Less verbose
        elif "surface_params" in asset_info:
            try:
                w, h, color = asset_info["surface_params"]
                surf = pygame.Surface((max(1, w), max(1, h))); surf.fill(color)
            except Exception as e: print(f"Error ASSETS: Creating surface for '{asset_key}': {e}"); # traceback.print_exc()

        if not surf:
            print(f"Warning ASSETS: Surface for '{asset_key}' is None. Creating fallback.")
            surf = pygame.Surface((ED_CONFIG.DEFAULT_GRID_SIZE, ED_CONFIG.DEFAULT_GRID_SIZE))
            surf.fill(getattr(ED_CONFIG.C, 'RED', (255,0,0))) # Use ED_CONFIG.C for colors if available
            pygame.draw.line(surf, getattr(ED_CONFIG.C, 'BLACK', (0,0,0)), (0,0), surf.get_size(), 1)
            pygame.draw.line(surf, getattr(ED_CONFIG.C, 'BLACK', (0,0,0)), (0,surf.get_height()-1), (surf.get_width()-1,0), 1)
            tooltip += " (Load Error)"; failed_loads += 1
        else: successful_loads +=1

        original_w, original_h = surf.get_size()
        scaled_surf = surf
        if original_w > ED_CONFIG.ASSET_THUMBNAIL_MAX_WIDTH or original_h > ED_CONFIG.ASSET_THUMBNAIL_MAX_HEIGHT:
            ratio = min(ED_CONFIG.ASSET_THUMBNAIL_MAX_WIDTH / original_w if original_w > 0 else 1,
                        ED_CONFIG.ASSET_THUMBNAIL_MAX_HEIGHT / original_h if original_h > 0 else 1)
            new_w, new_h = max(1, int(original_w * ratio)), max(1, int(original_h * ratio))
            try: 
                scaled_surf = pygame.transform.smoothscale(surf, (new_w, new_h)) # Use smoothscale for better quality
            except Exception: 
                print(f"Error ASSETS: Scaling '{asset_key}' failed. Using original."); scaled_surf = surf # Fallback to original if scaling fails
        
        try:
            # Ensure conversion for consistent pixel formats
            final_surf_to_store = scaled_surf.convert_alpha() if scaled_surf.get_flags() & pygame.SRCALPHA else scaled_surf.convert()
        except pygame.error as e: 
            print(f"Error ASSETS: Converting surface for '{asset_key}' failed: {e}. Using unoptimized surface."); 
            final_surf_to_store = scaled_surf # Fallback to unoptimized surface

        editor_state.assets_palette[asset_key] = {
            "image": final_surf_to_store, "game_type_id": game_type_id,
            "tooltip": tooltip, "category": category,
            "original_size_pixels": (original_w, original_h)
        }
    print(f"INFO ASSETS: Palette loading done. Success: {successful_loads}, Failed: {failed_loads}.")
    _calculate_asset_palette_total_height(editor_state)


def _calculate_asset_palette_total_height(editor_state: EditorState):
    current_calc_y = ED_CONFIG.ASSET_PALETTE_ITEM_PADDING 
    
    font_category = ED_CONFIG.FONT_CONFIG.get("medium")
    font_tooltip = ED_CONFIG.FONT_CONFIG.get("small")
    # Provide default heights if font objects are None (e.g., font file not found)
    cat_font_h = font_category.get_height() if font_category else 28 
    tip_font_h = font_tooltip.get_height() if font_tooltip else 20
    
    # Configurable vertical offset for tooltip text (space between image and text)
    tooltip_text_v_offset = getattr(ED_CONFIG, 'ASSET_PALETTE_TOOLTIP_TEXT_V_OFFSET', 2) # Default to 2px
    
    categories_in_order = getattr(ED_CONFIG, 'EDITOR_PALETTE_ASSETS_CATEGORIES_ORDER', 
                                  ["tile", "hazard", "item", "enemy", "spawn", "unknown"]) # Default order
    
    # Initialize dictionary to hold categorized assets
    categorized_assets_present: Dict[str, List[Dict[str, Any]]] = {cat_name: [] for cat_name in categories_in_order}
    if "unknown" not in categorized_assets_present: # Ensure "unknown" key exists if not in categories_in_order
        categorized_assets_present["unknown"] = []
    
    # Sort assets into categories
    for asset_key, data in editor_state.assets_palette.items():
        category_name = data.get("category", "unknown")
        # If category_name is not in pre-defined categories_in_order, add to "unknown"
        categorized_assets_present.get(category_name, categorized_assets_present["unknown"]).append(data)

    for category_name in categories_in_order:
        assets_in_this_category = categorized_assets_present.get(category_name, [])
        if not assets_in_this_category: 
            continue # Skip this category if it has no assets

        # Add height for category title and padding below it
        current_calc_y += cat_font_h + ED_CONFIG.ASSET_PALETTE_ITEM_PADDING
        
        # Special handling for side-by-side spawn items (player1_spawn, player2_spawn)
        if category_name == "spawn" and \
           any(d.get("game_type_id") == "player1_spawn" for d in assets_in_this_category) and \
           any(d.get("game_type_id") == "player2_spawn" for d in assets_in_this_category):
            
            p1_data = next((d for d in assets_in_this_category if d.get("game_type_id") == "player1_spawn"), None)
            p2_data = next((d for d in assets_in_this_category if d.get("game_type_id") == "player2_spawn"), None)
            
            max_img_h = 0
            if p1_data and p1_data.get("image"): max_img_h = max(max_img_h, p1_data["image"].get_height())
            if p2_data and p2_data.get("image"): max_img_h = max(max_img_h, p2_data["image"].get_height())
            
            if max_img_h > 0: # If at least one spawn item has an image
                current_calc_y += max_img_h # Height of the row of images
                current_calc_y += tip_font_h + tooltip_text_v_offset # Height for one line of text below, using configurable offset
                current_calc_y += ED_CONFIG.ASSET_PALETTE_ITEM_PADDING # Padding after this row
            
            # Remove P1 and P2 spawn from list so they are not processed again in the loop below
            # This rebinds `assets_in_this_category` to a new list for the subsequent loop;
            # it does not modify the list in `categorized_assets_present`.
            assets_in_this_category = [d for d in assets_in_this_category if d.get("game_type_id") not in ["player1_spawn", "player2_spawn"]]
            # Fallthrough to process any OTHER spawn items normally (if any)
        
        # Process remaining items in the category (or all if not "spawn" with P1/P2 handled above)
        for asset_data in assets_in_this_category:
            asset_img = asset_data.get("image")
            if not asset_img: 
                continue # Skip if asset has no image (e.g., load error)
            current_calc_y += asset_img.get_height() # Height of the asset image
            current_calc_y += tip_font_h + tooltip_text_v_offset # Height for tooltip text below, using configurable offset
            current_calc_y += ED_CONFIG.ASSET_PALETTE_ITEM_PADDING # Padding after this item
        
        # Add extra padding after the entire category block
        current_calc_y += ED_CONFIG.ASSET_PALETTE_ITEM_PADDING
            
    # Add a final overhang (e.g., ~1 inch in pixels) at the bottom of the palette content.
    # This ensures there's ample blank space, preventing potential UI elements at the
    # bottom of the palette (like a "bg color button") from obscuring the last asset items.
    asset_palette_bottom_overhang_px = getattr(ED_CONFIG, 'ASSET_PALETTE_BOTTOM_OVERHANG_PX', 72) # Default to 72 pixels (common for 1 inch at 72 DPI)
    current_calc_y += asset_palette_bottom_overhang_px
            
    editor_state.total_asset_palette_content_height = current_calc_y
    print(f"INFO ASSETS: Calculated total asset palette content height (incl. {asset_palette_bottom_overhang_px}px overhang): {editor_state.total_asset_palette_content_height}")

########## START OF FILE: editor\editor_config.py ##########

# editor_config.py
# -*- coding: utf-8 -*-
"""
## version 1.0.0.4 (Added typing imports for Optional, Dict)
Configuration constants for the Platformer Level Editor.
"""
import pygame
import sys
import os
import traceback 
from typing import Dict, Optional, Tuple, Any # ADDED Optional, Dict, Tuple, Any for type hints

# --- Add parent directory to sys.path ---
# (sys.path manipulation and constants import remains the same)
current_dir = os.path.dirname(os.path.abspath(__file__)) 
parent_dir = os.path.dirname(current_dir)                 
print(f"DEBUG CONFIG: current_dir (editor_config.py location): {current_dir}")
print(f"DEBUG CONFIG: parent_dir (project root attempt): {parent_dir}")

if parent_dir not in sys.path:
    sys.path.insert(0, parent_dir)
    print(f"DEBUG CONFIG: Added '{parent_dir}' to sys.path for 'constants' import.")
else:
    print(f"DEBUG CONFIG: '{parent_dir}' already in sys.path.")

try:
    import constants as C 
    print(f"DEBUG CONFIG: Successfully imported 'constants as C'. TILE_SIZE: {C.TILE_SIZE if hasattr(C, 'TILE_SIZE') else 'NOT FOUND'}")
except ImportError as e:
    print(f"CRITICAL CONFIG ERROR: Failed to import 'constants as C' from '{parent_dir}'. Error: {e}")
    print(f"DEBUG CONFIG: sys.path was: {sys.path}")
    class FallbackConstants: 
        TILE_SIZE = 32; WHITE = (255,255,255); BLACK = (0,0,0); RED = (255,0,0); GREEN = (0,255,0)
        BLUE = (0,0,255); GRAY = (128,128,128); DARK_GRAY = (50,50,50); YELLOW = (255,255,0)
        LIGHT_BLUE = (173,216,230); DARK_GREEN = (0,100,0); ORANGE_RED = (255,69,0)
        LIGHT_GRAY = (200,200,200); FPS = 60
    C = FallbackConstants()
    print("CRITICAL CONFIG ERROR: Using fallback constants. Editor functionality will be impaired.")
except Exception as e_gen:
    print(f"CRITICAL CONFIG ERROR: Unexpected error importing 'constants': {e_gen}"); traceback.print_exc()
    sys.exit("Failed to initialize constants in editor_config.py")


# --- Editor Window Dimensions ---
EDITOR_SCREEN_INITIAL_WIDTH = 1280
EDITOR_SCREEN_INITIAL_HEIGHT = 720

MENU_SECTION_WIDTH = 280
MENU_SECTION_HEIGHT = 250 

ASSET_PALETTE_SECTION_WIDTH = 220

SECTION_PADDING = 10 

MAP_VIEW_SECTION_DEFAULT_WIDTH = EDITOR_SCREEN_INITIAL_WIDTH - MENU_SECTION_WIDTH - ASSET_PALETTE_SECTION_WIDTH - (SECTION_PADDING * 3) 
MAP_VIEW_SECTION_DEFAULT_HEIGHT = EDITOR_SCREEN_INITIAL_HEIGHT - (SECTION_PADDING * 2)

# --- UI Element Sizes & Colors ---
BUTTON_WIDTH_STANDARD = 200
BUTTON_HEIGHT_STANDARD = 50
BUTTON_TEXT_COLOR: Tuple[int,int,int] = getattr(C, 'WHITE', (255,255,255))
BUTTON_COLOR_NORMAL: Tuple[int,int,int] = getattr(C, 'BLUE', (0,0,255))
BUTTON_COLOR_HOVER: Tuple[int,int,int] = getattr(C, 'GREEN', (0,255,0))
BUTTON_COLOR_BORDER: Tuple[int,int,int] = getattr(C, 'BLACK', (0,0,0))
BUTTON_BORDER_WIDTH = 2

ASSET_THUMBNAIL_MAX_WIDTH = getattr(C, 'TILE_SIZE', 32) * 2
ASSET_THUMBNAIL_MAX_HEIGHT = getattr(C, 'TILE_SIZE', 32) * 2
ASSET_PALETTE_ITEM_PADDING = 5
ASSET_PALETTE_BG_COLOR: Tuple[int,int,int] = (30, 30, 30)
ASSET_PALETTE_CATEGORY_TEXT_COLOR: Tuple[int,int,int] = getattr(C, 'YELLOW', (255,255,0))
ASSET_PALETTE_TOOLTIP_COLOR: Tuple[int,int,int] = getattr(C, 'LIGHT_GRAY', (200,200,200))
ASSET_PALETTE_HOVER_BG_COLOR: Tuple[int,int,int] = (50, 80, 50)

MAP_VIEW_GRID_COLOR: Tuple[int,int,int] = getattr(C, 'GRAY', (128,128,128))
MAP_VIEW_BORDER_COLOR: Tuple[int,int,int] = getattr(C, 'GRAY', (128,128,128))
MAP_VIEW_CAMERA_PAN_SPEED: int = getattr(C, 'TILE_SIZE', 32) // 2

DIALOG_BG_COLOR: Tuple[int,int,int] = (60, 60, 70)
DIALOG_INPUT_BOX_COLOR: Tuple[int,int,int] = getattr(C, 'WHITE', (255,255,255))
DIALOG_INPUT_TEXT_COLOR: Tuple[int,int,int] = getattr(C, 'BLACK', (0,0,0))
DIALOG_PROMPT_COLOR: Tuple[int,int,int] = getattr(C, 'WHITE', (255,255,255))
DIALOG_CURSOR_COLOR: Tuple[int,int,int] = getattr(C, 'BLACK', (0,0,0))

COLOR_PICKER_BUTTON_SIZE = 40
COLOR_PICKER_PADDING = 8
COLOR_PICKER_COLS = 5
COLOR_PICKER_BG_COLOR: Tuple[int,int,int] = (40, 40, 50)
COLOR_PICKER_TITLE_COLOR: Tuple[int,int,int] = getattr(C, 'WHITE', (255,255,255))
COLOR_PICKER_HOVER_BORDER_COLOR: Tuple[int,int,int] = getattr(C, 'YELLOW', (255,255,0))

MAPS_DIRECTORY = "maps" 

# --- Asset Definitions for Editor Palette ---
EDITOR_PALETTE_ASSETS: Dict[str, Dict[str, Any]] = { # Added Any
    "player1_spawn": {
        "source_file": "characters/player1/__Idle.gif", "game_type_id": "player1_spawn",
        "tooltip": "P1", "category": "spawn"
    },
    "player2_spawn": { 
        "source_file": "characters/player2/__Idle.gif", "game_type_id": "player2_spawn",
        "tooltip": "P2", "category": "spawn"
    },
    "enemy_cyan": {
        "source_file": "characters/cyan/__Idle.gif", "game_type_id": "enemy_cyan",
        "tooltip": "Enemy (Cyan)", "category": "enemy"
    },
    "enemy_green": {
        "source_file": "characters/green/__Idle.gif", "game_type_id": "enemy_green",
        "tooltip": "Enemy (Green)", "category": "enemy"
    },
    "enemy_pink": {
        "source_file": "characters/pink/__Idle.gif", "game_type_id": "enemy_pink",
        "tooltip": "Enemy (Pink)", "category": "enemy"
    },
    "enemy_purple": {
        "source_file": "characters/purple/__Idle.gif", "game_type_id": "enemy_purple",
        "tooltip": "Enemy (Purple)", "category": "enemy"
    },
    "enemy_red": {
        "source_file": "characters/red/__Idle.gif", "game_type_id": "enemy_red",
        "tooltip": "Enemy (Red)", "category": "enemy"
    },
    "enemy_yellow": {
        "source_file": "characters/yellow/__Idle.gif", "game_type_id": "enemy_yellow",
        "tooltip": "Enemy (Yellow)", "category": "enemy"
    },
    "chest": {
        "source_file": "characters/items/chest.gif", "game_type_id": "chest",
        "tooltip": "Chest", "category": "item"
    },
    "platform_wall_gray": {
        "surface_params": (getattr(C, 'TILE_SIZE', 32), getattr(C, 'TILE_SIZE', 32), getattr(C, 'GRAY', (128,128,128))), 
        "game_type_id": "platform_wall_gray", "tooltip": "Wall (Gray)", "category": "tile"
    },
    "platform_ledge_green": {
        "surface_params": (getattr(C, 'TILE_SIZE', 32), getattr(C, 'TILE_SIZE', 32), getattr(C, 'DARK_GREEN', (0,100,0))), 
        "game_type_id": "platform_ledge_green", "tooltip": "Ledge (Green)", "category": "tile"
    },
    "hazard_lava_tile": {
        "surface_params": (getattr(C, 'TILE_SIZE', 32), getattr(C, 'TILE_SIZE', 32), getattr(C, 'ORANGE_RED', (255,69,0))), 
        "game_type_id": "hazard_lava", "tooltip": "Lava Tile", "category": "hazard"
    },
}

EDITOR_PALETTE_ASSETS_CATEGORIES_ORDER = ["tile", "hazard", "item", "enemy", "spawn", "unknown"]

DEFAULT_MAP_WIDTH_TILES = 30
DEFAULT_MAP_HEIGHT_TILES = 20
DEFAULT_GRID_SIZE = getattr(C, 'TILE_SIZE', 32)
DEFAULT_BACKGROUND_COLOR: Tuple[int,int,int] = getattr(C, 'LIGHT_BLUE', (173,216,230))

LEVEL_EDITOR_SAVE_FORMAT_EXTENSION = ".json"
GAME_LEVEL_FILE_EXTENSION = ".py"

TOOLTIP_FONT_SIZE = 18
TOOLTIP_TEXT_COLOR: Tuple[int,int,int] = getattr(C, 'BLACK', (0,0,0))
TOOLTIP_BG_COLOR: Tuple[int,int,int] = (240, 240, 210) 
TOOLTIP_PADDING = 5
TOOLTIP_OFFSET_Y = 25

COLOR_PICKER_PRESETS: Dict[str, Tuple[int,int,int]] = {
    "Light Blue": getattr(C, 'LIGHT_BLUE', (173,216,230)), "White": getattr(C, 'WHITE', (255,255,255)), 
    "Black": getattr(C, 'BLACK', (0,0,0)), "Gray": getattr(C, 'GRAY', (128,128,128)),
    "Dark Gray": getattr(C, 'DARK_GRAY', (50,50,50)), "Red": getattr(C, 'RED', (255,0,0)), 
    "Green": getattr(C, 'GREEN', (0,255,0)), "Blue": getattr(C, 'BLUE', (0,0,255)),
    "Yellow": getattr(C, 'YELLOW', (255,255,0)), "Orange": getattr(C, 'ORANGE_RED', (255,69,0)), 
    "Purple": (128, 0, 128), "Brown": (139, 69, 19), 
    "Dark Green": getattr(C, 'DARK_GREEN', (0,100,0)), "Sky Blue": (100, 150, 255),
    "Dark Purple": (75,0,130), "Sand": (244,164,96)
}

FONT_CONFIG: Dict[str, Optional[pygame.font.Font]] = {
    "small": None, "medium": None, "large": None, "tooltip": None
}
try:
    if not pygame.font.get_init(): 
        print("DEBUG CONFIG: pygame.font not initialized, calling pygame.font.init()")
        pygame.font.init()
    
    if pygame.font.get_init(): 
        FONT_CONFIG["small"] = pygame.font.Font(None, 22)
        FONT_CONFIG["medium"] = pygame.font.Font(None, 28)
        FONT_CONFIG["large"] = pygame.font.Font(None, 36)
        FONT_CONFIG["tooltip"] = pygame.font.Font(None, TOOLTIP_FONT_SIZE)
        print("DEBUG CONFIG: Successfully initialized fonts in FONT_CONFIG.")
    else:
        print("CRITICAL CONFIG ERROR: pygame.font.init() failed. Fonts will be None.")
except pygame.error as e:
    print(f"CRITICAL CONFIG ERROR: Pygame error initializing fonts in editor_config: {e}"); traceback.print_exc()
except Exception as e_font:
    print(f"CRITICAL CONFIG ERROR: Generic error initializing fonts in editor_config: {e_font}"); traceback.print_exc()

for font_name, font_obj in FONT_CONFIG.items():
    if font_obj is None:
        print(f"WARNING CONFIG: Font '{font_name}' is None. UI elements using it might not render text correctly.")

print("DEBUG CONFIG: editor_config.py loaded.")

########## START OF FILE: editor\editor_drawing.py ##########

# editor_drawing.py
# -*- coding: utf-8 -*-
"""
## version 1.0.0.13 (Removed all semicolons again, verified side-by-side spawn)
Contains functions for drawing the different sections and elements
of the Platformer Level Editor UI using Pygame.
"""
import pygame
from typing import Dict, Tuple, Any, Optional 
import traceback 

import editor_config as ED_CONFIG
from editor_state import EditorState
from editor_ui import draw_button


def draw_menu_ui(surface: pygame.Surface, editor_state: EditorState, menu_section_rect: pygame.Rect,
                 fonts: Dict[str, Optional[pygame.font.Font]], mouse_pos: Tuple[int, int]):
    try:
        pygame.draw.rect(surface, getattr(ED_CONFIG.C, 'BLACK', (0,0,0)), menu_section_rect) 
        title_font = fonts.get("large") or ED_CONFIG.FONT_CONFIG.get("large")
        button_font = fonts.get("medium") or ED_CONFIG.FONT_CONFIG.get("medium")

        if title_font:
            title_surf = title_font.render("Level Editor", True, getattr(ED_CONFIG.C, 'WHITE', (255,255,255)))
            title_rect = title_surf.get_rect(centerx=menu_section_rect.centerx, top=menu_section_rect.top + 20)
            surface.blit(title_surf, title_rect)
        
        button_w = ED_CONFIG.BUTTON_WIDTH_STANDARD
        button_h = ED_CONFIG.BUTTON_HEIGHT_STANDARD
        spacing = 20
        num_buttons = 3
        total_button_h = (num_buttons * button_h) + ((num_buttons - 1) * spacing)
        title_h_approx = title_font.get_height() if title_font else 40
        content_start_y = menu_section_rect.top + title_h_approx + 30
        remaining_h = menu_section_rect.height - (content_start_y - menu_section_rect.top)
        start_y = max(content_start_y + (remaining_h - total_button_h) // 2, content_start_y)

        if not hasattr(editor_state, 'ui_elements_rects') or editor_state.ui_elements_rects is None:
            editor_state.ui_elements_rects = {}
        for k in [key for key in editor_state.ui_elements_rects if key.startswith("menu_")]:
            del editor_state.ui_elements_rects[k]
        
        if button_font:
            rect_params = [
                (start_y, "menu_new_map", "New Map"), 
                (start_y + button_h + spacing, "menu_load_map", "Load Map (.json)"),
                (start_y + 2 * (button_h + spacing), "menu_quit", "Quit Editor")
            ]
            for top_y, key, text in rect_params:
                btn_r = pygame.Rect(0,0,button_w,button_h)
                btn_r.centerx = menu_section_rect.centerx
                btn_r.top = top_y
                editor_state.ui_elements_rects[key] = btn_r
                draw_button(surface, btn_r, text, button_font, mouse_pos)
        else: 
            print("Warning DRAW: Menu button font missing.")
    except Exception as e: 
        print(f"ERROR DRAW: Exception in draw_menu_ui: {e}")
        traceback.print_exc()


def _draw_single_palette_item(scroll_surf: pygame.Surface, 
                              editor_state: EditorState, 
                              palette_section_rect: pygame.Rect, 
                              asset_key: str, asset_data: Dict[str, Any], 
                              item_x: int, item_y_on_scroll: int, 
                              tip_font: Optional[pygame.font.Font], 
                              mouse_pos: Tuple[int, int]) -> int:
    img = asset_data.get("image")
    tooltip_text = asset_data.get("tooltip", asset_key)
    if not img: return 0 

    item_rect_on_screen = pygame.Rect(
        palette_section_rect.left + item_x,
        palette_section_rect.top + item_y_on_scroll - editor_state.asset_palette_scroll_y,
        img.get_width(), img.get_height()
    )
    editor_state.ui_elements_rects['asset_palette_items'][asset_key] = item_rect_on_screen

    is_hovered = item_rect_on_screen.collidepoint(mouse_pos) and palette_section_rect.collidepoint(mouse_pos)
    is_selected = editor_state.selected_asset_editor_key == asset_key

    if is_hovered:
        editor_state.hovered_tooltip_text = tooltip_text
        editor_state.hovered_tooltip_pos = mouse_pos
        hover_bg_r = pygame.Rect(item_x - 2, item_y_on_scroll - 2, img.get_width() + 4, img.get_height() + 4)
        pygame.draw.rect(scroll_surf, ED_CONFIG.ASSET_PALETTE_HOVER_BG_COLOR, hover_bg_r, border_radius=2)
    if is_selected:
        select_b_r = pygame.Rect(item_x - 3, item_y_on_scroll - 3, img.get_width() + 6, img.get_height() + 6)
        pygame.draw.rect(scroll_surf, ED_CONFIG.C.YELLOW, select_b_r, 2, border_radius=3)
    
    scroll_surf.blit(img, (item_x, item_y_on_scroll))
    current_item_total_height = img.get_height()

    if tip_font:
        name_s = tip_font.render(tooltip_text, True, ED_CONFIG.ASSET_PALETTE_TOOLTIP_COLOR)
        text_x = item_x + (img.get_width() - name_s.get_width()) // 2
        scroll_surf.blit(name_s, (max(item_x, text_x), item_y_on_scroll + img.get_height() + 2))
        current_item_total_height += name_s.get_height() + 2
    
    return current_item_total_height


def draw_asset_palette_ui(surface: pygame.Surface, editor_state: EditorState, palette_section_rect: pygame.Rect,
                          fonts: Dict[str, Optional[pygame.font.Font]], mouse_pos: Tuple[int, int]):
    try:
        pygame.draw.rect(surface, ED_CONFIG.ASSET_PALETTE_BG_COLOR, palette_section_rect)
        if editor_state.total_asset_palette_content_height <= 0:
            font_small = fonts.get("small") or ED_CONFIG.FONT_CONFIG.get("small")
            if font_small:
                no_assets_text = "Assets Loading/Error..."
                if not ED_CONFIG.EDITOR_PALETTE_ASSETS: no_assets_text = "No assets defined."
                elif not editor_state.assets_palette : no_assets_text = "Asset palette empty."
                msg_surf = font_small.render(no_assets_text, True, getattr(ED_CONFIG.C, 'WHITE', (255,255,255)))
                surface.blit(msg_surf, msg_surf.get_rect(center=palette_section_rect.center))
            return

        scroll_surf = pygame.Surface((palette_section_rect.width, editor_state.total_asset_palette_content_height), pygame.SRCALPHA)
        scroll_surf.fill((0,0,0,0)) 
        current_y_on_scroll_surf = ED_CONFIG.ASSET_PALETTE_ITEM_PADDING
        cat_font = fonts.get("medium") or ED_CONFIG.FONT_CONFIG.get("medium")
        tip_font = fonts.get("small") or ED_CONFIG.FONT_CONFIG.get("small")
        
        editor_state.hovered_tooltip_text = None
        if not hasattr(editor_state, 'ui_elements_rects') or editor_state.ui_elements_rects is None: editor_state.ui_elements_rects = {}
        editor_state.ui_elements_rects['asset_palette_items'] = {}
        
        categories_order = getattr(ED_CONFIG, 'EDITOR_PALETTE_ASSETS_CATEGORIES_ORDER', 
                                   ["tile", "hazard", "item", "enemy", "spawn", "unknown"])

        for cat_name in categories_order:
            assets_in_category_tuples = [(k, d) for k, d in editor_state.assets_palette.items() if d.get("category", "unknown") == cat_name]
            if not assets_in_category_tuples: continue

            if cat_font:
                cat_surf = cat_font.render(cat_name.title(), True, ED_CONFIG.ASSET_PALETTE_CATEGORY_TEXT_COLOR)
                scroll_surf.blit(cat_surf, (ED_CONFIG.ASSET_PALETTE_ITEM_PADDING, current_y_on_scroll_surf))
                current_y_on_scroll_surf += cat_surf.get_height() + ED_CONFIG.ASSET_PALETTE_ITEM_PADDING
            
            row_start_y_for_current_items = current_y_on_scroll_surf 
            
            if cat_name == "spawn":
                p1_item_tuple = next(((k,d) for k,d in assets_in_category_tuples if k == "player1_spawn"), None)
                p2_item_tuple = next(((k,d) for k,d in assets_in_category_tuples if k == "player2_spawn"), None)
                other_items_in_this_category = [item for item in assets_in_category_tuples if item[0] not in ["player1_spawn", "player2_spawn"]]
                
                current_x_in_row = ED_CONFIG.ASSET_PALETTE_ITEM_PADDING
                max_h_for_this_row = 0

                if p1_item_tuple:
                    h = _draw_single_palette_item(scroll_surf, editor_state, palette_section_rect, p1_item_tuple[0], p1_item_tuple[1], current_x_in_row, row_start_y_for_current_items, tip_font, mouse_pos)
                    max_h_for_this_row = max(max_h_for_this_row, h)
                    if p1_item_tuple[1].get("image"):
                        current_x_in_row += p1_item_tuple[1]["image"].get_width() + ED_CONFIG.ASSET_PALETTE_ITEM_PADDING 
                
                if p2_item_tuple:
                    p2_img = p2_item_tuple[1].get("image")
                    if p2_img and current_x_in_row + p2_img.get_width() > palette_section_rect.width - ED_CONFIG.ASSET_PALETTE_ITEM_PADDING:
                        # Not enough horizontal space for P2 on the same line, advance Y
                        current_y_on_scroll_surf = row_start_y_for_current_items + max_h_for_this_row + ED_CONFIG.ASSET_PALETTE_ITEM_PADDING
                        row_start_y_for_current_items = current_y_on_scroll_surf # Update row_start_y for P2
                        current_x_in_row = ED_CONFIG.ASSET_PALETTE_ITEM_PADDING # Reset X for P2
                        max_h_for_this_row = 0 # Reset max height for this new "row" (which only has P2)

                    h = _draw_single_palette_item(scroll_surf, editor_state, palette_section_rect, p2_item_tuple[0], p2_item_tuple[1], current_x_in_row, row_start_y_for_current_items, tip_font, mouse_pos)
                    max_h_for_this_row = max(max_h_for_this_row, h)
                
                if max_h_for_this_row > 0:
                    current_y_on_scroll_surf = row_start_y_for_current_items + max_h_for_this_row + ED_CONFIG.ASSET_PALETTE_ITEM_PADDING
                
                assets_to_draw_this_category_loop = other_items_in_this_category
            else:
                assets_to_draw_this_category_loop = assets_in_category_tuples

            for asset_key, asset_data in assets_to_draw_this_category_loop:
                item_x_vertical = ED_CONFIG.ASSET_PALETTE_ITEM_PADDING
                item_y_vertical = current_y_on_scroll_surf
                
                item_total_height = _draw_single_palette_item(scroll_surf, editor_state, palette_section_rect, asset_key, asset_data, item_x_vertical, item_y_vertical, tip_font, mouse_pos)
                current_y_on_scroll_surf = item_y_vertical + item_total_height + ED_CONFIG.ASSET_PALETTE_ITEM_PADDING
            
            if assets_in_category_tuples : 
                current_y_on_scroll_surf += ED_CONFIG.ASSET_PALETTE_ITEM_PADDING

        surface.blit(scroll_surf, palette_section_rect.topleft, (0, editor_state.asset_palette_scroll_y, palette_section_rect.width, palette_section_rect.height))
        pygame.draw.rect(surface, getattr(ED_CONFIG.C, 'GRAY', (128,128,128)), palette_section_rect, 2)
        btn_font = fonts.get("small") or ED_CONFIG.FONT_CONFIG.get("small")
        if btn_font:
            btn_h = ED_CONFIG.BUTTON_HEIGHT_STANDARD*0.8
            cp_btn_r = pygame.Rect(palette_section_rect.left+ED_CONFIG.ASSET_PALETTE_ITEM_PADDING, palette_section_rect.bottom-btn_h-ED_CONFIG.ASSET_PALETTE_ITEM_PADDING, palette_section_rect.width-ED_CONFIG.ASSET_PALETTE_ITEM_PADDING*2, int(btn_h))
            editor_state.ui_elements_rects["palette_bg_color_button"] = cp_btn_r
            bg_lum = sum(editor_state.background_color)/3
            txt_col = getattr(ED_CONFIG.C, 'BLACK', (0,0,0)) if bg_lum > 128*1.5 else getattr(ED_CONFIG.C, 'WHITE', (255,255,255))
            draw_button(surface,cp_btn_r,"BG Color",btn_font,mouse_pos,text_color=txt_col,button_color_normal=editor_state.background_color,button_color_hover=pygame.Color(editor_state.background_color).lerp(getattr(ED_CONFIG.C, 'WHITE', (255,255,255)),0.3),border_color=getattr(ED_CONFIG.C, 'BLACK', (0,0,0)))
    except Exception as e: 
        print(f"ERROR DRAW: draw_asset_palette_ui: {e}")
        traceback.print_exc()


def draw_map_view_ui(surface: pygame.Surface, editor_state: EditorState, map_view_rect: pygame.Rect,
                     fonts: Dict[str, Optional[pygame.font.Font]], mouse_pos: Tuple[int, int]):
    try:
        if not editor_state.map_content_surface:
            pygame.draw.rect(surface, getattr(ED_CONFIG.C, 'DARK_GRAY', (50,50,50)), map_view_rect) 
            ph_font = fonts.get("medium") or ED_CONFIG.FONT_CONFIG.get("medium")
            if ph_font: 
                txt_surf = ph_font.render("No Map/Surface Error", True, getattr(ED_CONFIG.C, 'WHITE', (255,255,255)))
                surface.blit(txt_surf, txt_surf.get_rect(center=map_view_rect.center))
            pygame.draw.rect(surface, ED_CONFIG.MAP_VIEW_BORDER_COLOR, map_view_rect, 2)
            return

        editor_state.map_content_surface.fill(editor_state.background_color)
        for obj in editor_state.placed_objects:
            key,wx,wy=obj.get("asset_editor_key"),obj.get("world_x"),obj.get("world_y")
            if wx is None or wy is None: continue
            info = editor_state.assets_palette.get(key) if key else None
            if info and info.get("image"): 
                editor_state.map_content_surface.blit(info["image"], (wx,wy))
            else: 
                pygame.draw.rect(editor_state.map_content_surface, getattr(ED_CONFIG.C, 'RED', (255,0,0)), (wx,wy,editor_state.grid_size,editor_state.grid_size),1)
        
        if editor_state.show_grid: 
            draw_grid_on_map_surface(editor_state.map_content_surface, editor_state)
        
        surface.blit(editor_state.map_content_surface, map_view_rect.topleft, (editor_state.camera_offset_x, editor_state.camera_offset_y, map_view_rect.width, map_view_rect.height))
        pygame.draw.rect(surface, ED_CONFIG.MAP_VIEW_BORDER_COLOR, map_view_rect, 2)
        
        if editor_state.selected_asset_image_for_cursor:
            img = editor_state.selected_asset_image_for_cursor
            pos = img.get_rect(center=mouse_pos).topleft
            if map_view_rect.collidepoint(mouse_pos):
                world_mx = mouse_pos[0]-map_view_rect.left+editor_state.camera_offset_x
                world_my = mouse_pos[1]-map_view_rect.top+editor_state.camera_offset_y
                grid_wx = (world_mx//editor_state.grid_size)*editor_state.grid_size
                grid_wy = (world_my//editor_state.grid_size)*editor_state.grid_size
                pos = (grid_wx-editor_state.camera_offset_x+map_view_rect.left, grid_wy-editor_state.camera_offset_y+map_view_rect.top)
            
            clip_orig = surface.get_clip()
            surface.set_clip(map_view_rect)
            surface.blit(img,pos)
            surface.set_clip(clip_orig)
        
        _draw_map_view_info_text(surface, editor_state, map_view_rect, fonts, mouse_pos)
    except Exception as e: 
        print(f"ERROR DRAW: draw_map_view_ui: {e}")
        traceback.print_exc()

def _draw_map_view_info_text(surface: pygame.Surface, editor_state: EditorState, map_view_rect: pygame.Rect, 
                             fonts: Dict[str, Optional[pygame.font.Font]], general_mouse_pos: Tuple[int, int]):
    info_font = fonts.get("small") or ED_CONFIG.FONT_CONFIG.get("small")
    if not info_font: return

    lines = ["LMB Drag: Paint, RMB Drag: Erase", "WASD: Pan, G: Grid, ESC: Deselect/Menu", "Shift+RMB(Map): Save All", "Ctrl+S: Save All"]
    line_h = info_font.get_height()+3
    y_start = map_view_rect.bottom+7
    
    for i,line_text in enumerate(lines):
        txt_surf = info_font.render(line_text,True,getattr(ED_CONFIG.C, 'YELLOW', (255,255,0)))
        y_draw = y_start + i*line_h
        if y_draw + line_h > surface.get_height()-5: 
            y_draw = surface.get_height()-5 - line_h*(len(lines)-i)
        if i==0: y_draw = max(5, y_draw) 
        surface.blit(txt_surf, (map_view_rect.left+5, y_draw))
        
    coords_text_str = f"Cam:({editor_state.camera_offset_x},{editor_state.camera_offset_y})"
    if map_view_rect.collidepoint(general_mouse_pos):
        world_mx = general_mouse_pos[0]-map_view_rect.left+editor_state.camera_offset_x
        world_my = general_mouse_pos[1]-map_view_rect.top+editor_state.camera_offset_y
        tx,ty = world_mx//editor_state.grid_size, world_my//editor_state.grid_size
        coords_text_str += f" MouseW:({world_mx},{world_my}) Tile:({tx},{ty})"
    
    coords_surf = info_font.render(coords_text_str,True,getattr(ED_CONFIG.C, 'WHITE', (255,255,255)))
    coords_y_pos = map_view_rect.top-coords_surf.get_height()-4
    coords_x_pos = map_view_rect.left+5
    if coords_y_pos < 5: 
        coords_y_pos = y_start + len(lines)*line_h + 5 
        if coords_y_pos + coords_surf.get_height() > surface.get_height()-5: 
             coords_y_pos = surface.get_height()-5-coords_surf.get_height()
    surface.blit(coords_surf, (coords_x_pos, coords_y_pos))

def draw_grid_on_map_surface(map_content_surface: pygame.Surface, editor_state: EditorState):
    if not (editor_state.show_grid and editor_state.map_content_surface and editor_state.grid_size > 0): return
    w,h,gs = editor_state.get_map_pixel_width(), editor_state.get_map_pixel_height(), editor_state.grid_size
    gc = getattr(ED_CONFIG, 'MAP_VIEW_GRID_COLOR', (128,128,128)) 
    try:
        for x_coord in range(0, w + gs, gs): 
            pygame.draw.line(map_content_surface,gc,(x_coord,0),(x_coord,h)) 
        for y_coord in range(0, h + gs, gs): 
            pygame.draw.line(map_content_surface,gc,(0,y_coord),(w,y_coord)) 
    except Exception as e: 
        print(f"ERROR DRAW: draw_grid_on_map_surface: {e}")
        traceback.print_exc()

########## START OF FILE: editor\editor_event_handlers.py ##########

# editor_event_handlers.py
# -*- coding: utf-8 -*-
"""
## version 1.0.0.15 (Corrected MOUSEMOTION for painting/erasing, general cleanup)
Handles Pygame events for different modes and UI elements
of the Platformer Level Editor.
"""
import pygame
import os
from typing import Optional, Dict, Tuple, Any, Callable, List
import traceback

import editor_config as ED_CONFIG
from editor_state import EditorState
from editor_ui import start_text_input_dialog, start_color_picker_dialog, start_file_load_dialog
from editor_map_utils import (init_new_map_state, save_map_to_json,
                              load_map_from_json, export_map_to_game_python_script)

def handle_global_events(event: pygame.event.Event, editor_state: EditorState, main_screen: pygame.Surface) -> bool:
    if event.type == pygame.QUIT:
        print("DEBUG GLOBAL_EVENT: pygame.QUIT event received.")
        if editor_state.unsaved_changes:
            if not getattr(editor_state, '_quit_attempted_with_unsaved_changes', False):
                editor_state.set_status_message("Unsaved changes! Quit again to exit without saving, or save your map.", 5.0)
                editor_state._quit_attempted_with_unsaved_changes = True
                return True 
            else: 
                print("DEBUG GLOBAL_EVENT: Second quit attempt with unsaved changes. Proceeding to quit.")
                if hasattr(editor_state, '_quit_attempted_with_unsaved_changes'):
                    del editor_state._quit_attempted_with_unsaved_changes
                return False
        else: 
            if hasattr(editor_state, '_quit_attempted_with_unsaved_changes'):
                del editor_state._quit_attempted_with_unsaved_changes
            return False

    if event.type == pygame.VIDEORESIZE:
        print(f"DEBUG GLOBAL_EVENT: pygame.VIDEORESIZE to {event.w}x{event.h}")
        editor_state.set_status_message(f"Resized to {event.w}x{event.h}", 2.0)
    
    if event.type != pygame.QUIT and hasattr(editor_state, '_quit_attempted_with_unsaved_changes'):
        del editor_state._quit_attempted_with_unsaved_changes
        
    return True


def handle_dialog_events(event: pygame.event.Event, editor_state: EditorState):
    if not editor_state.active_dialog_type:
        return

    confirmed = False
    cancelled = False
    selected_value_from_dialog: Any = None
    dialog_type_being_processed = editor_state.active_dialog_type

    if event.type == pygame.KEYDOWN:
        if event.key == pygame.K_ESCAPE: cancelled = True
        elif event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
            if dialog_type_being_processed == "text_input":
                confirmed = True; selected_value_from_dialog = editor_state.dialog_input_text
            elif dialog_type_being_processed == "file_load" and editor_state.dialog_selected_file_index != -1 and \
                 0 <= editor_state.dialog_selected_file_index < len(editor_state.dialog_file_list):
                confirmed = True; selected_value_from_dialog = os.path.join(ED_CONFIG.MAPS_DIRECTORY, editor_state.dialog_file_list[editor_state.dialog_selected_file_index])
            elif dialog_type_being_processed == "file_load": editor_state.set_status_message("No file selected.", 2.5)
        if dialog_type_being_processed == "text_input":
            if event.key == pygame.K_BACKSPACE: editor_state.dialog_input_text = editor_state.dialog_input_text[:-1]
            elif event.unicode.isprintable() and (event.unicode.isalnum() or event.unicode in ['.', '_', '-', ' ', ',', '/', '\\']): editor_state.dialog_input_text += event.unicode
        elif dialog_type_being_processed == "file_load" and editor_state.dialog_file_list:
            list_len = len(editor_state.dialog_file_list)
            if list_len > 0:
                if event.key == pygame.K_UP: editor_state.dialog_selected_file_index = (editor_state.dialog_selected_file_index - 1 + list_len) % list_len
                elif event.key == pygame.K_DOWN: editor_state.dialog_selected_file_index = (editor_state.dialog_selected_file_index + 1) % list_len
            else: editor_state.dialog_selected_file_index = -1
            if editor_state.dialog_selected_file_index != -1: editor_state.dialog_input_text = editor_state.dialog_file_list[editor_state.dialog_selected_file_index]
            else: editor_state.dialog_input_text = ""
    elif event.type == pygame.MOUSEBUTTONDOWN: # event.pos is valid
        if editor_state.dialog_rect and editor_state.dialog_rect.collidepoint(event.pos) and event.button == 1:
            if dialog_type_being_processed == "color_picker":
                for color_name, swatch_rect_relative in editor_state.color_picker_rects.items():
                    absolute_swatch_rect = swatch_rect_relative.move(editor_state.dialog_rect.left, editor_state.dialog_rect.top)
                    if absolute_swatch_rect.collidepoint(event.pos):
                        selected_value_from_dialog = ED_CONFIG.COLOR_PICKER_PRESETS.get(color_name);
                        if selected_value_from_dialog: confirmed = True
                        break
            elif dialog_type_being_processed == "file_load":
                ok_rect, cancel_rect = editor_state.ui_elements_rects.get("dialog_file_load_ok"), editor_state.ui_elements_rects.get("dialog_file_load_cancel")
                if ok_rect and ok_rect.collidepoint(event.pos) and editor_state.dialog_selected_file_index != -1:
                    confirmed = True; selected_value_from_dialog = os.path.join(ED_CONFIG.MAPS_DIRECTORY, editor_state.dialog_file_list[editor_state.dialog_selected_file_index])
                elif cancel_rect and cancel_rect.collidepoint(event.pos): cancelled = True
                else:
                    for item_info in editor_state.ui_elements_rects.get('dialog_file_item_rects', []):
                        if item_info["rect"].collidepoint(event.pos): editor_state.dialog_selected_file_index = item_info["index"]; editor_state.dialog_input_text = item_info["text"]; break
                    scrollbar_handle_rect = editor_state.ui_elements_rects.get('file_dialog_scrollbar_handle')
                    if scrollbar_handle_rect and scrollbar_handle_rect.collidepoint(event.pos): editor_state.is_dragging_scrollbar = True; editor_state.scrollbar_drag_mouse_offset_y = event.pos[1] - scrollbar_handle_rect.top
        elif dialog_type_being_processed != "text_input": cancelled = True
    elif event.type == pygame.MOUSEBUTTONUP: # event.pos is valid
        if event.button == 1 and editor_state.is_dragging_scrollbar: editor_state.is_dragging_scrollbar = False
    elif event.type == pygame.MOUSEMOTION: # event.pos is valid
        if editor_state.is_dragging_scrollbar:
            scrollbar_area = editor_state.ui_elements_rects.get('file_dialog_scrollbar_area'); scrollbar_handle = editor_state.ui_elements_rects.get('file_dialog_scrollbar_handle')
            if scrollbar_area and scrollbar_handle and editor_state.dialog_file_list:
                mouse_y_in_area = event.pos[1] - scrollbar_area.top; handle_pos_y = mouse_y_in_area - editor_state.scrollbar_drag_mouse_offset_y
                item_font = ED_CONFIG.FONT_CONFIG.get("small"); item_h = (item_font.get_height() + 6) if item_font else 22
                content_h = len(editor_state.dialog_file_list) * item_h; display_h = scrollbar_area.height
                track_h = max(1, display_h - scrollbar_handle.height); scroll_px = max(0, content_h - display_h)
                if track_h > 0 and scroll_px > 0: clamped_y = max(0, min(handle_pos_y, track_h)); ratio = clamped_y / track_h; editor_state.dialog_file_scroll_y = ratio * scroll_px
    elif event.type == pygame.MOUSEWHEEL: # event.y is valid, event.pos might not be relevant for wheel itself
        if dialog_type_being_processed == "file_load" and editor_state.dialog_rect and editor_state.dialog_rect.collidepoint(pygame.mouse.get_pos()): # check mouse over dialog
            font_small = ED_CONFIG.FONT_CONFIG.get("small"); item_h = (font_small.get_height() + 6) if font_small else 22
            scroll_val = event.y * item_h; content_h = len(editor_state.dialog_file_list) * item_h
            font_medium = ED_CONFIG.FONT_CONFIG.get("medium"); prompt_h = (font_medium.get_height() + 25) if font_medium else 55
            buttons_h = 40; display_h = editor_state.dialog_rect.height - prompt_h - buttons_h - 10
            max_s = max(0, content_h - display_h); editor_state.dialog_file_scroll_y -= scroll_val; editor_state.dialog_file_scroll_y = max(0, min(editor_state.dialog_file_scroll_y, max_s))

    if confirmed:
        print(f"DEBUG DIALOG_EVENT: Dialog '{dialog_type_being_processed}' outcome: CONFIRMED.")
        active_dialog_type_before_cb = editor_state.active_dialog_type
        original_confirm_cb = editor_state.dialog_callback_confirm
        original_cancel_cb = editor_state.dialog_callback_cancel
        original_prompt = editor_state.dialog_prompt_message
        
        if confirm_cb_to_call := editor_state.dialog_callback_confirm: # Python 3.8+ walrus operator
            try:
                value_to_pass = selected_value_from_dialog if selected_value_from_dialog is not None else editor_state.dialog_input_text
                print(f"DEBUG DIALOG_EVENT: Calling confirm_callback for '{dialog_type_being_processed}' with value: '{value_to_pass}'")
                confirm_cb_to_call(value_to_pass) 
            except Exception as e: print(f"ERROR: Confirm CB Exception: {e}"); traceback.print_exc()
        
        new_dialog_was_started = False
        if editor_state.active_dialog_type is not None: # If a dialog is still set
            # Check if it's a *different* dialog than the one we just processed the confirm for,
            # or if its core properties (callbacks, prompt) changed, indicating re-initialization.
            if (editor_state.active_dialog_type != active_dialog_type_before_cb or
                editor_state.dialog_callback_confirm != original_confirm_cb or
                editor_state.dialog_callback_cancel != original_cancel_cb or
                editor_state.dialog_prompt_message != original_prompt):
                new_dialog_was_started = True
        
        if new_dialog_was_started:
            print(f"DEBUG DIALOG_EVENT: Dialog '{dialog_type_being_processed}' confirmed. Callback started a NEW dialog: '{editor_state.active_dialog_type}'.")
        else: # No new dialog took over, or callback explicitly cleared active_dialog_type
            print(f"DEBUG DIALOG_EVENT: Dialog '{dialog_type_being_processed}' confirmed. No new dialog active. Cleaning up.")
            editor_state.active_dialog_type = None 
            editor_state.dialog_callback_confirm = None; editor_state.dialog_callback_cancel = None
            editor_state.dialog_input_text = ""; editor_state.dialog_selected_file_index = -1
            editor_state.is_dragging_scrollbar = False

    elif cancelled:
        print(f"DEBUG DIALOG_EVENT: Dialog '{dialog_type_being_processed}' outcome: CANCELLED.")
        active_dialog_type_before_cb = editor_state.active_dialog_type
        original_confirm_cb = editor_state.dialog_callback_confirm
        original_cancel_cb = editor_state.dialog_callback_cancel
        original_prompt = editor_state.dialog_prompt_message

        if cancel_cb_to_call := editor_state.dialog_callback_cancel:
            try:
                print(f"DEBUG DIALOG_EVENT: Calling cancel_callback for '{dialog_type_being_processed}'.")
                cancel_cb_to_call()
            except Exception as e: print(f"ERROR: Cancel CB Exception: {e}"); traceback.print_exc()

        new_dialog_was_started = False
        if editor_state.active_dialog_type is not None:
            if (editor_state.active_dialog_type != active_dialog_type_before_cb or
                editor_state.dialog_callback_confirm != original_confirm_cb or
                editor_state.dialog_callback_cancel != original_cancel_cb or
                editor_state.dialog_prompt_message != original_prompt):
                new_dialog_was_started = True
        
        if new_dialog_was_started:
             print(f"DEBUG DIALOG_EVENT: Dialog '{dialog_type_being_processed}' cancelled. Callback started a NEW dialog: '{editor_state.active_dialog_type}'.")
        else:
            print(f"DEBUG DIALOG_EVENT: Dialog '{dialog_type_being_processed}' cancelled. No new dialog active. Cleaning up.")
            editor_state.active_dialog_type = None
            editor_state.dialog_callback_confirm = None; editor_state.dialog_callback_cancel = None
            editor_state.dialog_input_text = ""; editor_state.dialog_selected_file_index = -1
            editor_state.is_dragging_scrollbar = False


def handle_menu_events(event: pygame.event.Event, editor_state: EditorState, main_screen: pygame.Surface):
    if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
        mouse_pos = event.pos # Safe here
        ui_rects = editor_state.ui_elements_rects 
        
        if ui_rects.get("menu_new_map") and ui_rects["menu_new_map"].collidepoint(mouse_pos):
            print("DEBUG MENU_EVENT: 'New Map' button clicked.")
            def on_new_map_name_confirm(map_name: str):
                map_name = map_name.strip()
                if not map_name:
                    editor_state.set_status_message("Map name cannot be empty.", 3)
                    start_text_input_dialog(editor_state, "Name:", "", on_new_map_name_confirm, lambda: print("DEBUG MENU_EVENT: Name re-prompt cancelled"))
                    return
                editor_state.map_name_for_function_input = map_name
                def on_map_size_confirm(size_str: str):
                    try:
                        parts = [s.strip() for s in size_str.split(',')]
                        if len(parts) != 2 or not all(s.isdigit() for s in parts): raise ValueError("Format: W,H (numbers)")
                        w, h = int(parts[0]), int(parts[1])
                        if not (w > 0 and h > 0): raise ValueError("Dimensions > 0")
                        
                        init_new_map_state(editor_state, editor_state.map_name_for_function_input, w, h)
                        print(f"DEBUG MENU_EVENT: Auto-saving new map '{editor_state.map_name_for_function}'")
                        if save_map_to_json(editor_state) and export_map_to_game_python_script(editor_state):
                            editor_state.set_status_message(f"Map '{editor_state.map_name_for_function}' auto-saved.", 3)
                            # unsaved_changes is set False by export_map_to_game_python_script
                            pygame.display.set_caption(f"Editor - {editor_state.map_name_for_function}.py")
                        else:
                            editor_state.set_status_message(f"Auto-save failed for '{editor_state.map_name_for_function}'.", 4)
                            # Ensure unsaved_changes is true if save failed
                            editor_state.unsaved_changes = True 
                            pygame.display.set_caption(f"Editor - {editor_state.map_name_for_function}.py*")
                        editor_state.current_editor_mode = "editing_map"
                    except Exception as e:
                        editor_state.set_status_message(f"Invalid size: {e}", 3.5)
                        start_text_input_dialog(editor_state, "Size (W,H):", f"{ED_CONFIG.DEFAULT_MAP_WIDTH_TILES},{ED_CONFIG.DEFAULT_MAP_HEIGHT_TILES}", on_map_size_confirm, lambda: print("DEBUG MENU_EVENT: Size re-prompt cancelled"))
                start_text_input_dialog(editor_state, "Size (W,H):", f"{ED_CONFIG.DEFAULT_MAP_WIDTH_TILES},{ED_CONFIG.DEFAULT_MAP_HEIGHT_TILES}", on_map_size_confirm, lambda: print("DEBUG MENU_EVENT: Size dialog cancelled"))
            start_text_input_dialog(editor_state, "New Map Name:", "my_map", on_new_map_name_confirm, lambda: print("DEBUG MENU_EVENT: Name dialog cancelled"))
            return

        elif ui_rects.get("menu_load_map") and ui_rects["menu_load_map"].collidepoint(mouse_pos):
            print("DEBUG MENU_EVENT: 'Load Map' button clicked.")
            def on_file_selected(fp: str):
                if load_map_from_json(editor_state, fp):
                    editor_state.current_editor_mode = "editing_map"; pygame.display.set_caption(f"Editor - {editor_state.map_name_for_function}.py")
            start_file_load_dialog(editor_state, on_confirm=on_file_selected, on_cancel=lambda: print("DEBUG MENU_EVENT: Load dialog cancelled"))
            return

        elif ui_rects.get("menu_quit") and ui_rects["menu_quit"].collidepoint(mouse_pos):
            pygame.event.post(pygame.event.Event(pygame.QUIT))


def _place_tile_at_grid(editor_state: EditorState, grid_coords: Tuple[int, int]):
    if not editor_state.selected_asset_editor_key: return
    grid_world_x = grid_coords[0] * editor_state.grid_size
    grid_world_y = grid_coords[1] * editor_state.grid_size
    asset_data = editor_state.assets_palette[editor_state.selected_asset_editor_key]
    new_obj_game_type_id = asset_data["game_type_id"]
    is_spawn_item = asset_data.get("category") == "spawn"

    if not is_spawn_item:
        for obj in editor_state.placed_objects:
            if obj.get("world_x") == grid_world_x and \
               obj.get("world_y") == grid_world_y and \
               obj.get("game_type_id") == new_obj_game_type_id:
                return 
    elif is_spawn_item: # Only one of each spawn type allowed
        editor_state.placed_objects = [obj for obj in editor_state.placed_objects if obj.get("game_type_id") != new_obj_game_type_id]

    new_obj = {"asset_editor_key": editor_state.selected_asset_editor_key, "world_x": grid_world_x, "world_y": grid_world_y, "game_type_id": new_obj_game_type_id}
    editor_state.placed_objects.append(new_obj)
    if not editor_state.unsaved_changes: editor_state.unsaved_changes = True # Mark unsaved if not already
    pygame.display.set_caption(f"Editor - {editor_state.map_name_for_function}.py*")


def _erase_tile_at_grid(editor_state: EditorState, grid_coords: Tuple[int, int]):
    grid_world_x = grid_coords[0] * editor_state.grid_size
    grid_world_y = grid_coords[1] * editor_state.grid_size
    
    obj_erased = False
    for i in range(len(editor_state.placed_objects) - 1, -1, -1):
        obj = editor_state.placed_objects[i]
        # Simple check: if object's origin is in this grid cell.
        # More precise would be checking if any part of object's rect intersects grid cell.
        if obj.get("world_x") == grid_world_x and obj.get("world_y") == grid_world_y:
            asset_info = editor_state.assets_palette.get(obj.get("asset_editor_key"))
            tooltip = asset_info['tooltip'] if asset_info else "Object"
            print(f"DEBUG EDIT_MAP_EVENT: Erasing '{tooltip}' at grid ({grid_coords[0]},{grid_coords[1]}).")
            editor_state.placed_objects.pop(i)
            if not editor_state.unsaved_changes: editor_state.unsaved_changes = True
            pygame.display.set_caption(f"Editor - {editor_state.map_name_for_function}.py*")
            obj_erased = True
            break # Erase one object per erase action at a grid spot
    if obj_erased:
        editor_state.set_status_message(f"Erased tile at ({grid_coords[0]},{grid_coords[1]})", 1.5)


def handle_editing_map_events(event: pygame.event.Event, editor_state: EditorState,
                              palette_section_rect: pygame.Rect, map_view_rect: pygame.Rect,
                              main_screen: pygame.Surface):
    general_mouse_pos = pygame.mouse.get_pos() 

    if event.type == pygame.MOUSEWHEEL:
        if palette_section_rect.collidepoint(general_mouse_pos):
            font_small = ED_CONFIG.FONT_CONFIG.get("small"); scroll_speed = (font_small.get_height() + ED_CONFIG.ASSET_PALETTE_ITEM_PADDING) if font_small else 20
            editor_state.asset_palette_scroll_y -= event.y * scroll_speed 
            max_scroll = max(0, editor_state.total_asset_palette_content_height - palette_section_rect.height)
            editor_state.asset_palette_scroll_y = max(0, min(editor_state.asset_palette_scroll_y, max_scroll))
    
    elif event.type == pygame.MOUSEBUTTONDOWN:
        mouse_pos_for_click = event.pos
        if palette_section_rect.collidepoint(mouse_pos_for_click) and event.button == 1:
            bg_btn = editor_state.ui_elements_rects.get("palette_bg_color_button")
            if bg_btn and bg_btn.collidepoint(mouse_pos_for_click):
                def on_bg_sel(nc: Tuple[int,int,int]):
                    if nc: editor_state.background_color = nc; editor_state.unsaved_changes = True; pygame.display.set_caption(f"Editor - {editor_state.map_name_for_function}.py*"); editor_state.set_status_message(f"BG: {nc}")
                start_color_picker_dialog(editor_state, on_confirm=on_bg_sel, on_cancel=lambda: None); return
            for key, rect in editor_state.ui_elements_rects.get('asset_palette_items', {}).items():
                if rect.collidepoint(mouse_pos_for_click):
                    data = editor_state.assets_palette[key]; editor_state.selected_asset_editor_key = key
                    editor_state.selected_asset_image_for_cursor = data["image"].copy(); editor_state.set_status_message(f"Selected: {data['tooltip']}"); return
        elif map_view_rect.collidepoint(mouse_pos_for_click):
            map_world_mx = mouse_pos_for_click[0]-map_view_rect.left+editor_state.camera_offset_x; map_world_my = mouse_pos_for_click[1]-map_view_rect.top+editor_state.camera_offset_y
            tile_x, tile_y = map_world_mx//editor_state.grid_size, map_world_my//editor_state.grid_size
            if event.button == 1:
                if editor_state.selected_asset_editor_key:
                    editor_state.is_painting_tiles = True; editor_state.last_painted_tile_coords = (tile_x,tile_y); _place_tile_at_grid(editor_state, (tile_x,tile_y))
                else: 
                    editor_state.dragging_object_index = None
                    for i, obj in reversed(list(enumerate(editor_state.placed_objects))):
                        info = editor_state.assets_palette.get(obj.get("asset_editor_key"));
                        if info and "original_size_pixels" in info:
                            obj_w,obj_h=info["original_size_pixels"]; obj_r=pygame.Rect(obj["world_x"],obj["world_y"],obj_w,obj_h)
                            if obj_r.collidepoint(map_world_mx, map_world_my):
                                editor_state.dragging_object_index=i; editor_state.drag_start_mouse_map_x=map_world_mx; editor_state.drag_start_mouse_map_y=map_world_my
                                editor_state.drag_object_original_x=obj["world_x"]; editor_state.drag_object_original_y=obj["world_y"]; editor_state.set_status_message(f"Dragging {info['tooltip']}"); break
            elif event.button == 3:
                if pygame.key.get_mods() & (pygame.KMOD_LSHIFT | pygame.KMOD_RSHIFT): 
                    if editor_state.map_name_for_function and editor_state.map_name_for_function != "untitled_map": # Check for valid map name
                        if save_map_to_json(editor_state) and export_map_to_game_python_script(editor_state): pygame.display.set_caption(f"Editor - {editor_state.map_name_for_function}.py")
                    else: editor_state.set_status_message("Cannot save: Map not named.", 4)
                else: 
                    editor_state.is_erasing_tiles = True; editor_state.last_erased_tile_coords = (tile_x,tile_y); _erase_tile_at_grid(editor_state, (tile_x,tile_y))
    
    elif event.type == pygame.MOUSEBUTTONUP:
        if event.button == 1: 
            editor_state.is_painting_tiles = False
            editor_state.last_painted_tile_coords = None
            if editor_state.dragging_object_index is not None: 
                editor_state.dragging_object_index = None; editor_state.set_status_message("Drag complete")
        elif event.button == 3: 
            editor_state.is_erasing_tiles = False
            editor_state.last_erased_tile_coords = None
        if editor_state.is_dragging_scrollbar: editor_state.is_dragging_scrollbar = False # General scrollbar release
    
    elif event.type == pygame.MOUSEMOTION:
        mouse_pos_motion = event.pos
        if editor_state.dragging_object_index is not None and \
           0 <= editor_state.dragging_object_index < len(editor_state.placed_objects): # Dragging object
            obj_to_drag = editor_state.placed_objects[editor_state.dragging_object_index]
            map_world_mx = mouse_pos_motion[0] - map_view_rect.left + editor_state.camera_offset_x
            map_world_my = mouse_pos_motion[1] - map_view_rect.top + editor_state.camera_offset_y
            new_x = editor_state.drag_object_original_x + (map_world_mx - editor_state.drag_start_mouse_map_x)
            new_y = editor_state.drag_object_original_y + (map_world_my - editor_state.drag_start_mouse_map_y)
            snapped_x = (new_x // editor_state.grid_size) * editor_state.grid_size
            snapped_y = (new_y // editor_state.grid_size) * editor_state.grid_size
            if obj_to_drag["world_x"] != snapped_x or obj_to_drag["world_y"] != snapped_y:
                obj_to_drag["world_x"], obj_to_drag["world_y"] = snapped_x, snapped_y
                if not editor_state.unsaved_changes: editor_state.unsaved_changes = True
                pygame.display.set_caption(f"Editor - {editor_state.map_name_for_function}.py*")
        elif map_view_rect.collidepoint(mouse_pos_motion): # Painting or Erasing
            map_world_mx = mouse_pos_motion[0] - map_view_rect.left + editor_state.camera_offset_x
            map_world_my = mouse_pos_motion[1] - map_view_rect.top + editor_state.camera_offset_y
            curr_tx, curr_ty = map_world_mx // editor_state.grid_size, map_world_my // editor_state.grid_size
            curr_grid_coords = (curr_tx, curr_ty)
            
            mouse_buttons_pressed = pygame.mouse.get_pressed() # (left, middle, right)
            if editor_state.is_painting_tiles and mouse_buttons_pressed[0] and \
               editor_state.selected_asset_editor_key and curr_grid_coords != editor_state.last_painted_tile_coords:
                _place_tile_at_grid(editor_state, curr_grid_coords)
                editor_state.last_painted_tile_coords = curr_grid_coords
            elif editor_state.is_erasing_tiles and mouse_buttons_pressed[2] and \
                 curr_grid_coords != editor_state.last_erased_tile_coords:
                _erase_tile_at_grid(editor_state, curr_grid_coords)
                editor_state.last_erased_tile_coords = curr_grid_coords
        # If mouse moves outside map view while a drag-paint/erase was active, stop it.
        elif not map_view_rect.collidepoint(mouse_pos_motion):
            if editor_state.is_painting_tiles:
                editor_state.is_painting_tiles = False; editor_state.last_painted_tile_coords = None
            if editor_state.is_erasing_tiles:
                editor_state.is_erasing_tiles = False; editor_state.last_erased_tile_coords = None

    elif event.type == pygame.KEYDOWN:
        if event.key == pygame.K_ESCAPE:
            if editor_state.selected_asset_editor_key:
                editor_state.selected_asset_editor_key, editor_state.selected_asset_image_for_cursor = None, None
                editor_state.set_status_message("Asset deselected")
            else:
                if editor_state.unsaved_changes:
                    if not getattr(editor_state, '_esc_exit_attempted', False):
                        editor_state.set_status_message("Unsaved changes! Save or Esc again to discard.", 4); editor_state._esc_exit_attempted = True
                    else:
                        editor_state.current_editor_mode = "menu"; editor_state.reset_map_context()
                        pygame.display.set_caption("Platformer Level Editor - Menu")
                        if hasattr(editor_state, '_esc_exit_attempted'): del editor_state._esc_exit_attempted
                else:
                    editor_state.current_editor_mode = "menu"; editor_state.reset_map_context()
                    pygame.display.set_caption("Platformer Level Editor - Menu")
                    if hasattr(editor_state, '_esc_exit_attempted'): del editor_state._esc_exit_attempted
        
        elif event.key != pygame.K_ESCAPE and hasattr(editor_state, '_esc_exit_attempted'):
            del editor_state._esc_exit_attempted
        
        elif event.key == pygame.K_g:
            editor_state.show_grid = not editor_state.show_grid
            editor_state.set_status_message(f"Grid {'ON' if editor_state.show_grid else 'OFF'}")
        
        pan = ED_CONFIG.MAP_VIEW_CAMERA_PAN_SPEED
        if map_view_rect.width > 0 and map_view_rect.height > 0:
            map_w, map_h = editor_state.get_map_pixel_width(), editor_state.get_map_pixel_height()
            cam_moved = False
            if event.key == pygame.K_a: editor_state.camera_offset_x = max(0, editor_state.camera_offset_x - pan); cam_moved = True
            elif event.key == pygame.K_d: editor_state.camera_offset_x = min(max(0,map_w-map_view_rect.width), editor_state.camera_offset_x+pan); cam_moved = True
            elif event.key == pygame.K_w: editor_state.camera_offset_y = max(0, editor_state.camera_offset_y - pan); cam_moved = True
            elif event.key == pygame.K_s and not (pygame.key.get_mods() & pygame.KMOD_CTRL):
                editor_state.camera_offset_y = min(max(0,map_h-map_view_rect.height), editor_state.camera_offset_y+pan); cam_moved = True
            if cam_moved: print(f"DEBUG EDIT_MAP_EVENT: Camera panned to ({editor_state.camera_offset_x},{editor_state.camera_offset_y})")

        if event.key == pygame.K_s and (pygame.key.get_mods() & pygame.KMOD_CTRL):
            if editor_state.map_name_for_function and editor_state.map_name_for_function != "untitled_map":
                if save_map_to_json(editor_state) and export_map_to_game_python_script(editor_state): 
                    pygame.display.set_caption(f"Editor - {editor_state.map_name_for_function}.py")
            else: editor_state.set_status_message("Cannot save: Map not named.", 4)

########## START OF FILE: editor\editor_map_utils.py ##########

# editor_map_utils.py
# -*- coding: utf-8 -*-
"""
## version 1.0.0.5 (Added extensive debug prints for saving/loading and export)
Utility functions for map operations in the Level Editor,
including initializing new maps, saving/loading editor-specific
map data (JSON), and exporting maps to game-compatible Python scripts.
"""
import pygame
import sys
import os
import json
import traceback # For detailed error reporting
from typing import Optional, Dict, List, Tuple, Any

# --- Add parent directory to sys.path for editor_config & editor_state if this file is run standalone (unlikely here) ---
# This is more robustly handled in the main editor.py script.
# current_script_path_map_utils = os.path.dirname(os.path.abspath(__file__))
# parent_directory_map_utils = os.path.dirname(current_script_path_map_utils) # This should be 'editor'
# project_root_map_utils = os.path.dirname(parent_directory_map_utils) # This should be 'Platformer'
# if project_root_map_utils not in sys.path:
#     sys.path.insert(0, project_root_map_utils)
# if parent_directory_map_utils not in sys.path: # If editor_config is in 'editor' not project root
#    sys.path.insert(0, parent_directory_map_utils)

import editor_config as ED_CONFIG
from editor_state import EditorState

# constants.py and tiles.py should be accessible from the project root.
# This setup relies on editor.py correctly setting up sys.path.
import constants as C
from tiles import Platform, Ladder, Lava # Assuming these are used in export


def init_new_map_state(editor_state: EditorState, map_name_for_function: str,
                       map_width_tiles: int, map_height_tiles: int):
    """
    Initializes the editor_state for a new, empty map.
    Sets up dimensions, clears objects, prepares the map_content_surface.
    """
    print(f"DEBUG MAP_UTILS: init_new_map_state called. Map Name: '{map_name_for_function}', Size: {map_width_tiles}x{map_height_tiles}")
    
    clean_map_name = map_name_for_function.lower().replace(" ", "_").replace("-", "_")
    if not clean_map_name:
        clean_map_name = "untitled_map" # Fallback if name becomes empty
        print(f"DEBUG MAP_UTILS: map_name_for_function was empty after cleaning, defaulting to '{clean_map_name}'")
    
    editor_state.map_name_for_function = clean_map_name
    editor_state.map_width_tiles = map_width_tiles
    editor_state.map_height_tiles = map_height_tiles
    editor_state.placed_objects = []
    editor_state.background_color = ED_CONFIG.DEFAULT_BACKGROUND_COLOR
    editor_state.camera_offset_x = 0
    editor_state.camera_offset_y = 0
    editor_state.unsaved_changes = True # A new map inherently has unsaved changes until first save
    
    py_filename = editor_state.map_name_for_function + ED_CONFIG.GAME_LEVEL_FILE_EXTENSION
    editor_state.current_map_filename = os.path.join(ED_CONFIG.MAPS_DIRECTORY, py_filename)
    
    editor_state.recreate_map_content_surface() # This also prints a debug message
    
    print(f"DEBUG MAP_UTILS: Editor state initialized for new map. "
          f"map_name_for_function='{editor_state.map_name_for_function}', "
          f"current_map_filename='{editor_state.current_map_filename}', "
          f"unsaved_changes={editor_state.unsaved_changes}")

def ensure_maps_directory_exists() -> bool:
    """Checks if the MAPS_DIRECTORY exists, creates it if not. Returns success."""
    maps_dir = ED_CONFIG.MAPS_DIRECTORY
    # print(f"DEBUG MAP_UTILS: Checking if maps directory '{maps_dir}' exists.") # Can be verbose
    if not os.path.exists(maps_dir):
        print(f"DEBUG MAP_UTILS: Maps directory '{maps_dir}' does not exist. Attempting to create.")
        try:
            os.makedirs(maps_dir)
            print(f"DEBUG MAP_UTILS: Successfully created directory: {maps_dir}")
            return True
        except OSError as e:
            print(f"ERROR MAP_UTILS: Error creating directory {maps_dir}: {e}")
            traceback.print_exc()
            return False
    # print(f"DEBUG MAP_UTILS: Maps directory '{maps_dir}' already exists.")
    return True

def save_map_to_json(editor_state: EditorState) -> bool:
    """
    Saves the current editor state to a JSON file for editor reloading.
    Returns True on success, False on failure.
    """
    print(f"DEBUG MAP_UTILS: save_map_to_json called. Map name func: '{editor_state.map_name_for_function}'")
    if not editor_state.map_name_for_function or editor_state.map_name_for_function == "untitled_map":
        msg = "Map name is not set or is 'untitled_map'. Cannot save JSON."
        editor_state.set_status_message(f"Error: {msg}", 3)
        print(f"ERROR MAP_UTILS: {msg}")
        return False

    if not ensure_maps_directory_exists():
        msg = "Could not create or access maps directory."
        editor_state.set_status_message(f"Error: {msg}", 3)
        print(f"ERROR MAP_UTILS: {msg} JSON save aborted.")
        return False

    json_filename = editor_state.map_name_for_function + ED_CONFIG.LEVEL_EDITOR_SAVE_FORMAT_EXTENSION
    json_filepath = os.path.join(ED_CONFIG.MAPS_DIRECTORY, json_filename)
    print(f"DEBUG MAP_UTILS: Attempting to save JSON to: '{json_filepath}'")

    serializable_objects = []
    for i, obj in enumerate(editor_state.placed_objects):
        asset_key = obj.get("asset_editor_key")
        game_id = obj.get("game_type_id")
        world_x = obj.get("world_x")
        world_y = obj.get("world_y")

        if not all([asset_key, game_id is not None, world_x is not None, world_y is not None]):
             print(f"Warning MAP_UTILS: Object at index {i} has missing data, skipping for JSON: {obj}")
             continue

        s_obj = {
            "asset_editor_key": asset_key,
            "world_x": world_x,
            "world_y": world_y,
            "game_type_id": game_id
        }
        serializable_objects.append(s_obj)

    data_to_save = {
        "map_name_for_function": editor_state.map_name_for_function,
        "map_width_tiles": editor_state.map_width_tiles,
        "map_height_tiles": editor_state.map_height_tiles,
        "grid_size": editor_state.grid_size,
        "background_color": list(editor_state.background_color), # Convert tuple to list for JSON
        "placed_objects": serializable_objects,
        "camera_offset_x": editor_state.camera_offset_x,
        "camera_offset_y": editor_state.camera_offset_y,
        "show_grid": editor_state.show_grid
    }
    print(f"DEBUG MAP_UTILS: Data to save to JSON: {json.dumps(data_to_save, indent=2)}") # Log the data

    try:
        with open(json_filepath, "w") as f:
            json.dump(data_to_save, f, indent=4)
        success_msg = f"Editor data saved to: {json_filename}"
        print(f"DEBUG MAP_UTILS: {success_msg}")
        editor_state.set_status_message(success_msg)
        # editor_state.unsaved_changes = False # This should be set False AFTER .py export if successful
        return True
    except IOError as e:
        error_msg = f"IOError saving map to JSON '{json_filepath}': {e}"
    except Exception as e:
        error_msg = f"Unexpected error saving map to JSON '{json_filepath}': {e}"
        traceback.print_exc()
    
    print(f"ERROR MAP_UTILS: {error_msg}")
    editor_state.set_status_message(error_msg, 4)
    return False

def load_map_from_json(editor_state: EditorState, json_filepath: str) -> bool:
    """
    Loads map data from a JSON file into the editor_state.
    Returns True on success, False on failure.
    """
    print(f"DEBUG MAP_UTILS: load_map_from_json called. Filepath: '{json_filepath}'")
    if not os.path.exists(json_filepath) or not os.path.isfile(json_filepath):
        error_msg = f"JSON map file not found or is not a file: '{json_filepath}'"
        print(f"ERROR MAP_UTILS: {error_msg}")
        editor_state.set_status_message(error_msg, 3)
        return False
        
    try:
        with open(json_filepath, 'r') as f:
            data = json.load(f)
        print(f"DEBUG MAP_UTILS: Successfully read JSON data from '{json_filepath}'. Content snapshot: { {k: (type(v) if k != 'placed_objects' else f'{len(v)} items') for k,v in data.items()} }")
        
        editor_state.map_name_for_function = data.get("map_name_for_function", "loaded_map_error_name")
        editor_state.map_width_tiles = data.get("map_width_tiles", ED_CONFIG.DEFAULT_MAP_WIDTH_TILES)
        editor_state.map_height_tiles = data.get("map_height_tiles", ED_CONFIG.DEFAULT_MAP_HEIGHT_TILES)
        editor_state.grid_size = data.get("grid_size", ED_CONFIG.DEFAULT_GRID_SIZE)
        
        bg_color_data = data.get("background_color", ED_CONFIG.DEFAULT_BACKGROUND_COLOR)
        if isinstance(bg_color_data, list) and len(bg_color_data) == 3:
            editor_state.background_color = tuple(bg_color_data) # type: ignore
        else:
            editor_state.background_color = ED_CONFIG.DEFAULT_BACKGROUND_COLOR
            print(f"Warning MAP_UTILS: Invalid background_color format in JSON, using default. Got: {bg_color_data}")


        editor_state.placed_objects = []
        loaded_placed_objects = data.get("placed_objects", [])
        print(f"DEBUG MAP_UTILS: Loading {len(loaded_placed_objects)} objects from JSON.")
        for i, obj_data in enumerate(loaded_placed_objects):
            asset_key = obj_data.get("asset_editor_key")
            game_type_id_from_json = obj_data.get("game_type_id") # Get game_type_id from JSON
            world_x = obj_data.get("world_x")
            world_y = obj_data.get("world_y")

            if not all([asset_key, game_type_id_from_json is not None, world_x is not None, world_y is not None]):
                print(f"Warning MAP_UTILS: Loaded object at index {i} has missing core data, skipping: {obj_data}")
                continue

            if asset_key in ED_CONFIG.EDITOR_PALETTE_ASSETS:
                # It's generally safer to trust the game_type_id from the JSON file if it exists,
                # as the config might change. However, for consistency if asset_key is primary link:
                # game_type_id_from_config = ED_CONFIG.EDITOR_PALETTE_ASSETS[asset_key].get("game_type_id", asset_key)
                editor_state.placed_objects.append({
                    "asset_editor_key": asset_key,
                    "world_x": world_x,
                    "world_y": world_y,
                    "game_type_id": game_type_id_from_json # Use the one from the file
                })
            else:
                print(f"Warning MAP_UTILS: Asset key '{asset_key}' from loaded object (JSON type: '{game_type_id_from_json}') "
                      f"not found in current ED_CONFIG.EDITOR_PALETTE_ASSETS. Object at ({world_x},{world_y}) skipped.")

        editor_state.camera_offset_x = data.get("camera_offset_x", 0)
        editor_state.camera_offset_y = data.get("camera_offset_y", 0)
        editor_state.show_grid = data.get("show_grid", True)
        
        py_filename = editor_state.map_name_for_function + ED_CONFIG.GAME_LEVEL_FILE_EXTENSION
        editor_state.current_map_filename = os.path.join(ED_CONFIG.MAPS_DIRECTORY, py_filename)
        
        editor_state.recreate_map_content_surface()
        editor_state.unsaved_changes = False # Freshly loaded map has no unsaved changes
        
        success_msg = f"Map '{editor_state.map_name_for_function}' loaded from {os.path.basename(json_filepath)}"
        print(f"DEBUG MAP_UTILS: {success_msg}. unsaved_changes={editor_state.unsaved_changes}, current_map_filename='{editor_state.current_map_filename}'")
        editor_state.set_status_message(success_msg)
        return True
        
    except json.JSONDecodeError as e:
        error_msg = f"Error: Could not decode JSON from map file '{json_filepath}': {e}"
    except Exception as e:
        error_msg = f"Unexpected error loading map from JSON '{json_filepath}': {e}"
        traceback.print_exc()
    
    print(f"ERROR MAP_UTILS: {error_msg}")
    editor_state.set_status_message(error_msg, 4)
    return False

def export_map_to_game_python_script(editor_state: EditorState) -> bool:
    """
    Generates and saves the Python level script compatible with the main game.
    Returns True on success, False on failure.
    """
    print(f"DEBUG MAP_UTILS: export_map_to_game_python_script called. Map func name: '{editor_state.map_name_for_function}'")
    
    if not editor_state.map_name_for_function or editor_state.map_name_for_function == "untitled_map":
        msg = "Map name not set or is 'untitled_map'. Cannot export .py."
        editor_state.set_status_message(f"Error: {msg}", 3)
        print(f"ERROR MAP_UTILS: {msg}")
        return False
        
    if not editor_state.current_map_filename: # Should be set by init_new_map or load_map
        py_filename = editor_state.map_name_for_function + ED_CONFIG.GAME_LEVEL_FILE_EXTENSION
        editor_state.current_map_filename = os.path.join(ED_CONFIG.MAPS_DIRECTORY, py_filename)
        print(f"Warning MAP_UTILS: current_map_filename was not set, derived as '{editor_state.current_map_filename}' for export.")

    if not ensure_maps_directory_exists():
        msg = "Could not create or access maps directory for .py export."
        editor_state.set_status_message(f"Error: {msg}", 3)
        print(f"ERROR MAP_UTILS: {msg} PY export aborted.")
        return False

    function_name = f"load_map_{editor_state.map_name_for_function}"
    print(f"DEBUG MAP_UTILS: Exporting to function '{function_name}' in file '{editor_state.current_map_filename}'")

    platforms_code_lines = []
    ladders_code_lines = [] # Ensure ladders are handled if you add them
    hazards_code_lines = []
    enemy_spawns_code_lines = []
    collectible_spawns_code_lines = []

    # Default player spawn - will be overridden if a player spawn object is placed
    default_spawn_tile_x = editor_state.map_width_tiles // 2
    default_spawn_tile_y = editor_state.map_height_tiles // 2 
    default_spawn_world_x = default_spawn_tile_x * editor_state.grid_size + editor_state.grid_size // 2 # Mid of tile
    default_spawn_world_y = (default_spawn_tile_y + 1) * editor_state.grid_size # Bottom of tile
    player1_spawn_str = f"player1_spawn = ({default_spawn_world_x}, {default_spawn_world_y}) # Default P1 Spawn (midbottom of tile {default_spawn_tile_x},{default_spawn_tile_y})"

    all_placed_world_rects_for_bounds: List[pygame.Rect] = []
    print(f"DEBUG MAP_UTILS: Processing {len(editor_state.placed_objects)} objects for .py export.")

    for i, obj_data in enumerate(editor_state.placed_objects):
        game_type_id = obj_data.get("game_type_id")
        world_x = obj_data.get("world_x")
        world_y = obj_data.get("world_y")
        asset_editor_key = obj_data.get("asset_editor_key")

        if not all([game_type_id, world_x is not None, world_y is not None, asset_editor_key]):
            print(f"Warning MAP_UTILS: Export - Object at index {i} missing data, skipping: {obj_data}")
            continue
        
        asset_config = ED_CONFIG.EDITOR_PALETTE_ASSETS.get(asset_editor_key)
        
        # Determine object size for bounds calculation and export
        obj_width_px = editor_state.grid_size # Default
        obj_height_px = editor_state.grid_size # Default

        if asset_config:
            if "surface_params" in asset_config: # For simple colored rects
                obj_width_px = asset_config["surface_params"][0]
                obj_height_px = asset_config["surface_params"][1]
            elif asset_editor_key in editor_state.assets_palette: # For image-based assets
                palette_asset_data = editor_state.assets_palette[asset_editor_key]
                original_size = palette_asset_data.get("original_size_pixels")
                if original_size and len(original_size) == 2:
                    obj_width_px, obj_height_px = original_size
                else:
                    print(f"Warning MAP_UTILS: Asset '{asset_editor_key}' missing valid 'original_size_pixels' in assets_palette. Using grid_size for export bounds.")
        else:
             print(f"Warning MAP_UTILS: Asset key '{asset_editor_key}' for object (type '{game_type_id}') not in ED_CONFIG. Using grid_size for export bounds.")
        
        current_obj_rect = pygame.Rect(world_x, world_y, obj_width_px, obj_height_px)
        all_placed_world_rects_for_bounds.append(current_obj_rect)

        # --- Object type to code generation ---
        if game_type_id == "platform_wall_gray":
            platforms_code_lines.append(f"    platforms.add(Platform({world_x}, {world_y}, {obj_width_px}, {obj_height_px}, C.GRAY, platform_type='wall'))")
        elif game_type_id == "platform_ledge_green":
            platforms_code_lines.append(f"    platforms.add(Platform({world_x}, {world_y}, {obj_width_px}, {obj_height_px}, C.DARK_GREEN, platform_type='ledge'))")
        elif game_type_id == "hazard_lava": # Assuming Lava takes full tile size (or its original pixel size)
            hazards_code_lines.append(f"    hazards.add(Lava({world_x}, {world_y}, {obj_width_px}, {obj_height_px}, C.ORANGE_RED))")
        elif game_type_id == "player1_spawn":
            # Player spawn point is usually midbottom of the visual representation
            spawn_mid_x = world_x + obj_width_px // 2
            spawn_bottom_y = world_y + obj_height_px 
            player1_spawn_str = f"player1_spawn = ({spawn_mid_x}, {spawn_bottom_y})"
        elif "enemy" in game_type_id: # Generic enemy handling
            specific_enemy_color_id = game_type_id.split('_')[-1] if '_' in game_type_id else "unknown_enemy_color"
            # Enemy spawn point is usually midbottom
            spawn_mid_x = world_x + obj_width_px // 2
            spawn_bottom_y = world_y + obj_height_px
            enemy_spawns_code_lines.append(f"    enemy_spawns_data.append({{'pos': ({spawn_mid_x}, {spawn_bottom_y}), 'patrol': None, 'enemy_color_id': '{specific_enemy_color_id}'}})")
        elif game_type_id == "chest":
            # Chest spawn point is usually midbottom
            chest_spawn_x_midbottom = world_x + obj_width_px // 2
            chest_spawn_y_midbottom = world_y + obj_height_px
            collectible_spawns_code_lines.append(f"    collectible_spawns_data.append({{'type': 'chest', 'pos': ({chest_spawn_x_midbottom}, {chest_spawn_y_midbottom})}})")
        # Add other object types here (e.g., ladders)
        # elif game_type_id == "ladder":
        #     ladders_code_lines.append(f"    ladders.add(Ladder({world_x}, {world_y}, {obj_width_px}, {obj_height_px}))")
        else:
            print(f"Warning MAP_UTILS: Unknown game_type_id '{game_type_id}' for object at ({world_x},{world_y}). Not exported to .py.")


    platforms_code_str = "\n".join(platforms_code_lines)
    ladders_code_str = "\n".join(ladders_code_lines)
    hazards_code_str = "\n".join(hazards_code_lines)
    enemy_spawns_code_str = "\n".join(enemy_spawns_code_lines)
    collectible_spawns_code_str = "\n".join(collectible_spawns_code_lines)
    print(f"DEBUG MAP_UTILS: Generated code lines - Platforms: {len(platforms_code_lines)}, Ladders: {len(ladders_code_lines)}, etc.")

    # --- Calculate Map Boundaries for Game ---
    if not all_placed_world_rects_for_bounds: # Empty map
        print("DEBUG MAP_UTILS: No objects placed, using default map dimensions for export boundaries.")
        map_min_x_content = 0
        map_max_x_content = editor_state.get_map_pixel_width()
        map_min_y_content = 0
        map_max_y_content = editor_state.get_map_pixel_height()
    else:
        map_min_x_content = min(r.left for r in all_placed_world_rects_for_bounds)
        map_max_x_content = max(r.right for r in all_placed_world_rects_for_bounds)
        map_min_y_content = min(r.top for r in all_placed_world_rects_for_bounds)
        map_max_y_content = max(r.bottom for r in all_placed_world_rects_for_bounds)
    
    # Add padding around content for camera movement and player safety
    padding_px = C.TILE_SIZE * 2 
    game_map_total_width_pixels = int(max(ED_CONFIG.EDITOR_SCREEN_INITIAL_WIDTH, (map_max_x_content - map_min_x_content) + 2 * padding_px))
    # Ensure total width covers at least the editor's view of the map or the content width + padding

    # Absolute Y coordinates for the game camera system and boundaries
    game_level_min_y_absolute = int(map_min_y_content - padding_px) 
    game_level_max_y_absolute = int(map_max_y_content + padding_px) 
    
    # Reference for ground, typically where player stands or bottom of lowest platform
    game_main_ground_y_reference = int(map_max_y_content) 
    game_main_ground_height_reference = int(C.TILE_SIZE) # Typical tile height

    if game_level_min_y_absolute >= game_level_max_y_absolute :
        print(f"Warning MAP_UTILS: Calculated min_y_abs ({game_level_min_y_absolute}) >= max_y_abs ({game_level_max_y_absolute}) for map '{editor_state.map_name_for_function}'. Adjusting max_y_abs.")
        game_level_max_y_absolute = game_level_min_y_absolute + C.TILE_SIZE * 5 # Ensure some height

    print(f"DEBUG MAP_UTILS: Export boundaries - TotalWidthPx: {game_map_total_width_pixels}, MinYAbs: {game_level_min_y_absolute}, MaxYAbs: {game_level_max_y_absolute}")

    script_content = f"""# Level: {editor_state.map_name_for_function}
# Generated by Platformer Level Editor on {pygame.time.get_ticks()}
import pygame
from tiles import Platform, Ladder, Lava # Ensure all used tile types are imported by game
import constants as C

# Optional: Define level-specific background color if your game supports it
LEVEL_SPECIFIC_BACKGROUND_COLOR = {editor_state.background_color}

def {function_name}(initial_screen_width, initial_screen_height):
    \"\"\"
    Loads the '{editor_state.map_name_for_function}' level.
    Generated by the level editor.
    \"\"\"
    print(f"Loading map: {function_name}...") # Game-side log
    platforms = pygame.sprite.Group()
    ladders = pygame.sprite.Group()
    hazards = pygame.sprite.Group()
    enemy_spawns_data = []
    collectible_spawns_data = []

    {player1_spawn_str}
    
    # --- Placed Objects ---
{platforms_code_str if platforms_code_str else "    # No platforms placed."}
{ladders_code_str if ladders_code_str else "    # No ladders placed."}
{hazards_code_str if hazards_code_str else "    # No hazards placed."}
{enemy_spawns_code_str if enemy_spawns_code_str else "    # No enemy spawns defined."}
{collectible_spawns_code_str if collectible_spawns_code_str else "    # No collectible spawns defined."}

    # --- Level Dimensions for Game Camera & Boundaries ---
    map_total_width_pixels = {game_map_total_width_pixels}
    level_min_y_absolute = {game_level_min_y_absolute} # Top-most Y coordinate for camera/content
    level_max_y_absolute = {game_level_max_y_absolute} # Bottom-most Y coordinate for camera/content (e.g., death plane below this)
    
    main_ground_y_reference = {game_main_ground_y_reference} # Y-value of the main 'floor' surface
    main_ground_height_reference = {game_main_ground_height_reference} # Height of typical ground tiles

    # --- Auto-generated Boundary Walls (Invisible in game unless styled) ---
    # These ensure entities cannot go outside the defined level space.
    _boundary_thickness = C.TILE_SIZE * 2 # Make them thick enough
    _boundary_wall_height = level_max_y_absolute - level_min_y_absolute + (2 * _boundary_thickness) # Span slightly beyond min/max_y

    # Top boundary (ceiling) - place its bottom edge at level_min_y_absolute
    platforms.add(Platform(0, level_min_y_absolute - _boundary_thickness, map_total_width_pixels, _boundary_thickness, C.DARK_GRAY, platform_type="boundary_wall_top"))
    # Bottom boundary (floor/kill plane) - place its top edge at level_max_y_absolute
    platforms.add(Platform(0, level_max_y_absolute, map_total_width_pixels, _boundary_thickness, C.DARK_GRAY, platform_type="boundary_wall_bottom"))
    # Left boundary wall
    platforms.add(Platform(-_boundary_thickness, level_min_y_absolute - _boundary_thickness, _boundary_thickness, _boundary_wall_height, C.DARK_GRAY, platform_type="boundary_wall_left"))
    # Right boundary wall
    platforms.add(Platform(map_total_width_pixels, level_min_y_absolute - _boundary_thickness, _boundary_thickness, _boundary_wall_height, C.DARK_GRAY, platform_type="boundary_wall_right"))

    print(f"Map '{function_name}' loaded with: {{len(platforms)}} platforms, {{len(ladders)}} ladders, {{len(hazards)}} hazards.") # Game-side log
    return (platforms, ladders, hazards, enemy_spawns_data, collectible_spawns_data,
            player1_spawn,
            map_total_width_pixels, level_min_y_absolute, level_max_y_absolute,
            main_ground_y_reference, main_ground_height_reference,
            LEVEL_SPECIFIC_BACKGROUND_COLOR) # Return background color
"""
    py_filepath = editor_state.current_map_filename 
    print(f"DEBUG MAP_UTILS: Final .py script content to write to '{py_filepath}':\n{script_content[:500]}...") # Log start of content

    try:
        with open(py_filepath, "w") as f:
            f.write(script_content)
        success_msg = f"Map exported to game script: {os.path.basename(py_filepath)}"
        print(f"DEBUG MAP_UTILS: {success_msg}")
        editor_state.set_status_message(success_msg)
        editor_state.unsaved_changes = False # Crucial: set unsaved to false AFTER successful .py export
        print(f"DEBUG MAP_UTILS: unsaved_changes set to False after .py export.")
        return True
    except IOError as e:
        error_msg = f"IOError exporting map to .py '{py_filepath}': {e}"
    except Exception as e:
        error_msg = f"Unexpected error during .py export to '{py_filepath}': {e}"
        traceback.print_exc()
        
    print(f"ERROR MAP_UTILS: {error_msg}")
    editor_state.set_status_message(error_msg, 4)
    return False

########## START OF FILE: editor\editor_state.py ##########

# editor_state.py
# -*- coding: utf-8 -*-
"""
## version 1.0.0.6 (Added painting/erasing state attributes)
Defines the EditorState class, which holds all the dynamic state
and data for the level editor.
"""

import pygame
from typing import Optional, Dict, List, Tuple, Any, Callable 
import traceback 

import editor_config as ED_CONFIG

class EditorState:
    """
    Manages the current state of the level editor, including map data,
    UI selections, and editor modes.
    """
    def __init__(self):
        print("DEBUG STATE: Initializing EditorState...")
        # --- Map Data & File ---
        self.current_map_data: Dict[str, Any] = {}
        self.current_map_filename: Optional[str] = None
        self.map_name_for_function: str = "untitled_map"

        self.map_width_tiles: int = ED_CONFIG.DEFAULT_MAP_WIDTH_TILES
        self.map_height_tiles: int = ED_CONFIG.DEFAULT_MAP_HEIGHT_TILES
        self.grid_size: int = ED_CONFIG.DEFAULT_GRID_SIZE
        self.background_color: Tuple[int, int, int] = ED_CONFIG.DEFAULT_BACKGROUND_COLOR

        self.map_content_surface: Optional[pygame.Surface] = None

        # --- Placed Objects ---
        self.placed_objects: List[Dict[str, Any]] = []

        # --- Asset Palette & Selection ---
        self.assets_palette: Dict[str, Dict[str, Any]] = {}
        self._selected_asset_editor_key: Optional[str] = None
        self.selected_asset_image_for_cursor: Optional[pygame.Surface] = None
        self.asset_palette_scroll_y: int = 0
        self.total_asset_palette_content_height: int = 0

        # --- Map View & Camera ---
        self.camera_offset_x: int = 0
        self.camera_offset_y: int = 0
        self.show_grid: bool = True

        # --- Object Interaction ---
        self.dragging_object_index: Optional[int] = None
        self.drag_start_mouse_map_x: int = 0
        self.drag_start_mouse_map_y: int = 0
        self.drag_object_original_x: int = 0
        self.drag_object_original_y: int = 0

        # --- Tile Painting/Erasing State --- # ENSURE THESE ARE PRESENT
        self.is_painting_tiles: bool = False
        self.last_painted_tile_coords: Optional[Tuple[int, int]] = None
        self.is_erasing_tiles: bool = False 
        self.last_erased_tile_coords: Optional[Tuple[int, int]] = None
        # --- End Tile Painting/Erasing State ---

        # --- UI State ---
        self._current_editor_mode: str = "menu"
        self.unsaved_changes: bool = False
        self.hovered_tooltip_text: Optional[str] = None
        self.hovered_tooltip_pos: Optional[Tuple[int, int]] = None
        self.ui_elements_rects: Dict[str, Any] = {} 

        # --- Dialogs and Input Fields ---
        self._active_dialog_type: Optional[str] = None
        self.dialog_input_text: str = ""
        self.dialog_prompt_message: str = ""
        self.dialog_input_default: str = ""
        self.dialog_callback_confirm: Optional[Callable[..., None]] = None
        self.dialog_callback_cancel: Optional[Callable[[], None]] = None
        self.dialog_rect: Optional[pygame.Rect] = None 

        self.color_picker_rects: Dict[str, pygame.Rect] = {} 
        self.dialog_file_list: List[str] = []
        self.dialog_file_scroll_y: int = 0
        self.dialog_selected_file_index: int = -1
        self.is_dragging_scrollbar: bool = False
        self.scrollbar_drag_mouse_offset_y: int = 0

        self.map_name_for_function_input: str = "" 

        # --- Status Messages ---
        self.status_message: Optional[str] = None
        self.status_message_timer: float = 0.0
        self.status_message_duration: float = 3.0 

        # --- Final Initialization Steps ---
        self.recreate_map_content_surface() 
        print("DEBUG STATE: EditorState initialization complete.")

    @property
    def current_editor_mode(self) -> str:
        return self._current_editor_mode

    @current_editor_mode.setter
    def current_editor_mode(self, value: str):
        if self._current_editor_mode != value:
            print(f"DEBUG STATE: current_editor_mode changed from '{self._current_editor_mode}' to '{value}'")
            self._current_editor_mode = value

    @property
    def active_dialog_type(self) -> Optional[str]:
        return self._active_dialog_type

    @active_dialog_type.setter
    def active_dialog_type(self, value: Optional[str]):
        if self._active_dialog_type != value:
            old_dialog_type = self._active_dialog_type 
            print(f"DEBUG STATE: active_dialog_type changed from '{old_dialog_type}' to '{value}'")
            self._active_dialog_type = value
            if value is None or (old_dialog_type is not None and old_dialog_type != value):
                keys_to_remove = []
                if old_dialog_type == "file_load":
                    keys_to_remove.extend(['dialog_file_item_rects', 'file_dialog_scrollbar_handle',
                                           'file_dialog_scrollbar_area', 'dialog_file_load_ok', 'dialog_file_load_cancel'])
                elif old_dialog_type == "color_picker": self.color_picker_rects.clear()
                removed_count = 0
                for key in keys_to_remove:
                    if key in self.ui_elements_rects:
                        try: del self.ui_elements_rects[key]; removed_count +=1
                        except KeyError: pass 
                if removed_count > 0: print(f"DEBUG STATE: Cleared {removed_count} UI rect(s) for dialog '{old_dialog_type}'.")
            if value is None: self.dialog_rect = None

    @property
    def selected_asset_editor_key(self) -> Optional[str]:
        return self._selected_asset_editor_key

    @selected_asset_editor_key.setter
    def selected_asset_editor_key(self, value: Optional[str]):
        if self._selected_asset_editor_key != value:
            print(f"DEBUG STATE: selected_asset_editor_key changed from '{self._selected_asset_editor_key}' to '{value}'")
            self._selected_asset_editor_key = value

    def recreate_map_content_surface(self):
        map_pixel_width = self.map_width_tiles * self.grid_size
        map_pixel_height = self.map_height_tiles * self.grid_size
        safe_width, safe_height = max(1, map_pixel_width), max(1, map_pixel_height)
        try:
            self.map_content_surface = pygame.Surface((safe_width, safe_height))
            print(f"DEBUG STATE: Recreated map_content_surface: {safe_width}x{safe_height}")
        except pygame.error as e:
            print(f"ERROR STATE: Failed to create map_content_surface: {e}"); traceback.print_exc()
            try: self.map_content_surface = pygame.Surface((ED_CONFIG.DEFAULT_GRID_SIZE, ED_CONFIG.DEFAULT_GRID_SIZE))
            except Exception as e_fallback: self.map_content_surface = None; print(f"CRITICAL STATE: Fallback surface failed: {e_fallback}")

    def get_map_pixel_width(self) -> int: return self.map_width_tiles * self.grid_size
    def get_map_pixel_height(self) -> int: return self.map_height_tiles * self.grid_size
    def set_status_message(self, message: str, duration: float = 3.0):
        self.status_message, self.status_message_duration, self.status_message_timer = message, duration, duration
        print(f"STATUS MSG: {message} (duration: {duration:.1f}s)")

    def update_status_message(self, dt: float):
        if self.status_message and self.status_message_timer > 0:
            self.status_message_timer -= dt
            if self.status_message_timer <= 0: self.status_message, self.status_message_timer = None, 0.0

    def reset_map_context(self):
        print("DEBUG STATE: reset_map_context called.")
        self.map_name_for_function = "untitled_map"; self.current_map_filename = None
        self.placed_objects = []; self.map_width_tiles = ED_CONFIG.DEFAULT_MAP_WIDTH_TILES
        self.map_height_tiles = ED_CONFIG.DEFAULT_MAP_HEIGHT_TILES; self.background_color = ED_CONFIG.DEFAULT_BACKGROUND_COLOR
        self.camera_offset_x, self.camera_offset_y = 0, 0; self.unsaved_changes = False
        self.selected_asset_editor_key, self.selected_asset_image_for_cursor = None, None
        self.is_painting_tiles, self.last_painted_tile_coords = False, None # Reset painting state
        self.is_erasing_tiles, self.last_erased_tile_coords = False, None   # Reset erasing state
        # self.recreate_map_content_surface() # Typically called by init_new_map or load_map
        print(f"DEBUG STATE: Map context reset. Map name: '{self.map_name_for_function}'.")

########## START OF FILE: editor\editor_ui.py ##########

# editor_ui.py
# -*- coding: utf-8 -*-
"""
## version 1.0.0.6 (Added more debug prints for dialog start and drawing)
Pygame-based UI functions for the Level Editor.
Includes buttons, input dialogs, color pickers, and tooltips.
"""
import pygame
import os
from typing import Optional, Dict, Tuple, Any, Callable, List
import traceback # ADDED for more detailed error reporting

# --- Add parent directory to sys.path for editor_config & editor_state if this file is run standalone (unlikely here) ---
# This is more robustly handled in the main editor.py script.
# current_script_path_ui = os.path.dirname(os.path.abspath(__file__))
# parent_directory_ui = os.path.dirname(current_script_path_ui) # This should be 'editor'
# project_root_ui = os.path.dirname(parent_directory_ui) # This should be 'Platformer'
# if project_root_ui not in sys.path:
#     sys.path.insert(0, project_root_ui)
# if parent_directory_ui not in sys.path: # If editor_config is in 'editor' not project root
#    sys.path.insert(0, parent_directory_ui)


import editor_config as ED_CONFIG
from editor_state import EditorState
# Assuming constants.py (referenced by ED_CONFIG.C) is accessible from the project root.
# This setup relies on editor.py correctly setting up sys.path.

# --- UI Drawing Helpers ---

def draw_button(surface: pygame.Surface,
                rect: pygame.Rect,
                text: str,
                font: Optional[pygame.font.Font],
                mouse_pos: Tuple[int, int],
                text_color: Tuple[int, int, int] = ED_CONFIG.BUTTON_TEXT_COLOR,
                button_color_normal: Tuple[int, int, int] = ED_CONFIG.BUTTON_COLOR_NORMAL,
                button_color_hover: Tuple[int, int, int] = ED_CONFIG.BUTTON_COLOR_HOVER,
                border_color: Tuple[int, int, int] = ED_CONFIG.BUTTON_COLOR_BORDER,
                border_width: int = ED_CONFIG.BUTTON_BORDER_WIDTH,
                is_active: bool = True) -> bool:
    # print(f"DEBUG UI_DRAW: draw_button called for '{text}' at {rect}, active={is_active}") # Can be verbose
    is_hovered = False
    if is_active and rect.collidepoint(mouse_pos):
        is_hovered = True

    current_button_color = button_color_normal
    current_text_color = text_color

    if not is_active:
        current_button_color = tuple(int(c * 0.67) for c in button_color_normal) # Darker shade
        current_text_color = tuple(int(c * 0.67) for c in text_color)
    elif is_hovered:
        current_button_color = button_color_hover

    try:
        pygame.draw.rect(surface, current_button_color, rect)
        if border_width > 0:
            pygame.draw.rect(surface, border_color, rect, border_width)
        
        if font:
            text_surf = font.render(text, True, current_text_color)
            text_rect = text_surf.get_rect(center=rect.center)
            surface.blit(text_surf, text_rect)
        else:
            print(f"Warning UI_DRAW: draw_button called with no font for text '{text}'")
    except Exception as e:
        print(f"ERROR UI_DRAW: Exception in draw_button for '{text}': {e}")
        traceback.print_exc()
        
    return is_hovered

def draw_tooltip(surface: pygame.Surface,
                 editor_state: EditorState,
                 font: Optional[pygame.font.Font]):
    if editor_state.hovered_tooltip_text and editor_state.hovered_tooltip_pos and font:
        # print(f"DEBUG UI_DRAW: Drawing tooltip: '{editor_state.hovered_tooltip_text}' at {editor_state.hovered_tooltip_pos}") # Verbose
        try:
            text_surf = font.render(editor_state.hovered_tooltip_text, True, ED_CONFIG.TOOLTIP_TEXT_COLOR)
            text_rect = text_surf.get_rect(
                topleft=(editor_state.hovered_tooltip_pos[0] + 15,
                         editor_state.hovered_tooltip_pos[1] + 15)
            )
            bg_rect = text_rect.inflate(ED_CONFIG.TOOLTIP_PADDING * 2, ED_CONFIG.TOOLTIP_PADDING * 2)

            bg_rect.clamp_ip(surface.get_rect()) # Ensure tooltip stays on screen
            text_rect.clamp_ip(bg_rect.inflate(-ED_CONFIG.TOOLTIP_PADDING, -ED_CONFIG.TOOLTIP_PADDING)) # And text within tooltip bg

            pygame.draw.rect(surface, ED_CONFIG.TOOLTIP_BG_COLOR, bg_rect, border_radius=3)
            pygame.draw.rect(surface, ED_CONFIG.BUTTON_COLOR_BORDER, bg_rect, 1, border_radius=3)
            surface.blit(text_surf, text_rect)
        except Exception as e:
            print(f"ERROR UI_DRAW: Exception in draw_tooltip for '{editor_state.hovered_tooltip_text}': {e}")
            traceback.print_exc()

def draw_status_message(surface: pygame.Surface, editor_state: EditorState, font: Optional[pygame.font.Font]):
    if editor_state.status_message and font:
        # print(f"DEBUG UI_DRAW: Drawing status message: '{editor_state.status_message}'") # Verbose
        try:
            message_surf = font.render(editor_state.status_message, True, ED_CONFIG.C.YELLOW)
            message_rect = message_surf.get_rect(centerx=surface.get_width() // 2,
                                                  bottom=surface.get_height() - 10)
            bg_padding = 5
            bg_rect = message_rect.inflate(bg_padding * 2, bg_padding * 2)
            bg_rect.clamp_ip(surface.get_rect())
            message_rect.clamp_ip(bg_rect)

            s = pygame.Surface(bg_rect.size, pygame.SRCALPHA)
            s.fill((50, 50, 50, 180)) # Semi-transparent dark background
            surface.blit(s, bg_rect.topleft)
            surface.blit(message_surf, message_rect)
        except Exception as e:
            print(f"ERROR UI_DRAW: Exception in draw_status_message for '{editor_state.status_message}': {e}")
            traceback.print_exc()

# --- Pygame-based Dialogs ---

def start_text_input_dialog(editor_state: EditorState,
                            prompt: str,
                            default_text: str = "",
                            on_confirm: Optional[Callable[[str], None]] = None,
                            on_cancel: Optional[Callable[[], None]] = None):
    print(f"DEBUG UI_DIALOG: start_text_input_dialog. Prompt: '{prompt}', Default: '{default_text}', HasConfirm: {on_confirm is not None}, HasCancel: {on_cancel is not None}")
    editor_state.active_dialog_type = "text_input"
    editor_state.dialog_prompt_message = prompt
    editor_state.dialog_input_text = default_text
    editor_state.dialog_input_default = default_text # Store original default
    editor_state.dialog_callback_confirm = on_confirm
    editor_state.dialog_callback_cancel = on_cancel
    editor_state.dialog_rect = None # Will be set by draw_active_dialog

def start_color_picker_dialog(editor_state: EditorState,
                              on_confirm: Optional[Callable[[Tuple[int,int,int]], None]] = None,
                              on_cancel: Optional[Callable[[], None]] = None):
    print(f"DEBUG UI_DIALOG: start_color_picker_dialog. HasConfirm: {on_confirm is not None}, HasCancel: {on_cancel is not None}")
    editor_state.active_dialog_type = "color_picker"
    editor_state.dialog_prompt_message = "Select Background Color (Esc to Cancel)"
    editor_state.color_picker_rects.clear() 
    
    cols = ED_CONFIG.COLOR_PICKER_COLS
    button_size = ED_CONFIG.COLOR_PICKER_BUTTON_SIZE
    padding = ED_CONFIG.COLOR_PICKER_PADDING
    
    start_x_in_dialog = padding * 2 
    current_y_in_dialog = 50 
    current_x_in_dialog = start_x_in_dialog
    idx = 0
    for name in ED_CONFIG.COLOR_PICKER_PRESETS.keys():
        rect = pygame.Rect(current_x_in_dialog, current_y_in_dialog, button_size, button_size)
        editor_state.color_picker_rects[name] = rect 
        current_x_in_dialog += button_size + padding
        idx += 1
        if idx % cols == 0:
            current_x_in_dialog = start_x_in_dialog
            current_y_in_dialog += button_size + padding
            
    editor_state.dialog_callback_confirm = on_confirm
    editor_state.dialog_callback_cancel = on_cancel
    editor_state.dialog_rect = None

def start_file_load_dialog(editor_state: EditorState,
                           on_confirm: Optional[Callable[[str], None]] = None,
                           on_cancel: Optional[Callable[[], None]] = None,
                           initial_path: str = ED_CONFIG.MAPS_DIRECTORY,
                           file_extension: str = ED_CONFIG.LEVEL_EDITOR_SAVE_FORMAT_EXTENSION):
    print(f"DEBUG UI_DIALOG: start_file_load_dialog. Path: '{initial_path}', Ext: '{file_extension}', HasConfirm: {on_confirm is not None}, HasCancel: {on_cancel is not None}")
    editor_state.active_dialog_type = "file_load"
    editor_state.dialog_prompt_message = f"Select Map to Load (from ./{initial_path})"
    editor_state.dialog_input_text = "" 
    editor_state.dialog_file_list = []
    editor_state.dialog_file_scroll_y = 0
    editor_state.dialog_selected_file_index = -1 
    editor_state.dialog_rect = None

    # Ensure ui_elements_rects key for file items exists and is cleared
    if 'dialog_file_item_rects' not in editor_state.ui_elements_rects:
        editor_state.ui_elements_rects['dialog_file_item_rects'] = []
    else:
        editor_state.ui_elements_rects['dialog_file_item_rects'].clear()

    if not os.path.exists(initial_path):
        try:
            os.makedirs(initial_path)
            print(f"DEBUG UI_DIALOG: Created maps directory at '{initial_path}' during file_load_dialog start.")
            editor_state.set_status_message(f"Created maps dir '{initial_path}'. No files yet.", 2)
        except OSError as e:
            err_msg = f"Error creating dir '{initial_path}': {e}"
            editor_state.set_status_message(err_msg, 3)
            print(f"ERROR UI_DIALOG: {err_msg}")
            if on_cancel: on_cancel()
            editor_state.active_dialog_type = None # Critical error, abort dialog
            return

    try:
        for item in os.listdir(initial_path):
            if item.endswith(file_extension) and os.path.isfile(os.path.join(initial_path, item)): # Check if it's a file
                editor_state.dialog_file_list.append(item)
        editor_state.dialog_file_list.sort()
        print(f"DEBUG UI_DIALOG: Found files in '{initial_path}': {editor_state.dialog_file_list}")
    except OSError as e:
        err_msg = f"Error listing files in '{initial_path}': {e}"
        editor_state.set_status_message(err_msg, 3)
        print(f"ERROR UI_DIALOG: {err_msg}")
        if on_cancel: on_cancel()
        editor_state.active_dialog_type = None # Critical error, abort dialog
        return
    
    if not editor_state.dialog_file_list:
        editor_state.set_status_message(f"No '{file_extension}' files found in ./{initial_path}", 2.5)

    editor_state.dialog_callback_confirm = on_confirm
    editor_state.dialog_callback_cancel = on_cancel


def draw_active_dialog(surface: pygame.Surface, editor_state: EditorState, fonts: Dict[str, Optional[pygame.font.Font]]):
    if not editor_state.active_dialog_type:
        return
    
    # print(f"DEBUG UI_DRAW_DIALOG: Drawing dialog type '{editor_state.active_dialog_type}'") # Can be verbose

    try:
        screen_center_x, screen_center_y = surface.get_rect().center
        dialog_width, dialog_height = 450, 350 # Default size

        if editor_state.active_dialog_type == "text_input":
            dialog_width, dialog_height = 400, 200
        elif editor_state.active_dialog_type == "color_picker":
            num_colors = len(ED_CONFIG.COLOR_PICKER_PRESETS)
            cols = ED_CONFIG.COLOR_PICKER_COLS
            rows = (num_colors + cols - 1) // cols
            content_w = cols * ED_CONFIG.COLOR_PICKER_BUTTON_SIZE + (cols -1 if cols > 0 else 0) * ED_CONFIG.COLOR_PICKER_PADDING
            content_h = rows * ED_CONFIG.COLOR_PICKER_BUTTON_SIZE + (rows -1 if rows > 0 else 0) * ED_CONFIG.COLOR_PICKER_PADDING
            dialog_width = max(300, content_w + ED_CONFIG.COLOR_PICKER_PADDING * 4) # Padding around content
            title_space = 60 # Approx space for title and margin
            dialog_height = max(200, content_h + title_space + ED_CONFIG.COLOR_PICKER_PADDING * 2) 
        elif editor_state.active_dialog_type == "file_load":
            dialog_width, dialog_height = 400, 350

        # Calculate dialog_rect and store it in editor_state (critical for event handling)
        current_dialog_rect = pygame.Rect(0, 0, dialog_width, dialog_height)
        current_dialog_rect.center = screen_center_x, screen_center_y
        editor_state.dialog_rect = current_dialog_rect # Update state

        pygame.draw.rect(surface, ED_CONFIG.DIALOG_BG_COLOR, current_dialog_rect, border_radius=5)
        pygame.draw.rect(surface, ED_CONFIG.C.BLACK, current_dialog_rect, 2, border_radius=5)

        prompt_font = fonts.get("medium") or ED_CONFIG.FONT_CONFIG.get("medium")
        if prompt_font and editor_state.dialog_prompt_message:
            prompt_surf = prompt_font.render(editor_state.dialog_prompt_message, True, ED_CONFIG.DIALOG_PROMPT_COLOR)
            prompt_draw_rect = prompt_surf.get_rect(midtop=(current_dialog_rect.centerx, current_dialog_rect.top + 15))
            surface.blit(prompt_surf, prompt_draw_rect)

        # --- Specific Dialog Content ---
        if editor_state.active_dialog_type == "text_input":
            _draw_text_input_content(surface, editor_state, current_dialog_rect, fonts)
        elif editor_state.active_dialog_type == "color_picker":
            _draw_color_picker_content(surface, editor_state, current_dialog_rect, fonts)
        elif editor_state.active_dialog_type == "file_load":
            _draw_file_load_content(surface, editor_state, current_dialog_rect, fonts)

    except Exception as e:
        print(f"ERROR UI_DRAW_DIALOG: Exception in draw_active_dialog for type '{editor_state.active_dialog_type}': {e}")
        traceback.print_exc()
        # Optionally, draw an error message on the dialog itself
        error_font = fonts.get("small")
        if error_font and editor_state.dialog_rect:
            err_surf = error_font.render(f"Dialog Error! See console.", True, ED_CONFIG.C.RED)
            surface.blit(err_surf, err_surf.get_rect(center=editor_state.dialog_rect.center))


def _draw_text_input_content(surface: pygame.Surface, editor_state: EditorState, dialog_rect: pygame.Rect, fonts: Dict[str, Optional[pygame.font.Font]]):
    input_box_rect = pygame.Rect(0, 0, dialog_rect.width - 40, 40)
    input_box_rect.center = dialog_rect.centerx, dialog_rect.centery + 10 # Position below prompt
    
    pygame.draw.rect(surface, ED_CONFIG.DIALOG_INPUT_BOX_COLOR, input_box_rect)
    pygame.draw.rect(surface, ED_CONFIG.C.BLACK, input_box_rect, 2)

    text_font = fonts.get("medium") or ED_CONFIG.FONT_CONFIG.get("medium")
    if text_font:
        current_text_to_render = str(editor_state.dialog_input_text) if editor_state.dialog_input_text is not None else ""
        input_text_surf = text_font.render(current_text_to_render, True, ED_CONFIG.DIALOG_INPUT_TEXT_COLOR)
        
        text_clip_area_rect = input_box_rect.inflate(-12, -12) # Padding inside input box
        
        text_surf_width = input_text_surf.get_width()
        blit_area = None # Part of the input_text_surf to blit (for scrolling)
        
        # Default: text fits or is empty, draw from its left
        text_draw_pos_on_surface_x = text_clip_area_rect.left 

        if text_surf_width > text_clip_area_rect.width:
            # Text is wider than clip area, show the end part (cursor is at the end)
            # Blit the source surface such that its right edge aligns with clip_area's right
            text_draw_pos_on_surface_x = text_clip_area_rect.right - text_surf_width
            # Define the part of the source text surface to actually draw
            blit_source_x_offset = text_surf_width - text_clip_area_rect.width
            blit_area = pygame.Rect(blit_source_x_offset, 0, text_clip_area_rect.width, input_text_surf.get_height())
        
        blit_destination_topleft = (text_draw_pos_on_surface_x, 
                                    text_clip_area_rect.top + (text_clip_area_rect.height - input_text_surf.get_height()) // 2)

        original_clip = surface.get_clip()
        surface.set_clip(text_clip_area_rect)
        surface.blit(input_text_surf, blit_destination_topleft, area=blit_area)
        surface.set_clip(original_clip)

        # Cursor positioning: cursor should be at the end of the *rendered* text within the clip_area
        # If text was scrolled (blit_area is set), cursor is at the right of clip_area.
        # Otherwise, it's at the end of the un-scrolled text.
        if blit_area: # Text was wider than field
            cursor_render_x = text_clip_area_rect.right -1 # Slightly inside the box
        else: # Text fits
            cursor_render_x = text_clip_area_rect.left + input_text_surf.get_width() + 1
        
        # Clamp cursor to be visible within the input box's drawable area
        cursor_render_x = max(text_clip_area_rect.left, min(cursor_render_x, text_clip_area_rect.right -1))

        if int(pygame.time.get_ticks() / 500) % 2 == 0: # Blinking cursor
             pygame.draw.line(surface, ED_CONFIG.DIALOG_CURSOR_COLOR,
                             (cursor_render_x, input_box_rect.top + 5),
                             (cursor_render_x, input_box_rect.bottom - 5), 2)
    
    info_font = fonts.get("small") or ED_CONFIG.FONT_CONFIG.get("small")
    if info_font:
        info_surf = info_font.render("Enter: Confirm, Esc: Cancel", True, ED_CONFIG.C.LIGHT_GRAY)
        surface.blit(info_surf, info_surf.get_rect(midbottom=(dialog_rect.centerx, dialog_rect.bottom - 10)))

def _draw_color_picker_content(surface: pygame.Surface, editor_state: EditorState, dialog_rect: pygame.Rect, fonts: Dict[str, Optional[pygame.font.Font]]):
    mouse_pos_dialog = pygame.mouse.get_pos() 
    for name, swatch_rect_relative in editor_state.color_picker_rects.items():
        # swatch_rect_relative is relative to dialog content area, not dialog_rect.topleft directly.
        # It was calculated based on current_x_in_dialog, current_y_in_dialog from start_color_picker_dialog.
        absolute_swatch_rect = swatch_rect_relative.move(dialog_rect.left, dialog_rect.top)
        color_val = ED_CONFIG.COLOR_PICKER_PRESETS.get(name, ED_CONFIG.C.MAGENTA)
        
        pygame.draw.rect(surface, color_val, absolute_swatch_rect)
        border_col = ED_CONFIG.C.BLACK
        border_w = 1
        if absolute_swatch_rect.collidepoint(mouse_pos_dialog):
            border_col = ED_CONFIG.COLOR_PICKER_HOVER_BORDER_COLOR
            border_w = 3
        pygame.draw.rect(surface, border_col, absolute_swatch_rect, border_w)

def _draw_file_load_content(surface: pygame.Surface, editor_state: EditorState, dialog_rect: pygame.Rect, fonts: Dict[str, Optional[pygame.font.Font]]):
    prompt_font = fonts.get("medium") or ED_CONFIG.FONT_CONFIG.get("medium")
    title_height = prompt_font.get_height() + 25 if prompt_font else 55 # Space for prompt + padding
    buttons_panel_height = ED_CONFIG.BUTTON_HEIGHT_STANDARD // 2 + 20 # Approx for OK/Cancel + padding
    
    list_area_y_start = dialog_rect.top + title_height
    list_area_height = dialog_rect.height - title_height - buttons_panel_height
    
    # Main area for the file list itself
    list_area_rect = pygame.Rect(dialog_rect.left + 10, list_area_y_start, dialog_rect.width - 20, list_area_height)
    pygame.draw.rect(surface, ED_CONFIG.DIALOG_INPUT_BOX_COLOR, list_area_rect) # Background for list
    pygame.draw.rect(surface, ED_CONFIG.C.BLACK, list_area_rect, 1) # Border for list area

    item_font = fonts.get("small") or ED_CONFIG.FONT_CONFIG.get("small")
    item_line_height = (item_font.get_height() + 6) if item_font else 22 # Height of one file item row
    
    # Clear previous item rects for hit detection
    editor_state.ui_elements_rects['dialog_file_item_rects'] = [] 

    # Clipping rect for drawing list items, slightly smaller than list_area_rect
    list_clip_rect = list_area_rect.inflate(-8, -8) # Content area for text, inside list_area_rect border

    total_content_height_pixels = len(editor_state.dialog_file_list) * item_line_height
    
    scrollbar_width_drawn = 0 # Actual width taken by scrollbar if drawn
    if total_content_height_pixels > list_clip_rect.height: # Content taller than visible area, need scrollbar
        scrollbar_width_drawn = 15 # Desired width of scrollbar
        # Scrollbar track is to the right of the list_clip_rect
        scrollbar_track_rect = pygame.Rect(list_clip_rect.right + 2, list_clip_rect.top,
                                          scrollbar_width_drawn, list_clip_rect.height)
        pygame.draw.rect(surface, ED_CONFIG.C.DARK_GRAY, scrollbar_track_rect) # Scrollbar background
        
        handle_height_ratio = min(1.0, list_clip_rect.height / total_content_height_pixels if total_content_height_pixels > 0 else 1.0)
        handle_height = max(20, scrollbar_track_rect.height * handle_height_ratio) # Min handle height
        
        scrollable_content_outside_view = max(0, total_content_height_pixels - list_clip_rect.height)
        current_scroll_ratio_of_hidden = editor_state.dialog_file_scroll_y / scrollable_content_outside_view if scrollable_content_outside_view > 0 else 0
        
        # Position handle within the track based on scroll ratio
        handle_y_pos_on_track = (scrollbar_track_rect.height - handle_height) * current_scroll_ratio_of_hidden
        
        scrollbar_handle_rect = pygame.Rect(scrollbar_track_rect.left, 
                                            scrollbar_track_rect.top + handle_y_pos_on_track, 
                                            scrollbar_width_drawn, handle_height)
        pygame.draw.rect(surface, ED_CONFIG.C.GRAY, scrollbar_handle_rect, border_radius=3) # Scrollbar handle
        
        # Store rects for event handling
        editor_state.ui_elements_rects['file_dialog_scrollbar_handle'] = scrollbar_handle_rect
        editor_state.ui_elements_rects['file_dialog_scrollbar_area'] = scrollbar_track_rect # The whole track area
    
    # Adjust width available for list item text if scrollbar is present
    list_item_text_render_width = list_clip_rect.width - (scrollbar_width_drawn + 2 if scrollbar_width_drawn > 0 else 0)

    original_clip_pygame = surface.get_clip() # Save Pygame's current clip region
    surface.set_clip(list_clip_rect) # Clip drawing to the content area of the list

    current_y_offset_in_clip_rect = 0 # Relative Y for drawing items inside list_clip_rect
    for i, filename in enumerate(editor_state.dialog_file_list):
        # Calculate actual screen Y position for this item, considering scroll
        item_draw_y_on_surface = list_clip_rect.top + current_y_offset_in_clip_rect - editor_state.dialog_file_scroll_y
        
        # This is the rect on the main surface where this item *would* be drawn if fully visible
        item_full_rect_on_screen = pygame.Rect(list_clip_rect.left, item_draw_y_on_surface, 
                                           list_item_text_render_width, item_line_height)
        
        # Only process/draw if this item is (at least partially) visible within the list_clip_rect
        if list_clip_rect.colliderect(item_full_rect_on_screen):
            # Store this on-screen rect for mouse collision detection
            editor_state.ui_elements_rects['dialog_file_item_rects'].append(
                {"text": filename, "rect": item_full_rect_on_screen, "index": i}
            )
            if item_font:
                text_color = ED_CONFIG.C.BLACK
                bg_color_item = ED_CONFIG.DIALOG_INPUT_BOX_COLOR # Default item background
                if editor_state.dialog_selected_file_index == i:
                    bg_color_item = ED_CONFIG.C.BLUE # Highlight selected item
                    text_color = ED_CONFIG.C.WHITE
                
                # Draw the item background (will be clipped by surface.set_clip)
                pygame.draw.rect(surface, bg_color_item, item_full_rect_on_screen)
                
                text_surf = item_font.render(filename, True, text_color)
                # Center text vertically in the item_full_rect_on_screen
                text_draw_pos = (item_full_rect_on_screen.left + 5, 
                                 item_full_rect_on_screen.centery - text_surf.get_height() // 2)
                surface.blit(text_surf, text_draw_pos)
        
        current_y_offset_in_clip_rect += item_line_height # Move to next item position

    surface.set_clip(original_clip_pygame) # Restore Pygame's original clip region

    # --- Draw OK/Cancel Buttons ---
    button_font = fonts.get("small") or ED_CONFIG.FONT_CONFIG.get("small")
    if button_font:
        btn_width = ED_CONFIG.BUTTON_WIDTH_STANDARD // 2 - 15 # Slightly smaller buttons for dialog
        btn_height = ED_CONFIG.BUTTON_HEIGHT_STANDARD // 2 + 5 # Slimmer buttons
        
        # Position buttons below the list_area_rect
        buttons_y_pos = list_area_rect.bottom + 10 
        
        ok_button_rect = pygame.Rect(dialog_rect.centerx - btn_width - 5, buttons_y_pos, btn_width, btn_height)
        cancel_button_rect = pygame.Rect(dialog_rect.centerx + 5, buttons_y_pos, btn_width, btn_height)
        
        mouse_pos = pygame.mouse.get_pos() # Get current mouse pos for button hover state
        
        # OK button is active only if a file is selected
        ok_is_active = (editor_state.dialog_selected_file_index != -1 and 
                        0 <= editor_state.dialog_selected_file_index < len(editor_state.dialog_file_list))

        draw_button(surface, ok_button_rect, "Load", button_font, mouse_pos, is_active=ok_is_active)
        draw_button(surface, cancel_button_rect, "Cancel", button_font, mouse_pos)
        
        # Store button rects for event handling
        editor_state.ui_elements_rects["dialog_file_load_ok"] = ok_button_rect
        editor_state.ui_elements_rects["dialog_file_load_cancel"] = cancel_button_rect

########## START OF FILE: enemy.py ##########

########## START OF FILE: enemy.py ##########

# enemy.py
# -*- coding: utf-8 -*-
## version 1.0.0.9 (Added stomp kill mechanic)
"""
Defines the Enemy class, a CPU-controlled character.
Handles AI-driven movement (via enemy_ai_handler), animations, states,
combat (via enemy_combat_handler), and network synchronization
(via enemy_network_handler).
Each instance randomly selects a color variant for its animations if configured.
"""
import pygame
import random
import math
import os

from utils import PrintLimiter 
import constants as C 
from assets import load_all_player_animations 
from tiles import Lava 

from enemy_ai_handler import set_enemy_new_patrol_target, enemy_ai_update
from enemy_combat_handler import check_enemy_attack_collisions, enemy_take_damage
from enemy_network_handler import get_enemy_network_data, set_enemy_network_data


class Enemy(pygame.sprite.Sprite):
    # Class-level print limiter for non-critical warnings or infrequent info.
    # For heavy debugging, print statements should be temporary or use a more verbose logger.
    print_limiter = PrintLimiter(default_limit=3, default_period=10.0) 

    def __init__(self, start_x, start_y, patrol_area=None, enemy_id=None):
        super().__init__()
        self.spawn_pos = pygame.math.Vector2(start_x, start_y) 
        self.patrol_area = patrol_area 
        self.enemy_id = enemy_id if enemy_id is not None else id(self) 
        self._valid_init = True 
        character_base_asset_folder = 'characters'
        available_enemy_colors = ['cyan', 'green', 'pink', 'purple', 'red', 'yellow'] 
        if not available_enemy_colors: 
             if Enemy.print_limiter.can_print(f"enemy_{self.enemy_id}_init_no_colors"): # Use unique key
                print(f"Enemy Warning (ID: {self.enemy_id}): No enemy colors defined! Defaulting to 'player1' assets.")
             available_enemy_colors = ['player1'] 
        self.color_name = random.choice(available_enemy_colors) 
        chosen_enemy_asset_folder = os.path.join(character_base_asset_folder, self.color_name)
        
        self.animations = load_all_player_animations(relative_asset_folder=chosen_enemy_asset_folder)
        if self.animations is None: 
            print(f"Enemy CRITICAL (ID: {self.enemy_id}, Color: {self.color_name}): Failed loading animations from '{chosen_enemy_asset_folder}'.")
            self.image = pygame.Surface((30, 40)).convert_alpha(); self.image.fill(C.BLUE) 
            self.rect = self.image.get_rect(midbottom=(start_x, start_y))
            self._valid_init = False; self.is_dead = True; return 
        
        self._last_facing_right = True 
        self._last_state_for_debug = "init" # Can be removed if not actively debugging state machine
        self.state = 'idle'      
        self.current_frame = 0   
        self.last_anim_update = pygame.time.get_ticks() 
        
        initial_idle_animation = self.animations.get('idle')
        if not initial_idle_animation: 
             if Enemy.print_limiter.can_print(f"enemy_{self.enemy_id}_init_idle_missing"): # Use unique key
                print(f"Enemy Warning (ID: {self.enemy_id}, Color: {self.color_name}): 'idle' animation missing. Attempting fallback.")
             first_anim_key = next(iter(self.animations), None)
             initial_idle_animation = self.animations.get(first_anim_key) if first_anim_key and self.animations.get(first_anim_key) else None
        
        if initial_idle_animation and len(initial_idle_animation) > 0:
            self.image = initial_idle_animation[0]
        else: 
            self.image = pygame.Surface((30, 40)).convert_alpha(); self.image.fill(C.BLUE) 
            print(f"Enemy CRITICAL (ID: {self.enemy_id}): No suitable initial animation found after fallbacks.")
            self._valid_init = False; self.is_dead = True; return
            
        self.rect = self.image.get_rect(midbottom=(start_x, start_y)) 
        self.pos = pygame.math.Vector2(start_x, start_y) 
        self.vel = pygame.math.Vector2(0, 0)             
        self.acc = pygame.math.Vector2(0, getattr(C, 'ENEMY_GRAVITY', getattr(C, 'PLAYER_GRAVITY', 0.8))) 
        self.facing_right = random.choice([True, False]) 
        self.on_ground = False     
        self.ai_state = 'patrolling' 
        self.patrol_target_x = start_x 
        set_enemy_new_patrol_target(self) 
        self.is_attacking = False; self.attack_timer = 0
        self.attack_duration = getattr(C, 'ENEMY_ATTACK_STATE_DURATION', getattr(C, 'CHARACTER_ATTACK_STATE_DURATION', 500)) 
        self.attack_type = 0 
        self.attack_cooldown_timer = 0 
        self.post_attack_pause_timer = 0 
        self.post_attack_pause_duration = getattr(C, 'ENEMY_POST_ATTACK_PAUSE_DURATION', 200) 
        self.is_taking_hit = False; self.hit_timer = 0 
        self.hit_duration = getattr(C, 'ENEMY_HIT_STUN_DURATION', 300) 
        self.hit_cooldown = getattr(C, 'ENEMY_HIT_COOLDOWN', 500)      
        self.is_dead = False
        self.death_animation_finished = False 
        self.state_timer = 0 
        self.max_health = getattr(C, 'ENEMY_MAX_HEALTH', 100)
        self.current_health = self.max_health
        self.attack_hitbox = pygame.Rect(0, 0, 50, 35) 
        try: self.standard_height = self.animations['idle'][0].get_height() if self.animations.get('idle') else 60
        except (KeyError, IndexError, TypeError): self.standard_height = 60 

        # Stomp death attributes
        self.is_stomp_dying = False
        self.stomp_death_start_time = 0
        self.original_stomp_death_image = None
        self.original_stomp_facing_right = True


    def set_state(self, new_state: str):
        if not self._valid_init: return 
        
        # If being stomp-killed, visual state is handled by is_stomp_dying in animate()
        if self.is_stomp_dying and new_state != 'stomp_death': # Allow setting to 'stomp_death' if needed by logic
            return

        animation_key_to_validate = new_state 
        valid_direct_animation_states = ['idle', 'run', 'attack', 'attack_nm', 'hit', 'death', 'death_nm', 'fall', 'stomp_death']
        
        if new_state not in valid_direct_animation_states: 
            if new_state in ['chasing', 'patrolling']:
                animation_key_to_validate = 'run' 
            elif 'attack' in new_state: 
                animation_key_to_validate = new_state 
            else: 
                animation_key_to_validate = 'idle'

        # For stomp_death, there's no dedicated animation sheet, it's procedural
        if new_state == 'stomp_death':
            pass # No animation frames to validate for stomp_death
        elif animation_key_to_validate not in self.animations or not self.animations[animation_key_to_validate]:
            if Enemy.print_limiter.can_print(f"enemy_{self.enemy_id}_set_state_anim_miss_{animation_key_to_validate}"): # Use unique key
                print(f"Enemy Warning (ID: {self.enemy_id}): Animation for key '{animation_key_to_validate}' (from logical: '{new_state}') missing. Trying 'idle'.")
            animation_key_to_validate = 'idle' 
            if 'idle' not in self.animations or not self.animations['idle']: 
                 if Enemy.print_limiter.can_print(f"enemy_{self.enemy_id}_set_state_crit_idle_miss"): # Use unique key
                    print(f"Enemy CRITICAL (ID: {self.enemy_id}): Cannot find valid 'idle' animation. Halting state change for '{new_state}'.")
                 return 

        can_change_state_now = (self.state != new_state or new_state in ['death', 'stomp_death']) and \
                               not (self.is_dead and not self.death_animation_finished and new_state not in ['death', 'stomp_death'])

        if can_change_state_now:
            self._last_state_for_debug = new_state # Keep if still useful for your own debugging
            if 'attack' not in new_state: self.is_attacking = False; self.attack_type = 0
            if new_state != 'hit': self.is_taking_hit = False

            self.state = new_state 
            self.current_frame = 0 
            current_ticks_ms = pygame.time.get_ticks()
            self.last_anim_update = current_ticks_ms 
            self.state_timer = current_ticks_ms       

            if 'attack' in new_state: 
                self.is_attacking = True; self.attack_type = 1 
                self.attack_timer = current_ticks_ms; self.vel.x = 0 
            elif new_state == 'hit': 
                 self.is_taking_hit = True; self.hit_timer = self.state_timer 
                 self.vel.x *= -0.5 
                 self.vel.y = getattr(C, 'ENEMY_HIT_BOUNCE_Y', getattr(C, 'PLAYER_JUMP_STRENGTH', -10) * 0.3)
                 self.is_attacking = False 
            elif new_state == 'death' or new_state == 'stomp_death': 
                 self.is_dead = True; self.vel.x = 0; self.vel.y = 0 
                 self.acc.xy = 0, 0; self.current_health = 0 
                 self.death_animation_finished = False 
                 if new_state == 'stomp_death' and not self.is_stomp_dying: # Ensure stomp flags are set if directly setting this state
                     self.stomp_kill() # This will correctly initialize stomp death
            
            self.animate() 
        elif not self.is_dead: 
             self._last_state_for_debug = self.state 

    def animate(self):
        if not self._valid_init or not hasattr(self, 'animations') or not self.animations: return
        # Allow animation if alive() OR if is_dead and death animation not finished (covers normal and stomp death)
        if not (self.alive() or (self.is_dead and not self.death_animation_finished)):
            return

        current_time_ms = pygame.time.get_ticks()
        animation_frame_duration_ms = getattr(C, 'ANIM_FRAME_DURATION', 100) 

        if self.is_stomp_dying:
            if not self.original_stomp_death_image:
                self.death_animation_finished = True
                self.is_stomp_dying = False
                # if self.alive(): self.kill() # Let external logic handle kill based on death_animation_finished
                return

            elapsed_time = current_time_ms - self.stomp_death_start_time
            stomp_death_total_duration = getattr(C, 'ENEMY_STOMP_DEATH_DURATION', 300)
            scale_factor = 0.0

            if elapsed_time >= stomp_death_total_duration:
                self.death_animation_finished = True
                self.is_stomp_dying = False
            else:
                scale_factor = 1.0 - (elapsed_time / stomp_death_total_duration)
            
            scale_factor = max(0.0, min(1.0, scale_factor))

            original_width = self.original_stomp_death_image.get_width()
            original_height = self.original_stomp_death_image.get_height()
            new_height = int(original_height * scale_factor)

            if new_height <= 1: # Make it effectively invisible or 1px high
                self.image = pygame.Surface((original_width, 1), pygame.SRCALPHA)
                self.image.fill((0,0,0,0)) # Transparent
                if not self.death_animation_finished: # Ensure flags are set if shrink makes it disappear early
                    self.death_animation_finished = True
                    self.is_stomp_dying = False
            else:
                self.image = pygame.transform.scale(self.original_stomp_death_image, (original_width, new_height))
            
            old_midbottom = self.rect.midbottom
            self.rect = self.image.get_rect(midbottom=old_midbottom)
            # self._last_facing_right is not strictly needed here as stomp image is fixed.
            return # Stomp death animation overrides other animation logic

        determined_animation_key = 'idle' 

        if self.is_dead: # Regular death (not stomp)
            determined_animation_key = 'death_nm' if abs(self.vel.x) < 0.1 and abs(self.vel.y) < 0.1 and \
                                     self.animations.get('death_nm') else 'death'
            if not self.animations.get(determined_animation_key):
                determined_animation_key = 'death' if self.animations.get('death') else 'idle' 
        elif self.post_attack_pause_timer > 0 and current_time_ms < self.post_attack_pause_timer: 
            determined_animation_key = 'idle' 
        elif self.state in ['patrolling', 'chasing'] or (self.state == 'run' and abs(self.vel.x) > 0.1): 
             determined_animation_key = 'run' if abs(self.vel.x) > 0.1 else 'idle'
        elif self.is_attacking: 
            determined_animation_key = 'attack_nm' if self.animations.get('attack_nm') else 'attack'
            if not self.animations.get(determined_animation_key): determined_animation_key = 'idle'
        elif self.is_taking_hit: 
            determined_animation_key = 'hit' if self.animations.get('hit') else 'idle'
        elif not self.on_ground: 
            determined_animation_key = 'fall' if self.animations.get('fall') else 'idle'
        elif self.state == 'idle': 
            determined_animation_key = 'idle'
        elif self.state == 'run': 
            determined_animation_key = 'run' if abs(self.vel.x) > 0.1 else 'idle' 
        
        if not self.animations.get(determined_animation_key):
            if Enemy.print_limiter.can_print(f"enemy_{self.enemy_id}_animate_key_fallback_{determined_animation_key}"): # Use unique key
                print(f"Enemy Animate Warning (ID: {self.enemy_id}): Key '{determined_animation_key}' invalid for state '{self.state}'. Defaulting to 'idle'.")
            determined_animation_key = 'idle'
        
        current_animation_frames_list = self.animations.get(determined_animation_key)

        if not current_animation_frames_list: 
            if hasattr(self, 'image') and self.image: self.image.fill(C.BLUE) 
            if Enemy.print_limiter.can_print(f"enemy_{self.enemy_id}_animate_no_frames_{determined_animation_key}"): # Use unique key
                print(f"Enemy CRITICAL Animate (ID: {self.enemy_id}): No frames for '{determined_animation_key}' (state: {self.state})")
            return

        if not (self.is_dead and self.death_animation_finished): 
            if current_time_ms - self.last_anim_update > animation_frame_duration_ms: 
                self.last_anim_update = current_time_ms 
                self.current_frame += 1 
                
                if self.current_frame >= len(current_animation_frames_list): 
                    if self.is_dead: # Regular death animation finished
                        self.current_frame = len(current_animation_frames_list) - 1 
                        self.death_animation_finished = True
                        final_death_image_surface = current_animation_frames_list[self.current_frame]
                        if not self.facing_right: final_death_image_surface = pygame.transform.flip(final_death_image_surface, True, False)
                        old_enemy_midbottom = self.rect.midbottom
                        self.image = final_death_image_surface
                        self.rect = self.image.get_rect(midbottom=old_enemy_midbottom)
                        return 
                    elif self.state == 'hit': 
                        self.set_state('idle' if self.on_ground else 'fall') 
                        return 
                    else: 
                        self.current_frame = 0
                
                if self.current_frame >= len(current_animation_frames_list) and not self.is_dead : self.current_frame = 0
        
        if self.is_dead and self.death_animation_finished and not self.alive(): 
            return 

        if not current_animation_frames_list or self.current_frame < 0 or \
           self.current_frame >= len(current_animation_frames_list):
            self.current_frame = 0 
            if not current_animation_frames_list: 
                if hasattr(self, 'image') and self.image: self.image.fill(C.BLUE); return

        image_for_this_frame = current_animation_frames_list[self.current_frame]
        current_facing_is_right_for_anim = self.facing_right
        if not current_facing_is_right_for_anim: 
            image_for_this_frame = pygame.transform.flip(image_for_this_frame, True, False)
        
        if self.image is not image_for_this_frame or self._last_facing_right != current_facing_is_right_for_anim:
            old_enemy_midbottom_pos = self.rect.midbottom 
            self.image = image_for_this_frame 
            self.rect = self.image.get_rect(midbottom=old_enemy_midbottom_pos) 
            self._last_facing_right = current_facing_is_right_for_anim 

    def stomp_kill(self):
        if self.is_dead or self.is_stomp_dying:
            return
        # print(f"DEBUG Enemy {self.enemy_id}: Stomp kill initiated.")
        self.current_health = 0
        self.is_dead = True 
        self.is_stomp_dying = True
        self.stomp_death_start_time = pygame.time.get_ticks()
        
        # Capture current visual state for scaling
        # self.animate() # Ensure self.image is up-to-date before copying (might be risky if animate has side effects)
        # Best to rely on self.image being set from previous frame's animate call.
        self.original_stomp_death_image = self.image.copy() 
        self.original_stomp_facing_right = self.facing_right
        
        self.vel.xy = 0,0 
        self.acc.xy = 0,0 
        # No self.set_state('stomp_death') needed if animate() checks self.is_stomp_dying first.
        # self.state remains as is, or can be set to a generic 'dying' if needed.

    def _ai_update(self, players_list_for_targeting):
        enemy_ai_update(self, players_list_for_targeting)

    def _check_attack_collisions(self, player_target_list_for_combat):
        check_enemy_attack_collisions(self, player_target_list_for_combat)

    def take_damage(self, damage_amount_taken):
        enemy_take_damage(self, damage_amount_taken) 

    def get_network_data(self):
        return get_enemy_network_data(self)

    def set_network_data(self, received_network_data):
        set_enemy_network_data(self, received_network_data)


    def update(self, dt_sec, players_list_for_logic, platforms_group, hazards_group):
        if not self._valid_init: return
        
        if self.is_stomp_dying:
            self.animate() # Handles scaling and sets death_animation_finished
            # Removal from groups is handled by main game loop when death_animation_finished is true
            return

        if self.is_dead and self.alive(): # Regular death (not stomp)
            if not self.death_animation_finished: 
                if not self.on_ground: 
                    self.vel.y += self.acc.y 
                    self.vel.y = min(self.vel.y, getattr(C, 'TERMINAL_VELOCITY_Y', 18))
                    self.pos.y += self.vel.y
                    self.rect.bottom = round(self.pos.y)
                    self.on_ground = False 
                    for platform_sprite in pygame.sprite.spritecollide(self, platforms_group, False):
                        if self.vel.y > 0 and self.rect.bottom > platform_sprite.rect.top and \
                           (self.pos.y - self.vel.y) <= platform_sprite.rect.top + 1:
                            self.rect.bottom = platform_sprite.rect.top
                            self.on_ground = True; self.vel.y = 0; self.acc.y = 0 
                            self.pos.y = self.rect.bottom; break
            self.animate() 
            return 

        if self.is_dead and self.death_animation_finished: # Fully dead (stomp or regular)
            if self.alive(): self.kill() 
            return

        current_time_ms = pygame.time.get_ticks()

        if self.post_attack_pause_timer > 0 and current_time_ms >= self.post_attack_pause_timer:
            self.post_attack_pause_timer = 0 

        if self.is_taking_hit and current_time_ms - self.hit_timer > self.hit_cooldown:
            self.is_taking_hit = False 

        self._ai_update(players_list_for_logic) 

        if not self.is_dead: 
            self.vel.y += self.acc.y 
            
            enemy_friction_val = getattr(C, 'ENEMY_FRICTION', -0.12)
            enemy_run_speed_max = getattr(C, 'ENEMY_RUN_SPEED_LIMIT', 5)
            terminal_fall_speed_y = getattr(C, 'TERMINAL_VELOCITY_Y', 18) 

            self.vel.x += self.acc.x 

            apply_friction_to_enemy = self.on_ground and self.acc.x == 0 
            if apply_friction_to_enemy:
                friction_force_on_enemy = self.vel.x * enemy_friction_val
                if abs(self.vel.x) > 0.1: self.vel.x += friction_force_on_enemy
                else: self.vel.x = 0 

            self.vel.x = max(-enemy_run_speed_max, min(enemy_run_speed_max, self.vel.x))
            self.vel.y = min(self.vel.y, terminal_fall_speed_y)
            
            self.on_ground = False 

            self.pos.x += self.vel.x
            self.rect.centerx = round(self.pos.x)
            self.check_platform_collisions('x', platforms_group) 
            
            collided_horizontally_with_player = self.check_character_collision('x', players_list_for_logic)

            self.pos.y += self.vel.y
            self.rect.bottom = round(self.pos.y)
            self.check_platform_collisions('y', platforms_group) 

            if not collided_horizontally_with_player: 
                self.check_character_collision('y', players_list_for_logic)

            self.pos.x = self.rect.centerx
            self.pos.y = self.rect.bottom

            self.check_hazard_collisions(hazards_group)
            
            if self.is_attacking: 
                self._check_attack_collisions(players_list_for_logic) 
        
        self.animate()


    def check_platform_collisions(self, direction: str, platforms_group: pygame.sprite.Group):
        for platform_sprite in pygame.sprite.spritecollide(self, platforms_group, False):
            if direction == 'x': 
                original_vel_x = self.vel.x 
                if self.vel.x > 0: self.rect.right = platform_sprite.rect.left 
                elif self.vel.x < 0: self.rect.left = platform_sprite.rect.right 
                self.vel.x = 0 
                if self.ai_state == 'patrolling': 
                    if abs(original_vel_x) > 0.1 and \
                       (abs(self.rect.right - platform_sprite.rect.left) < 2 or \
                        abs(self.rect.left - platform_sprite.rect.right) < 2) :
                        set_enemy_new_patrol_target(self) 
            elif direction == 'y': 
                if self.vel.y > 0: 
                    if self.rect.bottom > platform_sprite.rect.top and \
                       (self.pos.y - self.vel.y) <= platform_sprite.rect.top + 1: 
                         self.rect.bottom = platform_sprite.rect.top
                         self.on_ground = True; self.vel.y = 0
                elif self.vel.y < 0: 
                    if self.rect.top < platform_sprite.rect.bottom and \
                       ((self.pos.y - self.rect.height) - self.vel.y) >= platform_sprite.rect.bottom -1:
                         self.rect.top = platform_sprite.rect.bottom
                         self.vel.y = 0 
            if direction == 'x': self.pos.x = self.rect.centerx
            else: self.pos.y = self.rect.bottom


    def check_character_collision(self, direction: str, player_list: list): 
        if not self._valid_init or self.is_dead or not self.alive(): return False
        collision_with_player_occurred = False
        for player_char_sprite in player_list:
            if not (player_char_sprite and player_char_sprite._valid_init and \
                    not player_char_sprite.is_dead and player_char_sprite.alive()):
                continue
            if self.rect.colliderect(player_char_sprite.rect): 
                collision_with_player_occurred = True
                bounce_vel_on_collision = getattr(C, 'CHARACTER_BOUNCE_VELOCITY', 2.5)
                if direction == 'x': 
                    push_direction_for_enemy = -1 if self.rect.centerx < player_char_sprite.rect.centerx else 1
                    if push_direction_for_enemy == -1: self.rect.right = player_char_sprite.rect.left
                    else: self.rect.left = player_char_sprite.rect.right
                    self.vel.x = push_direction_for_enemy * bounce_vel_on_collision 
                    if hasattr(player_char_sprite, 'vel'): 
                        player_char_sprite.vel.x = -push_direction_for_enemy * bounce_vel_on_collision
                    if hasattr(player_char_sprite, 'pos') and hasattr(player_char_sprite, 'rect'): 
                        player_char_sprite.pos.x += (-push_direction_for_enemy * 1.5) 
                        player_char_sprite.rect.centerx = round(player_char_sprite.pos.x)
                    self.pos.x = self.rect.centerx 
                elif direction == 'y': 
                    if self.vel.y > 0 and self.rect.bottom > player_char_sprite.rect.top and \
                       self.rect.centery < player_char_sprite.rect.centery:
                        self.rect.bottom = player_char_sprite.rect.top; self.on_ground = True; self.vel.y = 0
                    elif self.vel.y < 0 and self.rect.top < player_char_sprite.rect.bottom and \
                         self.rect.centery > player_char_sprite.rect.centery:
                        self.rect.top = player_char_sprite.rect.bottom; self.vel.y = 0
                    self.pos.y = self.rect.bottom 
        return collision_with_player_occurred


    def check_hazard_collisions(self, hazards_group: pygame.sprite.Group):
        current_time_ms = pygame.time.get_ticks()
        if not self._valid_init or self.is_dead or not self.alive() or \
           (self.is_taking_hit and current_time_ms - self.hit_timer < self.hit_cooldown): 
            return
        damage_taken_from_hazard_this_frame = False
        hazard_check_point_enemy_feet = (self.rect.centerx, self.rect.bottom - 1) 
        for hazard_sprite in hazards_group:
            if isinstance(hazard_sprite, Lava) and \
               hazard_sprite.rect.collidepoint(hazard_check_point_enemy_feet) and \
               not damage_taken_from_hazard_this_frame:
                self.take_damage(getattr(C, 'LAVA_DAMAGE', 50)) 
                damage_taken_from_hazard_this_frame = True
                if not self.is_dead: 
                     self.vel.y = getattr(C, 'PLAYER_JUMP_STRENGTH', -15) * 0.3 
                     push_dir_from_lava_hazard = 1 if self.rect.centerx < hazard_sprite.rect.centerx else -1
                     self.vel.x = -push_dir_from_lava_hazard * 4 
                     self.on_ground = False 
                break 


    def reset(self):
        if not self._valid_init: return
        self.pos = self.spawn_pos.copy() 
        self.rect.midbottom = (round(self.pos.x), round(self.pos.y))
        self.vel.xy = 0,0 
        self.acc.xy = 0, getattr(C, 'ENEMY_GRAVITY', getattr(C, 'PLAYER_GRAVITY', 0.7)) 
        self.current_health = self.max_health
        self.is_dead = False
        self.death_animation_finished = False
        self.is_taking_hit = False
        self.is_attacking = False; self.attack_type = 0
        self.hit_timer = 0; self.attack_timer = 0; self.attack_cooldown_timer = 0
        self.post_attack_pause_timer = 0 
        self.facing_right = random.choice([True, False]) 
        self.on_ground = False 
        self.ai_state = 'patrolling'
        set_enemy_new_patrol_target(self) 
        if hasattr(self.image, 'get_alpha') and self.image.get_alpha() is not None and \
           self.image.get_alpha() < 255:
            self.image.set_alpha(255)
        
        # Reset stomp death attributes
        self.is_stomp_dying = False
        self.stomp_death_start_time = 0
        self.original_stomp_death_image = None
        self.original_stomp_facing_right = self.facing_right

        self.set_state('idle')
########## END OF FILE: enemy.py ##########

########## START OF FILE: enemy_ai_handler.py ##########

# enemy_ai_handler.py
# -*- coding: utf-8 -*-
"""
version 1.0.0.2 (Corrected set_state logic for patrol/chase transitions)
Handles AI logic for enemies, including patrolling, chasing, and attacking decisions.
Functions here will typically take an 'enemy' instance as their first argument.
"""
import pygame
import random
import math
import constants as C # For accessing enemy-specific constants and general game constants

def set_enemy_new_patrol_target(enemy):
    """
    Sets a new patrol target X-coordinate for the enemy instance.
    If a patrol_area (pygame.Rect) is defined for the enemy, it patrols within that area.
    Otherwise, it patrols a set distance from its current position.

    Args:
        enemy (Enemy): The enemy instance for which to set a new patrol target.
    """
    # if not hasattr(enemy, 'rect') or not hasattr(enemy, 'pos'): # Guard against incomplete enemy object
    #     if hasattr(enemy, 'print_limiter') and enemy.print_limiter.can_print(f"enemy_patrol_target_no_rect_{enemy.enemy_id}"):
    #         print(f"ENEMY AI WARN ({enemy.enemy_id}): set_enemy_new_patrol_target called on enemy without rect/pos.")
        # return

    if enemy.patrol_area and isinstance(enemy.patrol_area, pygame.Rect):
         min_x_patrol = enemy.patrol_area.left + enemy.rect.width / 2
         max_x_patrol = enemy.patrol_area.right - enemy.rect.width / 2
         
         if min_x_patrol < max_x_patrol: 
             enemy.patrol_target_x = random.uniform(min_x_patrol, max_x_patrol)
         else: 
             enemy.patrol_target_x = enemy.patrol_area.centerx
    else: 
        patrol_direction = 1 if random.random() > 0.5 else -1
        enemy.patrol_target_x = enemy.pos.x + patrol_direction * getattr(C, 'ENEMY_PATROL_DIST', 150)


def enemy_ai_update(enemy, players_list_for_ai):
    """
    Updates the enemy's AI state (e.g., patrolling, chasing, attacking) and behavior
    based on player proximity and other conditions. Modifies the enemy instance directly.

    Args:
        enemy (Enemy): The enemy instance to update.
        players_list_for_ai (list): A list of player Sprites that the AI can target.
    """
    current_time_ms = pygame.time.get_ticks() 
    
    if enemy.post_attack_pause_timer > 0 and current_time_ms < enemy.post_attack_pause_timer:
        enemy.acc.x = 0 
        if enemy.state != 'idle': 
            enemy.set_state('idle') 
        return 

    if not enemy._valid_init or enemy.is_dead or not enemy.alive() or \
       (enemy.is_taking_hit and current_time_ms - enemy.hit_timer < enemy.hit_cooldown):
        enemy.acc.x = 0 
        return

    closest_target_player = None
    min_squared_distance_to_player = float('inf') 

    for player_candidate in players_list_for_ai:
        is_candidate_targetable = (
            player_candidate and player_candidate._valid_init and
            hasattr(player_candidate, 'pos') and hasattr(player_candidate, 'rect') and
            player_candidate.alive() and not getattr(player_candidate, 'is_dead', True) 
        )
        if is_candidate_targetable:
            squared_dist = (player_candidate.pos.x - enemy.pos.x)**2 + \
                           (player_candidate.pos.y - enemy.pos.y)**2
            if squared_dist < min_squared_distance_to_player:
                min_squared_distance_to_player = squared_dist
                closest_target_player = player_candidate
    
    if not closest_target_player: 
        enemy.ai_state = 'patrolling' 
        # If the AI decides to patrol, and the enemy's logical state isn't already
        # 'patrolling' or 'run' (which is used for patrol animation), then set it.
        # This allows transitioning from 'idle' to 'patrolling'.
        if enemy.state not in ['patrolling', 'run']: 
            enemy.set_state('patrolling') 
        
        if abs(enemy.pos.x - enemy.patrol_target_x) < 10: 
            set_enemy_new_patrol_target(enemy) 
        
        should_face_right_for_patrol = (enemy.patrol_target_x > enemy.pos.x)
        patrol_acceleration = getattr(C, 'ENEMY_ACCEL', 0.4) * 0.7 
        enemy.acc.x = patrol_acceleration * (1 if should_face_right_for_patrol else -1)
        
        if not enemy.is_attacking and enemy.facing_right != should_face_right_for_patrol:
            enemy.facing_right = should_face_right_for_patrol
        return 

    distance_to_target_player = math.sqrt(min_squared_distance_to_player) 
    enemy_attack_cooldown_duration = getattr(C, 'ENEMY_ATTACK_COOLDOWN', 1500) 
    enemy_attack_range = getattr(C, 'ENEMY_ATTACK_RANGE', 60) 
    enemy_detection_range = getattr(C, 'ENEMY_DETECTION_RANGE', 200) 
    enemy_standard_acceleration = getattr(C, 'ENEMY_ACCEL', 0.4)
    is_attack_off_cooldown = current_time_ms - enemy.attack_cooldown_timer > enemy_attack_cooldown_duration
    vertical_distance_to_player = abs(closest_target_player.rect.centery - enemy.rect.centery)
    has_vertical_line_of_sight = vertical_distance_to_player < enemy.rect.height * 1.0 
    is_player_in_attack_range = distance_to_target_player < enemy_attack_range and has_vertical_line_of_sight
    is_player_in_detection_range = distance_to_target_player < enemy_detection_range and has_vertical_line_of_sight

    if enemy.is_attacking and current_time_ms - enemy.attack_timer >= enemy.attack_duration:
         enemy.is_attacking = False; enemy.attack_type = 0      
         enemy.attack_cooldown_timer = current_time_ms 
         enemy.post_attack_pause_timer = current_time_ms + enemy.post_attack_pause_duration 
         enemy.set_state('idle'); enemy.acc.x = 0         
         return 

    if enemy.is_attacking:
        enemy.acc.x = 0 
        return

    current_target_acceleration_x = 0 
    current_target_facing_right = enemy.facing_right 

    if is_player_in_attack_range and is_attack_off_cooldown:
        enemy.ai_state = 'attacking'
        current_target_facing_right = (closest_target_player.pos.x > enemy.pos.x) 
        enemy.facing_right = current_target_facing_right
        attack_animation_key_to_use = 'attack_nm' if 'attack_nm' in enemy.animations and \
                                       enemy.animations['attack_nm'] else 'attack'
        enemy.set_state(attack_animation_key_to_use) 
        return 
    
    elif is_player_in_detection_range:
        enemy.ai_state = 'chasing'
        current_target_facing_right = (closest_target_player.pos.x > enemy.pos.x) 
        current_target_acceleration_x = enemy_standard_acceleration * (1 if current_target_facing_right else -1)
        # If AI decides to chase, and logical state isn't 'chasing' or 'run', set it.
        if enemy.state not in ['chasing', 'run']: 
            enemy.set_state('chasing') 
    
    else: 
        enemy.ai_state = 'patrolling'
        # If AI decides to patrol (because player is out of detection range),
        # and logical state isn't 'patrolling' or 'run', set it.
        if enemy.state not in ['patrolling', 'run']: 
            enemy.set_state('patrolling')
        
        if abs(enemy.pos.x - enemy.patrol_target_x) < 10: 
            set_enemy_new_patrol_target(enemy) 
        
        current_target_facing_right = (enemy.patrol_target_x > enemy.pos.x)
        current_target_acceleration_x = enemy_standard_acceleration * 0.7 * \
                                        (1 if current_target_facing_right else -1)

    enemy.acc.x = current_target_acceleration_x
    if not enemy.is_attacking and enemy.facing_right != current_target_facing_right:
         enemy.facing_right = current_target_facing_right

########## START OF FILE: enemy_combat_handler.py ##########

# enemy_combat_handler.py
# -*- coding: utf-8 -*-
"""
version 1.0000000.1
Handles enemy combat mechanics: checking attack collisions and processing damage taken.
Functions here will typically take an 'enemy' instance as their first argument.
"""
import pygame
import constants as C # For accessing damage values, hit stun duration, etc.

def check_enemy_attack_collisions(enemy, player_target_list):
    """
    Checks if the enemy's current attack (if any) hits any player in the target list.
    Applies damage to the player if a hit is registered.

    Args:
        enemy (Enemy): The attacking enemy instance.
        player_target_list (list): A list of Player sprites to check for collision.
    """
    # Enemy must be valid, actively attacking, and alive to deal damage
    if not enemy._valid_init or not enemy.is_attacking or enemy.is_dead or not enemy.alive():
        return

    # Position the enemy's attack hitbox based on its facing direction and current position.
    # It's assumed that enemy.attack_hitbox is a pygame.Rect attribute of the enemy instance,
    # and its size is defined in the Enemy class or constants.
    if enemy.facing_right:
        enemy.attack_hitbox.midleft = enemy.rect.midright # Position hitbox to the right
    else:
        enemy.attack_hitbox.midright = enemy.rect.midleft # Position hitbox to the left
    
    # Vertically align the hitbox with the enemy's center (can be adjusted if attacks are high/low)
    enemy.attack_hitbox.centery = enemy.rect.centery 
    
    current_time_ms = pygame.time.get_ticks()

    for player_sprite in player_target_list:
        # Ensure the player target is valid, alive, and not dead
        if not (player_sprite and player_sprite._valid_init and \
                not player_sprite.is_dead and player_sprite.alive()):
            continue

        # --- Check if the player target is currently invincible (e.g., recently hit) ---
        player_is_currently_invincible = False
        if hasattr(player_sprite, 'is_taking_hit') and hasattr(player_sprite, 'hit_timer') and \
           hasattr(player_sprite, 'hit_cooldown'):
            if player_sprite.is_taking_hit and \
               (current_time_ms - player_sprite.hit_timer < player_sprite.hit_cooldown):
                player_is_currently_invincible = True
        
        if player_is_currently_invincible:
            continue # Skip this player if they are invincible

        # --- Perform collision check between enemy's attack hitbox and player's rect ---
        if enemy.attack_hitbox.colliderect(player_sprite.rect):
            # A hit is registered!
            if hasattr(player_sprite, 'take_damage') and callable(player_sprite.take_damage):
                # Apply damage to the player
                damage_to_inflict_on_player = getattr(C, 'ENEMY_ATTACK_DAMAGE', 10) # Default damage
                # Future: Could have different damage based on enemy.attack_type if enemies have multiple attacks
                
                player_sprite.take_damage(damage_to_inflict_on_player)
                
                # Optional: Prevent the same attack swing from hitting the same player multiple times.
                # This might involve adding the player_sprite to a list of 'already_hit_this_swing'
                # on the enemy instance, and clearing that list when a new attack starts.
                # For simplicity here, one hit per check_attack_collisions call against a target.
                # If called every frame an attack is active, it might hit multiple frames.
                # Often, the attack state itself (is_attacking) is cleared after one successful hit check
                # or after a certain number of active frames.
                # For now, let's assume one hit is sufficient for this attack instance.
                # If the game design wants an attack to hit only once per animation,
                # the enemy.is_attacking flag or a specific hit flag should be managed carefully.
                
                # Example: If an attack should only connect once per animation, you might do:
                # if enemy.is_attacking and not getattr(enemy, '_has_hit_this_attack_swing', False):
                #     player_sprite.take_damage(damage_to_inflict_on_player)
                #     enemy._has_hit_this_attack_swing = True # Set a flag
                # (This flag would need to be reset when a new attack starts in enemy.set_state)
                
                # For now, simple damage application on collision.
                # If multiple players can be hit by one swing, this loop continues.
                # If only one player can be hit, you might 'return' here.

def enemy_take_damage(enemy, damage_amount):
    """
    Handles the enemy instance taking a specified amount of damage.
    Updates health and potentially triggers 'hit' or 'death' states for the enemy.

    Args:
        enemy (Enemy): The enemy instance receiving damage.
        damage_amount (int): The amount of damage to inflict.
    """
    current_time_ms = pygame.time.get_ticks()
    
    # Enemy cannot take damage if invalid, already dead, not in game world, or in hit cooldown
    if not enemy._valid_init or enemy.is_dead or not enemy.alive() or \
       (enemy.is_taking_hit and current_time_ms - enemy.hit_timer < enemy.hit_cooldown):
        # if enemy.print_limiter.can_print(f"enemy_{enemy.enemy_id}_damage_ignored_handler", limit=3): # Use enemy's limiter
        #     print(f"DEBUG Enemy {enemy.enemy_id} (CombatHandler): Damage IGNORED due to state/cooldown.")
        return

    enemy.current_health -= damage_amount
    enemy.current_health = max(0, enemy.current_health) # Clamp health at 0 (cannot be negative)

    # if enemy.print_limiter.can_print(f"enemy_{enemy.enemy_id}_health_update_handler", limit=5):
    #     print(f"DEBUG Enemy {enemy.enemy_id} (CombatHandler): Took {damage_amount} damage. New HP: {enemy.current_health}/{enemy.max_health}")

    if enemy.current_health <= 0: # Health has reached zero or below
        if not enemy.is_dead: # If not already marked as dead, transition to death state
            enemy.set_state('death') # This will trigger death animation and logic in Enemy class
    else: # Enemy is damaged but still alive
        # Transition to 'hit' state to show visual feedback and potentially interrupt actions,
        # but only if not already in a 'hit' state during its active stun duration.
        # ENEMY_HIT_STUN_DURATION is the duration the enemy is stunned and in 'hit' anim.
        # ENEMY_HIT_COOLDOWN is total invincibility time, which might be longer.
        if not (enemy.state == 'hit' and current_time_ms - enemy.state_timer < getattr(C, 'ENEMY_HIT_STUN_DURATION', 300)):
             enemy.set_state('hit') # Trigger hit animation and stun period

########## START OF FILE: enemy_network_handler.py ##########

########## START OF FILE: enemy_network_handler.py ##########

# enemy_network_handler.py
# -*- coding: utf-8 -*-
"""
version 1.0.0.2 (Updated stomp death networking and client-side image capture)
Handles network-related data serialization and deserialization for the Enemy class.
Functions here will typically take an 'enemy' instance as their first argument.
"""
import pygame
import constants as C # For any network-specific constants if needed in future
from assets import load_all_player_animations # For client-side enemy animation loading if color changes
import os # For os.path.join if needed for color sync (though GSM usually handles enemy creation)

def get_enemy_network_data(enemy):
    """
    Gathers essential enemy data into a dictionary for network transmission.
    This is typically called by the server to send enemy states to clients.

    Args:
        enemy (Enemy): The enemy instance whose data is being serialized.

    Returns:
        dict: A dictionary containing the enemy's network-relevant state.
    """
    # Ensure all serialized values are basic Python types for JSON compatibility
    data = {
        'enemy_id': enemy.enemy_id, 
        '_valid_init': enemy._valid_init, 
        
        'pos': (enemy.pos.x, enemy.pos.y), 
        'vel': (enemy.vel.x, enemy.vel.y), 
        'facing_right': enemy.facing_right, 
        
        'state': enemy.state, 
        'current_frame': enemy.current_frame, 
        'last_anim_update': enemy.last_anim_update, 
        
        'current_health': enemy.current_health, 
        'is_dead': enemy.is_dead,
        'death_animation_finished': enemy.death_animation_finished,
        
        'is_attacking': enemy.is_attacking, 
        'attack_type': enemy.attack_type, 
        
        'is_taking_hit': enemy.is_taking_hit, 
        'post_attack_pause_timer': enemy.post_attack_pause_timer, 
        'color_name': getattr(enemy, 'color_name', 'default_color'),

        # Stomp death specific fields
        'is_stomp_dying': getattr(enemy, 'is_stomp_dying', False), # Add getattr for safety
        'stomp_death_start_time': getattr(enemy, 'stomp_death_start_time', 0),
        'original_stomp_facing_right': getattr(enemy, 'original_stomp_facing_right', True),
    }
    return data

def set_enemy_network_data(enemy, network_data): 
    """
    Applies received network data to update the local enemy instance's state.
    This is primarily used on clients to reflect the server's authoritative state for each enemy.

    Args:
        enemy (Enemy): The enemy instance to be updated.
        network_data (dict): The dictionary of enemy state received over the network.
    """
    if network_data is None: return 
    
    enemy._valid_init = network_data.get('_valid_init', enemy._valid_init)
    if not enemy._valid_init:
        if enemy.alive(): enemy.kill()  
        return 

    pos_data = network_data.get('pos')
    if pos_data: enemy.pos.x, enemy.pos.y = pos_data
    
    vel_data = network_data.get('vel')
    if vel_data: enemy.vel.x, enemy.vel.y = vel_data
    
    enemy.facing_right = network_data.get('facing_right', enemy.facing_right) # General facing
    
    enemy.current_health = network_data.get('current_health', enemy.current_health)
    new_is_dead_from_net = network_data.get('is_dead', enemy.is_dead)
    enemy.death_animation_finished = network_data.get('death_animation_finished', enemy.death_animation_finished)

    # Stomp Death Handling
    new_is_stomp_dying_from_net = network_data.get('is_stomp_dying', False)
    if new_is_stomp_dying_from_net and not enemy.is_stomp_dying:
        enemy.is_stomp_dying = True
        enemy.stomp_death_start_time = network_data.get('stomp_death_start_time', pygame.time.get_ticks())
        # Use the server's facing direction at the moment of stomp for visual consistency
        enemy.original_stomp_facing_right = network_data.get('original_stomp_facing_right', enemy.facing_right)
        
        # Client needs to capture its current image (correctly oriented) as the base for scaling.
        # Ensure the enemy's state, frame, and facing are consistent with what the server *would have seen*
        # at the moment it decided to stomp_kill.
        # The server's `get_enemy_network_data` sends `state`, `current_frame`, and `facing_right`.
        # These should be applied *before* this stomp logic if they're part of the same network packet.
        
        # Temporarily set facing_right for image capture to match the server's view at stomp time
        original_facing = enemy.facing_right
        enemy.facing_right = enemy.original_stomp_facing_right
        
        # Animate once to get the correct base frame.
        # Temporarily disable stomp_dying during this animate call to ensure it uses regular animation logic.
        _temp_stomp_flag = enemy.is_stomp_dying
        enemy.is_stomp_dying = False
        enemy.animate() # This should set self.image based on current_frame and new facing_right
        enemy.is_stomp_dying = _temp_stomp_flag # Restore flag

        enemy.original_stomp_death_image = enemy.image.copy()
        enemy.facing_right = original_facing # Restore actual facing direction for subsequent logic if needed

        # Update other death-related states
        enemy.is_dead = True
        enemy.current_health = 0
        enemy.vel.xy = 0,0
        enemy.acc.xy = 0,0
        enemy.death_animation_finished = False # Stomp animation will handle this
        enemy.state = 'stomp_death' # Can be useful for client-side logic, though animation handles visual

    elif not new_is_stomp_dying_from_net and enemy.is_stomp_dying: # Stomp death ended/cancelled
        enemy.is_stomp_dying = False
        enemy.original_stomp_death_image = None
        # If the enemy is now considered alive by the server, the regular death logic below will handle it.

    # Regular Death Status (only if not currently stomp_dying)
    if not enemy.is_stomp_dying:
        if new_is_dead_from_net and not enemy.is_dead: 
            enemy.is_dead = True
            enemy.current_health = 0 
            enemy.set_state('death') 
        elif not new_is_dead_from_net and enemy.is_dead: # Revived
            enemy.is_dead = False
            enemy.death_animation_finished = False 
            if enemy.state in ['death', 'death_nm', 'stomp_death']: # Check stomp_death too
                enemy.set_state('idle') 
        else: 
            enemy.is_dead = new_is_dead_from_net 

    # Combat and Action States (only if not currently stomp_dying)
    if not enemy.is_stomp_dying:
        enemy.is_attacking = network_data.get('is_attacking', enemy.is_attacking)
        enemy.attack_type = network_data.get('attack_type', enemy.attack_type)
        
        new_is_taking_hit_from_net = network_data.get('is_taking_hit', enemy.is_taking_hit)
        if new_is_taking_hit_from_net and not enemy.is_taking_hit: 
            enemy.is_taking_hit = True
            enemy.hit_timer = pygame.time.get_ticks() 
            if enemy.state != 'hit' and not enemy.is_dead: enemy.set_state('hit') 
        elif not new_is_taking_hit_from_net and enemy.is_taking_hit: 
            enemy.is_taking_hit = False
            if enemy.state == 'hit' and not enemy.is_dead: enemy.set_state('idle') 

        enemy.post_attack_pause_timer = network_data.get('post_attack_pause_timer', enemy.post_attack_pause_timer)
        
        # Logical State (if not stomp_dying, as stomp_death state is managed above)
        new_logical_state_from_net = network_data.get('state', enemy.state)
        if enemy.state != 'stomp_death' and enemy.state != new_logical_state_from_net and \
           not (enemy.is_dead and new_logical_state_from_net in ['death', 'death_nm']):
             enemy.set_state(new_logical_state_from_net)
        else: # If state is the same, or it's a death/stomp_death state, just sync animation details
            enemy.current_frame = network_data.get('current_frame', enemy.current_frame)
            enemy.last_anim_update = network_data.get('last_anim_update', enemy.last_anim_update)
    
    enemy.rect.midbottom = (round(enemy.pos.x), round(enemy.pos.y)) 
    
    if enemy._valid_init and enemy.alive(): 
        enemy.animate() # This will correctly handle stomp animation if is_stomp_dying is true

########## START OF FILE: game_setup.py ##########

# game_setup.py
# -*- coding: utf-8 -*-
"""
Handles initialization of game elements, levels, and entities.
version 1.0.0.7 (Added debug prints for projectile group assignment)
"""
import pygame
import random
import traceback
import constants as C
from player import Player
from enemy import Enemy
from items import Chest 
import levels as LevelLoader 
from camera import Camera
from typing import Dict, Optional, Any, Tuple, List 
import importlib 

DEFAULT_LEVEL_MODULE_NAME = "level_default" 

def initialize_game_elements(current_width: int, current_height: int, 
                             for_game_mode: str = "unknown", 
                             existing_sprites_groups: Optional[Dict[str, Any]] = None,
                             map_module_name: Optional[str] = None) -> Optional[Dict[str, Any]]:
    print(f"DEBUG GameSetup: Initializing elements. Mode: '{for_game_mode}', Screen: {current_width}x{current_height}, Requested Map: '{map_module_name}'")

    platform_sprites = pygame.sprite.Group()
    ladder_sprites = pygame.sprite.Group()
    hazard_sprites = pygame.sprite.Group()
    enemy_sprites = pygame.sprite.Group()
    collectible_sprites = pygame.sprite.Group()
    
    # Ensure projectile_sprites and all_sprites are always valid groups
    # If they are passed in and are None, re-initialize them.
    projectile_sprites_from_existing = existing_sprites_groups.get('projectile_sprites') if existing_sprites_groups else None
    all_sprites_from_existing = existing_sprites_groups.get('all_sprites') if existing_sprites_groups else None

    projectile_sprites = projectile_sprites_from_existing if isinstance(projectile_sprites_from_existing, pygame.sprite.Group) else pygame.sprite.Group()
    all_sprites = all_sprites_from_existing if isinstance(all_sprites_from_existing, pygame.sprite.Group) else pygame.sprite.Group()
    
    print(f"DEBUG GameSetup: Initial projectile_sprites: {projectile_sprites} (Count: {len(projectile_sprites.sprites())})")
    print(f"DEBUG GameSetup: Initial all_sprites: {all_sprites} (Count: {len(all_sprites.sprites())})")


    print("DEBUG GameSetup: Clearing sprite groups (except projectile_sprites and all_sprites initially)...")
    player1_to_kill = existing_sprites_groups.get('player1') if existing_sprites_groups else None
    if player1_to_kill and hasattr(player1_to_kill, 'kill'): player1_to_kill.kill()
    player2_to_kill = existing_sprites_groups.get('player2') if existing_sprites_groups else None
    if player2_to_kill and hasattr(player2_to_kill, 'kill'): player2_to_kill.kill()
    current_chest_to_kill = existing_sprites_groups.get('current_chest') if existing_sprites_groups else None
    if current_chest_to_kill and hasattr(current_chest_to_kill, 'kill'): current_chest_to_kill.kill()
    
    # Empty groups that are definitely re-populated by level load or enemy spawn
    for group in [platform_sprites, ladder_sprites, hazard_sprites, enemy_sprites, collectible_sprites]:
        if group is not None: group.empty()
    
    # Selectively empty all_sprites and projectile_sprites to remove old game objects
    # but keep the group instances themselves if they were passed in.
    if all_sprites_from_existing: # if all_sprites was passed in
        for sprite in all_sprites.sprites(): # Remove all existing sprites from it
            if sprite not in [player1_to_kill, player2_to_kill, current_chest_to_kill]: # Avoid double kill
                 # Be careful here if other persistent sprites are needed across modes
                 if not isinstance(sprite, Player): # Don't kill player instances again if they were in all_sprites
                    sprite.kill() 
    else: # all_sprites was not passed in or was None, so it's a fresh group, no need to empty.
        pass
    
    if projectile_sprites_from_existing: # if projectile_sprites was passed in
        projectile_sprites.empty() # Clear any old projectiles
    else: # projectile_sprites was not passed in or was None, fresh group.
        pass

    print(f"DEBUG GameSetup: After clearing, projectile_sprites: {projectile_sprites} (Count: {len(projectile_sprites.sprites())})")
    print(f"DEBUG GameSetup: After clearing, all_sprites: {all_sprites} (Count: {len(all_sprites.sprites())})")

            
    enemy_list: List[Enemy] = [] 

    level_data_loaded_successfully = False
    target_map_name_for_load = map_module_name if map_module_name else DEFAULT_LEVEL_MODULE_NAME
    safe_map_name_for_func = target_map_name_for_load.replace('-', '_').replace(' ', '_')
    expected_level_load_func_name = f"load_map_{safe_map_name_for_func}"
    
    print(f"DEBUG GameSetup: Attempting to load map module 'maps.{target_map_name_for_load}' and call function '{expected_level_load_func_name}'")

    level_background_color = C.LIGHT_BLUE # Default
    local_enemy_spawns_data_list = [] 
    collectible_spawns_data_list = []
    player1_spawn_pos = (100, current_height - (C.TILE_SIZE * 2)) 
    player2_spawn_pos = (150, current_height - (C.TILE_SIZE * 2)) 
    level_pixel_width = current_width
    lvl_min_y_abs = 0
    lvl_max_y_abs = current_height
    ground_level_y = current_height - C.TILE_SIZE
    ground_platform_height = C.TILE_SIZE


    try:
        map_module = importlib.import_module(f"maps.{target_map_name_for_load}")
        load_level_function = getattr(map_module, expected_level_load_func_name)
        level_data_tuple = load_level_function(current_width, current_height)
        
        if level_data_tuple and len(level_data_tuple) >= 11:
            (platform_data_group, ladder_data_group, hazard_data_group, 
             local_enemy_spawns_data_list_loaded, collectible_spawns_data_list_loaded, p1_spawn_tuple, 
             lvl_total_width_pixels_loaded, lvl_min_y_abs_loaded, lvl_max_y_abs_loaded, 
             main_ground_y_reference_loaded, main_ground_height_reference_loaded, 
             *optional_bg_color_list) = level_data_tuple

            platform_sprites.add(platform_data_group.sprites() if platform_data_group else [])
            ladder_sprites.add(ladder_data_group.sprites() if ladder_data_group else [])
            hazard_sprites.add(hazard_data_group.sprites() if hazard_data_group else [])
            
            local_enemy_spawns_data_list = local_enemy_spawns_data_list_loaded if local_enemy_spawns_data_list_loaded else []
            collectible_spawns_data_list = collectible_spawns_data_list_loaded if collectible_spawns_data_list_loaded else []

            player1_spawn_pos = p1_spawn_tuple
            p2_spawn_x = p1_spawn_tuple[0] + C.TILE_SIZE * 1.5
            if p2_spawn_x + (C.TILE_SIZE / 2) > lvl_total_width_pixels_loaded - C.TILE_SIZE: 
                p2_spawn_x = lvl_total_width_pixels_loaded - C.TILE_SIZE * 2.5 
            if p2_spawn_x - (C.TILE_SIZE / 2) < C.TILE_SIZE:
                p2_spawn_x = C.TILE_SIZE * 2.5
            player2_spawn_pos = (p2_spawn_x, p1_spawn_tuple[1])
            
            level_pixel_width = lvl_total_width_pixels_loaded
            lvl_min_y_abs = lvl_min_y_abs_loaded
            lvl_max_y_abs = lvl_max_y_abs_loaded
            ground_level_y = main_ground_y_reference_loaded
            ground_platform_height = main_ground_height_reference_loaded
            
            if optional_bg_color_list and isinstance(optional_bg_color_list[0], (tuple, list)) and len(optional_bg_color_list[0]) == 3:
                level_background_color = optional_bg_color_list[0]
                
            print(f"DEBUG GameSetup: Level geometry loaded. Width: {level_pixel_width}, MinY: {lvl_min_y_abs}, MaxY: {lvl_max_y_abs}, P1 Spawn: {player1_spawn_pos}, P2 Spawn: {player2_spawn_pos}, BG Color: {level_background_color}")
            level_data_loaded_successfully = True
        else:
            print(f"CRITICAL GameSetup Error: Map '{target_map_name_for_load}' function '{expected_level_load_func_name}' did not return enough data elements.")

    except ImportError:
        print(f"CRITICAL GameSetup Error: Could not import map module 'maps.{target_map_name_for_load}'."); traceback.print_exc()
    except AttributeError:
        print(f"CRITICAL GameSetup Error: Map module 'maps.{target_map_name_for_load}' no func '{expected_level_load_func_name}'."); traceback.print_exc()
    except Exception as e:
        print(f"CRITICAL GameSetup Error: Unexpected error loading map '{target_map_name_for_load}': {e}"); traceback.print_exc()

    if not level_data_loaded_successfully:
        if target_map_name_for_load != DEFAULT_LEVEL_MODULE_NAME:
            print(f"GAME_SETUP Warning: Failed to load map '{target_map_name_for_load}'. Trying default '{DEFAULT_LEVEL_MODULE_NAME}'.")
            return initialize_game_elements(current_width, current_height, for_game_mode, existing_sprites_groups, DEFAULT_LEVEL_MODULE_NAME)
        else:
            print(f"GAME_SETUP FATAL: Default map '{DEFAULT_LEVEL_MODULE_NAME}' also failed. Cannot proceed."); return None

    # Add newly loaded map sprites to the main all_sprites group
    all_sprites.add(platform_sprites.sprites(), ladder_sprites.sprites(), hazard_sprites.sprites())
    
    player1, player2 = None, None 

    if for_game_mode in ["host", "couch_play", "join_lan", "join_ip"]:
        p1_id_val = "p1_host" if for_game_mode == "host" else \
                 "p1_couch" if for_game_mode == "couch_play" else \
                 "p1_client_ph" # Placeholder ID for client's local P1 representation
        player1 = Player(player1_spawn_pos[0], player1_spawn_pos[1], player_id=1) # Use int 1 for P1
        if not player1._valid_init: print(f"CRITICAL GameSetup: P1 init failed."); return None
        all_sprites.add(player1)

    if for_game_mode == "couch_play":
        player2 = Player(player2_spawn_pos[0], player2_spawn_pos[1], player_id=2) # Use int 2 for P2
        if not player2._valid_init: print(f"CRITICAL GameSetup: P2 (couch) init failed."); return None
        all_sprites.add(player2)
    elif for_game_mode in ["join_lan", "join_ip"]: 
        # For client, P2 is the locally controlled player. P1 is remote.
        player2 = Player(player2_spawn_pos[0], player2_spawn_pos[1], player_id=2) # Use int 2 for P2
        if not player2._valid_init: print(f"CRITICAL GameSetup: P2 (client) init failed."); return None
        all_sprites.add(player2)

    print(f"DEBUG GameSetup: Before setting proj groups for P1: projectile_sprites is {('set' if projectile_sprites is not None else 'None')}, all_sprites is {('set' if all_sprites is not None else 'None')}")
    if player1 and hasattr(player1, 'set_projectile_group_references'): 
        player1.set_projectile_group_references(projectile_sprites, all_sprites)
    
    print(f"DEBUG GameSetup: Before setting proj groups for P2: projectile_sprites is {('set' if projectile_sprites is not None else 'None')}, all_sprites is {('set' if all_sprites is not None else 'None')}")
    if player2 and hasattr(player2, 'set_projectile_group_references'): 
        player2.set_projectile_group_references(projectile_sprites, all_sprites)


    if (for_game_mode == "host" or for_game_mode == "couch_play") and local_enemy_spawns_data_list:
        print(f"DEBUG GameSetup: Spawning {len(local_enemy_spawns_data_list)} enemies...")
        from enemy import Enemy # Keep import local if only used here
        for i, spawn_info in enumerate(local_enemy_spawns_data_list):
            try:
                patrol_rect = pygame.Rect(spawn_info['patrol']) if spawn_info.get('patrol') else None
                # Ensure Enemy constructor uses correct parameter for color
                # Assuming Enemy takes 'start_x', 'start_y', 'patrol_area', 'enemy_id'
                # and 'color_name' is handled internally or via another param.
                # The current Enemy constructor takes 'start_x, start_y, patrol_area=None, enemy_id=None'
                # It seems enemy color is chosen randomly inside Enemy.__init__
                enemy = Enemy(start_x=spawn_info['pos'][0], start_y=spawn_info['pos'][1], 
                              patrol_area=patrol_rect, enemy_id=i) # Pass index as ID
                if enemy._valid_init: 
                    all_sprites.add(enemy); enemy_sprites.add(enemy); enemy_list.append(enemy)
                else:
                    print(f"Warning GameSetup: Enemy {i} at {spawn_info['pos']} failed _valid_init.")
            except Exception as e: print(f"Error spawning enemy {i} with data {spawn_info}: {e}"); traceback.print_exc()
    
    current_chest = None
    if Chest and (for_game_mode == "host" or for_game_mode == "couch_play"): 
        if collectible_spawns_data_list:
            for item_data in collectible_spawns_data_list:
                if item_data.get('type') == 'chest':
                    try:
                        chest_midbottom_x, chest_midbottom_y = item_data['pos']
                        current_chest = Chest(chest_midbottom_x, chest_midbottom_y) 
                        if current_chest._valid_init:
                            all_sprites.add(current_chest); collectible_sprites.add(current_chest)
                            print(f"DEBUG GameSetup: Chest spawned from level data at {current_chest.rect.topleft}")
                            break 
                        else: print(f"Warning GameSetup: Chest from level data at {item_data['pos']} failed _valid_init.")
                    except Exception as e: print(f"Error spawning chest from level data: {e}")
        
        if not current_chest: 
            print("DEBUG GameSetup: No chest from level data, attempting random spawn on ledge...")
            current_chest = spawn_chest(platform_sprites, ground_level_y) 
            if current_chest:
                all_sprites.add(current_chest); collectible_sprites.add(current_chest)
                print(f"DEBUG GameSetup: Random chest spawned at {current_chest.rect.topleft}")
            else: print("DEBUG GameSetup: Random chest spawn also failed or returned None.")


    camera_instance = Camera(level_pixel_width, lvl_min_y_abs, lvl_max_y_abs, current_width, current_height)

    print(f"DEBUG GameSetup: Final counts before return - AllSprites: {len(all_sprites.sprites())}, Projectiles: {len(projectile_sprites.sprites())}")

    game_elements_dict = {
        "player1": player1, "player2": player2, "camera": camera_instance,
        "current_chest": current_chest, "enemy_list": enemy_list,
        "platform_sprites": platform_sprites, "ladder_sprites": ladder_sprites,
        "hazard_sprites": hazard_sprites, "enemy_sprites": enemy_sprites,
        "collectible_sprites": collectible_sprites, "projectile_sprites": projectile_sprites,
        "all_sprites": all_sprites,
        "level_pixel_width": level_pixel_width, "level_min_y_absolute": lvl_min_y_abs,
        "level_max_y_absolute": lvl_max_y_abs, "ground_level_y": ground_level_y,
        "ground_platform_height": ground_platform_height,
        "player1_spawn_pos": player1_spawn_pos, "player2_spawn_pos": player2_spawn_pos,
        "enemy_spawns_data_cache": local_enemy_spawns_data_list, 
        "level_background_color": level_background_color
    }
    return game_elements_dict

# RENAMED FUNCTION from spawn_chest_on_ledge to spawn_chest
def spawn_chest(all_platform_sprites_group: pygame.sprite.Group, main_ground_y_surface_level: int) -> Optional[Chest]:
    """
    Spawns a chest ONLY on platforms explicitly marked as 'ledge'.
    """
    if Chest is None: print("Warning GS (spawn_chest): Chest class is None, cannot spawn."); return None
    try:
        ledge_platforms = [p for p in all_platform_sprites_group if hasattr(p, 'platform_type') and p.platform_type == "ledge" and p.rect.width > C.TILE_SIZE * 1.25]
        if not ledge_platforms: print("Warning GS (spawn_chest): No 'ledge' platforms for chest."); return None
        
        moderate_y_min = main_ground_y_surface_level - C.TILE_SIZE * 4 
        moderate_y_max = main_ground_y_surface_level + C.TILE_SIZE * 1 
        candidate_platforms = [p for p in ledge_platforms if moderate_y_min <= p.rect.top <= moderate_y_max]
        if not candidate_platforms: candidate_platforms = list(ledge_platforms)
        if not candidate_platforms: print("Warning GS (spawn_chest): No suitable candidate ledges."); return None

        chosen_platform = random.choice(candidate_platforms)
        inset = C.TILE_SIZE * 0.5 
        min_cx, max_cx = chosen_platform.rect.left + inset, chosen_platform.rect.right - inset
        cx = random.randint(int(min_cx), int(max_cx)) if min_cx < max_cx else chosen_platform.rect.centerx
        cy = chosen_platform.rect.top 
        
        print(f"DEBUG GS (spawn_chest): Attempting to spawn chest at calculated pos: ({cx},{cy}) on platform {chosen_platform.rect}")
        new_chest = Chest(cx, cy) # Chest constructor expects midbottom X, Y for its rect.bottom
        if hasattr(new_chest, '_valid_init') and new_chest._valid_init:
            print(f"DEBUG GS (spawn_chest): Chest spawned on ledge at {new_chest.rect.midbottom}")
            return new_chest
        else:
            print(f"Warning GS (spawn_chest): New chest created at ({cx},{cy}) failed _valid_init.")
    except Exception as e:
        print(f"Error in spawn_chest: {e}"); traceback.print_exc()
    return None

########## START OF FILE: game_state_manager.py ##########

########## START OF FILE: game_state_manager.py ##########

# game_state_manager.py
# -*- coding: utf-8 -*-
"""
version 1.0.0.3 (Players always update from network state on client; enemy color sync)
Manages game state, including reset and network synchronization.
"""
import pygame
import traceback
import os # Added for os.path.join
from game_setup import spawn_chest # For respawning chest
from enemy import Enemy # For creating new enemies on client
from items import Chest # For type checking and creating new chests on client
from projectiles import Fireball # For creating projectiles on client
from assets import load_all_player_animations # Added for reloading enemy animations
import constants as C # Added for fallback color C.BLUE

def reset_game_state(game_elements):
    """Resets the state of players, enemies, and collectibles."""
    print("DEBUG GSM: --- Resetting Platformer Game State ---") # DEBUG
    player1 = game_elements.get("player1")
    player2 = game_elements.get("player2")
    enemy_list = game_elements.get("enemy_list", [])
    current_chest = game_elements.get("current_chest")
    player1_spawn_pos = game_elements.get("player1_spawn_pos")
    player2_spawn_pos = game_elements.get("player2_spawn_pos")
    all_sprites = game_elements.get("all_sprites")
    enemy_sprites = game_elements.get("enemy_sprites")
    collectible_sprites = game_elements.get("collectible_sprites")
    projectile_sprites = game_elements.get("projectile_sprites")
    camera = game_elements.get("camera")

    if player1 and hasattr(player1, 'reset_state'):
        print(f"DEBUG GSM: Resetting P1 at {player1_spawn_pos}") # DEBUG
        player1.reset_state(player1_spawn_pos)
        if not player1.alive() and player1._valid_init: all_sprites.add(player1) # Ensure in group
        print("DEBUG GSM: P1 Reset complete.") # DEBUG
    if player2 and hasattr(player2, 'reset_state'):
        print(f"DEBUG GSM: Resetting P2 at {player2_spawn_pos}") # DEBUG
        player2.reset_state(player2_spawn_pos)
        if not player2.alive() and player2._valid_init: all_sprites.add(player2) # Ensure in group
        print("DEBUG GSM: P2 Reset complete.") # DEBUG

    for enemy_instance in enemy_list:
        if hasattr(enemy_instance, 'reset'):
            enemy_instance.reset()
            if enemy_instance._valid_init and not enemy_instance.alive(): # If reset somehow made it not alive but valid
                all_sprites.add(enemy_instance) # Re-add to ensure it's drawn/updated if it revives
                enemy_sprites.add(enemy_instance)
    print(f"DEBUG GSM: {len(enemy_list)} enemies processed for reset.") # DEBUG

    if projectile_sprites:
        for proj in projectile_sprites: proj.kill()
        projectile_sprites.empty()
        print("DEBUG GSM: Projectiles cleared.") # DEBUG


    if current_chest and current_chest.alive(): current_chest.kill()
    print(f"DEBUG GSM: Existing chest killed (if any).") # DEBUG


    new_chest = spawn_chest(game_elements.get("platform_sprites"), game_elements.get("ground_level_y"))
    if new_chest:
        all_sprites.add(new_chest)
        collectible_sprites.add(new_chest)
        game_elements["current_chest"] = new_chest # Update the reference in game_elements
        print("DEBUG GSM: Chest respawned.") # DEBUG
    else:
        game_elements["current_chest"] = None # Ensure it's None if spawn fails
        print("DEBUG GSM: Failed to respawn chest or Chest class not available.") # DEBUG

    if camera: camera.set_pos(0,0) # Reset camera position to default
    print("DEBUG GSM: Camera position reset.") # DEBUG

    print("DEBUG GSM: --- Game State Reset Finished ---\n") # DEBUG
    return new_chest # Return the new chest so main can update its reference if needed

def get_network_game_state(game_elements):
    """Gathers all relevant game state for network transmission."""
    # print("DEBUG GSM (get_network_game_state): Gathering state...") # DEBUG
    player1 = game_elements.get("player1")
    player2 = game_elements.get("player2")
    enemy_list = game_elements.get("enemy_list", [])
    current_chest = game_elements.get("current_chest")
    projectile_sprites = game_elements.get("projectile_sprites", pygame.sprite.Group()) # Default to empty group

    state = {'p1': None, 'p2': None, 'enemies': {}, 'chest': None, 'game_over': False, 'projectiles': []}

    if player1 and hasattr(player1, 'get_network_data'):
        state['p1'] = player1.get_network_data()
        # print(f"DEBUG GSM (get_network_game_state): P1 data: {state['p1']}") # DEBUG
    if player2 and hasattr(player2, 'get_network_data'):
        state['p2'] = player2.get_network_data()
        # print(f"DEBUG GSM (get_network_game_state): P2 data: {state['p2']}") # DEBUG


    # Include enemies that are alive or in the process of dying (animation not finished)
    for enemy in enemy_list:
        if hasattr(enemy, 'enemy_id') and hasattr(enemy, 'get_network_data'):
            if enemy.alive() or (enemy.is_dead and not enemy.death_animation_finished):
                 state['enemies'][str(enemy.enemy_id)] = enemy.get_network_data()

    if current_chest and current_chest.alive() and hasattr(current_chest, 'rect'):
        state['chest'] = {
            'pos': (current_chest.rect.centerx, current_chest.rect.centery),
            'is_collected': getattr(current_chest, 'is_collected', False)
        }

    # Determine game_over based on P1's state (typical for host/P1 centric games)
    p1_truly_gone = True # Assume P1 is gone
    if player1 and player1._valid_init: # If P1 was properly initialized
        if player1.alive(): # Is in sprite groups (could be dead but animating)
            if hasattr(player1, 'is_dead') and player1.is_dead: # Logically dead
                if hasattr(player1, 'death_animation_finished') and not player1.death_animation_finished:
                    p1_truly_gone = False # Still animating death, so not truly gone for game over
            else: # Alive and not dead
                p1_truly_gone = False
    state['game_over'] = p1_truly_gone # True if P1 is invalid OR dead AND death animation finished

    state['projectiles'] = [proj.get_network_data() for proj in projectile_sprites if hasattr(proj, 'get_network_data')]
    # print(f"DEBUG GSM (get_network_game_state): Final state to send (P1 Pos: {state['p1'].get('pos') if state['p1'] else 'N/A'}, P2 Pos: {state['p2'].get('pos') if state['p2'] else 'N/A'}, Num Enemies: {len(state['enemies'])})") # DEBUG
    return state

def set_network_game_state(network_state_data, game_elements, client_player_id=None): # client_player_id kept for potential future use
    """
    Applies received network state to local game elements.
    On the client, this updates both remote players and the client's own player
    to reflect the server's authoritative state.
    """
    # print(f"DEBUG GSM (set_network_game_state): Applying network state. Client ID: {client_player_id}") # DEBUG
    # if network_state_data: # DEBUG
        # print(f"DEBUG GSM (set_network_game_state): Received P1 data: {network_state_data.get('p1')}") # DEBUG
        # print(f"DEBUG GSM (set_network_game_state): Received P2 data: {network_state_data.get('p2')}") # DEBUG
    # else: # DEBUG
        # print("DEBUG GSM (set_network_game_state): network_state_data is None.") # DEBUG
        # return # DEBUG

    player1 = game_elements.get("player1")
    player2 = game_elements.get("player2")
    enemy_list = game_elements.get("enemy_list", []) 
    current_chest = game_elements.get("current_chest") 
    all_sprites = game_elements.get("all_sprites")
    enemy_sprites = game_elements.get("enemy_sprites")
    collectible_sprites = game_elements.get("collectible_sprites")
    projectile_sprites = game_elements.get("projectile_sprites", pygame.sprite.Group())
    enemy_spawns_data_cache = game_elements.get("enemy_spawns_data_cache", [])


    # Update Player 1 state from network data
    if player1 and 'p1' in network_state_data and network_state_data['p1'] and hasattr(player1, 'set_network_data'):
        # print(f"DEBUG GSM (set_network_game_state): Applying state to P1. Current P1 valid: {player1._valid_init}, alive: {player1.alive() if hasattr(player1, 'alive') else 'N/A'}") # DEBUG
        p1_data = network_state_data['p1']
        # print(f"DEBUG GSM (set_network_game_state): P1 network data being applied: pos={p1_data.get('pos')}, state={p1_data.get('state')}, valid={p1_data.get('_valid_init')}") # DEBUG
        player1.set_network_data(p1_data)
        # print(f"DEBUG GSM (set_network_game_state): P1 after set_network_data. Valid: {player1._valid_init}, Alive: {player1.alive()}, Pos: {player1.pos if hasattr(player1, 'pos') else 'N/A'}") # DEBUG
        if player1._valid_init and not player1.is_dead and not player1.alive():
             # print(f"DEBUG GSM (set_network_game_state): P1 became valid/alive but not in all_sprites. Adding.") # DEBUG
             all_sprites.add(player1)
        # elif not player1._valid_init and player1.alive(): # Should be handled by player1.set_network_data
            # print(f"DEBUG GSM (set_network_game_state): P1 became INvalid but IS in all_sprites. kill() should have been called.") #DEBUG

    # Update Player 2 state from network data
    if player2 and 'p2' in network_state_data and network_state_data['p2'] and hasattr(player2, 'set_network_data'):
        # print(f"DEBUG GSM (set_network_game_state): Applying state to P2. Current P2 valid: {player2._valid_init}, alive: {player2.alive() if hasattr(player2, 'alive') else 'N/A'}") # DEBUG
        p2_data = network_state_data['p2']
        # print(f"DEBUG GSM (set_network_game_state): P2 network data being applied: pos={p2_data.get('pos')}, state={p2_data.get('state')}, valid={p2_data.get('_valid_init')}") # DEBUG
        player2.set_network_data(p2_data)
        # print(f"DEBUG GSM (set_network_game_state): P2 after set_network_data. Valid: {player2._valid_init}, Alive: {player2.alive()}, Pos: {player2.pos if hasattr(player2, 'pos') else 'N/A'}") # DEBUG
        if player2._valid_init and not player2.is_dead and not player2.alive():
             # print(f"DEBUG GSM (set_network_game_state): P2 became valid/alive but not in all_sprites. Adding.") # DEBUG
             all_sprites.add(player2)
        # elif not player2._valid_init and player2.alive(): # Should be handled by player2.set_network_data
            # print(f"DEBUG GSM (set_network_game_state): P2 became INvalid but IS in all_sprites. kill() should have been called.") #DEBUG


    # Enemy state synchronization (critical for clients)
    if 'enemies' in network_state_data:
        received_enemy_data_map = network_state_data['enemies']
        # print(f"DEBUG GSM (set_network_game_state): Syncing {len(received_enemy_data_map)} enemies from network.") # DEBUG
        current_client_enemies_map = {str(enemy.enemy_id): enemy for enemy in enemy_list if hasattr(enemy, 'enemy_id')}

        for enemy_id_str, enemy_data_from_server in received_enemy_data_map.items():
            enemy_id_int = int(enemy_id_str)
            # print(f"DEBUG GSM (set_network_game_state): Processing enemy ID {enemy_id_str} from network. Data: {enemy_data_from_server.get('pos')}, valid: {enemy_data_from_server.get('_valid_init')}") # DEBUG

            if enemy_data_from_server.get('_valid_init', False): 
                if enemy_id_str in current_client_enemies_map: 
                    client_enemy = current_client_enemies_map[enemy_id_str]
                    # print(f"DEBUG GSM (set_network_game_state): Updating existing enemy ID {enemy_id_str}.") # DEBUG
                    if hasattr(client_enemy, 'set_network_data'):
                        client_enemy.set_network_data(enemy_data_from_server)
                        if client_enemy._valid_init and not client_enemy.alive():
                            if (client_enemy.is_dead and not client_enemy.death_animation_finished) or \
                               (not client_enemy.is_dead):
                                 # print(f"DEBUG GSM (set_network_game_state): Re-adding enemy {enemy_id_str} to sprite groups.") # DEBUG
                                 all_sprites.add(client_enemy); enemy_sprites.add(client_enemy)
                else: 
                    # print(f"DEBUG GSM (set_network_game_state): Creating NEW enemy ID {enemy_id_str}.") # DEBUG
                    try:
                        spawn_pos_e_default = enemy_data_from_server.get('pos', (0,0)) 
                        patrol_area_e_obj = None
                        if enemy_id_int < len(enemy_spawns_data_cache):
                            original_spawn_info = enemy_spawns_data_cache[enemy_id_int]
                            spawn_pos_e_default = original_spawn_info.get('pos', spawn_pos_e_default)
                            patrol_data_from_level = original_spawn_info.get('patrol')
                            if patrol_data_from_level:
                                try: patrol_area_e_obj = pygame.Rect(patrol_data_from_level)
                                except TypeError: print(f"Client: Invalid patrol data from cache for new enemy {enemy_id_int}.")
                        else:
                            print(f"Client: No original spawn data in cache for new enemy_id {enemy_id_int}.")

                        new_enemy_instance = Enemy(spawn_pos_e_default[0], spawn_pos_e_default[1],
                                             patrol_area=patrol_area_e_obj, enemy_id=enemy_id_int)
                        # print(f"DEBUG GSM (set_network_game_state): New enemy {enemy_id_str} created. Valid: {new_enemy_instance._valid_init}") # DEBUG


                        if new_enemy_instance._valid_init:
                            server_color_name = enemy_data_from_server.get('color_name')
                            if server_color_name and hasattr(new_enemy_instance, 'color_name') and new_enemy_instance.color_name != server_color_name:
                                # print(f"DEBUG GSM (set_network_game_state): Enemy {enemy_id_str} color mismatch (local '{new_enemy_instance.color_name}', net '{server_color_name}'). Reloading animations.") # DEBUG
                                new_enemy_instance.color_name = server_color_name
                                enemy_asset_folder = os.path.join('characters', server_color_name)
                                new_enemy_instance.animations = load_all_player_animations(
                                    relative_asset_folder=enemy_asset_folder
                                )
                                if new_enemy_instance.animations is None:
                                    print(f"Client CRITICAL: Failed to reload animations for enemy {enemy_id_int} with server color {server_color_name} from '{enemy_asset_folder}'")
                                    new_enemy_instance._valid_init = False
                                    if hasattr(C, 'BLUE'):
                                        new_enemy_instance.image = pygame.Surface((30, 40)).convert_alpha()
                                        new_enemy_instance.image.fill(C.BLUE)
                                        new_enemy_instance.rect = new_enemy_instance.image.get_rect(midbottom=(spawn_pos_e_default[0], spawn_pos_e_default[1]))
                                else:
                                    initial_idle_animation_new_color = new_enemy_instance.animations.get('idle')
                                    if initial_idle_animation_new_color and len(initial_idle_animation_new_color) > 0:
                                        new_enemy_instance.image = initial_idle_animation_new_color[0]
                                    else:
                                        if hasattr(C, 'BLUE'):
                                            new_enemy_instance.image = pygame.Surface((30, 40)).convert_alpha()
                                            new_enemy_instance.image.fill(C.BLUE)
                                    new_enemy_instance.rect = new_enemy_instance.image.get_rect(midbottom=(spawn_pos_e_default[0], spawn_pos_e_default[1]))
                                # print(f"DEBUG GSM (set_network_game_state): Enemy {enemy_id_str} animations reloaded. New valid: {new_enemy_instance._valid_init}") # DEBUG


                        if new_enemy_instance._valid_init:
                            new_enemy_instance.set_network_data(enemy_data_from_server)
                            all_sprites.add(new_enemy_instance); enemy_sprites.add(new_enemy_instance)
                            enemy_list.append(new_enemy_instance)
                            # print(f"DEBUG GSM (set_network_game_state): New enemy {enemy_id_str} added to lists and groups.") # DEBUG
                        # else: # DEBUG
                            # print(f"DEBUG GSM (set_network_game_state): New enemy {enemy_id_str} was NOT valid after creation/color sync.") # DEBUG
                    except Exception as e:
                        print(f"Client: Error creating new instance of enemy {enemy_id_str}: {e}")
                        traceback.print_exc()

            elif enemy_id_str in current_client_enemies_map: # Server says enemy invalid, but client has it
                enemy_to_remove = current_client_enemies_map[enemy_id_str]
                # print(f"DEBUG GSM (set_network_game_state): Server marked enemy {enemy_id_str} as invalid. Removing from client.") # DEBUG
                if enemy_to_remove.alive(): enemy_to_remove.kill()
                if enemy_to_remove in enemy_list: enemy_list.remove(enemy_to_remove)

        server_enemy_ids_present_in_message = set(received_enemy_data_map.keys())
        client_enemy_ids_to_remove_fully = set(current_client_enemies_map.keys()) - server_enemy_ids_present_in_message
        for removed_id_str_fully in client_enemy_ids_to_remove_fully:
            if removed_id_str_fully in current_client_enemies_map:
                enemy_to_remove_fully = current_client_enemies_map[removed_id_str_fully]
                # print(f"DEBUG GSM (set_network_game_state): Enemy {removed_id_str_fully} not in server message. Removing from client.") # DEBUG
                if enemy_to_remove_fully.alive(): enemy_to_remove_fully.kill()
                if enemy_to_remove_fully in enemy_list: enemy_list.remove(enemy_to_remove_fully)


    # Chest state synchronization
    if 'chest' in network_state_data:
        chest_data_from_server = network_state_data['chest']
        # print(f"DEBUG GSM (set_network_game_state): Chest data from server: {chest_data_from_server}") # DEBUG
        if chest_data_from_server and Chest is not None: 
            chest_pos_center_server = chest_data_from_server.get('pos')
            chest_is_collected_server = chest_data_from_server.get('is_collected', False)

            if chest_is_collected_server: 
                if current_chest and current_chest.alive(): current_chest.kill()
                game_elements["current_chest"] = None 
                # print(f"DEBUG GSM (set_network_game_state): Server says chest collected. Cleared local chest.") # DEBUG
            elif chest_pos_center_server: 
                if not current_chest or not current_chest.alive(): 
                    # print(f"DEBUG GSM (set_network_game_state): Client needs to create chest at {chest_pos_center_server}.") # DEBUG
                    if current_chest: current_chest.kill() 
                    try:
                        temp_chest_surf_for_height = Chest(0,0).image
                        temp_chest_height_approx = temp_chest_surf_for_height.get_height() if temp_chest_surf_for_height else 30
                        chest_spawn_x_midbottom = chest_pos_center_server[0]
                        chest_spawn_y_midbottom = chest_pos_center_server[1] + temp_chest_height_approx / 2
                        new_chest_instance_client = Chest(chest_spawn_x_midbottom, chest_spawn_y_midbottom)
                        if hasattr(new_chest_instance_client, '_valid_init') and new_chest_instance_client._valid_init:
                            all_sprites.add(new_chest_instance_client)
                            collectible_sprites.add(new_chest_instance_client)
                            game_elements["current_chest"] = new_chest_instance_client
                            if hasattr(game_elements["current_chest"], 'is_collected'):
                                game_elements["current_chest"].is_collected = False
                            # print(f"DEBUG GSM (set_network_game_state): New client chest created: {new_chest_instance_client}") # DEBUG
                        else:
                            game_elements["current_chest"] = None
                            # print(f"DEBUG GSM (set_network_game_state): New client chest FAILED init.") # DEBUG
                    except Exception as e:
                        # print(f"DEBUG GSM (set_network_game_state): Exception creating client chest: {e}") # DEBUG
                        game_elements["current_chest"] = None
                elif current_chest: # Client has a chest, server has one uncollected - ensure local not marked collected
                    # print(f"DEBUG GSM (set_network_game_state): Client and server both have uncollected chest. Ensuring local is_collected is False.") # DEBUG
                    if hasattr(current_chest, 'is_collected'):
                        current_chest.is_collected = False

        elif not network_state_data.get('chest'): # Server says no chest
            if current_chest and current_chest.alive(): current_chest.kill()
            game_elements["current_chest"] = None
            # print(f"DEBUG GSM (set_network_game_state): Server says NO chest. Cleared local chest.") # DEBUG


    # Projectile state synchronization
    if 'projectiles' in network_state_data:
        received_proj_data_map = {p_data['id']: p_data for p_data in network_state_data.get('projectiles', []) if 'id' in p_data}
        # print(f"DEBUG GSM (set_network_game_state): Syncing {len(received_proj_data_map)} projectiles from network.") # DEBUG
        current_client_proj_map = {p.projectile_id: p for p in projectile_sprites if hasattr(p, 'projectile_id')}

        for proj_id_server, proj_data_server in received_proj_data_map.items():
            # print(f"DEBUG GSM (set_network_game_state): Processing projectile ID {proj_id_server} from network. Pos: {proj_data_server.get('pos')}") # DEBUG
            if proj_id_server in current_client_proj_map:
                existing_proj_client = current_client_proj_map[proj_id_server]
                if hasattr(existing_proj_client, 'set_network_data'):
                    existing_proj_client.set_network_data(proj_data_server)
            else: # New projectile for this client
                owner_instance_client = None
                owner_id_from_server = proj_data_server.get('owner_id')
                if owner_id_from_server is not None:
                    if owner_id_from_server == 1 and player1: owner_instance_client = player1
                    elif owner_id_from_server == 2 and player2: owner_instance_client = player2
                
                # print(f"DEBUG GSM (set_network_game_state): Attempting to create new projectile {proj_id_server}. Owner ID: {owner_id_from_server}, Owner instance client-side: {owner_instance_client}") # DEBUG


                if owner_instance_client and 'pos' in proj_data_server and 'vel' in proj_data_server:
                    direction_vec_server = pygame.math.Vector2(proj_data_server['vel'])
                    if direction_vec_server.length_squared() == 0:
                        direction_vec_server = pygame.math.Vector2(1,0) if owner_instance_client.facing_right else pygame.math.Vector2(-1,0)

                    try:
                        new_proj_client = Fireball(proj_data_server['pos'][0], proj_data_server['pos'][1],
                                             direction_vec_server, owner_instance_client)
                        new_proj_client.projectile_id = proj_id_server
                        if hasattr(new_proj_client, 'set_network_data'):
                            new_proj_client.set_network_data(proj_data_server)
                        projectile_sprites.add(new_proj_client)
                        all_sprites.add(new_proj_client)
                        # print(f"DEBUG GSM (set_network_game_state): New projectile {proj_id_server} created and added.") # DEBUG
                    except Exception as e:
                        print(f"DEBUG GSM (set_network_game_state): Error creating new projectile {proj_id_server}: {e}") # DEBUG
                        traceback.print_exc()
                # else: # DEBUG
                    # print(f"DEBUG GSM (set_network_game_state): Cannot create projectile {proj_id_server} - owner missing or data incomplete.") # DEBUG


        client_proj_ids_to_remove = set(current_client_proj_map.keys()) - set(received_proj_data_map.keys())
        for removed_proj_id_client in client_proj_ids_to_remove:
            if removed_proj_id_client in current_client_proj_map:
                proj_to_kill_client = current_client_proj_map[removed_proj_id_client]
                # print(f"DEBUG GSM (set_network_game_state): Projectile {removed_proj_id_client} not in server message. Removing from client.") # DEBUG
                if proj_to_kill_client.alive(): proj_to_kill_client.kill()
    # print(f"DEBUG GSM (set_network_game_state): Network state application finished. P1 alive: {player1.alive() if player1 else 'N/A'}, P2 alive: {player2.alive() if player2 else 'N/A'}") # DEBUG

########## END OF FILE: game_state_manager.py ##########

########## START OF FILE: game_ui.py ##########

# game_ui.py
# -*- coding: utf-8 -*-
## version 1.0.0.4 (Added select_map_dialog)
"""
Functions for drawing User Interface elements like health bars, player HUDs,
main menus, input dialogs, and the main game scene.
"""
import pygame
import time 
import os # Needed for listing map files
import constants as C 
from typing import Dict, Optional, Any, List # Added List

# --- (PYPERCLIP_AVAILABLE_UI_MODULE and SCRAP_INITIALIZED_UI_MODULE setup remains the same) ---
PYPERCLIP_AVAILABLE_UI_MODULE = False
try:
    import pyperclip
    PYPERCLIP_AVAILABLE_UI_MODULE = True
except ImportError:
    pass 

SCRAP_INITIALIZED_UI_MODULE = False 

def check_pygame_scrap_init_status():
    global SCRAP_INITIALIZED_UI_MODULE
    try:
        if pygame.scrap.get_init(): SCRAP_INITIALIZED_UI_MODULE = True
        else: SCRAP_INITIALIZED_UI_MODULE = False
    except (AttributeError, pygame.error): SCRAP_INITIALIZED_UI_MODULE = False
    return SCRAP_INITIALIZED_UI_MODULE

# --- (draw_health_bar, draw_player_hud, draw_platformer_scene_on_surface, show_main_menu, get_server_ip_input_dialog remain the same as your provided version) ---
# --- Health Bar Drawing Function ---
def draw_health_bar(surface: pygame.Surface, x: int, y: int, 
                    width: int, height: int, 
                    current_hp: float, max_hp: float):
    if max_hp <= 0: return
    current_hp_clamped = max(0, min(current_hp, max_hp))
    bar_width = max(1, int(width)); bar_height = max(1, int(height))
    health_ratio = current_hp_clamped / max_hp
    color_red = getattr(C, 'RED', (255,0,0)); color_green = getattr(C, 'GREEN', (0,255,0))
    color_dark_gray = getattr(C, 'DARK_GRAY', (50,50,50)); color_black = getattr(C, 'BLACK', (0,0,0))
    try: health_color = pygame.Color(color_red).lerp(pygame.Color(color_green), health_ratio)
    except AttributeError:
        r = int(color_red[0] * (1 - health_ratio) + color_green[0] * health_ratio)
        g = int(color_red[1] * (1 - health_ratio) + color_green[1] * health_ratio)
        b = int(color_red[2] * (1 - health_ratio) + color_green[2] * health_ratio)
        health_color = (max(0, min(255, r)), max(0, min(255, g)), max(0, min(255, b)))
    background_rect = pygame.Rect(x, y, bar_width, bar_height)
    pygame.draw.rect(surface, color_dark_gray, background_rect)
    health_fill_width = int(bar_width * health_ratio)
    if health_fill_width > 0: pygame.draw.rect(surface, health_color, pygame.Rect(x, y, health_fill_width, bar_height))
    pygame.draw.rect(surface, color_black, background_rect, 1) 

def draw_player_hud(surface: pygame.Surface, x: int, y: int, player_instance: Any, 
                    player_number: int, hud_font_obj: Optional[pygame.font.Font]):
    if not player_instance or not hasattr(player_instance, 'current_health') or not hasattr(player_instance, 'max_health'): return
    player_label_text = f"P{player_number}"; label_height_offset = 0; color_white = getattr(C, 'WHITE', (255,255,255))
    if hud_font_obj: 
        try:
            label_surface = hud_font_obj.render(player_label_text, True, color_white) 
            surface.blit(label_surface, (x, y)); label_height_offset = label_surface.get_height() 
        except Exception as e: label_height_offset = getattr(hud_font_obj, 'get_height', lambda: 20)()
    health_bar_pos_x = x; health_bar_pos_y = y + label_height_offset + 5  
    hud_health_bar_width = getattr(C, 'HUD_HEALTH_BAR_WIDTH', getattr(C, 'HEALTH_BAR_WIDTH', 50) * 2)
    hud_health_bar_height = getattr(C, 'HUD_HEALTH_BAR_HEIGHT', getattr(C, 'HEALTH_BAR_HEIGHT', 8) + 4)
    draw_health_bar(surface, health_bar_pos_x, health_bar_pos_y, hud_health_bar_width, hud_health_bar_height,
                    player_instance.current_health, player_instance.max_health)
    if hud_font_obj: 
        try:
            health_value_text = f"{int(player_instance.current_health)}/{int(player_instance.max_health)}"
            health_text_surface = hud_font_obj.render(health_value_text, True, color_white)
            health_text_pos_x = health_bar_pos_x + hud_health_bar_width + 10 
            health_text_pos_y = health_bar_pos_y + (hud_health_bar_height - health_text_surface.get_height()) // 2
            surface.blit(health_text_surface, (health_text_pos_x, health_text_pos_y))
        except Exception as e: pass

def draw_platformer_scene_on_surface(screen_surface: pygame.Surface, game_elements: Dict[str, Any], 
                                     fonts: Dict[str, Optional[pygame.font.Font]], current_game_time_ticks: int): 
    camera_instance = game_elements.get("camera"); all_sprites_group = game_elements.get("all_sprites") 
    enemy_list_for_health_bars = game_elements.get("enemy_list", [])
    player1_instance, player2_instance = game_elements.get("player1"), game_elements.get("player2")
    font_for_hud = fonts.get("medium") or (pygame.font.Font(None, 24) if pygame.font.get_init() else None)
    current_screen_width, _ = screen_surface.get_size(); bg_color = getattr(C, 'LIGHT_BLUE', (135, 206, 235))
    level_bg_color = game_elements.get("level_background_color", bg_color) # Use level specific if available
    screen_surface.fill(level_bg_color) 
    if camera_instance and all_sprites_group:
        for entity_sprite in all_sprites_group: 
            if entity_sprite.alive() and hasattr(entity_sprite, 'image') and hasattr(entity_sprite, 'rect'):
                 screen_surface.blit(entity_sprite.image, camera_instance.apply(entity_sprite.rect))
        for enemy_sprite in enemy_list_for_health_bars:
            if enemy_sprite.alive() and getattr(enemy_sprite, '_valid_init', False) and not \
               (getattr(enemy_sprite, 'is_dead', False) and getattr(enemy_sprite, 'death_animation_finished', False)) and \
               hasattr(enemy_sprite, 'current_health') and hasattr(enemy_sprite, 'max_health'):
                enemy_rect_on_screen = camera_instance.apply(enemy_sprite.rect) 
                hb_w, hb_h = getattr(C, 'HEALTH_BAR_WIDTH', 50), getattr(C, 'HEALTH_BAR_HEIGHT', 8)
                hb_x, hb_y = enemy_rect_on_screen.centerx - hb_w // 2, enemy_rect_on_screen.top - hb_h - getattr(C, 'HEALTH_BAR_OFFSET_ABOVE', 5) 
                draw_health_bar(screen_surface, hb_x, hb_y, hb_w, hb_h, enemy_sprite.current_health, enemy_sprite.max_health)
    elif all_sprites_group: all_sprites_group.draw(screen_surface)
    if player1_instance and getattr(player1_instance, '_valid_init', False) and player1_instance.alive():
        draw_player_hud(screen_surface, 10, 10, player1_instance, 1, font_for_hud)
    if player2_instance and getattr(player2_instance, '_valid_init', False) and player2_instance.alive():
        p2_hud_w = getattr(C, 'HUD_HEALTH_BAR_WIDTH', getattr(C, 'HEALTH_BAR_WIDTH',50)*2) + 120 
        draw_player_hud(screen_surface, current_screen_width - p2_hud_w - 10, 10, player2_instance, 2, font_for_hud)

def show_main_menu(screen_surface: pygame.Surface, clock_obj: pygame.time.Clock, 
                   fonts: Dict[str, Optional[pygame.font.Font]], app_status_obj: Any) -> Optional[str]:
    button_w, button_h, spacing, title_gap = 350, 55, 20, 60
    current_w, current_h = screen_surface.get_size()
    font_title = fonts.get("large") or (pygame.font.Font(None, 60) if pygame.font.get_init() else None)
    if not font_title: return "quit"
    title_surf = font_title.render("Platformer Adventure LAN", True, getattr(C, 'WHITE',(255,255,255)))
    menu_buttons = {"host": {"text": "Host Game", "action": "host"}, "join_lan": {"text": "Join LAN", "action": "join_lan"},
                    "join_ip": {"text": "Join by IP", "action": "join_ip"}, "couch_play": {"text": "Couch Play", "action": "couch_play"},
                    "quit": {"text": "Quit", "action": "quit"}}
    font_button = fonts.get("medium") or (pygame.font.Font(None, 30) if pygame.font.get_init() else None)
    if not font_button: return "quit"
    title_rect = title_surf.get_rect(center=(current_w // 2, current_h // 4))
    
    def update_btn_geo():
        nonlocal title_rect # Need to update title_rect if screen resizes
        current_w_local, current_h_local = screen_surface.get_size() # Use current screen size
        title_rect = title_surf.get_rect(center=(current_w_local // 2, current_h_local // 4))
        btn_y = title_rect.bottom + title_gap
        for props in menu_buttons.values():
            props["rect"] = pygame.Rect(0, 0, button_w, button_h); props["rect"].centerx, props["rect"].top = current_w_local // 2, btn_y
            props["text_surf"] = font_button.render(props["text"], True, getattr(C, 'WHITE',(255,255,255)))
            props["text_rect"] = props["text_surf"].get_rect(center=props["rect"].center); btn_y += button_h + spacing
    update_btn_geo()
    selected_action = None
    while selected_action is None and app_status_obj.app_running:
        mouse_pos = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT: app_status_obj.app_running = False; selected_action = "quit"
            if event.type == pygame.VIDEORESIZE and not (screen_surface.get_flags() & pygame.FULLSCREEN):
                try:
                    current_w, current_h = max(320,event.w), max(240,event.h)
                    screen_surface = pygame.display.set_mode((current_w,current_h), pygame.RESIZABLE|pygame.DOUBLEBUF)
                    update_btn_geo()
                except pygame.error as e: print(f"Menu resize error: {e}")
            if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE: app_status_obj.app_running = False; selected_action = "quit"
            if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                for props in menu_buttons.values():
                    if "rect" in props and props["rect"].collidepoint(mouse_pos): selected_action = props["action"]; break
        if not app_status_obj.app_running: break
        screen_surface.fill(getattr(C, 'BLACK',(0,0,0))); screen_surface.blit(title_surf, title_rect)
        for props in menu_buttons.values():
            if "rect" in props:
                hover = props["rect"].collidepoint(mouse_pos)
                color = getattr(C, 'GREEN',(0,255,0)) if hover else getattr(C, 'BLUE',(0,0,255))
                pygame.draw.rect(screen_surface, color, props["rect"], border_radius=8)
                if "text_surf" in props and "text_rect" in props: screen_surface.blit(props["text_surf"], props["text_rect"])
        pygame.display.flip(); clock_obj.tick(30)
    return selected_action

def get_server_ip_input_dialog(screen_surface: pygame.Surface, clock_obj: pygame.time.Clock, 
                               fonts: Dict[str, Optional[pygame.font.Font]], app_status_obj: Any, 
                               default_input_text: str = "") -> Optional[str]:
    current_input = default_input_text; active = True; cursor_visible = True; last_blink = time.time()
    current_w, current_h = screen_surface.get_size()
    box_w = max(200, current_w // 2); box_rect = pygame.Rect(0,0, box_w, 50); box_rect.center = (current_w//2, current_h//2)
    pygame.key.set_repeat(250, 25); paste_msg = None; paste_time = 0
    check_pygame_scrap_init_status()
    font_prompt = fonts.get("medium") or (pygame.font.Font(None,30) if pygame.font.get_init() else None)
    font_info = fonts.get("small") or (pygame.font.Font(None,20) if pygame.font.get_init() else None)
    font_input = fonts.get("medium") or (pygame.font.Font(None,30) if pygame.font.get_init() else None)
    if not all([font_prompt, font_info, font_input]): pygame.key.set_repeat(0,0); return None
    while active and app_status_obj.app_running:
        now = time.time()
        if now - last_blink > 0.5: cursor_visible = not cursor_visible; last_blink = now
        for event in pygame.event.get():
            if event.type == pygame.QUIT: app_status_obj.app_running = False; active = False; current_input = None
            if event.type == pygame.VIDEORESIZE and not (screen_surface.get_flags() & pygame.FULLSCREEN):
                try:
                    current_w,current_h=max(320,event.w),max(240,event.h)
                    screen_surface=pygame.display.set_mode((current_w,current_h), pygame.RESIZABLE|pygame.DOUBLEBUF)
                    box_w = max(200, current_w // 2); box_rect = pygame.Rect(0,0, box_w, 50); box_rect.center = (current_w//2, current_h//2)
                except pygame.error as e: print(f"IP Dialog resize error: {e}")
            if event.type == pygame.KEYDOWN:
                paste_msg = None
                if event.key == pygame.K_ESCAPE: active = False; current_input = None
                elif event.key == pygame.K_RETURN: active = False
                elif event.key == pygame.K_BACKSPACE: current_input = current_input[:-1]
                elif event.key == pygame.K_v and (event.mod & pygame.KMOD_CTRL or event.mod & pygame.KMOD_META):
                    pasted = ""; method = "None"
                    try:
                        if SCRAP_INITIALIZED_UI_MODULE:
                            cb_bytes = pygame.scrap.get(pygame.SCRAP_TEXT); 
                            if cb_bytes: pasted = cb_bytes.decode('utf-8','ignore').replace('\x00','').strip()
                            if pasted: method = "scrap"
                        if not pasted and PYPERCLIP_AVAILABLE_UI_MODULE:
                            cb_str = pyperclip.paste()
                            if isinstance(cb_str,str): pasted = cb_str.replace('\x00','').strip()
                            if pasted: method = "pyperclip"
                    except Exception as e: print(f"Paste error (Method {method}): {e}")
                    if pasted: current_input += pasted
                    else: paste_msg = "Paste Failed/Empty"; paste_time = now
                elif event.unicode.isprintable() and (event.unicode.isalnum() or event.unicode in ['.',':','-']): current_input += event.unicode
        if not app_status_obj.app_running: break
        screen_surface.fill(getattr(C,'BLACK',(0,0,0)))
        prompt_surf = font_prompt.render("Enter Host IP or IP:Port", True, getattr(C,'WHITE',(255,255,255)))
        screen_surface.blit(prompt_surf, prompt_surf.get_rect(center=(current_w//2, current_h//2-60)))
        info_surf = font_info.render("(Enter=OK, Esc=Cancel, Ctrl+V=Paste)", True, getattr(C,'GRAY',(128,128,128)))
        screen_surface.blit(info_surf, info_surf.get_rect(center=(current_w//2, current_h-40)))
        pygame.draw.rect(screen_surface, getattr(C,'GRAY',(128,128,128)), box_rect,0,5)
        pygame.draw.rect(screen_surface, getattr(C,'WHITE',(255,255,255)), box_rect,2,5)
        input_surf = font_input.render(current_input, True, getattr(C,'BLACK',(0,0,0)))
        input_rect = input_surf.get_rect(midleft=(box_rect.left+10, box_rect.centery))
        clip_area = box_rect.inflate(-12,-12)
        if input_rect.width > clip_area.width: input_rect.right = clip_area.right
        else: input_rect.left = clip_area.left
        screen_surface.set_clip(clip_area); screen_surface.blit(input_surf, input_rect); screen_surface.set_clip(None)
        if cursor_visible:
            cursor_x = max(clip_area.left, min(input_rect.right+2, clip_area.right-1))
            pygame.draw.line(screen_surface, getattr(C,'BLACK',(0,0,0)), (cursor_x,box_rect.top+5), (cursor_x,box_rect.bottom-5),2)
        if paste_msg and now - paste_time < 2.0:
            msg_surf = font_info.render(paste_msg, True, getattr(C,'RED',(255,0,0)))
            screen_surface.blit(msg_surf, msg_surf.get_rect(center=(current_w//2,box_rect.bottom+30)))
        elif paste_msg: paste_msg = None
        pygame.display.flip(); clock_obj.tick(30)
    pygame.key.set_repeat(0,0)
    return current_input.strip() if current_input is not None else None

# --- ADD THIS NEW FUNCTION ---
MAPS_DIRECTORY_GAME_UI = "maps" # Define it locally or import from editor_config if preferred

def select_map_dialog(screen: pygame.Surface, clock: pygame.time.Clock, 
                      fonts: Dict[str, Optional[pygame.font.Font]], 
                      app_status: Any) -> Optional[str]:
    """
    Displays a dialog to select a map from the 'maps' directory.
    Returns the selected map module name (without .py) or None if cancelled/quit.
    """
    print("GAME_UI: Opening select_map_dialog...")
    map_module_names: List[str] = []
    if os.path.exists(MAPS_DIRECTORY_GAME_UI) and os.path.isdir(MAPS_DIRECTORY_GAME_UI):
        try:
            for f_name in os.listdir(MAPS_DIRECTORY_GAME_UI):
                if f_name.endswith(".py") and f_name != "__init__.py":
                    map_module_names.append(f_name[:-3]) # Remove .py
            map_module_names.sort()
            print(f"GAME_UI: Found maps: {map_module_names}")
        except OSError as e:
            print(f"GAME_UI Error: Could not read maps directory '{MAPS_DIRECTORY_GAME_UI}': {e}")
            map_module_names = [] # Ensure it's empty on error
    else:
        print(f"GAME_UI Warning: Maps directory '{MAPS_DIRECTORY_GAME_UI}' not found.")

    if not map_module_names:
        # Display a "No Maps Found" message briefly and return
        font_medium = fonts.get("medium") or (pygame.font.Font(None, 36) if pygame.font.get_init() else None)
        if font_medium:
            screen_w, screen_h = screen.get_size()
            screen.fill(getattr(C, 'BLACK', (0,0,0)))
            msg_surf = font_medium.render("No Maps Found in 'maps/' folder.", True, getattr(C, 'RED', (255,0,0)))
            screen.blit(msg_surf, msg_surf.get_rect(center=(screen_w//2, screen_h//2)))
            pygame.display.flip()
            pygame.time.wait(2500) # Show message for 2.5 seconds
        return None # No map to select

    selected_index = 0
    dialog_active = True
    
    font_title = fonts.get("large") or (pygame.font.Font(None, 60) if pygame.font.get_init() else None)
    font_item = fonts.get("medium") or (pygame.font.Font(None, 30) if pygame.font.get_init() else None)
    font_instr = fonts.get("small") or (pygame.font.Font(None, 24) if pygame.font.get_init() else None)

    if not all([font_title, font_item, font_instr]):
        print("GAME_UI Error: Essential fonts for map selection dialog missing.")
        return map_module_names[0] if map_module_names else None # Fallback: auto-select first or None

    # Pagination/Scrolling (simplified for now, shows first N maps)
    maps_per_page = 8 # Show up to 8 maps at a time
    current_page = 0
    max_pages = (len(map_module_names) + maps_per_page - 1) // maps_per_page

    # Button dimensions
    button_height = 45
    button_spacing = 10
    button_width_factor = 0.6 # Relative to screen width
    
    # Colors
    color_white = getattr(C, 'WHITE', (255,255,255))
    color_black = getattr(C, 'BLACK', (0,0,0))
    color_blue = getattr(C, 'BLUE', (0,0,255))
    color_green = getattr(C, 'GREEN', (0,255,0))
    color_gray = getattr(C, 'GRAY', (128,128,128))

    while dialog_active and app_status.app_running:
        screen_w, screen_h = screen.get_size()
        mouse_pos = pygame.mouse.get_pos()

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                app_status.app_running = False; dialog_active = False
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    dialog_active = False; return None # Cancel selection
                elif event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                    if 0 <= selected_index < len(map_module_names):
                        print(f"GAME_UI: Map selected: {map_module_names[selected_index]}")
                        return map_module_names[selected_index]
                elif event.key == pygame.K_UP:
                    selected_index = (selected_index - 1 + len(map_module_names)) % len(map_module_names)
                    # Adjust page if selection goes off current visible list
                    current_page = selected_index // maps_per_page
                elif event.key == pygame.K_DOWN:
                    selected_index = (selected_index + 1) % len(map_module_names)
                    current_page = selected_index // maps_per_page
                elif event.key == pygame.K_PAGEUP or (event.key == pygame.K_LEFT and max_pages > 1) : # Prev page
                    current_page = max(0, current_page - 1)
                    selected_index = current_page * maps_per_page # Select first item on new page
                elif event.key == pygame.K_PAGEDOWN or (event.key == pygame.K_RIGHT and max_pages > 1): # Next page
                    current_page = min(max_pages - 1, current_page + 1)
                    selected_index = current_page * maps_per_page
            
            if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                # Check clicks on map items
                start_idx = current_page * maps_per_page
                end_idx = min(start_idx + maps_per_page, len(map_module_names))
                visible_maps_on_page = map_module_names[start_idx:end_idx]

                title_surf = font_title.render("Select a Map", True, color_white)
                title_rect = title_surf.get_rect(center=(screen_w // 2, screen_h * 0.15))
                current_btn_y = title_rect.bottom + 40

                for i, map_name in enumerate(visible_maps_on_page):
                    actual_map_index = start_idx + i
                    item_rect = pygame.Rect(0, 0, screen_w * button_width_factor, button_height)
                    item_rect.centerx = screen_w // 2
                    item_rect.top = current_btn_y
                    if item_rect.collidepoint(mouse_pos):
                        print(f"GAME_UI: Map selected by click: {map_name}")
                        return map_name # Return map name without .py
                    current_btn_y += button_height + button_spacing
        
        if not app_status.app_running: break

        # --- Drawing ---
        screen.fill(color_black)
        
        # Title
        title_surf = font_title.render("Select a Map to Play", True, color_white)
        title_rect = title_surf.get_rect(center=(screen_w // 2, screen_h * 0.15))
        screen.blit(title_surf, title_rect)

        # Instructions
        instr_text = "Use UP/DOWN Arrows, Enter to Select. PgUp/PgDn or LEFT/RIGHT for pages. ESC to cancel."
        instr_surf = font_instr.render(instr_text, True, color_gray)
        instr_rect = instr_surf.get_rect(center=(screen_w // 2, title_rect.bottom + 20))
        screen.blit(instr_surf, instr_rect)
        
        # List maps for the current page
        start_idx = current_page * maps_per_page
        end_idx = min(start_idx + maps_per_page, len(map_module_names))
        visible_maps_on_page = map_module_names[start_idx:end_idx]

        current_btn_y = title_rect.bottom + 60 # Start Y for first map item

        for i, map_name in enumerate(visible_maps_on_page):
            actual_map_index = start_idx + i # Index in the full map_module_names list
            
            item_text = f"{map_name}"
            item_color = color_white
            bg_color = color_blue

            if actual_map_index == selected_index:
                item_color = color_black # Text color for selected
                bg_color = color_green   # Background for selected
            
            item_surf = font_item.render(item_text, True, item_color)
            
            item_rect = pygame.Rect(0, 0, screen_w * button_width_factor, button_height)
            item_rect.centerx = screen_w // 2
            item_rect.top = current_btn_y
            
            pygame.draw.rect(screen, bg_color, item_rect, border_radius=5)
            pygame.draw.rect(screen, color_white, item_rect, 1, border_radius=5) # Border
            
            text_rect = item_surf.get_rect(center=item_rect.center)
            screen.blit(item_surf, text_rect)
            
            current_btn_y += button_height + button_spacing

        # Page number
        if max_pages > 1:
            page_text = f"Page {current_page + 1} of {max_pages}"
            page_surf = font_instr.render(page_text, True, color_gray)
            page_rect = page_surf.get_rect(center=(screen_w // 2, screen_h - 30))
            screen.blit(page_surf, page_rect)

        pygame.display.flip()
        clock.tick(30) # Menu can run at a lower FPS

    print("GAME_UI: Exiting select_map_dialog.")
    return None # Default if loop exits due to app_status not running

########## START OF FILE: items.py ##########

# items.py
# -*- coding: utf-8 -*-
"""
Defines collectible items like Chests.
Uses resource_path helper for PyInstaller compatibility.
"""
# version 1.00000.1
import pygame
import os
import sys # Needed for resource_path logic (imported via assets)
import random

# Import necessary components
import constants as C
# Import BOTH the loader AND the path helper from assets.py
from assets import load_gif_frames, resource_path

class Chest(pygame.sprite.Sprite):
    """
    A chest that restores player health when collected.
    """
    def __init__(self, x, y):
        super().__init__()

        # --- Define the relative path to the asset ---
        # This path is relative to the project root (or wherever resource_path resolves from)
        relative_chest_path = os.path.join('characters', 'items', 'chest.gif')

        # --- Use resource_path to get the correct full path ---
        # resource_path figures out if we're running bundled or locally
        full_chest_path = resource_path(relative_chest_path)
        print(f"Attempting to load chest GIF from resolved path: {full_chest_path}") # Debug print resolved path

        # --- Load frames using the full path ---
        self.frames = load_gif_frames(full_chest_path)

        # --- Error Handling and Placeholder ---
        # Check if loading failed OR if load_gif_frames returned its standard red placeholder
        # (assuming the standard placeholder size is 30x40 from assets.py)
        is_placeholder = False
        if self.frames and len(self.frames) == 1:
             placeholder_check_surf = self.frames[0]
             # Basic check based on size and maybe color (adjust size if your placeholder is different)
             if placeholder_check_surf.get_size() == (30, 40) and placeholder_check_surf.get_at((0,0)) == C.RED:
                 is_placeholder = True

        if not self.frames or is_placeholder:
            # Provide a specific fallback surface for the chest if loading fails OR returns default placeholder
            if not self.frames:
                print(f"Error: Failed to load chest from '{full_chest_path}'. Using placeholder.")
            else: # It returned a placeholder
                print(f"Warning: Chest loaded as a default placeholder from '{full_chest_path}'. Check file/path.")

            self.image = pygame.Surface((30, 30)).convert_alpha()
            self.image.fill(C.YELLOW) # Use a distinct placeholder color for chest issues
            pygame.draw.rect(self.image, C.BLACK, self.image.get_rect(), 1)
            pygame.draw.line(self.image, C.BLACK, (0, 0), (30, 30), 1) # Add cross to placeholder
            pygame.draw.line(self.image, C.BLACK, (0, 30), (30, 0), 1)
            self.frames = [self.image] # Make frames list contain the specific chest placeholder
            self._valid_init = False # Indicate potential issue, though it might still draw
        else:
            # Successfully loaded actual frames
            self.image = self.frames[0] # Use the first frame
            self._valid_init = True
            print(f"Successfully loaded {len(self.frames)} frame(s) for chest.")

        self.rect = self.image.get_rect(midbottom=(x, y))
        self.pos = pygame.math.Vector2(x, y) # Store position if needed later

        # Animation state
        self.current_frame = 0
        self.last_anim_update = pygame.time.get_ticks()
        self.is_collected = False # Flag to prevent multiple collections

    def update(self, dt):
        """ Handles animation if the GIF has multiple frames. dt is not used here yet. """
        # Don't animate if initialization potentially failed or only 1 frame (placeholder/static)
        if not self._valid_init or len(self.frames) <= 1:
            return

        now = pygame.time.get_ticks()
        # Adjust ANIM_FRAME_DURATION if chest animation speed should differ
        anim_speed_multiplier = 2 # Example: make chest animation slower than player/enemy
        if now - self.last_anim_update > C.ANIM_FRAME_DURATION * anim_speed_multiplier:
            self.last_anim_update = now
            self.current_frame = (self.current_frame + 1) % len(self.frames) # Loop animation
            current_midbottom = self.rect.midbottom # Store position anchor
            self.image = self.frames[self.current_frame]
            # Re-center rect if frame sizes change during animation (unlikely for simple items)
            self.rect = self.image.get_rect(midbottom=current_midbottom) # Re-anchor rect after getting new image

    def collect(self, player):
        """ Action when the player collects the chest. """
        # Only collect if properly initialized and not already collected
        if not self.is_collected and self._valid_init:
            print("Player collected chest!")
            # Ensure player has the heal_to_full method before calling it
            if hasattr(player, 'heal_to_full') and callable(player.heal_to_full):
                player.heal_to_full()
            else:
                print("Warning: Player object does not have 'heal_to_full' method.")
            self.is_collected = True
            self.kill() # Remove sprite from all groups it belongs to

########## START OF FILE: levels.py ##########

# levels.py
# -*- coding: utf-8 -*-
"""
levels.py
Returns sprite groups for platforms, ladders, hazards, spawns, level width,
and absolute min/max Y coordinates for the entire level.
"""
# version 1.0.0.9 (Added platform_type tags to all platforms)
import pygame
import random
from tiles import Platform, Ladder, Lava # Import tile classes
from constants import TILE_SIZE, GRAY, DARK_GREEN, ORANGE_RED, LAVA_PATCH_HEIGHT, BLACK
import constants as C # Already imported, but C alias is good practice

FENCE_WIDTH = 8
FENCE_HEIGHT = 15
FENCE_COLOR = GRAY

def _add_map_boundary_walls(platforms_group, map_total_width, all_content_sprites_list,
                            initial_screen_height_fallback, extra_sky_clearance=0):
    """
    Calculates content extents and adds TILE_SIZE thick boundary walls.
    map_total_width is the outer width including walls.
    extra_sky_clearance pushes the ceiling collision object higher.
    Returns min_y_overall, max_y_overall (absolute top/bottom of level including walls).
    """
    if not all_content_sprites_list:
        print("Warning: _add_map_boundary_walls called with empty content list. Using fallback extents.")
        min_y_content = 0 - TILE_SIZE * 5
        max_y_content = initial_screen_height_fallback
    else:
        all_rects = [s.rect for s in all_content_sprites_list if hasattr(s, 'rect')]
        if not all_rects:
            min_y_content = 0 - TILE_SIZE * 5
            max_y_content = initial_screen_height_fallback
        else:
            min_y_content = min(r.top for r in all_rects)
            max_y_content = max(r.bottom for r in all_rects)

    ceiling_object_top_y = min_y_content - TILE_SIZE - extra_sky_clearance
    level_min_y_abs = ceiling_object_top_y
    level_max_y_abs = max_y_content + TILE_SIZE
    boundary_box_height = level_max_y_abs - level_min_y_abs

    platforms_group.add(Platform(0, ceiling_object_top_y, map_total_width, TILE_SIZE, GRAY, platform_type="boundary"))
    platforms_group.add(Platform(0, max_y_content, map_total_width, TILE_SIZE, GRAY, platform_type="boundary"))
    platforms_group.add(Platform(0, level_min_y_abs, TILE_SIZE, boundary_box_height, GRAY, platform_type="boundary"))
    platforms_group.add(Platform(map_total_width - TILE_SIZE, level_min_y_abs, TILE_SIZE, boundary_box_height, GRAY, platform_type="boundary"))

    return level_min_y_abs, level_max_y_abs


def load_map_original(initial_width, initial_height):
    """ Creates the original level layout with boundary walls and colored ledges. """
    platforms = pygame.sprite.Group()
    ladders = pygame.sprite.Group()
    hazards = pygame.sprite.Group()
    enemy_spawns_data = []

    map_total_width = initial_width * 2.5
    player_spawn = (TILE_SIZE + 60, initial_height - TILE_SIZE - TILE_SIZE - 1)
    main_ground_y_ref = initial_height - TILE_SIZE
    main_ground_segment_height_ref = TILE_SIZE

    # Ground
    ground = Platform(TILE_SIZE, main_ground_y_ref, map_total_width - 2 * TILE_SIZE, main_ground_segment_height_ref, GRAY, platform_type="ground")
    platforms.add(ground)

    # Ledges
    platforms.add(Platform(TILE_SIZE + 160, initial_height - 150, 250, 20, DARK_GREEN, platform_type="ledge"))
    platforms.add(Platform(TILE_SIZE + 410, initial_height - 300, 180, 20, DARK_GREEN, platform_type="ledge"))
    platforms.add(Platform(min(map_total_width - TILE_SIZE - 200, TILE_SIZE + initial_width - 350), initial_height - 450, 200, 20, DARK_GREEN, platform_type="ledge"))
    platforms.add(Platform(min(map_total_width - TILE_SIZE - 150, TILE_SIZE + initial_width + 150), initial_height - 250, 150, 20, DARK_GREEN, platform_type="ledge"))
    platforms.add(Platform(TILE_SIZE + 860, initial_height - 550, 100, 20, DARK_GREEN, platform_type="ledge"))

    # Structural Wall
    wall_mid_x = TILE_SIZE + 760
    wall_mid_width = 30
    if wall_mid_x + wall_mid_width > map_total_width - TILE_SIZE:
        wall_mid_width = max(1, (map_total_width - TILE_SIZE) - wall_mid_x)
    platforms.add(Platform(wall_mid_x, initial_height - 400, wall_mid_width, 360, GRAY, platform_type="wall"))

    # Ladders
    ladder_width = 40
    ladder_height_main = 250
    ladders.add(Ladder(min(map_total_width - TILE_SIZE - ladder_width, TILE_SIZE + initial_width - 500),
                       main_ground_y_ref - ladder_height_main, ladder_width, ladder_height_main))
    ladders.add(Ladder(TILE_SIZE + 310, initial_height - 250, ladder_width, 150))

    all_content_sprites = list(platforms.sprites()) + list(ladders.sprites())
    level_min_y_abs, level_max_y_abs = _add_map_boundary_walls(platforms, map_total_width, all_content_sprites, initial_height, extra_sky_clearance=TILE_SIZE * 5)

    return platforms, ladders, hazards, enemy_spawns_data, player_spawn, \
           map_total_width, level_min_y_abs, level_max_y_abs, \
           main_ground_y_ref, main_ground_segment_height_ref

def load_map_lava(initial_width, initial_height):
    """ Creates a level with lava, boundary walls, and colored ledges. """
    platforms = pygame.sprite.Group()
    ladders = pygame.sprite.Group()
    hazards = pygame.sprite.Group()
    enemy_spawns_data = []
    map_total_width = initial_width * 2.8
    player_spawn_x = TILE_SIZE + 30
    player_spawn_y = initial_height - 120 - TILE_SIZE
    player_spawn = (player_spawn_x, player_spawn_y)
    main_ground_y_ref = initial_height - TILE_SIZE

    # Ledges
    platforms.add(Platform(TILE_SIZE, initial_height - 120, 150, 20, DARK_GREEN, platform_type="ledge"))
    platforms.add(Platform(TILE_SIZE + 260, initial_height - 180, 120, 20, DARK_GREEN, platform_type="ledge"))
    platforms.add(Platform(TILE_SIZE + 460, initial_height - 150, 100, 20, DARK_GREEN, platform_type="ledge"))
    platforms.add(Platform(TILE_SIZE + 660, initial_height - 200, 130, 20, DARK_GREEN, platform_type="ledge"))
    platforms.add(Platform(TILE_SIZE + 860, initial_height - 250, 100, 20, DARK_GREEN, platform_type="ledge"))
    platforms.add(Platform(TILE_SIZE + 1210, initial_height - 350, 150, 20, DARK_GREEN, platform_type="ledge"))
    platforms.add(Platform(TILE_SIZE + 1560, initial_height - 480, 200, 20, DARK_GREEN, platform_type="ledge"))

    # Structural Walls
    wall1_height = (main_ground_y_ref) - (initial_height - 400)
    platforms.add(Platform(TILE_SIZE + 1060, initial_height - 400, 30, wall1_height, GRAY, platform_type="wall"))
    wall2_height = (main_ground_y_ref) - (initial_height - 500)
    platforms.add(Platform(TILE_SIZE + 1410, initial_height - 500, 30, wall2_height, GRAY, platform_type="wall"))

    # Lava
    lava_y_surface = main_ground_y_ref
    hazards.add(Lava(TILE_SIZE, lava_y_surface, 1100 - TILE_SIZE, LAVA_PATCH_HEIGHT, ORANGE_RED))
    hazards.add(Lava(1130, lava_y_surface, 320, LAVA_PATCH_HEIGHT, ORANGE_RED))
    lava3_start_x = 1550
    lava3_width = (map_total_width - TILE_SIZE) - lava3_start_x
    if lava3_width > 0:
        hazards.add(Lava(lava3_start_x, lava_y_surface, lava3_width, LAVA_PATCH_HEIGHT, ORANGE_RED))

    all_content_sprites = list(platforms.sprites()) + list(hazards.sprites())
    level_min_y_abs, level_max_y_abs = _add_map_boundary_walls(platforms, map_total_width, all_content_sprites, initial_height, extra_sky_clearance=TILE_SIZE * 5)

    return platforms, ladders, hazards, enemy_spawns_data, player_spawn, \
           map_total_width, level_min_y_abs, level_max_y_abs, \
           main_ground_y_ref, 0

def load_map_cpu_extended(initial_width, initial_height):
    """
    Creates a larger level with CPU enemies, DEEP LAVA WELLS with fences,
    boundary walls, and colored ledges. Platform height adjusted.
    """
    platforms = pygame.sprite.Group()
    ladders = pygame.sprite.Group()
    hazards = pygame.sprite.Group()
    enemy_spawns_data = []
    map_total_width = initial_width * 3.5
    main_ground_y_ref = initial_height - TILE_SIZE
    main_ground_segment_height_ref = TILE_SIZE
    player_spawn = (TILE_SIZE * 2, main_ground_y_ref)
    gap_width_lava = TILE_SIZE * 4
    lava_collision_y_level = main_ground_y_ref + 1
    fence_y_pos = main_ground_y_ref - FENCE_HEIGHT

    # Ground Segments
    seg1_start_x = TILE_SIZE
    seg1_width = (initial_width * 0.7) - TILE_SIZE
    seg1_end_x = seg1_start_x + seg1_width
    platforms.add(Platform(seg1_start_x, main_ground_y_ref, seg1_width, main_ground_segment_height_ref, GRAY, platform_type="ground"))

    lava1_start_x = seg1_end_x
    lava1_width = gap_width_lava
    hazards.add(Lava(lava1_start_x, lava_collision_y_level, lava1_width, LAVA_PATCH_HEIGHT, ORANGE_RED))
    platforms.add(Platform(lava1_start_x - FENCE_WIDTH, fence_y_pos, FENCE_WIDTH, FENCE_HEIGHT, FENCE_COLOR, platform_type="fence"))
    platforms.add(Platform(lava1_start_x + lava1_width, fence_y_pos, FENCE_WIDTH, FENCE_HEIGHT, FENCE_COLOR, platform_type="fence"))

    seg2_start_x = lava1_start_x + lava1_width
    seg2_width = initial_width * 1.0
    seg2_end_x = seg2_start_x + seg2_width
    platforms.add(Platform(seg2_start_x, main_ground_y_ref, seg2_width, main_ground_segment_height_ref, GRAY, platform_type="ground"))

    lava2_start_x = seg2_end_x
    lava2_width = gap_width_lava * 0.8
    hazards.add(Lava(lava2_start_x, lava_collision_y_level, lava2_width, LAVA_PATCH_HEIGHT, ORANGE_RED))
    platforms.add(Platform(lava2_start_x - FENCE_WIDTH, fence_y_pos, FENCE_WIDTH, FENCE_HEIGHT, FENCE_COLOR, platform_type="fence"))
    platforms.add(Platform(lava2_start_x + lava2_width, fence_y_pos, FENCE_WIDTH, FENCE_HEIGHT, FENCE_COLOR, platform_type="fence"))

    seg3_start_x = lava2_start_x + lava2_width
    seg3_width = (map_total_width - TILE_SIZE) - seg3_start_x
    if seg3_width > 0:
        platforms.add(Platform(seg3_start_x, main_ground_y_ref, seg3_width, main_ground_segment_height_ref, GRAY, platform_type="ground"))

    # Floating Platforms (Ledges)
    plat1_x = TILE_SIZE + (initial_width * 0.3 - TILE_SIZE)
    plat1_x = max(seg1_start_x + TILE_SIZE, min(plat1_x, seg1_end_x - TILE_SIZE*7))
    platforms.add(Platform(plat1_x, main_ground_y_ref - TILE_SIZE * 1.8, TILE_SIZE * 6, TILE_SIZE * 0.5, DARK_GREEN, platform_type="ledge"))
    platforms.add(Platform(seg2_start_x + TILE_SIZE * 2, main_ground_y_ref - TILE_SIZE * 3, TILE_SIZE * 8, TILE_SIZE * 0.5, DARK_GREEN, platform_type="ledge"))
    platforms.add(Platform(seg3_start_x + TILE_SIZE * 4, main_ground_y_ref - TILE_SIZE * 5.5, TILE_SIZE * 7, TILE_SIZE * 0.5, DARK_GREEN, platform_type="ledge"))

    # Enemy Spawns
    spawn_y_on_ground = main_ground_y_ref - 1
    enemy1_x_pos = seg2_start_x + seg2_width * 0.5
    patrol_rect_enemy1 = pygame.Rect(
        seg2_start_x + TILE_SIZE, main_ground_y_ref - TILE_SIZE * 2,
        seg2_width - TILE_SIZE * 2, TILE_SIZE * 2
    )
    enemy_spawns_data.append({'pos': (enemy1_x_pos, spawn_y_on_ground), 'patrol': patrol_rect_enemy1})

    enemy2_platform_ref_x = seg2_start_x + TILE_SIZE * 2
    enemy2_platform = next((p for p in platforms if p.rect.left == enemy2_platform_ref_x and p.rect.width == TILE_SIZE * 8 and p.platform_type == "ledge"), None)
    if enemy2_platform:
        enemy2_x_pos = enemy2_platform.rect.centerx
        enemy2_y_pos = enemy2_platform.rect.top - 1
        enemy_spawns_data.append({'pos': (enemy2_x_pos, enemy2_y_pos), 'patrol': None})

    enemy3_x_pos = seg3_start_x + seg3_width * 0.3
    enemy_spawns_data.append({'pos': (enemy3_x_pos, spawn_y_on_ground), 'patrol': None})

    all_content_sprites = list(platforms.sprites()) + list(hazards.sprites())
    sky_clearance = TILE_SIZE * 10
    level_min_y_abs, level_max_y_abs = _add_map_boundary_walls(platforms, map_total_width, all_content_sprites, initial_height, extra_sky_clearance=sky_clearance)

    return platforms, ladders, hazards, enemy_spawns_data, player_spawn, \
           map_total_width, level_min_y_abs, level_max_y_abs, \
           main_ground_y_ref, main_ground_segment_height_ref

load_map_cpu = load_map_cpu_extended

# --- Test block for levels.py (if run directly) ---
if __name__ == '__main__':
    pygame.init()
    screen_width_test = 1000
    screen_height_test = 700
    test_screen = pygame.display.set_mode((screen_width_test, screen_height_test), pygame.RESIZABLE)

    test_platforms, test_ladders, test_hazards, test_enemy_spawns, test_player_spawn, \
    test_level_width, test_level_min_y, test_level_max_y, \
    test_main_ground_y, test_main_ground_h = \
        load_map_cpu_extended(screen_width_test, screen_height_test)
    pygame.display.set_caption("Level.py - Map Test (load_map_cpu_extended)")

    all_test_sprites = pygame.sprite.Group()
    all_test_sprites.add(test_platforms.sprites(), test_ladders.sprites(), test_hazards.sprites())

    if test_enemy_spawns:
        for spawn_info in test_enemy_spawns:
            spawn_pos = spawn_info['pos']
            enemy_placeholder = pygame.sprite.Sprite()
            enemy_placeholder.image = pygame.Surface((TILE_SIZE*0.5, TILE_SIZE*0.8))
            enemy_placeholder.image.fill(ORANGE_RED)
            enemy_placeholder.rect = enemy_placeholder.image.get_rect(midbottom=spawn_pos)
            all_test_sprites.add(enemy_placeholder)
            if spawn_info.get('patrol'):
                patrol_rect_vis = spawn_info['patrol'].copy()
                patrol_placeholder = pygame.sprite.Sprite()
                patrol_placeholder.image = pygame.Surface((patrol_rect_vis.width, patrol_rect_vis.height), pygame.SRCALPHA)
                patrol_placeholder.image.fill((255,0,255,50))
                pygame.draw.rect(patrol_placeholder.image, (255,0,255, 150), patrol_placeholder.image.get_rect(), 1)
                patrol_placeholder.rect = patrol_rect_vis
                all_test_sprites.add(patrol_placeholder)

    class TestDummyPlayer(pygame.sprite.Sprite):
        def __init__(self, x, y):
            super().__init__()
            self.image = pygame.Surface((TILE_SIZE * 0.75, TILE_SIZE))
            self.image.fill(DARK_GREEN)
            self.rect = self.image.get_rect(midbottom=(x,y))
            self.vel = pygame.math.Vector2(0,0)
            self.on_ground_flag = False
            self.gravity = C.PLAYER_GRAVITY
            self.jump_strength = C.PLAYER_JUMP_STRENGTH

        def update(self, platform_group_for_collision):
            self.vel.y += self.gravity
            if self.vel.y > C.TERMINAL_VELOCITY_Y: self.vel.y = C.TERMINAL_VELOCITY_Y
            pressed_keys = pygame.key.get_pressed()
            if pressed_keys[pygame.K_LEFT]: self.vel.x = -5
            elif pressed_keys[pygame.K_RIGHT]: self.vel.x = 5
            else: self.vel.x = 0
            if pressed_keys[pygame.K_UP] and self.on_ground_flag:
                self.vel.y = self.jump_strength
                self.on_ground_flag = False
            self.rect.x += self.vel.x
            self.test_collision_resolution('x', platform_group_for_collision)
            self.rect.y += self.vel.y
            self.on_ground_flag = False
            self.test_collision_resolution('y', platform_group_for_collision)

        def test_collision_resolution(self, direction, platform_group_to_collide_with):
            for plat in pygame.sprite.spritecollide(self, platform_group_to_collide_with, False):
                if plat.image.get_alpha() == 0 : continue
                if direction == 'x':
                    if self.vel.x > 0: self.rect.right = plat.rect.left
                    if self.vel.x < 0: self.rect.left = plat.rect.right
                    self.vel.x = 0
                if direction == 'y':
                    if self.vel.y > 0:
                        self.rect.bottom = plat.rect.top
                        self.on_ground_flag = True
                        self.vel.y = 0
                    if self.vel.y < 0:
                        self.rect.top = plat.rect.bottom
                        self.vel.y = 0

    dummy_test_player = TestDummyPlayer(test_player_spawn[0], test_player_spawn[1])
    all_test_sprites.add(dummy_test_player)
    camera_x_offset = 0
    camera_y_offset = 0
    test_game_running = True
    test_clock = pygame.time.Clock()
    effective_level_height_for_test = test_level_max_y - test_level_min_y

    while test_game_running:
        current_screen_width, current_screen_height = test_screen.get_size()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                test_game_running = False
            if event.type == pygame.VIDEORESIZE:
                 test_screen = pygame.display.set_mode((event.w, event.h), pygame.RESIZABLE)
        dummy_test_player.update(test_platforms)
        camera_x_offset = -dummy_test_player.rect.centerx + current_screen_width // 2
        camera_y_offset = -dummy_test_player.rect.centery + current_screen_height // 2
        camera_x_offset = min(0, camera_x_offset)
        if test_level_width > current_screen_width:
            camera_x_offset = max(-(test_level_width - current_screen_width), camera_x_offset)
        else:
            camera_x_offset = 0
        if effective_level_height_for_test <= current_screen_height:
            camera_y_offset = -(test_level_min_y + effective_level_height_for_test / 2 - current_screen_height / 2)
        else:
            camera_y_offset = min(-test_level_min_y, camera_y_offset)
            camera_y_offset = max(-(test_level_max_y - current_screen_height), camera_y_offset)
        test_screen.fill(BLACK)
        for sprite_to_draw in all_test_sprites:
            test_screen.blit(sprite_to_draw.image,
                             (sprite_to_draw.rect.x + camera_x_offset,
                              sprite_to_draw.rect.y + camera_y_offset))
        pygame.display.flip()
        test_clock.tick(60)
    pygame.quit()

########## START OF FILE: main.py ##########

# main.py
# -*- coding: utf-8 -*-
## version 1.0.0.6 (Safer global game_elements defaults)
import sys
import os
import pygame
import traceback 
from typing import Dict, Optional, Any # Ensure these are imported for type hints

# --- Pyperclip Check ---
PYPERCLIP_AVAILABLE_MAIN = False
try:
    import pyperclip
    PYPERCLIP_AVAILABLE_MAIN = True
    print("Pyperclip library found and imported successfully for main.")
except ImportError:
    print("Main: Pyperclip library not found (pip install pyperclip). Paste in UI may be limited.")

# --- Platformer Game Module Imports ---
try:
    import constants as C # This should make C available globally in this module
    from camera import Camera
    from items import Chest
    from game_setup import initialize_game_elements 
    from server_logic import ServerState, run_server_mode
    from client_logic import ClientState, run_client_mode
    from couch_play_logic import run_couch_play_mode
    import game_ui 

    print("Platformer modules imported successfully.")
except ImportError as e:
    print(f"FATAL MAIN: Failed to import a required platformer module: {e}")
    traceback.print_exc()
    sys.exit(1)
except Exception as e:
    print(f"FATAL MAIN: An unexpected error occurred during platformer module imports: {e}")
    traceback.print_exc()
    sys.exit(1)

# --- Pygame Initialization ---
os.environ['SDL_VIDEO_WINDOW_POS'] = '0,0' 
pygame.init() 
pygame.font.init() 

class AppStatus:
    def __init__(self):
        self.app_running = True

# --- Display Setup ---
# These need to be defined before game_elements if game_elements uses WIDTH, HEIGHT
try:
    display_info = pygame.display.Info()
    monitor_width = display_info.current_w
    monitor_height = display_info.current_h
    initial_width = max(800, min(1600, monitor_width * 3 // 4))
    initial_height = max(600, min(900, monitor_height * 3 // 4))
    WIDTH_MAIN, HEIGHT_MAIN = initial_width, initial_height # Use different names to avoid conflict if C also has WIDTH/HEIGHT
    screen_flags = pygame.RESIZABLE | pygame.DOUBLEBUF
    screen = pygame.display.set_mode((WIDTH_MAIN, HEIGHT_MAIN), screen_flags)
    pygame.display.set_caption("Platformer Adventure LAN")
    print(f"Initial window dimensions: {WIDTH_MAIN}x{HEIGHT_MAIN}")
except Exception as e:
    print(f"FATAL MAIN: Error setting up Pygame display: {e}")
    pygame.quit()
    sys.exit(1)

# --- Pygame Scrap Initialization ---
SCRAP_INITIALIZED_MAIN = False
try:
    if pygame.display.get_init(): 
        pygame.scrap.init() 
        SCRAP_INITIALIZED_MAIN = pygame.scrap.get_init()
        if SCRAP_INITIALIZED_MAIN: print("Main: pygame.scrap clipboard module initialized successfully.")
        else: print("Main Warning: pygame.scrap.init() called but pygame.scrap.get_init() returned False.")
    else: print("Main Warning: Display not initialized before pygame.scrap.init() attempt.")
except AttributeError: print("Main Warning: pygame.scrap module not found or available on this system.")
except pygame.error as e: print(f"Main Warning: pygame.scrap module could not be initialized: {e}")
except Exception as e: print(f"Main Warning: An unexpected error occurred during pygame.scrap init: {e}")


# --- Global Game Variables ---
# These are placeholders; initialize_game_elements will populate them correctly.
# Avoid direct use of C.X here if C might not be fully "ready" for complex constants,
# though basic color tuples and TILE_SIZE should be fine after a successful import.
# The main thing is that initialize_game_elements will use C properly from within its scope.
_TILE_SIZE_DEFAULT = 40 # A hardcoded fallback if C.TILE_SIZE access fails globally
_LIGHT_BLUE_DEFAULT = (173, 216, 230)

game_elements: Dict[str, Any] = {
    "player1": None, "player2": None, "camera": None,
    "current_chest": None, "enemy_list": [],
    "platform_sprites": pygame.sprite.Group(),
    "ladder_sprites": pygame.sprite.Group(),
    "hazard_sprites": pygame.sprite.Group(),
    "enemy_sprites": pygame.sprite.Group(),
    "collectible_sprites": pygame.sprite.Group(),
    "projectile_sprites": pygame.sprite.Group(),
    "all_sprites": pygame.sprite.Group(),
    
    # These defaults are less critical as initialize_game_elements recalculates them based on loaded level.
    "level_pixel_width": WIDTH_MAIN, 
    "level_min_y_absolute": 0, 
    "level_max_y_absolute": HEIGHT_MAIN,
    "ground_level_y": HEIGHT_MAIN - getattr(C, 'TILE_SIZE', _TILE_SIZE_DEFAULT),
    "ground_platform_height": getattr(C, 'TILE_SIZE', _TILE_SIZE_DEFAULT),
    "player1_spawn_pos": (100, HEIGHT_MAIN - (getattr(C, 'TILE_SIZE', _TILE_SIZE_DEFAULT) * 2)),
    "player2_spawn_pos": (150, HEIGHT_MAIN - (getattr(C, 'TILE_SIZE', _TILE_SIZE_DEFAULT) * 2)),
    "enemy_spawns_data_cache": [],
    "level_background_color": getattr(C, 'LIGHT_BLUE', _LIGHT_BLUE_DEFAULT)
}

# --- Main Execution ---
if __name__ == "__main__":
    print("MAIN: Starting __main__ execution block.")
    main_clock = pygame.time.Clock()
    app_status = AppStatus()

    fonts: Dict[str, Optional[pygame.font.Font]] = {
        "small": None, "medium": None, "large": None, "debug": None
    }
    try:
        fonts["small"] = pygame.font.Font(None, 28)
        fonts["medium"] = pygame.font.Font(None, 36)
        fonts["large"] = pygame.font.Font(None, 72)
        fonts["debug"] = pygame.font.Font(None, 20)
        if any(f is None for f in fonts.values()):
            raise pygame.error("One or more default fonts failed to load after init.")
        print("MAIN: Fonts loaded successfully.")
    except pygame.error as e:
        print(f"FATAL MAIN: Font loading error: {e}. Ensure Pygame font module is working.")
        app_status.app_running = False 
    except Exception as e:
        print(f"FATAL MAIN: Unexpected error during font loading: {e}")
        app_status.app_running = False

    # --- Main Application Loop ---
    while app_status.app_running:
        current_screen_width, current_screen_height = screen.get_size()
        pygame.display.set_caption("Platformer Adventure - Main Menu")
        
        print("\nMAIN: Showing main menu...")
        menu_choice = game_ui.show_main_menu(screen, main_clock, fonts, app_status)
        print(f"MAIN: Main menu choice: '{menu_choice}'")
        
        if not app_status.app_running or menu_choice == "quit":
            app_status.app_running = False; break 

        map_to_load_for_game: Optional[str] = None 
        if menu_choice in ["couch_play", "host"]:
            print(f"MAIN: Mode '{menu_choice}' requires map selection. Opening map dialog...")
            map_to_load_for_game = game_ui.select_map_dialog(screen, main_clock, fonts, app_status)
            if not app_status.app_running: print("MAIN: App quit during map selection."); break 
            if map_to_load_for_game is None:
                print("MAIN: Map selection cancelled/no maps. Returning to main menu."); continue 
            print(f"MAIN: Map selected for '{menu_choice}': '{map_to_load_for_game}'")
        
        print(f"MAIN: Initializing game elements for mode '{menu_choice}' with map '{map_to_load_for_game if map_to_load_for_game else 'Default/Server-defined'}'...")
        initialized_elements = initialize_game_elements(
            current_screen_width, current_screen_height, 
            for_game_mode=menu_choice,
            existing_sprites_groups={ 
                "all_sprites": game_elements["all_sprites"], "projectile_sprites": game_elements["projectile_sprites"],
                "player1": game_elements.get("player1"), "player2": game_elements.get("player2"),
                "current_chest": game_elements.get("current_chest")
            },
            map_module_name=map_to_load_for_game 
        )

        if initialized_elements is None:
            print(f"Main Error: Failed to initialize game elements for mode '{menu_choice}' (Map: '{map_to_load_for_game}'). Returning to menu.")
            screen.fill(getattr(C, 'BLACK', (0,0,0))) 
            if fonts.get("medium"):
                err_msg_surf = fonts["medium"].render(f"Error starting {menu_choice} mode.", True, getattr(C, 'RED', (255,0,0)))
                screen.blit(err_msg_surf, err_msg_surf.get_rect(center=(current_screen_width//2, current_screen_height//2)))
            pygame.display.flip(); pygame.time.wait(3000); continue

        game_elements.update(initialized_elements)
        
        if game_elements.get("camera"):
            cam_instance = game_elements["camera"]
            if hasattr(cam_instance, "set_screen_dimensions"):
                 cam_instance.set_screen_dimensions(current_screen_width, current_screen_height)
            else: 
                 cam_instance.screen_width, cam_instance.screen_height = current_screen_width, current_screen_height
                 if hasattr(cam_instance, 'camera_rect'):
                    cam_instance.camera_rect.width, cam_instance.camera_rect.height = current_screen_width, current_screen_height
            print(f"MAIN: Camera screen dimensions updated to {current_screen_width}x{current_screen_height}")

        print(f"MAIN: Launching game mode: '{menu_choice}'")
        if menu_choice == "host":
            server_state = ServerState(); server_state.app_running = app_status.app_running 
            run_server_mode(screen, main_clock, fonts, game_elements, server_state)
            app_status.app_running = server_state.app_running
        elif menu_choice == "join_lan":
            client_state = ClientState(); client_state.app_running = app_status.app_running
            run_client_mode(screen, main_clock, fonts, game_elements, client_state, target_ip_port_str=None)
            app_status.app_running = client_state.app_running
        elif menu_choice == "join_ip":
            print("MAIN: Requesting IP input for 'join_ip' mode...")
            target_ip_input = game_ui.get_server_ip_input_dialog(screen, main_clock, fonts, app_status, default_input_text="127.0.0.1:5555")
            print(f"MAIN: IP input dialog returned: '{target_ip_input}'")
            if target_ip_input and app_status.app_running: 
                client_state = ClientState(); client_state.app_running = app_status.app_running
                run_client_mode(screen, main_clock, fonts, game_elements, client_state, target_ip_port_str=target_ip_input)
                app_status.app_running = client_state.app_running
            elif not app_status.app_running: print("MAIN: IP input cancelled or app quit during dialog.")
            else: print("MAIN: No IP entered. Returning to main menu.")
        elif menu_choice == "couch_play":
            run_couch_play_mode(screen, main_clock, fonts, game_elements, app_status)
        
        print(f"MAIN: Returned from game mode '{menu_choice}'. App running: {app_status.app_running}")

    print("MAIN: Exiting application loop gracefully.")
    pygame.quit()
    if SCRAP_INITIALIZED_MAIN and pygame.scrap.get_init():
        try: pygame.scrap.quit(); print("Main: pygame.scrap quit successfully.")
        except Exception as e: print(f"Main Warning: Error during pygame.scrap.quit(): {e}")
    print("MAIN: Application terminated.")
    sys.exit(0)

########## START OF FILE: maps\try.py ##########

# Level: try
# Generated by Platformer Level Editor on 1385294
import pygame
from tiles import Platform, Ladder, Lava # Ensure all used tile types are imported by game
import constants as C

# Optional: Define level-specific background color if your game supports it
LEVEL_SPECIFIC_BACKGROUND_COLOR = (173, 216, 230)

def load_map_try(initial_screen_width, initial_screen_height):
    """
    Loads the 'try' level.
    Generated by the level editor.
    """
    print(f"Loading map: load_map_try...") # Game-side log
    platforms = pygame.sprite.Group()
    ladders = pygame.sprite.Group()
    hazards = pygame.sprite.Group()
    enemy_spawns_data = []
    collectible_spawns_data = []

    player1_spawn = (129, 517)
    
    # --- Placed Objects ---
    platforms.add(Platform(40, 520, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(80, 520, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(120, 520, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(160, 520, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(240, 520, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(280, 520, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(360, 520, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(400, 520, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(440, 520, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(480, 520, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(520, 520, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(560, 520, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(600, 520, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(640, 520, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(680, 520, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(720, 520, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(760, 520, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(800, 520, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(840, 520, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(880, 520, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(920, 520, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(960, 520, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(320, 520, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(200, 520, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(40, 480, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(40, 440, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(40, 400, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(40, 360, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(40, 320, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(80, 320, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(120, 320, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(160, 320, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(200, 320, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(240, 320, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(280, 320, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(320, 320, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(360, 320, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(400, 320, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(400, 360, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(400, 400, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(640, 440, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(640, 480, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(680, 440, 40, 40, C.DARK_GREEN, platform_type='ledge'))
    platforms.add(Platform(720, 440, 40, 40, C.DARK_GREEN, platform_type='ledge'))
    platforms.add(Platform(760, 440, 40, 40, C.DARK_GREEN, platform_type='ledge'))
    platforms.add(Platform(800, 440, 40, 40, C.DARK_GREEN, platform_type='ledge'))
    platforms.add(Platform(600, 280, 40, 40, C.DARK_GREEN, platform_type='ledge'))
    platforms.add(Platform(640, 280, 40, 40, C.DARK_GREEN, platform_type='ledge'))
    platforms.add(Platform(680, 280, 40, 40, C.DARK_GREEN, platform_type='ledge'))
    platforms.add(Platform(720, 280, 40, 40, C.DARK_GREEN, platform_type='ledge'))
    platforms.add(Platform(760, 280, 40, 40, C.DARK_GREEN, platform_type='ledge'))
    platforms.add(Platform(920, 360, 40, 40, C.DARK_GREEN, platform_type='ledge'))
    platforms.add(Platform(960, 360, 40, 40, C.DARK_GREEN, platform_type='ledge'))
    platforms.add(Platform(360, 160, 40, 40, C.DARK_GREEN, platform_type='ledge'))
    platforms.add(Platform(400, 160, 40, 40, C.DARK_GREEN, platform_type='ledge'))
    platforms.add(Platform(440, 160, 40, 40, C.DARK_GREEN, platform_type='ledge'))
    platforms.add(Platform(480, 160, 40, 40, C.DARK_GREEN, platform_type='ledge'))
    platforms.add(Platform(520, 160, 40, 40, C.DARK_GREEN, platform_type='ledge'))
    platforms.add(Platform(1000, 520, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(1040, 520, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(1080, 520, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(1120, 520, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(1160, 520, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(1160, 480, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(1160, 440, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(1160, 400, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(1160, 360, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(1160, 320, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(1160, 280, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(1160, 240, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(1160, 200, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(1160, 160, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(1160, 120, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(1160, 80, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(1160, 40, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(1160, 0, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(1040, 480, 40, 40, C.GRAY, platform_type='wall'))
    platforms.add(Platform(1040, 440, 40, 40, C.GRAY, platform_type='wall'))
    # No ladders placed.
    hazards.add(Lava(1120, 480, 40, 40, C.ORANGE_RED))
    hazards.add(Lava(1080, 480, 40, 40, C.ORANGE_RED))
    hazards.add(Lava(1080, 440, 40, 40, C.ORANGE_RED))
    enemy_spawns_data.append({'pos': (729, 517), 'patrol': None, 'enemy_color_id': 'cyan'})
    enemy_spawns_data.append({'pos': (929, 517), 'patrol': None, 'enemy_color_id': 'pink'})
    collectible_spawns_data.append({'type': 'chest', 'pos': (426, 159)})

    # --- Level Dimensions for Game Camera & Boundaries ---
    map_total_width_pixels = 1320
    level_min_y_absolute = -80 # Top-most Y coordinate for camera/content
    level_max_y_absolute = 640 # Bottom-most Y coordinate for camera/content (e.g., death plane below this)
    
    main_ground_y_reference = 560 # Y-value of the main 'floor' surface
    main_ground_height_reference = 40 # Height of typical ground tiles

    # --- Auto-generated Boundary Walls (Invisible in game unless styled) ---
    # These ensure entities cannot go outside the defined level space.
    _boundary_thickness = C.TILE_SIZE * 2 # Make them thick enough
    _boundary_wall_height = level_max_y_absolute - level_min_y_absolute + (2 * _boundary_thickness) # Span slightly beyond min/max_y

    # Top boundary (ceiling) - place its bottom edge at level_min_y_absolute
    platforms.add(Platform(0, level_min_y_absolute - _boundary_thickness, map_total_width_pixels, _boundary_thickness, C.DARK_GRAY, platform_type="boundary_wall_top"))
    # Bottom boundary (floor/kill plane) - place its top edge at level_max_y_absolute
    platforms.add(Platform(0, level_max_y_absolute, map_total_width_pixels, _boundary_thickness, C.DARK_GRAY, platform_type="boundary_wall_bottom"))
    # Left boundary wall
    platforms.add(Platform(-_boundary_thickness, level_min_y_absolute - _boundary_thickness, _boundary_thickness, _boundary_wall_height, C.DARK_GRAY, platform_type="boundary_wall_left"))
    # Right boundary wall
    platforms.add(Platform(map_total_width_pixels, level_min_y_absolute - _boundary_thickness, _boundary_thickness, _boundary_wall_height, C.DARK_GRAY, platform_type="boundary_wall_right"))

    print(f"Map 'load_map_try' loaded with: {len(platforms)} platforms, {len(ladders)} ladders, {len(hazards)} hazards.") # Game-side log
    return (platforms, ladders, hazards, enemy_spawns_data, collectible_spawns_data,
            player1_spawn,
            map_total_width_pixels, level_min_y_absolute, level_max_y_absolute,
            main_ground_y_reference, main_ground_height_reference,
            LEVEL_SPECIFIC_BACKGROUND_COLOR) # Return background color


########## START OF FILE: network_comms.py ##########

# network_comms.py
# -*- coding: utf-8 -*-
# version 1.0000000.1
"""
Networking utilities for data encoding/decoding and IP retrieval.
"""
import socket
import json

def get_local_ip():
    """Gets the local IP address of the machine."""
    best_ip = '127.0.0.1'
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80)) # Connect to a known external server (doesn't send data)
        best_ip = s.getsockname()[0]
        s.close()
    except Exception:
        try:
            best_ip = socket.gethostbyname(socket.gethostname())
        except Exception:
            best_ip = '127.0.0.1' # Fallback
    return best_ip

def encode_data(data):
    """Encodes Python dictionary to JSON bytes with a newline delimiter."""
    try:
        return json.dumps(data).encode('utf-8') + b'\n'
    except TypeError as e:
        print(f"Encoding Error: {e} Data: {str(data)[:100]}")
        return None
    except Exception as e:
        print(f"Unexpected Encoding Error: {e}")
        return None

def decode_data_stream(byte_buffer):
    """
    Decodes a stream of newline-delimited JSON byte data.
    Returns a list of decoded objects and the remaining unparsed buffer.
    """
    decoded_objects = []
    remaining_buffer = byte_buffer
    while b'\n' in remaining_buffer:
        message, remaining_buffer = remaining_buffer.split(b'\n', 1)
        if not message:  # Skip empty messages (e.g. if multiple newlines)
            continue
        try:
            decoded_objects.append(json.loads(message.decode('utf-8')))
        except json.JSONDecodeError as e:
            # print(f"JSON Decode Error: {e}. Malformed message: {message[:100]}") # Optional: log malformed
            continue # Skip malformed JSON
        except Exception as e:
            # print(f"Unexpected Decode Error: {e}. Message: {message[:100]}") # Optional: log other errors
            continue
    return decoded_objects, remaining_buffer

########## START OF FILE: player.py ##########

########## START OF FILE: player.py ##########

# player.py
# -*- coding: utf-8 -*-
"""
## version 1.0.0.1 (Added stomp functionality)
Defines the Player class, handling core attributes, physics, animation,
and state transitions. Delegates input, combat, and network handling
to respective handler modules for improved organization.
"""
import pygame
import os # Not strictly needed here if assets.py handles all pathing
import sys # Not strictly needed here
import math
# import time # Only if PrintLimiter was defined directly in this file

from utils import PrintLimiter # Use the shared PrintLimiter from utils.py
import constants as C # Game constants
from assets import load_all_player_animations # For loading player sprites
from tiles import Lava # For type checking in hazard collision
from enemy import Enemy # For type checking in stomp

# Import handler modules that contain functions operating on the Player instance
from player_input_handler import process_player_input_logic
from player_combat_handler import (fire_player_fireball, check_player_attack_collisions, 
                                   player_take_damage, player_self_inflict_damage, player_heal_to_full)
from player_network_handler import (get_player_network_data, set_player_network_data, 
                                    handle_player_network_input, get_player_input_state_for_network)


class Player(pygame.sprite.Sprite):
    """
    Represents a player character in the game.
    Manages player's state, animation, physics, and interactions.
    Delegates complex input, combat, and network logic to specialized handlers.
    """
    print_limiter = PrintLimiter(default_limit=5, default_period=3.0) # Class-level limiter for player messages

    def __init__(self, start_x, start_y, player_id=1):
        super().__init__()
        self.player_id = player_id
        self._valid_init = True # Flag to indicate if initialization was successful
        print(f"DEBUG Player (init P{self.player_id}): Initializing at ({start_x}, {start_y})") # DEBUG

        # --- Determine Asset Folder based on Player ID ---
        if self.player_id == 1: asset_folder_path = 'characters/player1'
        elif self.player_id == 2: asset_folder_path = 'characters/player2'
        else: # Fallback for any other player_id
            asset_folder_path = 'characters/player1' # Default to player1 assets
            if Player.print_limiter.can_print(f"player_init_unrecognized_id_{self.player_id}"):
                print(f"Player Info ({self.player_id}): Unrecognized ID. Defaulting to player1 assets from '{asset_folder_path}'.")
        
        print(f"DEBUG Player (init P{self.player_id}): Asset folder path: '{asset_folder_path}'") # DEBUG
        # --- Load Animations ---
        self.animations = load_all_player_animations(relative_asset_folder=asset_folder_path)
        if self.animations is None: # Critical failure if essential animations (like idle) are missing
            print(f"CRITICAL Player Init Error ({self.player_id}): Failed to load critical animations from '{asset_folder_path}'. Player will be invalid.")
            # Create a minimal placeholder image for error representation
            self.image = pygame.Surface((30, 40)).convert_alpha()
            self.image.fill(C.RED) # Red indicates error
            self.rect = self.image.get_rect(midbottom=(start_x, start_y))
            self.is_dead = True; self._valid_init = False # Mark as invalid and stop further initialization
            print(f"DEBUG Player (init P{self.player_id}): Animation load FAILED. _valid_init set to False.") # DEBUG
            return

        print(f"DEBUG Player (init P{self.player_id}): Animations loaded. Number of animation states: {len(self.animations)}") # DEBUG
        if 'idle' not in self.animations or not self.animations['idle']: # DEBUG
            print(f"DEBUG Player (init P{self.player_id}): CRITICAL - 'idle' animation missing after load_all_player_animations returned non-None.") # DEBUG


        # --- Initialize Core Attributes ---
        # Standard height (from idle animation, used for some calculations)
        try: self.standard_height = self.animations['idle'][0].get_height()
        except (KeyError, IndexError, TypeError): # Handle if 'idle' animation is missing or empty
            self.standard_height = 60 # Fallback height
            if Player.print_limiter.can_print(f"player_init_idle_height_warning_{self.player_id}"):
                print(f"Player Warning ({self.player_id}): Could not get idle animation height, using default {self.standard_height}.")

        # Animation and State Variables
        self._last_facing_right = True # Tracks last facing direction for image flipping (True for right)
        self._last_state_for_debug = "init" # For debugging state transitions
        self.state = 'idle'      # Current logical state of the player
        self.current_frame = 0   # Index of the current animation frame
        self.last_anim_update = pygame.time.get_ticks() # Timestamp of last animation frame update

        # Set initial image (first frame of idle animation)
        idle_animation_frames = self.animations.get('idle')
        if idle_animation_frames and len(idle_animation_frames) > 0:
            self.image = idle_animation_frames[0]
            print(f"DEBUG Player (init P{self.player_id}): Initial image set from 'idle' animation, frame 0. Image size: {self.image.get_size()}") # DEBUG
        else: # Fallback if idle animation is missing (should be caught by load_all_player_animations)
            self.image = pygame.Surface((30,40)); self.image.fill(C.RED) # Error placeholder
            print(f"CRITICAL Player Init Error ({self.player_id}): 'idle' animation missing or empty after loader. Player invalid.")
            self._valid_init = False; return

        self.rect = self.image.get_rect(midbottom=(start_x, start_y)) # Player's collision rectangle
        print(f"DEBUG Player (init P{self.player_id}): Initial rect: {self.rect}") # DEBUG
        
        # Physics and Movement Attributes
        self.pos = pygame.math.Vector2(start_x, start_y) # Precise position (floating point)
        self.vel = pygame.math.Vector2(0, 0)             # Current velocity
        self.acc = pygame.math.Vector2(0, C.PLAYER_GRAVITY) # Current acceleration (gravity applied by default)
        self.facing_right = True   # True if facing right, False if facing left
        self.on_ground = False     # True if standing on a solid platform
        self.on_ladder = False     # True if currently on a ladder
        self.can_grab_ladder = False # True if overlapping a ladder and can interact
        self.touching_wall = 0       # -1 for left wall, 1 for right wall, 0 for no wall contact
        self.can_wall_jump = False   # True if conditions for a wall jump are met
        self.wall_climb_timer = 0    # Timer for wall climb duration ability

        # Player State Flags and Timers (for actions like dash, roll, attack, etc.)
        self.is_crouching = False
        self.is_dashing = False; self.dash_timer = 0; self.dash_duration = getattr(C, 'PLAYER_DASH_DURATION', 150) # ms
        self.is_rolling = False; self.roll_timer = 0; self.roll_duration = getattr(C, 'PLAYER_ROLL_DURATION', 300) # ms
        self.is_sliding = False; self.slide_timer = 0; self.slide_duration = getattr(C, 'PLAYER_SLIDE_DURATION', 400) # ms
        
        self.is_attacking = False; self.attack_timer = 0; self.attack_duration = 300 # ms, duration varies by attack type
        self.attack_type = 0 # 0:none, 1:attack1, 2:attack2, 3:combo, 4:crouch_attack
        self.can_combo = False # Flag indicating if player is in a window to perform a combo attack
        self.combo_window = getattr(C, 'PLAYER_COMBO_WINDOW', 150) # ms time window for combo input

        self.wall_climb_duration = getattr(C, 'PLAYER_WALL_CLIMB_DURATION', 500) # Max ms for a wall climb attempt

        self.is_taking_hit = False; self.hit_timer = 0 # Timer for current hit stun / invincibility period
        self.hit_duration = getattr(C, 'PLAYER_HIT_STUN_DURATION', 300) # ms duration of the hit stun animation/effect
        self.hit_cooldown = getattr(C, 'PLAYER_HIT_COOLDOWN', 600)   # ms total invincibility period after being hit

        self.is_dead = False # True if player's health is zero or less
        self.death_animation_finished = False # True when the death animation sequence has completed
        self.state_timer = 0 # General timer that can be used by states for duration tracking

        # Health and Combat
        self.max_health = C.PLAYER_MAX_HEALTH
        self.current_health = self.max_health
        self.attack_hitbox = pygame.Rect(0, 0, 45, 30) # Default size, positioned dynamically during attack checks

        # Input State Flags (primarily set by input handlers, read by update/state logic)
        self.is_trying_to_move_left = False
        self.is_trying_to_move_right = False
        self.is_holding_climb_ability_key = False # Usually 'up' key, for climbing ladders/walls
        self.is_holding_crouch_ability_key = False # Usually 'down' key, for crouching/sliding

        # Fireball / Projectile Attributes
        self.fireball_cooldown_timer = 0 # Timestamp of last fireball fired (for cooldown)
        self.fireball_last_input_dir = pygame.math.Vector2(1.0 if self.facing_right else -1.0, 0.0) # Default aim direction
        self.projectile_sprites_group = None # Reference to game's projectile group (set by main game)
        self.all_sprites_group = None      # Reference to game's all_sprites group (set by main game)
        
        # Player-specific key for firing fireball (allows different keys for P1/P2)
        self.fireball_key = None 
        if self.player_id == 1: self.fireball_key = getattr(C, 'P1_FIREBALL_KEY', pygame.K_1)
        elif self.player_id == 2: self.fireball_key = getattr(C, 'P2_FIREBALL_KEY', pygame.K_0)
        print(f"DEBUG Player (init P{self.player_id}): Init completed. _valid_init: {self._valid_init}") # DEBUG


    def set_projectile_group_references(self, projectile_group: pygame.sprite.Group, 
                                        all_sprites_group: pygame.sprite.Group):
        """
        Called by the main game setup to provide the Player instance with references
        to the sprite groups needed for managing projectiles.
        """
        self.projectile_sprites_group = projectile_group
        self.all_sprites_group = all_sprites_group

    def set_state(self, new_state: str):
        """
        Sets the player's logical and animation state, handling transitions and
        state-specific initializations.

        Args:
            new_state (str): The key for the new state (e.g., 'idle', 'run', 'attack').
        """
        if not self._valid_init: return # Cannot change state if player init failed
        
        original_new_state_request = new_state # For debugging purposes

        # --- Validate that the requested animation state exists; fallback if necessary ---
        animation_frames_for_new_state = self.animations.get(new_state)
        if not animation_frames_for_new_state: # Animation for new_state doesn't exist or is empty
            # Determine a sensible fallback state
            fallback_state_key = 'fall' if not self.on_ground else 'idle'
            if fallback_state_key in self.animations and self.animations[fallback_state_key]:
                new_state = fallback_state_key # Use idle/fall as fallback
                if Player.print_limiter.can_print(f"player_set_state_fallback_{self.player_id}_{original_new_state_request}"):
                    print(f"Player Warning ({self.player_id}): State '{original_new_state_request}' anim missing. Fallback to '{new_state}'.")
            else: # Critical: Even idle/fall animations are missing (should be caught by asset loader)
                first_available_anim_key = next((key for key, anim in self.animations.items() if anim), None)
                if not first_available_anim_key: # No animations loaded at all
                    if Player.print_limiter.can_print(f"player_set_state_no_anims_{self.player_id}"):
                        print(f"CRITICAL Player Error ({self.player_id}): No animations available in set_state. Requested: '{original_new_state_request}'. Player invalid.")
                    self._valid_init = False; return # Player cannot function
                new_state = first_available_anim_key # Use the first available animation as a last resort
                if Player.print_limiter.can_print(f"player_set_state_critical_fallback_{self.player_id}"):
                    print(f"Player CRITICAL Warning ({self.player_id}): State '{original_new_state_request}' and fallbacks missing. Using first available: '{new_state}'.")
        
        # --- Determine if a state change is allowed/needed ---
        # Can change if new state is different, OR if it's 'death' (can re-trigger death anim),
        # AND not already dead with death animation finished (unless new state is 'death' itself).
        can_change_state_now = (self.state != new_state or new_state == 'death') and \
                               not (self.is_dead and self.death_animation_finished and new_state != 'death')

        if can_change_state_now:
            # print(f"DEBUG Player ({self.player_id}): Set State: '{self.state}' -> '{new_state}' (Req: '{original_new_state_request}'). Pos: {self.pos.x:.1f},{self.pos.y:.1f}, Vel: {self.vel.x:.1f},{self.vel.y:.1f}") # DEBUG
            self._last_state_for_debug = new_state # Update debug tracker
            
            # --- Reset flags for states the player is exiting ---
            if 'attack' not in new_state and self.is_attacking: self.is_attacking = False; self.attack_type = 0
            if new_state != 'hit': self.is_taking_hit = False # Clear general hit stun if not entering 'hit' state
            if new_state != 'dash': self.is_dashing = False
            if new_state != 'roll': self.is_rolling = False
            if new_state not in ['slide', 'slide_trans_start', 'slide_trans_end']: self.is_sliding = False

            # --- Set the new state and reset animation frame/timers ---
            self.state = new_state
            self.current_frame = 0 # Start animation from the beginning
            self.last_anim_update = pygame.time.get_ticks() # Reset animation timer
            self.state_timer = pygame.time.get_ticks()      # General timer for this new state

            # --- State-Specific Initialization Logic (executed when entering a new state) ---
            if new_state == 'dash':
                self.is_dashing = True; self.dash_timer = self.state_timer # Record dash start time
                self.vel.x = C.PLAYER_DASH_SPEED * (1 if self.facing_right else -1) # Apply dash velocity
                self.vel.y = 0 # Dash is purely horizontal
            elif new_state == 'roll':
                 self.is_rolling = True; self.roll_timer = self.state_timer
                 # Give a speed boost if rolling from standstill or slow movement
                 if abs(self.vel.x) < C.PLAYER_ROLL_SPEED / 2: self.vel.x = C.PLAYER_ROLL_SPEED * (1 if self.facing_right else -1)
                 elif abs(self.vel.x) < C.PLAYER_ROLL_SPEED: self.vel.x += (C.PLAYER_ROLL_SPEED / 3) * (1 if self.facing_right else -1)
                 self.vel.x = max(-C.PLAYER_ROLL_SPEED, min(C.PLAYER_ROLL_SPEED, self.vel.x)) # Clamp to roll speed limit
            elif new_state == 'slide' or new_state == 'slide_trans_start': # Entering slide
                 self.is_sliding = True; self.slide_timer = self.state_timer
                 # Ensure some initial speed if sliding from a slow run (input handler might also do this)
                 if abs(self.vel.x) < C.PLAYER_RUN_SPEED_LIMIT * 0.5:
                     self.vel.x = C.PLAYER_RUN_SPEED_LIMIT * 0.6 * (1 if self.facing_right else -1)
            elif 'attack' in new_state: # Covers all attack variations (attack, attack_nm, attack2, etc.)
                self.is_attacking = True; self.attack_timer = self.state_timer # Record attack start time
                # Calculate attack duration based on animation frames and speed modifier (if any)
                animation_for_this_attack = self.animations.get(new_state)
                num_attack_frames = len(animation_for_this_attack) if animation_for_this_attack else 0
                base_ms_per_frame = C.ANIM_FRAME_DURATION
                
                # Attack 2 might have a different speed (longer frame duration)
                if self.attack_type == 2 and hasattr(C, 'PLAYER_ATTACK2_FRAME_DURATION_MULTIPLIER'):
                    self.attack_duration = num_attack_frames * int(base_ms_per_frame * C.PLAYER_ATTACK2_FRAME_DURATION_MULTIPLIER) if num_attack_frames > 0 else 300 # Default duration
                else:
                    self.attack_duration = num_attack_frames * base_ms_per_frame if num_attack_frames > 0 else 300
                
                # Stop horizontal movement for "No Movement" (_nm) attacks or crouch attacks
                if new_state.endswith('_nm') or new_state == 'crouch_attack':
                    self.vel.x = 0
            elif new_state == 'hit': # Player is hit
                 self.is_taking_hit = True; self.hit_timer = self.state_timer # Start hit stun / invincibility timer
                 # Apply knockback/stun effect physics
                 if not self.on_ground and self.vel.y > -abs(C.PLAYER_JUMP_STRENGTH * 0.5): # If in air and not strongly ascending
                    self.vel.x *= -0.3 # Slight horizontal knockback in opposite direction of current vel
                    self.vel.y = C.PLAYER_JUMP_STRENGTH * 0.4 # Slight vertical pop-up
                 self.is_attacking = False; self.attack_type = 0 # Cancel any current attack
            elif new_state == 'death' or new_state == 'death_nm': # Player dies
                 self.is_dead = True; self.vel.x = 0 # Stop horizontal movement
                 if self.vel.y < -1: self.vel.y = 1 # Stop strong upward momentum (e.g., if died mid-jump)
                 self.acc.x = 0 # No horizontal acceleration during death
                 if not self.on_ground: self.acc.y = C.PLAYER_GRAVITY # Normal gravity if dying in air
                 else: self.vel.y = 0; self.acc.y = 0 # Rest on ground if already there
                 self.death_animation_finished = False # Reset death animation flag
            elif new_state == 'wall_climb':
                 self.wall_climb_timer = self.state_timer # Start wall climb duration timer
                 self.vel.y = C.PLAYER_WALL_CLIMB_SPEED # Apply wall climb speed
            elif new_state == 'wall_slide' or new_state == 'wall_hang':
                 self.wall_climb_timer = 0 # Reset wall climb timer if sliding or hanging (not actively climbing up)

            self.animate() # Update player image immediately to reflect the new state
        
        elif not self.is_dead: # If state didn't change but player is not dead
             self._last_state_for_debug = self.state # Keep debug state current


    def animate(self):
        """
        Updates the player's current image based on its state, frame, and facing direction.
        Handles animation looping, transitions at the end of non-looping animations,
        and image flipping.
        """
        if not self._valid_init or not hasattr(self, 'animations') or not self.animations:
            # print(f"DEBUG Player (animate P{self.player_id}): Animation skipped. Valid: {self._valid_init}, HasAnims: {hasattr(self, 'animations')}, AnimsOK: {bool(self.animations if hasattr(self, 'animations') else False)}") # DEBUG
            return
        if not self.alive(): # Don't animate if sprite is not in any groups (e.g., after self.kill())
            # print(f"DEBUG Player (animate P{self.player_id}): Animation skipped, player not alive (not in groups).") # DEBUG
            return 

        current_time_ms = pygame.time.get_ticks()
        animation_key_to_use = self.state # Start with the player's current logical state

        # --- Determine the correct animation key based on current state and conditions ---
        # This complex logic maps the player's detailed situation to specific animation sheet keys.
        player_is_intending_to_move_lr = self.is_trying_to_move_left or self.is_trying_to_move_right

        if self.is_dead: 
            # Choose between death animation with movement (_nm for No Movement) or static death animation
            animation_key_to_use = 'death_nm' if abs(self.vel.x) < 0.5 and abs(self.vel.y) < 1.0 and \
                                     'death_nm' in self.animations and self.animations['death_nm'] \
                                  else 'death'
            if animation_key_to_use not in self.animations or not self.animations[animation_key_to_use]:
                animation_key_to_use = 'death' # Fallback if preferred death animation is missing
        elif self.is_attacking:
            # Choose attack animation based on attack_type and if player is intending to move
            if self.attack_type == 1: animation_key_to_use = 'attack' if player_is_intending_to_move_lr and 'attack' in self.animations and self.animations['attack'] else 'attack_nm'
            elif self.attack_type == 2: animation_key_to_use = 'attack2' if player_is_intending_to_move_lr and 'attack2' in self.animations and self.animations['attack2'] else 'attack2_nm'
            elif self.attack_type == 3: animation_key_to_use = 'attack_combo' if player_is_intending_to_move_lr and 'attack_combo' in self.animations and self.animations['attack_combo'] else 'attack_combo_nm'
            elif self.attack_type == 4: animation_key_to_use = 'crouch_attack'
            
            # Fallback if specific attack_nm (No Movement) or standard attack animation is missing
            if animation_key_to_use not in self.animations or not self.animations[animation_key_to_use]:
                 base_attack_state_key = animation_key_to_use.replace('_nm', '') # Try without '_nm' suffix
                 if base_attack_state_key in self.animations and self.animations[base_attack_state_key]:
                     animation_key_to_use = base_attack_state_key
                 else: # Ultimate fallback for attack animations
                     animation_key_to_use = 'idle' 
        elif self.state == 'wall_climb': # Specific logic for wall climb animation
             player_is_actively_climbing_wall = self.is_holding_climb_ability_key and \
                                    abs(self.vel.y - C.PLAYER_WALL_CLIMB_SPEED) < 0.1 # Check if actually moving upwards
             animation_key_to_use = 'wall_climb' if player_is_actively_climbing_wall and 'wall_climb' in self.animations and self.animations['wall_climb'] else 'wall_climb_nm'
             if animation_key_to_use not in self.animations or not self.animations[animation_key_to_use]:
                 animation_key_to_use = 'wall_climb' # Fallback to base wall_climb if _nm variant missing
        elif self.state == 'hit': animation_key_to_use = 'hit' # Standard hit animation
        elif not self.on_ground and not self.on_ladder and self.touching_wall == 0 and \
             self.state not in ['jump', 'jump_fall_trans'] and self.vel.y > 1: # Standard falling animation
             animation_key_to_use = 'fall'
        elif self.on_ladder: # Ladder animations
            animation_key_to_use = 'ladder_climb' if abs(self.vel.y) > 0.1 else 'ladder_idle' # Moving or idle on ladder
            if animation_key_to_use not in self.animations or not self.animations[animation_key_to_use]:
                animation_key_to_use = 'idle' # Fallback if specific ladder animations are missing
        # Direct state-to-animation key mappings for special movement/action states
        elif self.is_dashing: animation_key_to_use = 'dash'
        elif self.is_rolling: animation_key_to_use = 'roll'
        elif self.is_sliding: animation_key_to_use = 'slide' # Main sliding animation
        elif self.state == 'slide_trans_start': animation_key_to_use = 'slide_trans_start'
        elif self.state == 'slide_trans_end': animation_key_to_use = 'slide_trans_end'
        elif self.state == 'crouch_trans': animation_key_to_use = 'crouch_trans'
        elif self.state == 'turn': animation_key_to_use = 'turn'
        elif self.state == 'jump': animation_key_to_use = 'jump'
        elif self.state == 'jump_fall_trans': animation_key_to_use = 'jump_fall_trans'
        elif self.state == 'wall_slide': animation_key_to_use = 'wall_slide'
        elif self.state == 'wall_hang': animation_key_to_use = 'wall_hang'
        elif self.on_ground: # Grounded states based on movement intention and crouching
            if self.is_crouching:
                animation_key_to_use = 'crouch_walk' if player_is_intending_to_move_lr and 'crouch_walk' in self.animations and self.animations['crouch_walk'] else 'crouch'
            elif player_is_intending_to_move_lr: animation_key_to_use = 'run'
            else: animation_key_to_use = 'idle'
        
        # Final fallback if the derived animation_key_to_use is invalid or missing
        if animation_key_to_use not in self.animations or not self.animations[animation_key_to_use]: 
            # print(f"DEBUG Player (animate P{self.player_id}): Anim key '{animation_key_to_use}' for state '{self.state}' not found or empty. Falling back to 'idle'.") # DEBUG
            animation_key_to_use = 'idle' # Default to 'idle' animation
        
        current_animation_frames_list = self.animations.get(animation_key_to_use)

        if not current_animation_frames_list: # Should not happen if 'idle' is guaranteed by asset loader
            if hasattr(self, 'image') and self.image: self.image.fill(C.RED) # Error placeholder
            if Player.print_limiter.can_print(f"player_animate_no_frames_{self.player_id}_{animation_key_to_use}"):
                print(f"CRITICAL Player Animate Error ({self.player_id}): No frames found for anim key '{animation_key_to_use}' (Logical state: {self.state})")
            return
        
        # print(f"DEBUG Player (animate P{self.player_id}): Using anim key '{animation_key_to_use}', state '{self.state}', {len(current_animation_frames_list)} frames. Current frame idx: {self.current_frame}") # DEBUG - Can be noisy

        # Determine frame duration (e.g., Attack 2 might be slower, having longer frame durations)
        ms_per_frame_for_current_anim = C.ANIM_FRAME_DURATION
        if self.is_attacking and self.attack_type == 2 and hasattr(C, 'PLAYER_ATTACK2_FRAME_DURATION_MULTIPLIER'):
            ms_per_frame_for_current_anim = int(C.ANIM_FRAME_DURATION * C.PLAYER_ATTACK2_FRAME_DURATION_MULTIPLIER)

        # --- Animation Frame Progression ---
        if not (self.is_dead and self.death_animation_finished): # Don't advance frame if death animation has completed
            if current_time_ms - self.last_anim_update > ms_per_frame_for_current_anim: # Time for next frame
                self.last_anim_update = current_time_ms # Reset timer for this frame
                self.current_frame += 1 # Advance to the next frame
                
                if self.current_frame >= len(current_animation_frames_list): # Reached the end of the animation sequence
                    if self.is_dead: # If death animation just finished playing
                        # if Player.print_limiter.can_print(f"player_animate_death_anim_completed_{self.player_id}"):
                        #     print(f"DEBUG Player ({self.player_id}): Death Animation sequence visually FINISHED.")
                        self.current_frame = len(current_animation_frames_list) - 1 # Hold the last frame of death animation
                        self.death_animation_finished = True
                        # Update image one last time for the final death frame before returning
                        final_death_image_surface = current_animation_frames_list[self.current_frame]
                        if not self.facing_right: final_death_image_surface = pygame.transform.flip(final_death_image_surface, True, False)
                        old_player_midbottom = self.rect.midbottom
                        self.image = final_death_image_surface
                        self.rect = self.image.get_rect(midbottom=old_player_midbottom)
                        return # Stop further animation processing for this frame once death anim is done
                    
                    # --- Handle transitions for non-looping animations ---
                    # Define states whose animations should not loop but transition to another state.
                    non_looping_animation_states = [
                        'attack','attack_nm','attack2','attack2_nm','attack_combo','attack_combo_nm',
                        'crouch_attack','dash','roll','slide','hit','turn','jump',
                        'jump_fall_trans','crouch_trans','slide_trans_start','slide_trans_end']
                    
                    if self.state in non_looping_animation_states: # If current logical state's animation just finished
                         next_logical_state_after_anim = None # Determine the state to transition to
                         current_logical_state_of_player = self.state 
                         player_is_intending_to_move_at_anim_end = self.is_trying_to_move_left or self.is_trying_to_move_right

                         # Determine next state based on the one that just finished
                         if current_logical_state_of_player == 'jump':
                             next_logical_state_after_anim = 'jump_fall_trans' if 'jump_fall_trans' in self.animations and self.animations['jump_fall_trans'] else 'fall'
                         elif current_logical_state_of_player == 'jump_fall_trans':
                             next_logical_state_after_anim = 'fall'
                         elif current_logical_state_of_player == 'hit': 
                             next_logical_state_after_anim = 'fall' if not self.on_ground and not self.on_ladder else 'idle'
                         elif current_logical_state_of_player == 'turn':
                             next_logical_state_after_anim = 'run' if player_is_intending_to_move_at_anim_end else 'idle'
                         elif 'attack' in current_logical_state_of_player: # Any attack animation finished
                              self.is_attacking = False; self.attack_type = 0 # Reset attack flags
                              # Transition based on player's situation after attack
                              if self.on_ladder: pass # Ladder logic will take over if still on ladder
                              elif self.is_crouching: next_logical_state_after_anim = 'crouch'
                              elif not self.on_ground: next_logical_state_after_anim = 'fall'
                              elif player_is_intending_to_move_at_anim_end : next_logical_state_after_anim = 'run'
                              else: next_logical_state_after_anim = 'idle'
                         elif current_logical_state_of_player == 'crouch_trans': # Crouch transition (e.g., stand to crouch) finished
                             self.is_crouching = self.is_holding_crouch_ability_key # Update crouch based on key hold
                             next_logical_state_after_anim = 'crouch' if self.is_crouching else 'idle'
                         elif current_logical_state_of_player == 'slide_trans_start': # Slide entry transition finished
                             next_logical_state_after_anim = 'slide' # Enter main slide animation
                         elif current_logical_state_of_player in ['slide_trans_end', 'slide']: # Slide finished (either main or exit transition)
                             self.is_sliding = False # No longer sliding
                             self.is_crouching = self.is_holding_crouch_ability_key # Check if still holding crouch
                             next_logical_state_after_anim = 'crouch' if self.is_crouching else 'idle'
                         else: # For other non-looping states like dash, roll
                              if current_logical_state_of_player == 'dash': self.is_dashing = False # Dash action ends
                              if current_logical_state_of_player == 'roll': self.is_rolling = False # Roll action ends
                              # Default transition based on environment after action
                              if self.on_ladder: pass 
                              elif self.is_crouching: next_logical_state_after_anim = 'crouch'
                              elif not self.on_ground: next_logical_state_after_anim = 'fall'
                              elif player_is_intending_to_move_at_anim_end : next_logical_state_after_anim = 'run'
                              else: next_logical_state_after_anim = 'idle'
                         
                         if next_logical_state_after_anim: # If a next state was determined
                             self.set_state(next_logical_state_after_anim) # Transition to it
                             return # set_state calls animate(), so return to avoid double processing this frame
                         else: # Should not happen for defined non-looping states; implies missing transition logic
                             self.current_frame = 0 # Loop this non-looping anim (usually an error in state logic)
                    else: # For looping animations (e.g. idle, run, fall), reset to first frame
                        self.current_frame = 0 
                
                # Ensure current_frame is valid after potential reset/change due to animation end
                if self.current_frame >= len(current_animation_frames_list): self.current_frame = 0
        
        # --- Get the actual image surface for the current animation frame ---
        # Handle cases where animation frames might be empty (though asset loader should prevent this)
        if not current_animation_frames_list or self.current_frame < 0 or self.current_frame >= len(current_animation_frames_list):
            # print(f"DEBUG Player (animate P{self.player_id}): Invalid frame index ({self.current_frame}) or empty frame list for anim '{animation_key_to_use}'. Resetting to 0.") # DEBUG
            self.current_frame = 0 # Reset frame index to prevent crash
            if not current_animation_frames_list: # Still no frames (major issue)
                if hasattr(self, 'image') and self.image: self.image.fill(C.RED) # Error placeholder
                return

        image_for_this_frame = current_animation_frames_list[self.current_frame]
        # Flip image horizontally if player is not facing right
        if not self.facing_right: 
            image_for_this_frame = pygame.transform.flip(image_for_this_frame, True, False)
        
        # --- Update player's main image and rect if it changed or facing direction changed ---
        # This optimizes by avoiding unnecessary image/rect updates if nothing visual changed.
        if self.image is not image_for_this_frame or self._last_facing_right != self.facing_right:
            old_player_midbottom_pos = self.rect.midbottom # Preserve position anchor (midbottom)
            self.image = image_for_this_frame # Set the new image
            self.rect = self.image.get_rect(midbottom=old_player_midbottom_pos) # Re-anchor rect
            self._last_facing_right = self.facing_right # Update tracking of last facing direction
            # print(f"DEBUG Player (animate P{self.player_id}): Image updated. New image size: {self.image.get_size()}, Rect: {self.rect}") # DEBUG


    # --- Input Handling Methods (delegate to player_input_handler) ---
    def handle_input(self, keys_pressed_state, pygame_event_list):
        """Handles standard WASD keyboard input by delegating to the input handler."""
        # Default key configuration for Player 1 (or single player)
        default_key_config = {
            'left': pygame.K_a, 'right': pygame.K_d, 'up': pygame.K_w, 'down': pygame.K_s,
            'attack1': pygame.K_v, 'attack2': pygame.K_b, 'dash': pygame.K_LSHIFT,
            'roll': pygame.K_LCTRL, 'interact': pygame.K_e
        }
        process_player_input_logic(self, keys_pressed_state, pygame_event_list, default_key_config)

    def handle_mapped_input(self, keys_pressed_state, pygame_event_list, key_map_dict):
        """Handles input based on a provided key_map dictionary (e.g., for Player 2)."""
        process_player_input_logic(self, keys_pressed_state, pygame_event_list, key_map_dict)

    # --- Combat Handling Methods (delegate to player_combat_handler) ---
    def fire_fireball(self):
        """Initiates firing a fireball by delegating to the combat handler."""
        fire_player_fireball(self)

    def check_attack_collisions(self, list_of_targets):
        """Checks for collisions during an attack by delegating to the combat handler."""
        check_player_attack_collisions(self, list_of_targets)

    def take_damage(self, damage_amount_taken):
        """Processes damage taken by delegating to the combat handler."""
        player_take_damage(self, damage_amount_taken)

    def self_inflict_damage(self, damage_amount_to_self):
        """Inflicts damage on self (debug/special) by delegating to the combat handler."""
        player_self_inflict_damage(self, damage_amount_to_self)

    def heal_to_full(self):
        """Heals player to full health by delegating to the combat handler."""
        player_heal_to_full(self)
        
    # --- Network Handling Methods (delegate to player_network_handler) ---
    def get_network_data(self):
        """Gets player state for network transmission by delegating to the network handler."""
        return get_player_network_data(self)

    def set_network_data(self, received_network_data):
        """Applies received network data to this player by delegating to the network handler."""
        set_player_network_data(self, received_network_data)

    def handle_network_input(self, network_input_data_dict):
        """Processes input commands received over network by delegating to the network handler."""
        handle_player_network_input(self, network_input_data_dict)

    def get_input_state_for_network(self, current_pygame_keys_state, current_pygame_event_list, 
                                    key_map_for_this_player):
        """Gathers local input state for network transmission by delegating to the network handler."""
        return get_player_input_state_for_network(self, current_pygame_keys_state, 
                                                  current_pygame_event_list, key_map_for_this_player)

    # --- Core Update Method (Physics, State Timers, Collisions) ---
    def update(self, dt_sec, platforms_group, ladders_group, hazards_group, 
               other_players_sprite_list, enemies_sprite_list):
        """
        Main update loop for the player. Handles physics, state timer progression,
        and collision detection/resolution.

        Args:
            dt_sec (float): Delta time in seconds since the last frame. Not directly used in this
                            version's physics, but good practice for frame-rate independent movement.
            platforms_group (pygame.sprite.Group): Group of solid platform sprites.
            ladders_group (pygame.sprite.Group): Group of ladder sprites.
            hazards_group (pygame.sprite.Group): Group of hazard sprites (e.g., lava).
            other_players_sprite_list (list): List of other Player sprites for character collision.
            enemies_sprite_list (list): List of Enemy sprites for character and attack collision.
        """
        # print(f"DEBUG Player (update P{self.player_id}): Start of update. Pos: {self.pos.x:.1f},{self.pos.y:.1f}, Vel: {self.vel.x:.1f},{self.vel.y:.1f}, State: {self.state}, Valid: {self._valid_init}, Alive: {self.alive()}") # DEBUG - Very noisy
        if not self._valid_init: return # Do nothing if player initialization failed
        
        # --- Handle Death State Separately ---
        # If player is dead, only handle falling physics (if applicable) and death animation.
        if self.is_dead: 
            if self.alive() and hasattr(self, 'animate'): # Ensure still in sprite groups and can animate
                if not self.death_animation_finished: # If death animation is still playing
                    if not self.on_ground: # Apply gravity if in air during death sequence
                        # self.acc.y should be C.PLAYER_GRAVITY, set in set_state('death')
                        self.vel.y += self.acc.y 
                        self.vel.y = min(self.vel.y, getattr(C, 'TERMINAL_VELOCITY_Y', 18)) # Cap fall speed
                        self.pos.y += self.vel.y # Update position
                        self.rect.bottom = round(self.pos.y) # Update rect
                        # Check for ground collision during death fall
                        self.on_ground = False # Assume not on ground until collision proves otherwise
                        for platform_sprite in pygame.sprite.spritecollide(self, platforms_group, False):
                            # Check if landed on top of platform
                            if self.vel.y > 0 and self.rect.bottom > platform_sprite.rect.top and \
                               (self.pos.y - self.vel.y) <= platform_sprite.rect.top + 1: # Approx. prev bottom
                                self.rect.bottom = platform_sprite.rect.top
                                self.on_ground = True; self.vel.y = 0; self.acc.y = 0 # Stop falling
                                self.pos.y = self.rect.bottom; break # Landed
                self.animate() # Continue playing/holding death animation
            return # No further updates (movement, input, etc.) if dead

        current_time_ms = pygame.time.get_ticks() # Current game time

        # --- Manage State Timers and Cooldowns (Dash, Roll, Slide, Hit Invincibility) ---
        # Dash timer: if dash duration ends, transition out of dash state
        if self.is_dashing and current_time_ms - self.dash_timer > self.dash_duration:
            self.is_dashing = False # Dash action finished
            self.set_state('idle' if self.on_ground else 'fall') # Transition to appropriate state
        
        # Roll timer: if roll duration ends, transition out of roll state
        if self.is_rolling and current_time_ms - self.roll_timer > self.roll_duration:
            self.is_rolling = False # Roll action finished
            self.set_state('idle' if self.on_ground else 'fall')
        
        # Slide timer: if slide duration ends (can also end by friction or animation)
        if self.is_sliding and current_time_ms - self.slide_timer > self.slide_duration:
            # Slide logic in animate() or input_handler often transitions out earlier based on friction/anim end.
            # This timer is a failsafe or for fixed-duration slides.
            if self.state == 'slide': # If still in main slide state by timer end
                self.is_sliding = False
                # Transition to slide end animation or crouch/idle based on input
                slide_end_anim_key = 'slide_trans_end' if 'slide_trans_end' in self.animations else None
                if slide_end_anim_key: self.set_state(slide_end_anim_key)
                else: self.set_state('crouch' if self.is_holding_crouch_ability_key else 'idle')

        # Hit stun / invincibility cooldown: manage when player can be hit again
        if self.is_taking_hit and current_time_ms - self.hit_timer > self.hit_cooldown:
            # Note: self.hit_duration is for the stun animation/effect. self.hit_cooldown is for total invincibility.
            if self.state == 'hit': # If still in 'hit' state after invincibility cooldown (anim might be longer)
                self.is_taking_hit = False # Cooldown over, can be hit again
                # Don't force state change here; let 'hit' animation finish or other logic transition player out.
            else: # Cooldown ended, and player is no longer in 'hit' state (already transitioned)
                self.is_taking_hit = False
        
        # --- Ladder Interaction ---
        self.check_ladder_collisions(ladders_group) # Update self.can_grab_ladder
        if self.on_ladder and not self.can_grab_ladder: # If was on ladder but no longer can grab (e.g., moved off)
            self.on_ladder = False # No longer on ladder
            self.set_state('fall' if not self.on_ground else 'idle') # Transition to fall or idle

        # --- Apply Physics (Movement based on Velocity and Acceleration) ---
        # Vertical movement (gravity, jump, ladder climbing speed)
        should_apply_gravity_this_frame = not (
            self.on_ladder or self.state == 'wall_hang' or
            (self.state == 'wall_climb' and self.vel.y <= C.PLAYER_WALL_CLIMB_SPEED + 0.1) or # If actively climbing up
            self.is_dashing # Dashing is purely horizontal
        )
        if should_apply_gravity_this_frame:
            self.vel.y += self.acc.y # self.acc.y is usually C.PLAYER_GRAVITY

        # Horizontal movement (acceleration from input, friction)
        should_apply_horizontal_physics = not (
            self.is_dashing or self.is_rolling or self.on_ladder or
            (self.state == 'wall_climb' and self.vel.y <= C.PLAYER_WALL_CLIMB_SPEED + 0.1) # No horiz control while climbing up
        )
        if should_apply_horizontal_physics:
            self.vel.x += self.acc.x # self.acc.x is set by input_handler

            # --- Apply Friction ---
            friction_coefficient_to_apply = 0 # Default: no friction
            if self.on_ground and self.acc.x == 0 and not self.is_sliding and self.state != 'slide':
                friction_coefficient_to_apply = C.PLAYER_FRICTION # Standard ground friction when not accelerating
            elif not self.on_ground and not self.is_attacking and \
                 self.state not in ['wall_slide','wall_hang','wall_climb','wall_climb_nm']:
                friction_coefficient_to_apply = C.PLAYER_FRICTION * 0.2 # Air friction (less effective)
            elif self.is_sliding or self.state == 'slide':
                friction_coefficient_to_apply = C.PLAYER_FRICTION * 0.7 # Specific friction for sliding

            if friction_coefficient_to_apply != 0:
                 friction_force_applied = self.vel.x * friction_coefficient_to_apply # Friction opposes velocity
                 if abs(self.vel.x) > 0.1: self.vel.x += friction_force_applied # Apply friction
                 else: self.vel.x = 0 # Stop if velocity is very low
                 
                 # If sliding and friction brings velocity very low, end slide
                 if abs(self.vel.x) < 0.5 and (self.is_sliding or self.state == 'slide'):
                     self.is_sliding = False # No longer sliding
                     # Transition to slide end animation or crouch/idle
                     slide_end_anim_key_friction = 'slide_trans_end' if 'slide_trans_end' in self.animations and self.animations['slide_trans_end'] else None
                     if slide_end_anim_key_friction: self.set_state(slide_end_anim_key_friction)
                     else: # No transition animation, decide based on crouch key hold
                         self.is_crouching = self.is_holding_crouch_ability_key
                         self.set_state('crouch' if self.is_crouching else 'idle')
            
            # --- Speed Limiting (Horizontal) ---
            # Apply normal run speed limit, or reduced limit if crouch-walking.
            # Dash, roll, and slide manage their own speeds and are excluded here.
            current_horizontal_speed_limit = C.PLAYER_RUN_SPEED_LIMIT
            if self.is_crouching and self.state == 'crouch_walk':
                current_horizontal_speed_limit *= 0.6 # Slower when crouch-walking
            
            if not self.is_dashing and not self.is_rolling and not self.is_sliding and self.state != 'slide':
                self.vel.x = max(-current_horizontal_speed_limit, min(current_horizontal_speed_limit, self.vel.x))

        # --- Terminal Velocity (Vertical) ---
        # Cap falling speed to prevent excessive acceleration.
        if self.vel.y > 0 and not self.on_ladder: # If moving downwards and not on a ladder
            self.vel.y = min(self.vel.y, getattr(C, 'TERMINAL_VELOCITY_Y', 18))

        # --- Collision Detection and Resolution ---
        self.touching_wall = 0 # Reset wall touch state each frame; will be set by x-collision
        self.on_ground = False # Reset ground state; will be set by y-collision with platforms

        # --- Horizontal Collision Pass ---
        self.pos.x += self.vel.x # Update precise horizontal position
        self.rect.centerx = round(self.pos.x) # Update rect for collision check
        self.check_platform_collisions('x', platforms_group) # Check and resolve platform collisions
        
        # Consolidate list of other characters for collision checks
        all_other_character_sprites = [p for p in other_players_sprite_list if p and p._valid_init and p.alive() and p is not self] + \
                                      [e for e in enemies_sprite_list if e and e._valid_init and e.alive()]
        collided_horizontally_with_character = self.check_character_collisions('x', all_other_character_sprites)

        # --- Vertical Collision Pass ---
        self.pos.y += self.vel.y # Update precise vertical position
        self.rect.bottom = round(self.pos.y) # Update rect for collision check
        self.check_platform_collisions('y', platforms_group) # Check and resolve platform collisions (sets self.on_ground)

        # Only check for vertical character collisions if no horizontal character collision occurred in this frame
        # to prevent characters from getting "stuck" or pushed through each other weirdly due to double collision resolution.
        if not collided_horizontally_with_character: 
            self.check_character_collisions('y', all_other_character_sprites) 

        # --- Synchronize Precise Position with Rect after all collision resolutions ---
        self.pos.x = self.rect.centerx 
        self.pos.y = self.rect.bottom

        # --- Hazard Collisions (e.g., Lava) ---
        self.check_hazard_collisions(hazards_group)

        # --- Attack Collisions (if player is currently attacking) ---
        if self.alive() and not self.is_dead and self.is_attacking: # Ensure player is in a state to attack
            # Targets for melee attacks can be other players or enemies
            targets_for_player_attack = [p for p in other_players_sprite_list if p and p._valid_init and p.alive() and p is not self] + \
                                        [e for e in enemies_sprite_list if e and e._valid_init and e.alive()]
            self.check_attack_collisions(targets_for_player_attack) # Delegates to combat_handler via self.method
        
        # --- Final Animation Update for the Frame ---
        # This ensures the player's visual representation matches their current state and facing direction.
        self.animate()
        # print(f"DEBUG Player (update P{self.player_id}): End of update. Pos: {self.pos.x:.1f},{self.pos.y:.1f}, Rect: {self.rect}, Image: {self.image.get_size() if self.image else 'NoImg'}") # DEBUG - Very Noisy


    def check_platform_collisions(self, direction: str, platforms_group: pygame.sprite.Group):
        """
        Handles collisions between the player and solid platforms.
        Resolves collisions by adjusting player position and velocity.
        Updates `self.on_ground` and `self.touching_wall` flags.

        Args:
            direction (str): The axis of collision to check ('x' or 'y').
            platforms_group (pygame.sprite.Group): The sprite group containing platforms.
        """
        collided_with_wall_on_side = 0 # For detecting wall touch: -1 for left, 1 for right
        
        # Iterate through all platforms the player is currently colliding with
        for platform_sprite in pygame.sprite.spritecollide(self, platforms_group, False):
            if direction == 'x': # --- Horizontal Collision Resolution ---
                if self.vel.x > 0: # Player was moving right, collided with platform's left side
                    self.rect.right = platform_sprite.rect.left # Align player's right edge with platform's left
                    # Check if this collision constitutes a wall touch (player is in air, not on ladder)
                    if not self.on_ground and not self.on_ladder and self.rect.bottom > platform_sprite.rect.top + 5: # +5 to avoid false positives from ground edges
                        collided_with_wall_on_side = 1 # Touched a wall on player's right
                elif self.vel.x < 0: # Player was moving left, collided with platform's right side
                    self.rect.left = platform_sprite.rect.right # Align player's left edge with platform's right
                    if not self.on_ground and not self.on_ladder and self.rect.bottom > platform_sprite.rect.top + 5:
                        collided_with_wall_on_side = -1 # Touched a wall on player's left
                self.vel.x = 0 # Stop horizontal movement due to collision
                self.pos.x = self.rect.centerx # Update precise position based on new rect.centerx
            
            elif direction == 'y': # --- Vertical Collision Resolution ---
                if self.vel.y > 0: # Player was moving down (falling or landing)
                    # Check if player was above or at platform's top edge in the previous frame (approximately)
                    # This helps ensure landing only happens when coming from above.
                    if self.rect.bottom > platform_sprite.rect.top and \
                       (self.pos.y - self.vel.y) <= platform_sprite.rect.top + C.PLAYER_STOMP_LAND_ON_ENEMY_GRACE_PX: # pos.y is bottom, vel.y is positive
                        self.rect.bottom = platform_sprite.rect.top # Align player's bottom with platform's top
                        if not self.on_ground: # If this is the frame the player lands
                            self.can_wall_jump=False; self.wall_climb_timer=0 # Reset wall abilities upon landing
                            if not self.is_sliding and self.state != 'slide_trans_end': # Don't kill slide momentum on land
                                self.vel.x *= 0.8 # Apply slight horizontal friction on landing if not sliding
                        self.on_ground=True; self.vel.y=0 # Player is now on ground, stop vertical velocity
                elif self.vel.y < 0: # Player was moving up (e.g., jumping into a ceiling)
                    # Check if player was below or at platform's bottom edge in previous frame (approx)
                    # Player's top edge is at (pos.y - rect.height)
                    if self.rect.top < platform_sprite.rect.bottom and \
                       ((self.pos.y - self.rect.height) - self.vel.y) >= platform_sprite.rect.bottom -1 :
                         if self.on_ladder: self.on_ladder = False # Knocked off ladder if hit ceiling
                         self.rect.top = platform_sprite.rect.bottom # Align player's top with platform's bottom
                         self.vel.y=0 # Stop upward movement due to collision
                self.pos.y = self.rect.bottom # Update precise position based on new rect.bottom
        
        # After checking all platforms, if a wall collision was detected horizontally:
        if direction == 'x' and collided_with_wall_on_side != 0 and \
           not self.on_ground and not self.on_ladder: # Wall interactions only happen in air
             self.touching_wall = collided_with_wall_on_side # Set which side wall is on
             # Player can wall jump unless they are actively climbing upwards (which consumes the jump ability for that climb)
             self.can_wall_jump = not (self.state == 'wall_climb' and self.is_holding_climb_ability_key)


    def check_ladder_collisions(self, ladders_group: pygame.sprite.Group):
        """
        Checks if the player is overlapping a ladder and can grab onto it.
        Updates `self.can_grab_ladder`.

        Args:
            ladders_group (pygame.sprite.Group): The sprite group containing ladders.
        """
        if not self._valid_init: return # Cannot interact if player is invalid
        
        # Use a slightly smaller rectangle for ladder detection to make grabbing more intentional
        # This helps avoid grabbing ladders accidentally when just brushing past the sides.
        # Inflate by negative values to shrink the rect. Shrink width more than height.
        ladder_check_rect = self.rect.inflate(-self.rect.width * 0.6, -self.rect.height * 0.1) 
        
        self.can_grab_ladder = False # Reset flag each frame
        # Check for collision with any ladder using the smaller check_rect
        for ladder_sprite in pygame.sprite.spritecollide(self, ladders_group, False, 
                               collided=lambda player_sprite, ladder_rect_obj: ladder_check_rect.colliderect(ladder_rect_obj.rect)):
            # Additional conditions for a valid grab:
            # Player should be somewhat horizontally centered on the ladder.
            # Player's vertical center should be within the ladder's vertical span.
            if abs(self.rect.centerx - ladder_sprite.rect.centerx) < ladder_sprite.rect.width * 0.7 and \
               ladder_sprite.rect.top < self.rect.centery < ladder_sprite.rect.bottom : 
                  self.can_grab_ladder = True; break # Found a grabbable ladder


    def check_character_collisions(self, direction: str, characters_list: list):
        """
        Handles collisions between this player and other characters (players, enemies).
        Applies a simple push-back effect to both colliding characters.
        Handles stomp mechanic if player lands on an enemy.

        Args:
            direction (str): The axis of collision to check ('x' or 'y').
            characters_list (list): A list of other character Sprites to check against.

        Returns:
            bool: True if a collision with another character occurred on this axis, False otherwise.
        """
        if not self._valid_init or self.is_dead or not self.alive(): return False # Cannot collide if in these states
        
        a_character_collision_occurred_this_frame = False
        for other_char_sprite in characters_list:
            if other_char_sprite is self: continue # Skip collision check with self
            
            # Ensure the other character is valid, alive, and not dead
            if not (other_char_sprite and hasattr(other_char_sprite, '_valid_init') and \
                    other_char_sprite._valid_init and hasattr(other_char_sprite, 'is_dead') and \
                    not other_char_sprite.is_dead and other_char_sprite.alive()):
                continue 

            if self.rect.colliderect(other_char_sprite.rect): # If a collision is detected
                a_character_collision_occurred_this_frame = True
                
                # --- Stomp Mechanic (check before generic character collision resolution) ---
                is_enemy_and_stompable = isinstance(other_char_sprite, Enemy) and \
                                         not other_char_sprite.is_dead and \
                                         not getattr(other_char_sprite, 'is_stomp_dying', False)

                if is_enemy_and_stompable and direction == 'y' and self.vel.y > 0.5: # Player is falling/jumping downwards
                    # Stomp condition: Player's bottom is near the enemy's top
                    player_bottom_vs_enemy_top_diff = self.rect.bottom - other_char_sprite.rect.top
                    
                    # Check if player's bottom edge is within a small grace area of the enemy's top edge
                    # and player's previous bottom edge was above or at the enemy's top edge.
                    # This ensures the player is landing ON TOP, not just brushing past vertically.
                    previous_player_bottom = self.pos.y - self.vel.y 
                    
                    if (previous_player_bottom <= other_char_sprite.rect.top + C.PLAYER_STOMP_LAND_ON_ENEMY_GRACE_PX and \
                        player_bottom_vs_enemy_top_diff >= 0 and \
                        player_bottom_vs_enemy_top_diff < other_char_sprite.rect.height * 0.33): # Landed within top third
                        
                        if hasattr(other_char_sprite, 'stomp_kill') and callable(other_char_sprite.stomp_kill):
                            other_char_sprite.stomp_kill()
                            self.vel.y = C.PLAYER_STOMP_BOUNCE_STRENGTH # Player bounces off
                            self.on_ground = False # Player is in the air after bounce
                            self.set_state('jump') # Optional: Could use a specific bounce animation if available
                            # Player position might need slight adjustment to ensure clear bounce
                            self.rect.bottom = other_char_sprite.rect.top -1 # Place player slightly above enemy
                            self.pos.y = self.rect.bottom 
                        return True # Stomp occurred, no further collision checks for this interaction

                # --- Generic Character Collision (if not a stomp) ---
                bounce_velocity_on_char_collision = getattr(C, 'CHARACTER_BOUNCE_VELOCITY', 2.5) # From constants
                
                if direction == 'x': # --- Horizontal Character Collision ---
                    # Determine push direction: self is pushed away from other_char
                    push_direction_for_self = -1 if self.rect.centerx < other_char_sprite.rect.centerx else 1
                    
                    # Adjust self's rect to resolve overlap
                    if push_direction_for_self == -1: self.rect.right = other_char_sprite.rect.left
                    else: self.rect.left = other_char_sprite.rect.right
                    self.vel.x = push_direction_for_self * bounce_velocity_on_char_collision # Apply bounce to self
                    
                    # Apply opposite bounce to the other character if it has physics attributes
                    if hasattr(other_char_sprite, 'vel'): 
                        other_char_sprite.vel.x = -push_direction_for_self * bounce_velocity_on_char_collision
                    # Slightly nudge other character's precise position to help prevent immediate re-collision
                    if hasattr(other_char_sprite, 'pos') and hasattr(other_char_sprite, 'rect'): 
                        other_char_sprite.pos.x += (-push_direction_for_self * 1.5) # Small separation nudge
                        other_char_sprite.rect.centerx = round(other_char_sprite.pos.x)
                    self.pos.x = self.rect.centerx # Update self's precise position

                elif direction == 'y': # --- Vertical Character Collision ---
                    # Scenario 1: This player lands on top of another character
                    if self.vel.y > 0 and self.rect.bottom > other_char_sprite.rect.top and \
                       self.rect.centery < other_char_sprite.rect.centery: # Ensure self is mostly above other
                        self.rect.bottom = other_char_sprite.rect.top # Land on top of other character
                        self.on_ground = True; self.vel.y = 0 # Player is now "on_ground" (on the other char)
                    # Scenario 2: This player hits another character from below (e.g., headbutt)
                    elif self.vel.y < 0 and self.rect.top < other_char_sprite.rect.bottom and \
                         self.rect.centery > other_char_sprite.rect.centery: # Ensure self is mostly below other
                        self.rect.top = other_char_sprite.rect.bottom # Align top with other's bottom
                        self.vel.y = 0 # Stop upward movement
                    self.pos.y = self.rect.bottom # Update self's precise position
        return a_character_collision_occurred_this_frame


    def check_hazard_collisions(self, hazards_group: pygame.sprite.Group):
        """
        Checks for collisions with hazards like lava.
        If a collision occurs, player takes damage and is bounced.

        Args:
            hazards_group (pygame.sprite.Group): The sprite group containing hazards.
        """
        current_time_ms = pygame.time.get_ticks()
        # Player cannot be damaged by hazards if invalid, dead, or in hit cooldown period
        if not self._valid_init or self.is_dead or not self.alive() or \
           (self.is_taking_hit and current_time_ms - self.hit_timer < self.hit_cooldown): 
            return
            
        has_been_damaged_by_hazard_this_frame = False
        # Use a specific point for hazard collision (e.g., near player's feet for lava)
        # This prevents taking damage if only the top of the player sprite brushes a hazard.
        hazard_check_point_at_feet = (self.rect.centerx, self.rect.bottom - 2) 

        for hazard_sprite_instance in hazards_group: 
            # Check specifically for Lava instances (can be extended for other hazard types)
            if isinstance(hazard_sprite_instance, Lava) and \
               hazard_sprite_instance.rect.collidepoint(hazard_check_point_at_feet):
                
                if not has_been_damaged_by_hazard_this_frame: # Avoid multiple damage ticks per frame from same hazard type
                    # if Player.print_limiter.can_print(f"player_hazard_touch_{self.player_id}_lava"):
                    #     print(f"DEBUG Player ({self.player_id}): Touched LAVA at {hazard_check_point_at_feet}.")
                    
                    self.take_damage(C.LAVA_DAMAGE) # Delegates to combat_handler via self.take_damage method
                    has_been_damaged_by_hazard_this_frame = True 
                    
                    if not self.is_dead: # If player survived the lava damage, bounce them out
                         self.vel.y = C.PLAYER_JUMP_STRENGTH * 0.75 # Strong bounce upwards
                         # Bounce horizontally away from the center of the lava hazard
                         horizontal_push_direction_from_hazard = 1 if self.rect.centerx < hazard_sprite_instance.rect.centerx else -1
                         self.vel.x = -horizontal_push_direction_from_hazard * \
                                      getattr(C, 'PLAYER_RUN_SPEED_LIMIT', 7) * 0.5 # Moderate horizontal push
                         self.on_ground = False # Player is now in the air
                         self.on_ladder = False # And definitely not on a ladder
                    break # Process one lava collision per frame to avoid multiple damage instances


    def reset_state(self, spawn_position_tuple: tuple):
        """
        Resets the player to their initial state at the given spawn position.
        Called for game restarts or when player respawns.

        Args:
            spawn_position_tuple (tuple): (x, y) coordinates for the player's midbottom.
        """
        print(f"DEBUG Player (reset_state P{self.player_id}): Resetting state to spawn at {spawn_position_tuple}. Current valid: {self._valid_init}") # DEBUG
        if not self._valid_init: 
            # if Player.print_limiter.can_print(f"player_reset_fail_invalid_init_{self.player_id}"):
            #     print(f"Player Warning ({self.player_id}): Cannot reset, _valid_init is False.")
            # Try to re-validate if possible, might be risky if assets truly failed
            asset_folder_path = 'characters/player1' if self.player_id == 1 else 'characters/player2'
            self.animations = load_all_player_animations(relative_asset_folder=asset_folder_path)
            if self.animations is not None:
                self._valid_init = True
                idle_animation_frames = self.animations.get('idle')
                if idle_animation_frames and len(idle_animation_frames) > 0:
                    self.image = idle_animation_frames[0]
                else:
                    self.image = pygame.Surface((30,40)); self.image.fill(C.RED)
                print(f"DEBUG Player (reset_state P{self.player_id}): Re-attempted animation load. New _valid_init: {self._valid_init}") # DEBUG
            else:
                print(f"DEBUG Player (reset_state P{self.player_id}): Re-animation load FAILED. Still invalid.") # DEBUG
                return
        
        # print(f"Player Info ({self.player_id}): RESETTING state to spawn at {spawn_position_tuple}")
        # Reset position and physics
        self.pos = pygame.math.Vector2(spawn_position_tuple[0], spawn_position_tuple[1])
        self.rect.midbottom = (round(self.pos.x), round(self.pos.y))
        self.vel = pygame.math.Vector2(0, 0) # Reset velocity
        self.acc = pygame.math.Vector2(0, C.PLAYER_GRAVITY if hasattr(C, 'PLAYER_GRAVITY') else 0.7) # Reset accel
        
        # Reset health and status flags
        self.current_health = self.max_health
        self.is_dead = False
        self.death_animation_finished = False
        self.is_taking_hit = False
        self.is_attacking = False; self.attack_type = 0
        self.is_dashing = False; self.is_rolling = False; self.is_sliding = False
        self.on_ladder = False; self.touching_wall = 0; self.facing_right = True # Default to facing right
        
        # Reset any lingering timers or cooldowns
        self.hit_timer = 0; self.dash_timer = 0; self.roll_timer = 0; self.slide_timer = 0
        self.attack_timer = 0; self.wall_climb_timer = 0; self.fireball_cooldown_timer = 0
        self.fireball_last_input_dir = pygame.math.Vector2(1.0 if self.facing_right else -1.0, 0.0)

        # Ensure visual state is reset (e.g., if player image was faded out or alpha changed)
        if hasattr(self.image, 'set_alpha') and hasattr(self.image, 'get_alpha') and \
           self.image.get_alpha() is not None and self.image.get_alpha() < 255: # If image is transparent
            self.image.set_alpha(255) # Make fully opaque
        
        self.set_state('idle') # Set to a neutral, stable initial state
        print(f"DEBUG Player (reset_state P{self.player_id}): Reset complete. Pos: {self.pos}, HP: {self.current_health}") # DEBUG

########## END OF FILE: player.py ##########

########## START OF FILE: player_combat_handler.py ##########

# player_combat_handler.py
# -*- coding: utf-8 -*-
"""
version 1.0.0.2 (Added debug prints for fireball firing)
Handles player combat: attacks, damage dealing/taking, healing, and projectile firing.
Functions here will typically take a 'player' instance as their first argument.
"""
import pygame
import constants as C
from projectiles import Fireball # Needed for instantiating Fireball

def fire_player_fireball(player):
    """
    Handles the logic for the player instance firing a fireball.
    Checks cooldowns, determines spawn position and direction, and adds
    the fireball to appropriate sprite groups.

    Args:
        player (Player): The player instance attempting to fire.
    """
    # ADD THIS DEBUG PRINT:
    print(f"DEBUG PCH (P{player.player_id}): Attempting fire_player_fireball. Valid: {player._valid_init}, Dead: {player.is_dead}, Alive: {player.alive() if hasattr(player, 'alive') else 'N/A'}, ProjGrp: {player.projectile_sprites_group is not None}, AllGrp: {player.all_sprites_group is not None}")

    # Basic validation: Player must be valid, alive, and have sprite group references
    if not player._valid_init or player.is_dead or not player.alive():
        print(f"DEBUG PCH (P{player.player_id}): Fireball RETURN early - player not valid/alive.") # ADDED
        return
    if player.projectile_sprites_group is None or player.all_sprites_group is None:
        print(f"DEBUG PCH (P{player.player_id}): Fireball RETURN early - sprite groups not set.") # MODIFIED/ADDED
        if player.print_limiter.can_print(f"player_{player.player_id}_fireball_no_group_ref_handler"):
            # Use a unique key for PrintLimiter to avoid message collision
            print(f"Player {player.player_id} (CombatHandler): Cannot fire fireball, projectile/all_sprites group not set.")
        return

    current_time_ms = pygame.time.get_ticks()
    # ADD THIS DEBUG PRINT:
    print(f"DEBUG PCH (P{player.player_id}): Fireball Cooldown Check. Current: {current_time_ms}, LastFire: {player.fireball_cooldown_timer}, CooldownVal: {C.FIREBALL_COOLDOWN}, Diff: {current_time_ms - player.fireball_cooldown_timer}")
    
    # Check if fireball is off cooldown
    if current_time_ms - player.fireball_cooldown_timer >= C.FIREBALL_COOLDOWN:
        player.fireball_cooldown_timer = current_time_ms # Reset cooldown timer

        # Determine fireball spawn position relative to player
        spawn_x = player.rect.centerx
        spawn_y = player.rect.centery 
        
        # Use the player's last stored aim direction for the fireball
        current_aim_direction = player.fireball_last_input_dir.copy()
        # Ensure the aim direction has a non-zero length (fallback to facing direction)
        if current_aim_direction.length_squared() == 0: 
            current_aim_direction.x = 1.0 if player.facing_right else -1.0
            current_aim_direction.y = 0.0
        
        offset_distance = (player.rect.width / 2) + (C.FIREBALL_DIMENSIONS[0] / 2) - 35 
        
        if abs(current_aim_direction.y) > 0.8 * abs(current_aim_direction.x): 
            offset_distance = (player.rect.height / 2) + (C.FIREBALL_DIMENSIONS[1] / 2) - 35
        
        if current_aim_direction.length_squared() > 0: 
            offset_vector = current_aim_direction.normalize() * offset_distance
            spawn_x += offset_vector.x
            spawn_y += offset_vector.y

        new_fireball = Fireball(spawn_x, spawn_y, current_aim_direction, player)
        player.projectile_sprites_group.add(new_fireball)
        player.all_sprites_group.add(new_fireball)
        
        # ADD THIS AT THE END OF SUCCESSFUL FIRING
        print(f"DEBUG PCH (P{player.player_id}): Fireball CREATED AND ADDED to groups. Groups now: Proj Count={len(player.projectile_sprites_group.sprites())}, All Count={len(player.all_sprites_group.sprites())}")
        
        if player.print_limiter.can_print(f"player_{player.player_id}_fire_fireball_msg_combat_handler"):
            print(f"Player {player.player_id} (CombatHandler) fires fireball. Aim Dir: {current_aim_direction}, Spawn Pos: ({spawn_x:.1f}, {spawn_y:.1f})")
    else: # Fireball is on cooldown
        # ADD THIS PRINT
        print(f"DEBUG PCH (P{player.player_id}): Fireball ON COOLDOWN.")
        if player.print_limiter.can_print(f"player_{player.player_id}_fireball_cooldown_combat_handler"):
            print(f"Player {player.player_id} (CombatHandler): Fireball on cooldown.")


def check_player_attack_collisions(player, targets_list):
    """
    Checks for collisions between the player's active attack hitbox and a list of targets.
    Applies damage to targets if a hit is registered.

    Args:
        player (Player): The attacking player instance.
        targets_list (list): A list of potential target Sprites (e.g., enemies, other players).
    """
    # Player must be valid, actively attacking, and alive to deal damage
    if not player._valid_init or not player.is_attacking or player.is_dead or not player.alive():
        return

    # --- Position the player's attack hitbox based on facing direction and state ---
    if player.facing_right:
        player.attack_hitbox.midleft = player.rect.midright # Hitbox to the right
    else:
        player.attack_hitbox.midright = player.rect.midleft # Hitbox to the left
    
    vertical_offset_for_crouch_attack = -10 if player.is_crouching and player.attack_type == 4 else 0
    player.attack_hitbox.centery = player.rect.centery + vertical_offset_for_crouch_attack
    
    current_time_ms = pygame.time.get_ticks()
    for target_sprite in targets_list:
        if target_sprite is player: continue 

        if not (target_sprite and hasattr(target_sprite, '_valid_init') and target_sprite._valid_init and \
                hasattr(target_sprite, 'is_dead') and not target_sprite.is_dead and target_sprite.alive()):
            continue

        target_is_currently_invincible = False
        if hasattr(target_sprite, 'is_taking_hit') and hasattr(target_sprite, 'hit_timer') and \
           hasattr(target_sprite, 'hit_cooldown'):
            if target_sprite.is_taking_hit and \
               (current_time_ms - target_sprite.hit_timer < target_sprite.hit_cooldown):
                target_is_currently_invincible = True
        
        if target_is_currently_invincible:
            continue 

        if player.attack_hitbox.colliderect(target_sprite.rect):
            if hasattr(target_sprite, 'take_damage') and callable(target_sprite.take_damage):
                damage_to_inflict = 0
                if player.attack_type == 1: damage_to_inflict = C.PLAYER_ATTACK1_DAMAGE
                elif player.attack_type == 2: damage_to_inflict = C.PLAYER_ATTACK2_DAMAGE
                elif player.attack_type == 3: damage_to_inflict = C.PLAYER_COMBO_ATTACK_DAMAGE
                elif player.attack_type == 4: damage_to_inflict = C.PLAYER_CROUCH_ATTACK_DAMAGE
                
                if damage_to_inflict > 0:
                    target_sprite.take_damage(damage_to_inflict) 


def player_take_damage(player, damage_amount):
    """
    Handles the player instance taking a specified amount of damage.
    Updates health, and potentially triggers 'hit' or 'death' states.

    Args:
        player (Player): The player instance receiving damage.
        damage_amount (int): The amount of damage to inflict.
    """
    current_time_ms = pygame.time.get_ticks()
    
    if not player._valid_init or player.is_dead or not player.alive() or \
       (player.is_taking_hit and current_time_ms - player.hit_timer < player.hit_cooldown): 
        return

    player.current_health -= damage_amount
    player.current_health = max(0, player.current_health) 

    if player.current_health <= 0: 
        if not player.is_dead: 
            player.set_state('death') 
    else: 
        if not (player.state == 'hit' and current_time_ms - player.state_timer < player.hit_duration):
             player.set_state('hit') 

def player_self_inflict_damage(player, damage_amount):
    """
    Allows the player instance to inflict damage on themselves.
    Typically used for debugging or special abilities.

    Args:
        player (Player): The player instance.
        damage_amount (int): The amount of damage for self-infliction.
    """
    if not player._valid_init or player.is_dead or not player.alive(): return 
    player_take_damage(player, damage_amount) 

def player_heal_to_full(player):
    """
    Heals the player instance to their maximum health.
    Can also cancel 'hit' stun state.

    Args:
        player (Player): The player instance to be healed.
    """
    if not player._valid_init: return
    if player.is_dead and player.current_health <=0 : return 
    
    player.current_health = player.max_health
    
    if player.is_taking_hit: player.is_taking_hit = False 
    if player.state == 'hit': player.set_state('idle')

########## START OF FILE: player_input_handler.py ##########

# player_input_handler.py
# -*- coding: utf-8 -*-
"""
version 1.0.0.2 (Added debug print for fireball key press)
Handles processing of player input and translating it to actions.
Functions here will typically take a 'player' instance as their first argument.
"""
import pygame
import constants as C

def process_player_input_logic(player, keys_pressed, pygame_events, key_config_map):
    """
    Core logic for processing raw Pygame input (held keys and events) 
    into player actions and state changes.
    Modifies the 'player' instance directly based on the input and key configuration.

    Args:
        player (Player): The player instance to be controlled.
        keys_pressed (pygame.key.ScancodeWrapper): Snapshot of currently held keys 
                                                   (from pygame.key.get_pressed()).
        pygame_events (list): List of Pygame events for the current frame 
                              (from pygame.event.get()).
        key_config_map (dict): A dictionary mapping action strings 
                               (e.g., 'left', 'attack1') to Pygame key constants 
                               (e.g., pygame.K_a, pygame.K_v).
    """
    if not player._valid_init: return # Do nothing if player initialization failed
    
    current_time_ms = pygame.time.get_ticks() # For managing state timers and cooldowns
    
    is_input_blocked = player.is_dead or \
                       (player.is_taking_hit and current_time_ms - player.hit_timer < player.hit_duration) 

    if is_input_blocked:
        player.acc.x = 0 
        return

    player.is_trying_to_move_left = keys_pressed[key_config_map['left']]
    player.is_trying_to_move_right = keys_pressed[key_config_map['right']]
    player.is_holding_climb_ability_key = keys_pressed[key_config_map['up']] 
    player.is_holding_crouch_ability_key = keys_pressed[key_config_map['down']] 

    fireball_aim_x_input = 0.0
    fireball_aim_y_input = 0.0
    if keys_pressed[key_config_map['left']]: fireball_aim_x_input = -1.0
    elif keys_pressed[key_config_map['right']]: fireball_aim_x_input = 1.0
    
    if keys_pressed[key_config_map['up']]: fireball_aim_y_input = -1.0
    elif keys_pressed[key_config_map['down']]: fireball_aim_y_input = 1.0
    
    if fireball_aim_x_input != 0.0 or fireball_aim_y_input != 0.0:
        player.fireball_last_input_dir.x = fireball_aim_x_input
        player.fireball_last_input_dir.y = fireball_aim_y_input
    elif player.fireball_last_input_dir.length_squared() == 0: 
        player.fireball_last_input_dir.x = 1.0 if player.facing_right else -1.0
        player.fireball_last_input_dir.y = 0.0

    player.acc.x = 0 
    player_intends_horizontal_move = False

    can_player_control_horizontal_movement = not (
        player.is_dashing or player.is_rolling or player.is_sliding or player.on_ladder or
        (player.is_attacking and player.state in ['attack_nm','attack2_nm','attack_combo_nm','crouch_attack']) or 
        player.state in ['turn','hit','death','death_nm','wall_climb','wall_climb_nm','wall_hang']
    )
    
    if can_player_control_horizontal_movement:
        if player.is_trying_to_move_left and not player.is_trying_to_move_right:
            player.acc.x = -C.PLAYER_ACCEL
            player_intends_horizontal_move = True
            if player.facing_right and player.on_ground and not player.is_crouching and \
               not player.is_attacking and player.state in ['idle','run']:
                player.set_state('turn')
            player.facing_right = False 
        elif player.is_trying_to_move_right and not player.is_trying_to_move_left:
            player.acc.x = C.PLAYER_ACCEL
            player_intends_horizontal_move = True
            if not player.facing_right and player.on_ground and not player.is_crouching and \
               not player.is_attacking and player.state in ['idle','run']:
                player.set_state('turn')
            player.facing_right = True

    can_player_initiate_crouch = player.on_ground and not player.on_ladder and \
                                 not (player.is_dashing or player.is_rolling or player.is_sliding or \
                                      player.is_attacking or player.state in ['turn','hit','death'])
    
    if player.is_holding_crouch_ability_key and can_player_initiate_crouch:
        if not player.is_crouching: 
            player.is_crouching = True
            player.is_sliding = False 
            if 'crouch_trans' in player.animations and player.animations['crouch_trans'] and \
               player.state not in ['crouch','crouch_walk','crouch_trans']:
                player.set_state('crouch_trans')
    elif not player.is_holding_crouch_ability_key and player.is_crouching: 
        player.is_crouching = False

    if player.on_ladder:
         player.vel.y = 0 
         if player.is_holding_climb_ability_key: 
             player.vel.y = -C.PLAYER_LADDER_CLIMB_SPEED
         elif player.is_holding_crouch_ability_key: 
             player.vel.y = C.PLAYER_LADDER_CLIMB_SPEED

    for event in pygame_events:
        if event.type == pygame.KEYDOWN:
            if event.key == key_config_map['up']:
                  can_perform_jump_action = not player.is_crouching and not player.is_attacking and \
                                            not player.is_rolling and not player.is_sliding and \
                                            not player.is_dashing and player.state not in ['turn','hit']
                  if player.on_ground and can_perform_jump_action: 
                      player.vel.y = C.PLAYER_JUMP_STRENGTH
                      player.set_state('jump')
                      player.on_ground = False 
                  elif player.on_ladder and can_perform_jump_action: 
                      player.vel.y = C.PLAYER_JUMP_STRENGTH * 0.8 
                      player.vel.x = C.PLAYER_RUN_SPEED_LIMIT * 0.5 * (1 if player.facing_right else -1) 
                      player.on_ladder = False 
                      player.set_state('jump')
                  elif player.can_wall_jump and player.touching_wall != 0 and can_perform_jump_action: 
                      player.vel.y = C.PLAYER_JUMP_STRENGTH 
                      player.vel.x = C.PLAYER_RUN_SPEED_LIMIT * 1.5 * (-player.touching_wall) 
                      player.facing_right = not player.facing_right 
                      player.set_state('jump')
                      player.can_wall_jump = False; player.touching_wall = 0; player.wall_climb_timer = 0
            
            if event.key == key_config_map['attack1']:
                  can_perform_attack_action = not player.is_attacking and not player.is_dashing and \
                                              not player.is_rolling and not player.is_sliding and \
                                              not player.on_ladder and player.state not in ['turn','hit']
                  if can_perform_attack_action:
                       player.attack_type = 1 
                       is_moving_for_attack_anim = (player.acc.x !=0 or abs(player.vel.x) > 1.0)
                       attack_animation_key = 'attack' if is_moving_for_attack_anim and \
                                              'attack' in player.animations and player.animations['attack'] \
                                              else 'attack_nm'
                       if player.is_crouching: 
                           player.attack_type = 4 
                           attack_animation_key = 'crouch_attack'
                       player.set_state(attack_animation_key) 
            
            if event.key == key_config_map['attack2']:
                  can_perform_attack2_action = not player.is_dashing and not player.is_rolling and \
                                               not player.is_sliding and not player.on_ladder and \
                                               player.state not in ['turn','hit']
                  if can_perform_attack2_action:
                       is_moving_for_attack2_anim = (player.acc.x != 0 or abs(player.vel.x) > 1.0)
                       
                       time_since_attack1_ended = current_time_ms - (player.attack_timer + player.attack_duration)
                       is_in_combo_window_for_attack3 = (player.attack_type == 1 and not player.is_attacking and 
                                                         time_since_attack1_ended < player.combo_window)
                       
                       selected_attack2_anim_key = ''
                       if is_in_combo_window_for_attack3 and \
                          'attack_combo' in player.animations and player.animations['attack_combo']:
                           player.attack_type = 3 
                           selected_attack2_anim_key = 'attack_combo' if is_moving_for_attack2_anim and \
                                                       'attack_combo' in player.animations and player.animations['attack_combo'] \
                                                       else 'attack_combo_nm'
                       elif player.is_crouching and 'crouch_attack' in player.animations and \
                            player.animations['crouch_attack'] and not player.is_attacking :
                           player.attack_type = 4 
                           selected_attack2_anim_key = 'crouch_attack'
                       elif not player.is_attacking and 'attack2' in player.animations and \
                            player.animations['attack2']: 
                           player.attack_type = 2 
                           selected_attack2_anim_key = 'attack2' if is_moving_for_attack2_anim and \
                                                       'attack2' in player.animations and player.animations['attack2'] \
                                                       else 'attack2_nm'
                       elif not player.is_attacking and player.attack_type == 0 and \
                            'attack' in player.animations and player.animations['attack']: 
                           player.attack_type = 1
                           selected_attack2_anim_key = 'attack' if is_moving_for_attack2_anim else 'attack_nm'
                       
                       if selected_attack2_anim_key : player.set_state(selected_attack2_anim_key)

            if event.key == key_config_map['dash']:
                  if player.on_ground and not player.is_dashing and not player.is_rolling and \
                     not player.is_attacking and not player.is_crouching and not player.on_ladder and \
                     player.state not in ['turn','hit']:
                      player.set_state('dash') 

            if event.key == key_config_map['roll']:
                  if player.on_ground and not player.is_rolling and not player.is_dashing and \
                     not player.is_attacking and not player.is_crouching and not player.on_ladder and \
                     player.state not in ['turn','hit']:
                      player.set_state('roll') 
            
            if event.key == key_config_map['down']: 
                  can_initiate_slide_action = player.on_ground and player.state == 'run' and \
                                              abs(player.vel.x) > C.PLAYER_RUN_SPEED_LIMIT * 0.6 and \
                                              not player.is_sliding and not player.is_crouching and \
                                              not player.is_attacking and not player.is_rolling and \
                                              not player.is_dashing and not player.on_ladder and \
                                              player.state not in ['turn','hit']
                  if can_initiate_slide_action:
                       slide_start_anim_key = 'slide_trans_start' if 'slide_trans_start' in player.animations and \
                                                player.animations['slide_trans_start'] else 'slide'
                       if slide_start_anim_key in player.animations and player.animations[slide_start_anim_key]:
                           player.set_state(slide_start_anim_key)
            
            if event.key == key_config_map['interact']:
                  if player.can_grab_ladder and not player.on_ladder: 
                      player.on_ladder = True; player.vel.y=0; player.vel.x=0; player.on_ground=False
                      player.touching_wall=0; player.can_wall_jump=False; player.wall_climb_timer=0
                      player.set_state('ladder_idle') 
                  elif player.on_ladder: 
                      player.on_ladder = False
                      player.set_state('fall' if not player.on_ground else 'idle') 
            
            if player.fireball_key and event.key == player.fireball_key:
                 # ADD THIS PRINT
                 print(f"DEBUG PIH (P{player.player_id}): Matched fireball key press ({event.key}). Calling player.fire_fireball().")
                 if hasattr(player, 'fire_fireball'):
                     player.fire_fireball()

    is_in_manual_override_or_transition_state = player.is_attacking or player.is_dashing or \
                                                player.is_rolling or player.is_sliding or \
                                                player.is_taking_hit or \
                                                player.state in [
                                                    'jump','turn','death','death_nm','hit','jump_fall_trans',
                                                    'crouch_trans','slide_trans_start','slide_trans_end',
                                                    'wall_climb','wall_climb_nm','wall_hang','wall_slide',
                                                    'ladder_idle','ladder_climb'
                                                ]
    
    if not is_in_manual_override_or_transition_state: 
        if player.on_ladder: 
            if abs(player.vel.y) > 0.1 : 
                player.set_state('ladder_climb' if 'ladder_climb' in player.animations and \
                                 player.animations['ladder_climb'] else 'idle')
            else: 
                player.set_state('ladder_idle' if 'ladder_idle' in player.animations and \
                                 player.animations['ladder_idle'] else 'idle')
        elif player.on_ground: 
             if player.is_crouching: 
                 target_crouch_state_key = 'crouch_walk' if player_intends_horizontal_move and \
                                             'crouch_walk' in player.animations and player.animations['crouch_walk'] \
                                             else 'crouch'
                 if player.state not in ['crouch', 'crouch_walk'] or player.state != target_crouch_state_key:
                    player.set_state(target_crouch_state_key if target_crouch_state_key in player.animations and \
                                     player.animations[target_crouch_state_key] else 'idle')
             elif player_intends_horizontal_move: 
                 player.set_state('run' if 'run' in player.animations and player.animations['run'] else 'idle')
             else: 
                 player.set_state('idle')
        else: 
             if player.touching_wall != 0: 
                 current_wall_time_ms = pygame.time.get_ticks()
                 is_wall_climb_duration_expired = (player.wall_climb_duration > 0 and player.wall_climb_timer > 0 and
                                                   current_wall_time_ms - player.wall_climb_timer > player.wall_climb_duration)
                 
                 if player.vel.y > C.PLAYER_WALL_SLIDE_SPEED * 0.5 or is_wall_climb_duration_expired:
                     player.set_state('wall_slide')
                     player.can_wall_jump = True 
                 elif player.is_holding_climb_ability_key and abs(player.vel.x) < 1.0 and \
                      not is_wall_climb_duration_expired and 'wall_climb' in player.animations and \
                      player.animations['wall_climb']:
                     player.set_state('wall_climb')
                     player.can_wall_jump = False 
                 else: 
                     player.set_state('wall_slide')
                     player.can_wall_jump = True
             elif player.vel.y > 1.0 and player.state not in ['jump','jump_fall_trans']: 
                  player.set_state('fall' if 'fall' in player.animations and player.animations['fall'] else 'idle')
             elif player.state not in ['jump','jump_fall_trans','fall']: 
                  player.set_state('idle')

########## START OF FILE: player_network_handler.py ##########

########## START OF FILE: player_network_handler.py ##########

# player_network_handler.py
# -*- coding: utf-8 -*-
"""
version 1.0000000.1
Handles network-related data serialization, deserialization, and input processing
for the Player class in a networked environment.
Functions here will typically take a 'player' instance as their first argument.
"""
import pygame
import constants as C # For potential network-related constants if any

def get_player_network_data(player):
    """
    Gathers essential player data into a dictionary for network transmission.

    Args:
        player (Player): The player instance whose data is being serialized.

    Returns:
        dict: A dictionary containing the player's network-relevant state.
    """
    # Ensure all serialized values are basic Python types (int, float, bool, str, list, dict)
    # Pygame Vector2 needs to be converted to a tuple of floats.
    data = {
        'player_id': player.player_id, 
        '_valid_init': player._valid_init, # Important for client to know if player is valid
        
        'pos': (player.pos.x, player.pos.y), 
        'vel': (player.vel.x, player.vel.y), 
        'facing_right': player.facing_right, 
        
        'state': player.state, # Current logical state string
        'current_frame': player.current_frame, 
        'last_anim_update': player.last_anim_update, # Timestamp for animation sync
        
        'current_health': player.current_health, 
        'is_dead': player.is_dead,
        'death_animation_finished': player.death_animation_finished,
        
        'is_attacking': player.is_attacking, 
        'attack_type': player.attack_type,
        # Add other relevant boolean flags if needed for precise state replication
        'is_crouching': player.is_crouching,
        'is_dashing': player.is_dashing,
        'is_rolling': player.is_rolling,
        'is_sliding': player.is_sliding,
        'on_ladder': player.on_ladder,
        'is_taking_hit': player.is_taking_hit, # To sync hit stun visuals/invincibility
        
        # Fireball aim direction is crucial for remote players to see where fireballs might go
        'fireball_aim_x': player.fireball_last_input_dir.x, 
        'fireball_aim_y': player.fireball_last_input_dir.y
    }
    # print(f"DEBUG PNH (get_player_network_data) for P{player.player_id}: pos={data['pos']}, valid={data['_valid_init']}, alive (instance): {player.alive() if hasattr(player, 'alive') else 'N/A'}") # DEBUG
    return data

def set_player_network_data(player, network_data): 
    """
    Applies received network data to update the local player instance's state.
    This is typically used on clients to reflect the server's authoritative state,
    or on the server to update a remote player's placeholder.

    Args:
        player (Player): The player instance to be updated.
        network_data (dict): The dictionary of player state received over the network.
    """
    if network_data is None:
        # print(f"DEBUG PNH (set_player_network_data) for P{player.player_id}: Received None network_data. No update.") # DEBUG
        return

    # print(f"DEBUG PNH (set_player_network_data) for P{player.player_id}: Applying network data. Current valid: {player._valid_init}, alive: {player.alive() if hasattr(player, 'alive') else 'N/A'}. Net valid: {network_data.get('_valid_init')}, Net pos: {network_data.get('pos')}") # DEBUG
    
    player_id_from_data = network_data.get('player_id', 'Unknown') # For logging

    # Critical: Update _valid_init first.
    new_valid_init = network_data.get('_valid_init', player._valid_init)
    if player._valid_init != new_valid_init:
        # print(f"DEBUG PNH (set_player_network_data) for P{player_id_from_data}: _valid_init changed from {player._valid_init} to {new_valid_init}") # DEBUG
        player._valid_init = new_valid_init
    
    if not player._valid_init:
        if player.alive(): 
            # print(f"DEBUG PNH (set_player_network_data) for P{player_id_from_data}: Player became invalid, killing sprite.") # DEBUG
            player.kill()  
        return 

    pos_data = network_data.get('pos')
    if pos_data: 
        # print(f"DEBUG PNH (set_player_network_data) for P{player_id_from_data}: Old Pos: {player.pos}, New Net Pos: {pos_data}") # DEBUG
        player.pos.x, player.pos.y = pos_data
    
    vel_data = network_data.get('vel')
    if vel_data: player.vel.x, player.vel.y = vel_data
    
    player.facing_right = network_data.get('facing_right', player.facing_right)
    
    player.current_health = network_data.get('current_health', player.current_health)
    new_is_dead_from_net = network_data.get('is_dead', player.is_dead)
    player.death_animation_finished = network_data.get('death_animation_finished', player.death_animation_finished)

    if new_is_dead_from_net and not player.is_dead: 
        # print(f"DEBUG PNH (set_player_network_data) for P{player_id_from_data}: Transitioning to DEAD from network.") # DEBUG
        player.is_dead = True
        player.current_health = 0 
        player.set_state('death') 
    elif not new_is_dead_from_net and player.is_dead: 
        # print(f"DEBUG PNH (set_player_network_data) for P{player_id_from_data}: Transitioning to ALIVE from network (was dead).") # DEBUG
        player.is_dead = False
        player.death_animation_finished = False 
        if player.state in ['death', 'death_nm']: 
            player.set_state('idle') 
    else: 
        player.is_dead = new_is_dead_from_net 

    player.is_attacking = network_data.get('is_attacking', player.is_attacking)
    player.attack_type = network_data.get('attack_type', player.attack_type)
    player.is_crouching = network_data.get('is_crouching', player.is_crouching)
    player.is_dashing = network_data.get('is_dashing', player.is_dashing)
    player.is_rolling = network_data.get('is_rolling', player.is_rolling)
    player.is_sliding = network_data.get('is_sliding', player.is_sliding)
    player.on_ladder = network_data.get('on_ladder', player.on_ladder)
    
    new_is_taking_hit_from_net = network_data.get('is_taking_hit', player.is_taking_hit)
    if new_is_taking_hit_from_net and not player.is_taking_hit: 
        player.is_taking_hit = True
        player.hit_timer = pygame.time.get_ticks() 
        if player.state != 'hit' and not player.is_dead : player.set_state('hit') 
    elif not new_is_taking_hit_from_net and player.is_taking_hit: 
        player.is_taking_hit = False
        if player.state == 'hit' and not player.is_dead : player.set_state('idle') 

    new_logical_state_from_net = network_data.get('state', player.state)
    if player.state != new_logical_state_from_net and \
       not (player.is_dead and new_logical_state_from_net in ['death', 'death_nm']):
         # print(f"DEBUG PNH (set_player_network_data) for P{player_id_from_data}: Setting state from '{player.state}' to '{new_logical_state_from_net}'") # DEBUG
         player.set_state(new_logical_state_from_net)
    else: 
        player.current_frame = network_data.get('current_frame', player.current_frame)
        player.last_anim_update = network_data.get('last_anim_update', player.last_anim_update)
    
    fb_aim_x_net = network_data.get('fireball_aim_x')
    fb_aim_y_net = network_data.get('fireball_aim_y')
    if fb_aim_x_net is not None and fb_aim_y_net is not None:
        player.fireball_last_input_dir.x = float(fb_aim_x_net)
        player.fireball_last_input_dir.y = float(fb_aim_y_net)
    
    player.rect.midbottom = (round(player.pos.x), round(player.pos.y))
    # print(f"DEBUG PNH (set_player_network_data) for P{player_id_from_data}: Updated rect.midbottom to {player.rect.midbottom}") # DEBUG
    
    if player._valid_init and player.alive(): 
        # print(f"DEBUG PNH (set_player_network_data) for P{player_id_from_data}: Player valid and alive, calling animate().") # DEBUG
        player.animate()
    # else: # DEBUG
        # print(f"DEBUG PNH (set_player_network_data) for P{player_id_from_data}: Player NOT valid or NOT alive. Valid: {player._valid_init}, Alive: {player.alive() if hasattr(player, 'alive') else 'N/A'}. Skipping animate.") # DEBUG


def handle_player_network_input(player, received_input_data_dict): 
    """
    Processes input data received over the network for this player instance.
    This is used by the server to update a remote player's actions based on
    what their client sent. It's a simplified version of local input processing.

    Args:
        player (Player): The player instance whose actions are being driven by network input.
        received_input_data_dict (dict): The input state dictionary from the client.
    """
    # print(f"DEBUG PNH (handle_player_network_input) for P{player.player_id}: Processing input: {received_input_data_dict}") # DEBUG
    if not player._valid_init or player.is_dead or not player.alive():
        # print(f"DEBUG PNH (handle_player_network_input) for P{player.player_id}: Input ignored, player not valid/alive. Valid: {player._valid_init}, Dead: {player.is_dead}, Alive: {player.alive() if hasattr(player,'alive') else 'N/A'}") # DEBUG
        return

    player.acc.x = 0 
    
    intends_move_left_net = received_input_data_dict.get('left_held', False)
    intends_move_right_net = received_input_data_dict.get('right_held', False)
    
    net_fireball_aim_x = received_input_data_dict.get('fireball_aim_x')
    net_fireball_aim_y = received_input_data_dict.get('fireball_aim_y')
    if net_fireball_aim_x is not None and net_fireball_aim_y is not None:
        if float(net_fireball_aim_x) != 0.0 or float(net_fireball_aim_y) != 0.0:
            player.fireball_last_input_dir.x = float(net_fireball_aim_x)
            player.fireball_last_input_dir.y = float(net_fireball_aim_y)
    
    can_control_horizontal_via_net = not (
        player.is_dashing or player.is_rolling or player.is_sliding or player.on_ladder or
        (player.is_attacking and player.state in ['attack_nm','attack2_nm','attack_combo_nm','crouch_attack']) or
        player.state in ['turn','hit','death','death_nm','wall_climb','wall_climb_nm','wall_hang']
    )
    
    new_facing_direction_net = player.facing_right 
    if can_control_horizontal_via_net:
        if intends_move_left_net and not intends_move_right_net:
            player.acc.x = -C.PLAYER_ACCEL
            new_facing_direction_net = False
        elif intends_move_right_net and not intends_move_left_net:
            player.acc.x = C.PLAYER_ACCEL
            new_facing_direction_net = True
            
    if player.on_ground and player.state in ['idle', 'run'] and not player.is_attacking and \
       player.facing_right != new_facing_direction_net:
        player.facing_right = new_facing_direction_net
        player.set_state('turn') 
    else: 
        player.facing_right = new_facing_direction_net
    
    can_perform_action_net = not player.is_attacking and not player.is_dashing and \
                             not player.is_rolling and not player.is_sliding and \
                             not player.on_ladder and player.state not in ['turn','hit']
    
    if received_input_data_dict.get('attack1_pressed_event', False) and can_perform_action_net:
        player.attack_type = 4 if player.is_crouching else 1 
        attack_anim_key_net = 'crouch_attack' if player.is_crouching else \
                              ('attack' if (intends_move_left_net or intends_move_right_net) else 'attack_nm')
        player.set_state(attack_anim_key_net)
    
    if received_input_data_dict.get('attack2_pressed_event', False) and can_perform_action_net:
        player.attack_type = 4 if player.is_crouching else 2 
        attack2_anim_key_net = 'crouch_attack' if player.is_crouching else \
                               ('attack2' if (intends_move_left_net or intends_move_right_net) else 'attack2_nm')
        player.set_state(attack2_anim_key_net)

    if received_input_data_dict.get('fireball_pressed_event', False) and can_perform_action_net:
        if hasattr(player, 'fire_fireball'): 
             player.fire_fireball() 

    if received_input_data_dict.get('jump_intent', False) and can_perform_action_net and not player.is_crouching:
         if player.on_ground: 
             player.vel.y = C.PLAYER_JUMP_STRENGTH
             player.set_state('jump')
             player.on_ground = False 

    if received_input_data_dict.get('dash_pressed_event', False) and player.on_ground and \
       can_perform_action_net and not player.is_crouching:
        player.set_state('dash')
    
    if received_input_data_dict.get('roll_pressed_event', False) and player.on_ground and \
       can_perform_action_net and not player.is_crouching:
        player.set_state('roll')
    
    # Set player's intention flags based on network input for server-side update logic
    player.is_holding_crouch_ability_key = received_input_data_dict.get('down_held', False)
    player.is_holding_climb_ability_key = received_input_data_dict.get('up_held', False)
    # print(f"DEBUG PNH (handle_player_network_input) for P{player.player_id}: Accel.x set to {player.acc.x}, FacingRight: {player.facing_right}") # DEBUG


def get_player_input_state_for_network(player, current_pygame_keys, current_pygame_events, key_map):
    """
    Gathers the local player's current input state into a dictionary format
    suitable for sending over the network.

    Args:
        player (Player): The local player instance (used for player_id and fireball_key config).
        current_pygame_keys: The result of pygame.key.get_pressed().
        current_pygame_events: The list from pygame.event.get().
        key_map (dict): The key mapping for this player's controls.

    Returns:
        dict: A dictionary representing the player's input state.
    """
    input_state_dict = {
        'left_held': bool(current_pygame_keys[key_map['left']]),
        'right_held': bool(current_pygame_keys[key_map['right']]),
        'up_held': bool(current_pygame_keys[key_map['up']]),
        'down_held': bool(current_pygame_keys[key_map['down']]),
        
        'attack1_pressed_event': False, 
        'attack2_pressed_event': False,
        'dash_pressed_event': False, 
        'roll_pressed_event': False,
        'interact_pressed_event': False, 
        'jump_intent': False, 
        'fireball_pressed_event': False,
        
        'fireball_aim_x': player.fireball_last_input_dir.x, 
        'fireball_aim_y': player.fireball_last_input_dir.y
    }
    
    for event in current_pygame_events:
        if event.type == pygame.KEYDOWN:
            if event.key == key_map.get('attack1'): input_state_dict["attack1_pressed_event"] = True
            if event.key == key_map.get('attack2'): input_state_dict["attack2_pressed_event"] = True
            if event.key == key_map.get('dash'): input_state_dict["dash_pressed_event"] = True
            if event.key == key_map.get('roll'): input_state_dict["roll_pressed_event"] = True
            if event.key == key_map.get('interact'): input_state_dict["interact_pressed_event"] = True
            if event.key == key_map.get('up'): input_state_dict["jump_intent"] = True 
            
            if player.fireball_key and event.key == player.fireball_key:
                input_state_dict['fireball_pressed_event'] = True
                
    # print(f"DEBUG PNH (get_player_input_state_for_network) for P{player.player_id}: Generated input state: {input_state_dict}") # DEBUG
    return input_state_dict

########## END OF FILE: player_network_handler.py ##########

########## START OF FILE: projectiles.py ##########

# projectiles.py
# -*- coding: utf-8 -*-
"""
Defines projectile classes like Fireball.
"""
# version 1.0.1 (fixed length_sq typo in init)
import pygame
import os # For path joining
import constants as C
from assets import load_gif_frames, resource_path

class Fireball(pygame.sprite.Sprite):
    def __init__(self, x, y, direction_vector, owner_player):
        super().__init__()
        self.owner_player = owner_player
        self.damage = C.FIREBALL_DAMAGE
        self.speed = C.FIREBALL_SPEED

        full_gif_path = resource_path(C.FIREBALL_SPRITE_PATH)
        self.frames = load_gif_frames(full_gif_path)
        
        if not self.frames or \
           (len(self.frames) == 1 and self.frames[0].get_size() == (30,40) and self.frames[0].get_at((0,0)) == C.RED): 
            print(f"Warning: Fireball GIF '{full_gif_path}' failed to load or is default placeholder. Using fallback.")
            self.image = pygame.Surface(C.FIREBALL_DIMENSIONS, pygame.SRCALPHA).convert_alpha()
            self.image.fill((0,0,0,0)) 
            pygame.draw.circle(self.image, (255, 120, 0, 200), (C.FIREBALL_DIMENSIONS[0]//2, C.FIREBALL_DIMENSIONS[1]//2), C.FIREBALL_DIMENSIONS[0]//3)
            pygame.draw.circle(self.image, C.RED, (C.FIREBALL_DIMENSIONS[0]//2, C.FIREBALL_DIMENSIONS[1]//2), C.FIREBALL_DIMENSIONS[0]//4)
            self.frames = [self.image]
        
        self.current_frame_index = 0
        self.image = self.frames[self.current_frame_index]
        self.rect = self.image.get_rect(center=(x, y))
        self.pos = pygame.math.Vector2(self.rect.center)

        # <<< CORRECTED HERE >>>
        if direction_vector.length_squared() > 0: # Was length_sq()
            self.vel = direction_vector.normalize() * self.speed
        else: 
            self.vel = pygame.math.Vector2(1 if owner_player.facing_right else -1, 0) * self.speed
        
        self.spawn_time = pygame.time.get_ticks()
        self.last_anim_update = self.spawn_time
        self.projectile_id = f"fb_{getattr(owner_player, 'player_id', 'unknown')}_{self.spawn_time}"

    def animate(self):
        now = pygame.time.get_ticks()
        anim_duration = C.ANIM_FRAME_DURATION / 1.5 
        if now - self.last_anim_update > anim_duration:
            self.last_anim_update = now
            self.current_frame_index = (self.current_frame_index + 1) % len(self.frames)
            old_center = self.rect.center
            self.image = self.frames[self.current_frame_index]
            if self.vel.x < 0: 
                 self.image = pygame.transform.flip(self.frames[self.current_frame_index], True, False)
            else:
                 self.image = self.frames[self.current_frame_index]
            self.rect = self.image.get_rect(center=old_center)

    def update(self, dt_sec, platforms, characters_to_hit_group): 
        self.pos += self.vel 
        self.rect.center = round(self.pos.x), round(self.pos.y)
        self.animate()

        if pygame.time.get_ticks() - self.spawn_time > C.FIREBALL_LIFESPAN:
            self.kill()
            return

        if pygame.sprite.spritecollideany(self, platforms):
            self.kill()
            return

        hit_characters = pygame.sprite.spritecollide(self, characters_to_hit_group, False)
        for char in hit_characters:
            if char is self.owner_player and (pygame.time.get_ticks() - self.spawn_time < 100): 
                continue
            if char is self.owner_player and not getattr(C, "ALLOW_SELF_FIREBALL_DAMAGE", False): 
                continue

            if hasattr(char, 'take_damage') and callable(char.take_damage):
                can_damage_target = True
                if hasattr(char, 'is_taking_hit') and hasattr(char, 'hit_timer') and hasattr(char, 'hit_cooldown'):
                    now = pygame.time.get_ticks()
                    if char.is_taking_hit and (now - char.hit_timer < char.hit_cooldown):
                        can_damage_target = False
                
                if can_damage_target:
                    char.take_damage(self.damage)
                    self.kill()
                    return 
        
    def get_network_data(self):
        return {
            'id': self.projectile_id,
            'pos': (self.pos.x, self.pos.y),
            'vel': (self.vel.x, self.vel.y), 
            'owner_id': self.owner_player.player_id if self.owner_player else None,
            'frame': self.current_frame_index,
            'spawn_time': self.spawn_time,
            'image_flipped': self.vel.x < 0 
        }

    def set_network_data(self, data):
        self.pos.x, self.pos.y = data['pos']
        if 'vel' in data:
             self.vel.x, self.vel.y = data['vel']
        self.rect.center = round(self.pos.x), round(self.pos.y)
        self.current_frame_index = data.get('frame', self.current_frame_index)
        old_center = self.rect.center
        base_image = self.frames[self.current_frame_index]
        if data.get('image_flipped', False):
            self.image = pygame.transform.flip(base_image, True, False)
        else:
            self.image = base_image
        self.rect = self.image.get_rect(center=old_center)

########## START OF FILE: server_logic.py ##########

########## START OF FILE: server_logic.py ##########

# server_logic.py
# -*- coding: utf-8 -*-
"""
version 1.0000000.1
Handles server-side game logic, connection management, and broadcasting.
"""
import pygame
import socket
import threading
import time
import traceback
import constants as C
from network_comms import get_local_ip, encode_data, decode_data_stream
from game_state_manager import get_network_game_state, reset_game_state
from enemy import Enemy # For print_limiter access if needed, or just for type hinting
from game_ui import draw_platformer_scene_on_surface # For drawing the server's view

# Shared lock for client connection and input buffer
client_lock = threading.Lock()

class ServerState:
    """
    A simple class to hold server-specific shared state used by the server's
    main loop and its threads. This helps in managing shared resources and
    the running state of the server components.
    """
    def __init__(self):
        self.client_connection = None  # Holds the active client socket object
        self.client_address = None     # Holds the (IP, port) of the active client
        self.client_input_buffer = {}  # Stores the last processed input from the client
        self.app_running = True        # Global flag: True if the application is running
        
        # Network socket objects
        self.server_tcp_socket = None  # TCP socket for listening to client connections
        self.server_udp_socket = None  # UDP socket for broadcasting server presence
        
        # Thread objects
        self.broadcast_thread = None       # Thread for LAN broadcasting
        self.client_handler_thread = None  # Thread for handling communication with the connected client
        
        # Configuration (can be loaded from constants.py or passed)
        self.service_name = getattr(C, "SERVICE_NAME", "platformer_adventure_lan_v1")
        self.discovery_port_udp = getattr(C, "DISCOVERY_PORT_UDP", 5556)
        self.server_port_tcp = getattr(C, "SERVER_PORT_TCP", 5555)
        self.buffer_size = getattr(C, "BUFFER_SIZE", 8192)
        self.broadcast_interval_s = getattr(C, "BROADCAST_INTERVAL_S", 1.0)


def broadcast_presence_thread(server_state_obj: ServerState):
    """
    Thread function to periodically broadcast the server's presence on the LAN.
    Uses UDP to send a discovery message.
    """
    current_lan_ip = get_local_ip() # Get the server's LAN IP for the broadcast message
    broadcast_message_dict = {
        "service": server_state_obj.service_name,
        "tcp_ip": current_lan_ip,
        "tcp_port": server_state_obj.server_port_tcp
    }
    broadcast_message_bytes = encode_data(broadcast_message_dict)

    if not broadcast_message_bytes:
        print("Server Error: Could not encode broadcast message for presence.")
        return

    try:
        # Create and configure the UDP socket for broadcasting
        server_state_obj.server_udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
        server_state_obj.server_udp_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        server_state_obj.server_udp_socket.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
        server_state_obj.server_udp_socket.settimeout(0.5) # Timeout for socket operations to allow periodic checks
    except socket.error as e:
        print(f"Server Error: Failed to create UDP broadcast socket: {e}")
        server_state_obj.server_udp_socket = None
        return
    
    broadcast_address = ('<broadcast>', server_state_obj.discovery_port_udp)
    print(f"DEBUG Server (broadcast_presence_thread): Broadcasting presence: {broadcast_message_dict} to {broadcast_address} (LAN IP: {current_lan_ip})") # DEBUG

    while server_state_obj.app_running:
        try:
            server_state_obj.server_udp_socket.sendto(broadcast_message_bytes, broadcast_address)
            # print(f"DEBUG Server (broadcast_presence_thread): Broadcast sent.") # DEBUG - can be very noisy
        except socket.error as sock_err:
            print(f"DEBUG Server (broadcast_presence_thread): Socket error during broadcast send: {sock_err}") # DEBUG
            pass 
        except Exception as e:
            print(f"Server Warning: Unexpected error during broadcast send: {e}")
        
        # Sleep for the broadcast interval, checking app_running periodically for a timely exit
        for _ in range(int(server_state_obj.broadcast_interval_s * 10)): # e.g., check every 100ms
            if not server_state_obj.app_running: break
            time.sleep(0.1)
            
    # Cleanup UDP socket when the thread stops
    if server_state_obj.server_udp_socket:
        server_state_obj.server_udp_socket.close()
        server_state_obj.server_udp_socket = None
    print("DEBUG Server (broadcast_presence_thread): Broadcast thread stopped.") # DEBUG


def handle_client_connection_thread(conn: socket.socket, addr, server_state_obj: ServerState):
    """
    Thread function to handle receiving data from a single connected client.
    Updates the server_state_obj.client_input_buffer with the latest client input.
    """
    print(f"DEBUG Server (handle_client_connection_thread): Client connected from {addr}. Handler thread started.") # DEBUG
    conn.settimeout(1.0) # Use a timeout for recv to keep the loop responsive
    partial_data_from_client = b"" # Buffer for accumulating partial messages

    while server_state_obj.app_running:
        with client_lock: # Synchronize access to shared server state
            if server_state_obj.client_connection is not conn:
                print(f"DEBUG Server Handler ({addr}): Stale connection. Exiting thread.") # DEBUG
                break 
        try:
            chunk = conn.recv(server_state_obj.buffer_size)
            if not chunk: 
                print(f"DEBUG Server Handler ({addr}): Client disconnected (received empty data).") # DEBUG
                break
            
            # print(f"DEBUG Server Handler ({addr}): Received chunk: {chunk[:60]}...") # DEBUG - can be noisy
            partial_data_from_client += chunk
            decoded_inputs, partial_data_from_client = decode_data_stream(partial_data_from_client)

            if decoded_inputs:
                last_input_data = decoded_inputs[-1] 
                # print(f"DEBUG Server Handler ({addr}): Decoded client input: {last_input_data}") # DEBUG
                if "input" in last_input_data:
                    with client_lock:
                        if server_state_obj.client_connection is conn: 
                            server_state_obj.client_input_buffer = last_input_data["input"]
                            # print(f"DEBUG Server Handler ({addr}): Updated client_input_buffer: {server_state_obj.client_input_buffer}") # DEBUG
        except socket.timeout:
            continue 
        except socket.error as e:
            if server_state_obj.app_running:
                print(f"DEBUG Server Handler ({addr}): Socket error: {e}. Assuming disconnect.") # DEBUG
            break 
        except Exception as e:
            if server_state_obj.app_running:
                print(f"DEBUG Server Handler ({addr}): Unexpected error: {e}") # DEBUG
                traceback.print_exc()
            break

    with client_lock:
        if server_state_obj.client_connection is conn: 
            print(f"DEBUG Server Handler ({addr}): Closing active connection from handler.") # DEBUG
            server_state_obj.client_connection = None 
            server_state_obj.client_input_buffer = {"disconnect": True} 
    try:
        conn.shutdown(socket.SHUT_RDWR) 
    except: pass 
    try:
        conn.close() 
    except: pass
    print(f"DEBUG Server: Client handler for {addr} finished.") # DEBUG


def run_server_mode(screen: pygame.Surface, clock: pygame.time.Clock, 
                    fonts: dict, game_elements_ref: dict, server_state_obj: ServerState):
    """
    Main function to run the game in server mode.
    Manages client connections, game loop, and state synchronization.
    """
    print("DEBUG Server: Entering run_server_mode.") # DEBUG
    pygame.display.set_caption("Platformer - HOST (P1: WASD+VB | Self-Harm: H | Heal: G | Reset: R)")
    
    server_state_obj.app_running = True 
    current_width, current_height = screen.get_size()

    if server_state_obj.broadcast_thread and server_state_obj.broadcast_thread.is_alive():
        print("DEBUG Server: Broadcast thread already running (normal if re-entering server mode without full app restart).") # DEBUG
    else:
        print("DEBUG Server: Starting broadcast thread.") # DEBUG
        server_state_obj.broadcast_thread = threading.Thread(
            target=broadcast_presence_thread, args=(server_state_obj,), daemon=True
        )
        server_state_obj.broadcast_thread.start()

    if server_state_obj.server_tcp_socket: 
        print("DEBUG Server: Closing existing TCP socket before creating new one.") # DEBUG
        try: server_state_obj.server_tcp_socket.close()
        except: pass
    
    server_state_obj.server_tcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_state_obj.server_tcp_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    try:
        server_state_obj.server_tcp_socket.bind((C.SERVER_IP_BIND, server_state_obj.server_port_tcp))
        server_state_obj.server_tcp_socket.listen(1) 
        server_state_obj.server_tcp_socket.settimeout(1.0) 
        print(f"DEBUG Server: Listening on {C.SERVER_IP_BIND}:{server_state_obj.server_port_tcp}") # DEBUG
    except socket.error as e:
        print(f"FATAL SERVER ERROR: Failed to bind/listen TCP socket: {e}")
        return 

    print("DEBUG Server: Waiting for Player 2 to connect...") # DEBUG
    temp_client_conn_obj = None 
    while temp_client_conn_obj is None and server_state_obj.app_running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT: server_state_obj.app_running = False; break
            if event.type == pygame.VIDEORESIZE:
                if not screen.get_flags() & pygame.FULLSCREEN:
                    current_width, current_height = max(320,event.w), max(240,event.h)
                    screen = pygame.display.set_mode((current_width, current_height), pygame.RESIZABLE|pygame.DOUBLEBUF)
                    if game_elements_ref.get("camera"): 
                        game_elements_ref["camera"].screen_width = current_width
                        game_elements_ref["camera"].screen_height = current_height
            if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
                server_state_obj.app_running = False; break 
        if not server_state_obj.app_running: break
        
        screen.fill(C.BLACK)
        if fonts.get("large"):
            wait_text_surf = fonts["large"].render("Waiting for P2...", True, C.WHITE)
            screen.blit(wait_text_surf, wait_text_surf.get_rect(center=(current_width//2, current_height//2)))
        pygame.display.flip()
        clock.tick(10) 

        try:
            temp_client_conn_obj, temp_client_addr_tuple = server_state_obj.server_tcp_socket.accept()
            with client_lock:
                 if server_state_obj.client_connection: 
                     print("DEBUG Server: Closing pre-existing client connection before new one.") # DEBUG
                     try: server_state_obj.client_connection.close()
                     except: pass
                 server_state_obj.client_connection = temp_client_conn_obj
                 server_state_obj.client_address = temp_client_addr_tuple
                 server_state_obj.client_input_buffer = {} 
                 print(f"DEBUG Server: Accepted connection from {temp_client_addr_tuple}") # DEBUG
        except socket.timeout:
            continue 
        except Exception as e:
            if server_state_obj.app_running:
                print(f"DEBUG Server: Error during client accept: {e}") # DEBUG
            break 
    
    if not server_state_obj.app_running or server_state_obj.client_connection is None:
        print("DEBUG Server: Exiting wait loop (no client connected or app closed).") # DEBUG
        return 

    print(f"DEBUG Server: Client {server_state_obj.client_address} connected. Starting game...") # DEBUG
    if server_state_obj.client_handler_thread and server_state_obj.client_handler_thread.is_alive():
        print("DEBUG Server: Previous client handler thread still alive. Attempting to join.") # DEBUG
        server_state_obj.client_handler_thread.join(timeout=0.2) 
    
    server_state_obj.client_handler_thread = threading.Thread(
        target=handle_client_connection_thread, 
        args=(server_state_obj.client_connection, server_state_obj.client_address, server_state_obj), 
        daemon=True
    )
    server_state_obj.client_handler_thread.start()
    print("DEBUG Server: Client handler thread started.") # DEBUG

    p1 = game_elements_ref.get("player1") 
    p2 = game_elements_ref.get("player2") 
    if p1: print(f"DEBUG Server: P1 instance from game_elements: {p1}, Valid: {p1._valid_init if p1 else 'N/A'}") # DEBUG
    if p2: print(f"DEBUG Server: P2 instance from game_elements: {p2}, Valid: {p2._valid_init if p2 else 'N/A'}") # DEBUG


    p1_key_map_config = { 
        'left': pygame.K_a, 'right': pygame.K_d, 'up': pygame.K_w, 'down': pygame.K_s,
        'attack1': pygame.K_v, 'attack2': pygame.K_b, 'dash': pygame.K_LSHIFT,
        'roll': pygame.K_LCTRL, 'interact': pygame.K_e
    }
    
    server_game_active = True
    while server_game_active and server_state_obj.app_running:
        dt_sec = clock.tick(C.FPS) / 1000.0 
        now_ticks_server = pygame.time.get_ticks() 
        
        pygame_events = pygame.event.get()
        keys_pressed_p1 = pygame.key.get_pressed()

        is_p1_game_over_for_reset = False
        if p1 and p1._valid_init:
            if p1.is_dead and (not p1.alive() or (hasattr(p1, 'death_animation_finished') and p1.death_animation_finished)):
                is_p1_game_over_for_reset = True
        else: 
            is_p1_game_over_for_reset = True

        host_requested_reset = False
        for event in pygame_events:
            if event.type == pygame.QUIT: server_game_active = False; server_state_obj.app_running = False; break
            if event.type == pygame.VIDEORESIZE:
                if not screen.get_flags() & pygame.FULLSCREEN:
                    current_width, current_height = max(320,event.w), max(240,event.h)
                    screen = pygame.display.set_mode((current_width,current_height), pygame.RESIZABLE|pygame.DOUBLEBUF)
                    if game_elements_ref.get("camera"):
                        game_elements_ref["camera"].screen_width = current_width
                        game_elements_ref["camera"].screen_height = current_height
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE: server_game_active = False 
                if event.key == pygame.K_r: host_requested_reset = True
                if p1 and p1._valid_init: 
                    if event.key == pygame.K_h and hasattr(p1, 'self_inflict_damage'): p1.self_inflict_damage(C.PLAYER_SELF_DAMAGE)
                    if event.key == pygame.K_g and hasattr(p1, 'heal_to_full'): p1.heal_to_full()
        
        if not server_state_obj.app_running or not server_game_active: break

        if p1 and p1._valid_init and not p1.is_dead:
            if hasattr(p1, 'handle_mapped_input'):
                p1.handle_mapped_input(keys_pressed_p1, pygame_events, p1_key_map_config)

        p2_network_input, client_disconnected_signal, p2_requested_reset = None, False, False
        with client_lock: 
            if server_state_obj.client_input_buffer:
                buffered_input = server_state_obj.client_input_buffer
                # print(f"DEBUG Server: Processing client_input_buffer: {buffered_input}") # DEBUG
                if buffered_input.get("disconnect"): client_disconnected_signal = True
                elif buffered_input.get("action_reset", False): p2_requested_reset = True
                elif p2 and p2._valid_init:
                    if buffered_input.get("action_self_harm", False) and hasattr(p2, 'self_inflict_damage'):
                        p2.self_inflict_damage(C.PLAYER_SELF_DAMAGE)
                    elif buffered_input.get("action_heal", False) and hasattr(p2, 'heal_to_full'):
                        p2.heal_to_full()
                else: 
                    p2_network_input = buffered_input.copy()
                server_state_obj.client_input_buffer = {} 

        if client_disconnected_signal:
            print("DEBUG Server: Client disconnected signal received in main loop.") # DEBUG
            server_game_active = False 
            break 

        if p2 and p2._valid_init and p2_network_input and hasattr(p2, 'handle_network_input'):
            # print(f"DEBUG Server: Handling P2 network input: {p2_network_input}") # DEBUG
            p2.handle_network_input(p2_network_input) 

        if host_requested_reset or (p2_requested_reset and is_p1_game_over_for_reset):
            print("DEBUG Server: Game state reset triggered.") # DEBUG
            game_elements_ref["current_chest"] = reset_game_state(game_elements_ref)

        if p1 and p1._valid_init:
            other_players_for_p1_update = [char for char in [p2] if char and char._valid_init and char.alive() and char is not p1]
            p1.update(dt_sec, game_elements_ref["platform_sprites"], game_elements_ref["ladder_sprites"], 
                      game_elements_ref["hazard_sprites"], other_players_for_p1_update, game_elements_ref["enemy_list"])

        if p2 and p2._valid_init:
            other_players_for_p2_update = [char for char in [p1] if char and char._valid_init and char.alive() and char is not p2]
            p2.update(dt_sec, game_elements_ref["platform_sprites"], game_elements_ref["ladder_sprites"], 
                      game_elements_ref["hazard_sprites"], other_players_for_p2_update, game_elements_ref["enemy_list"])

        active_players_for_enemy_ai = [char for char in [p1, p2] if char and char._valid_init and not char.is_dead and char.alive()]
        for enemy in list(game_elements_ref.get("enemy_list", [])): 
            if enemy._valid_init:
                enemy.update(dt_sec, active_players_for_enemy_ai, game_elements_ref["platform_sprites"], game_elements_ref["hazard_sprites"])
                if enemy.is_dead and hasattr(enemy, 'death_animation_finished') and \
                   enemy.death_animation_finished and enemy.alive():
                    if hasattr(Enemy, 'print_limiter') and Enemy.print_limiter.can_print(f"server_killing_enemy_{enemy.enemy_id}"):
                         print(f"Server: Auto-killing enemy {enemy.enemy_id} as death anim finished.")
                    enemy.kill() 
            
        hittable_characters_server_group = pygame.sprite.Group()
        if p1 and p1.alive() and p1._valid_init: hittable_characters_server_group.add(p1)
        if p2 and p2.alive() and p2._valid_init: hittable_characters_server_group.add(p2)
        for enemy_inst_proj in game_elements_ref.get("enemy_list", []):
            if enemy_inst_proj and enemy_inst_proj.alive() and enemy_inst_proj._valid_init:
                hittable_characters_server_group.add(enemy_inst_proj)
        game_elements_ref.get("projectile_sprites", pygame.sprite.Group()).update(dt_sec, game_elements_ref["platform_sprites"], hittable_characters_server_group)
        
        game_elements_ref.get("collectible_sprites", pygame.sprite.Group()).update(dt_sec)
        server_current_chest = game_elements_ref.get("current_chest")
        if server_current_chest and server_current_chest.alive(): 
            player_who_collected_chest = None
            if p1 and p1._valid_init and not p1.is_dead and p1.alive() and pygame.sprite.collide_rect(p1, server_current_chest):
                player_who_collected_chest = p1
            elif p2 and p2._valid_init and not p2.is_dead and p2.alive() and pygame.sprite.collide_rect(p2, server_current_chest):
                player_who_collected_chest = p2
            
            if player_who_collected_chest:
                server_current_chest.collect(player_who_collected_chest) 
                game_elements_ref["current_chest"] = None 
        
        server_camera = game_elements_ref.get("camera")
        if server_camera:
            camera_focus_target = None
            if p1 and p1.alive() and p1._valid_init and not p1.is_dead: camera_focus_target = p1
            elif p2 and p2.alive() and p2._valid_init and not p2.is_dead: camera_focus_target = p2
            
            if camera_focus_target: server_camera.update(camera_focus_target)
            else: server_camera.static_update() 

        if server_state_obj.client_connection: 
            network_state_to_send = get_network_game_state(game_elements_ref)
            # print(f"DEBUG Server: State to send: P1 pos {network_state_to_send.get('p1', {}).get('pos')}, P2 pos {network_state_to_send.get('p2', {}).get('pos')}") # DEBUG
            encoded_game_state = encode_data(network_state_to_send)
            if encoded_game_state:
                try:
                    server_state_obj.client_connection.sendall(encoded_game_state)
                except socket.error as e:
                    print(f"DEBUG Server: Send failed to client: {e}. Client likely disconnected.") # DEBUG
                    server_game_active = False 
                    with client_lock: server_state_obj.client_connection = None 
                    break 
            # else: print("DEBUG Server Error: Failed to encode game state for sending.") # DEBUG
        
        try:
            draw_platformer_scene_on_surface(screen, game_elements_ref, fonts, now_ticks_server)
        except Exception as e:
            print(f"Server draw error: {e}"); traceback.print_exc()
            server_game_active = False; break
        pygame.display.flip()

    print("DEBUG Server: Exiting active game loop.") # DEBUG
    
    connection_to_close_at_server_exit = None
    with client_lock:
        if server_state_obj.client_connection:
            connection_to_close_at_server_exit = server_state_obj.client_connection
            server_state_obj.client_connection = None 
    if connection_to_close_at_server_exit:
        print("DEBUG Server: Mode exit cleanup - closing client connection.") # DEBUG
        try:
            connection_to_close_at_server_exit.shutdown(socket.SHUT_RDWR)
            connection_to_close_at_server_exit.close()
        except: pass 

    if server_state_obj.server_tcp_socket:
        print("DEBUG Server: Closing main TCP listening socket.") # DEBUG
        server_state_obj.server_tcp_socket.close()
        server_state_obj.server_tcp_socket = None
    
    print("DEBUG Server: Server mode finished and returned to caller.") # DEBUG

########## END OF FILE: server_logic.py ##########

########## START OF FILE: tiles.py ##########

# tiles.py
# -*- coding: utf-8 -*-
"""
Defines classes for static and interactive tiles in the game world.
"""
# version 1.0.0.1 (Added platform_type to Platform class)
import pygame
# Import all necessary constants, including DARK_GREEN if not already present
from constants import GRAY, BLUE, ORANGE_RED, DARK_GREEN 

class Platform(pygame.sprite.Sprite):
    """ 
    Standard solid platform.
    Can be tagged with a platform_type (e.g., "ground", "ledge", "wall").
    """
    def __init__(self, x, y, width, height, color=GRAY, platform_type="generic"):
        super().__init__()
        
        # Ensure valid dimensions for the surface
        surf_width = max(1, int(width))
        surf_height = max(1, int(height))
        
        self.image = pygame.Surface((surf_width, surf_height))
        self.image.fill(color)
        self.rect = self.image.get_rect(topleft=(x, y))
        
        self.color = color # Store the color, can be useful for debugging or logic
        self.platform_type = platform_type # Store the type of platform

        if width <= 0 or height <= 0:
            print(f"Warning: Platform created with non-positive dimensions: w={width}, h={height} at ({x},{y}). Using 1x1.")
            # Surface already created with max(1,...) dimensions, rect is based on original x,y


class Ladder(pygame.sprite.Sprite):
    """ Climbable ladder area. """
    def __init__(self, x, y, width, height):
        super().__init__()
        # Ensure valid dimensions
        width = max(1, int(width))
        height = max(1, int(height))
        self.image = pygame.Surface((width, height)).convert_alpha()
        self.image.fill((0, 0, 0, 0)) # Fully transparent background
        self.image.set_alpha(100) # Make semi-transparent visually

        # Draw visual cues (rungs, rails)
        rung_color = (40, 40, 180, 200) # Slightly transparent dark blue
        num_rungs = int(height / 15)
        if num_rungs > 0: # Avoid division by zero if height is too small
            rung_spacing = height / num_rungs
            for i in range(1, num_rungs + 1): # Iterate to include a rung near the top
                rung_y = i * rung_spacing
                # Ensure rung_y is within bounds before drawing
                if rung_y < height -1 : # -1 to keep it within the surface
                    pygame.draw.line(self.image, rung_color, (0, rung_y), (width, rung_y), 2)
        
        # Draw side rails (ensure lines are within surface bounds)
        # Use min/max to prevent drawing outside the surface if width is very small
        rail_thickness = 3
        left_rail_x = min(rail_thickness -1, width -1) # If width=1, rail is at x=0
        right_rail_x = max(0, width - rail_thickness)   # If width=1, rail is at x=0
        
        pygame.draw.line(self.image, rung_color, (left_rail_x, 0), (left_rail_x, height), rail_thickness)
        if width > rail_thickness * 2: # Only draw second rail if there's space
             pygame.draw.line(self.image, rung_color, (right_rail_x, 0), (right_rail_x, height), rail_thickness)

        self.rect = self.image.get_rect(topleft=(x, y))

class Lava(pygame.sprite.Sprite):
    """ Dangerous lava tile that damages characters. """
    def __init__(self, x, y, width, height, color=ORANGE_RED):
        super().__init__()
        # Ensure valid dimensions
        width = max(1, int(width))
        height = max(1, int(height))
        self.image = pygame.Surface((width, height))
        self.image.fill(color)
        self.rect = self.image.get_rect(topleft=(x, y))
        # Optional: Add visual effect like simple noise/flicker
        # import random
        # for _ in range(int(width*height*0.05)): # Add some darker spots
        #      px = random.randint(0, width-1)
        #      py = random.randint(0, height-1)
        #      dark_color_r = max(0, color[0]-random.randint(30,70))
        #      dark_color_g = max(0, color[1]-random.randint(10,40))
        #      dark_color_b = max(0, color[2]-random.randint(0,20))
        #      self.image.set_at((px, py), (dark_color_r, dark_color_g, dark_color_b))

########## START OF FILE: utils.py ##########

# utils.py
# -*- coding: utf-8 -*-
"""
Shared utility classes and functions.
version 1.0000000.1
"""
import time

class PrintLimiter:
    def __init__(self, default_limit=5, default_period=2.0):
        self.counts = {}
        self.timestamps = {}
        self.default_limit = default_limit
        self.default_period = default_period
        self.globally_suppressed = {} # Tracks if the "suppressing further prints" message was shown

    def can_print(self, message_key, limit=None, period=None):
        limit = limit if limit is not None else self.default_limit
        period = period if period is not None else self.default_period
        current_time = time.time()
        
        if message_key not in self.timestamps:
            self.timestamps[message_key] = current_time
            self.counts[message_key] = 0
            self.globally_suppressed[message_key] = False

        if current_time - self.timestamps[message_key] > period:
            self.timestamps[message_key] = current_time
            self.counts[message_key] = 0
            self.globally_suppressed[message_key] = False # Reset suppression message flag

        if self.counts[message_key] < limit:
            self.counts[message_key] += 1
            return True
        elif not self.globally_suppressed[message_key]: # Only print suppression message once per period
            # print(f"[PrintLimiter] Suppressing further prints for '{message_key}' for {period:.1f}s (limit: {limit})") # Keep this commented for less console noise
            self.globally_suppressed[message_key] = True
            return False
        return False