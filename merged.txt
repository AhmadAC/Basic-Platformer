

########## START OF FILE: assets.py ##########

# assets.py
# -*- coding: utf-8 -*-
## version 1.0.0.4 (Integrated global logger)
"""
Handles loading game assets, primarily animations from GIF files.
Includes a helper function `resource_path` to ensure correct asset pathing
both during local development and when the game is packaged by PyInstaller (especially --onedir).
"""
import pygame
import os
import sys
from PIL import Image # Pillow library for GIF processing
from typing import Dict, List, Optional # For type hinting

# --- Import Logger ---
try:
    # Import the specific logging functions that check LOGGING_ENABLED
    from logger import info, debug, warning, error, critical
except ImportError:
    # Fallback if logger.py is not found - this should not happen in a correct setup
    print("CRITICAL ASSETS: logger.py not found. Falling back to print statements for logging.")
    def info(msg): print(f"INFO: {msg}")
    def debug(msg): print(f"DEBUG: {msg}")
    def warning(msg): print(f"WARNING: {msg}")
    def error(msg): print(f"ERROR: {msg}")
    def critical(msg): print(f"CRITICAL: {msg}")

# --- Import Constants (specifically colors for placeholder images) ---
# Attempting a different import style for diagnostics
try:
    import constants # Import the whole module
    RED = constants.RED
    BLACK = constants.BLACK
    BLUE = constants.BLUE
    YELLOW = constants.YELLOW
    MAPS_DIR = constants.MAPS_DIR # Added for assets to know where maps are, if ever needed by assets directly
    info("Assets: Successfully imported 'constants' and attributes.")
except ImportError:
    warning("Assets Warning: Failed to import 'constants' (using 'import constants'). Using fallback colors and MAPS_DIR.")
    RED = (255, 0, 0)
    BLACK = (0, 0, 0)
    BLUE = (0, 0, 255)
    YELLOW = (255, 255, 0)
    MAPS_DIR = "maps" # Fallback
except AttributeError as e_attr:
    # This block will catch if 'constants' was imported but one of the specific color names is missing.
    warning(f"Assets Warning: Imported 'constants' but an attribute is missing: {e_attr}. Using fallback colors and MAPS_DIR.")
    RED = (255, 0, 0)
    BLACK = (0, 0, 0)
    BLUE = (0, 0, 255)
    YELLOW = (255, 255, 0)
    # Safely try to get MAPS_DIR if constants module was at least partially imported
    if 'constants' in sys.modules:
        MAPS_DIR = getattr(sys.modules['constants'], "MAPS_DIR", "maps")
    else:
        MAPS_DIR = "maps"
except Exception as e_general_import: # Catch any other unexpected error during constants import
    critical(f"Assets CRITICAL: Unexpected error importing 'constants': {e_general_import}. Using fallback colors and MAPS_DIR.")
    RED = (255, 0, 0)
    BLACK = (0, 0, 0)
    BLUE = (0, 0, 255)
    YELLOW = (255, 255, 0)
    MAPS_DIR = "maps" # Fallback


# --- Helper Function for PyInstaller Compatibility ---
def resource_path(relative_path: str) -> str:
    """
    Get the absolute path to a resource, works for development and for PyInstaller.
    When running as a PyInstaller bundle (especially --onedir or --onefile),
    assets are often bundled relative to sys._MEIPASS.

    Args:
        relative_path (str): The path to the resource relative to the project root
                             (or where assets are expected to be found).

    Returns:
        str: The absolute path to the resource.
    """
    try:
        base_path = sys._MEIPASS
    except AttributeError:
        base_path = os.path.abspath(".")

    # Check if relative_path is for the maps directory
    # If so, ensure it's treated as relative to the project root, not potentially sys._MEIPASS
    # This is important because maps are user-modifiable/downloadable and should be in a predictable user-accessible location.
    if relative_path.startswith(MAPS_DIR + os.sep) or relative_path == MAPS_DIR:
        # Always use os.path.abspath(".") for maps, ensuring they are in the CWD/script dir (or project root for dev)
        # and not inside _MEIPASS if bundled.
        base_path_for_maps = os.path.abspath(".")
        full_asset_path = os.path.join(base_path_for_maps, relative_path)
        # debug(f"DEBUG resource_path (map): relative='{relative_path}', base='{base_path_for_maps}', full='{full_asset_path}'")
        return full_asset_path

    full_asset_path = os.path.join(base_path, relative_path)
    # debug(f"DEBUG resource_path (asset): relative='{relative_path}', base='{base_path}', full='{full_asset_path}'")
    return full_asset_path
# ----------------------------------------------------


# --- GIF Loading Function ---
def load_gif_frames(full_path_to_gif_file: str) -> List[pygame.Surface]:
    """
    Loads all frames from a GIF file using the Pillow library and converts them
    into a list of Pygame Surface objects. Handles transparency.
    """
    loaded_frames: List[pygame.Surface] = []
    try:
        pil_gif_image = Image.open(full_path_to_gif_file)
        frame_index = 0
        while True:
            try:
                pil_gif_image.seek(frame_index)
                current_pil_frame = pil_gif_image.copy()
                rgba_pil_frame = current_pil_frame.convert('RGBA')
                frame_pixel_data = rgba_pil_frame.tobytes()
                frame_dimensions = rgba_pil_frame.size
                pygame_surface_frame = pygame.image.frombuffer(frame_pixel_data, frame_dimensions, "RGBA")
                pygame_surface_frame = pygame_surface_frame.convert_alpha()
                loaded_frames.append(pygame_surface_frame)
                frame_index += 1
            except EOFError:
                break # End of frames
            except Exception as e_frame:
                error(f"Assets Error: Processing frame {frame_index} in '{full_path_to_gif_file}': {e_frame}")
                frame_index += 1 # Try next frame

        if not loaded_frames:
             error(f"Assets Error: No frames loaded from '{full_path_to_gif_file}'. Creating a RED placeholder.")
             placeholder_surface = pygame.Surface((30, 40)).convert_alpha()
             placeholder_surface.fill(RED) # Use RED from constants or fallback
             pygame.draw.rect(placeholder_surface, BLACK, placeholder_surface.get_rect(), 1) # Use BLACK
             return [placeholder_surface]

        return loaded_frames

    except FileNotFoundError:
        error(f"Assets Error: GIF file not found at resolved path: '{full_path_to_gif_file}'")
    except Exception as e_load:
        error(f"Assets Error: Loading GIF '{full_path_to_gif_file}' with Pillow: {e_load}")

    # Fallback placeholder if any error occurs during loading
    placeholder_surface_on_error = pygame.Surface((30, 40)).convert_alpha()
    placeholder_surface_on_error.fill(RED) # Use RED
    pygame.draw.rect(placeholder_surface_on_error, BLACK, placeholder_surface_on_error.get_rect(), 2) # Use BLACK
    return [placeholder_surface_on_error]


# --- Player/Enemy Animation Loading Function ---
def load_all_player_animations(relative_asset_folder: str = 'characters/player1') -> Optional[Dict[str, List[pygame.Surface]]]:
    """
    Loads all defined animations for a character.
    """
    animations_dict: Dict[str, List[pygame.Surface]] = {}
    animation_filenames_map = {
        'attack': '__Attack.gif', 'attack2': '__Attack2.gif', 'attack_combo': '__AttackCombo2hit.gif',
        'attack_nm': '__AttackNoMovement.gif', 'attack2_nm': '__Attack2NoMovement.gif',
        'attack_combo_nm': '__AttackComboNoMovement.gif',
        'crouch': '__Crouch.gif', 'crouch_trans': '__CrouchTransition.gif',
        'crouch_walk': '__CrouchWalk.gif', 'crouch_attack': '__CrouchAttack.gif',
        'dash': '__Dash.gif',
        'death': '__Death.gif', 'death_nm': '__DeathNoMovement.gif',
        'fall': '__Fall.gif', 'hit': '__Hit.gif', 'idle': '__Idle.gif',
        'jump': '__Jump.gif', 'jump_fall_trans': '__JumpFallInbetween.gif',
        'roll': '__Roll.gif', 'run': '__Run.gif',
        'slide': '__SlideAll.gif', 'slide_trans_start': '__SlideTransitionStart.gif',
        'slide_trans_end': '__SlideTransitionEnd.gif',
        'turn': '__TurnAround.gif',
        'wall_climb': '__WallClimb.gif', 'wall_climb_nm': '__WallClimbNoMovement.gif',
        'wall_hang': '__WallHang.gif', 'wall_slide': '__WallSlide.gif',
    }

    info(f"Assets Info: Attempting to load animations from relative folder: '{relative_asset_folder}'")
    missing_files_log: List[tuple[str, str, str]] = []

    for anim_state_name, gif_filename in animation_filenames_map.items():
         relative_path_to_gif = os.path.join(relative_asset_folder, gif_filename)
         absolute_gif_path = resource_path(relative_path_to_gif)

         if not os.path.exists(absolute_gif_path):
             missing_files_log.append(
                 (anim_state_name, relative_path_to_gif, absolute_gif_path)
             )
             animations_dict[anim_state_name] = [] # Mark as missing for later placeholder generation
             continue

         loaded_animation_frames = load_gif_frames(absolute_gif_path)
         animations_dict[anim_state_name] = loaded_animation_frames

         # Check if load_gif_frames returned its RED placeholder due to an internal error
         if not animations_dict[anim_state_name] or \
            (len(animations_dict[anim_state_name]) == 1 and \
             animations_dict[anim_state_name][0].get_size() == (30,40) and \
             animations_dict[anim_state_name][0].get_at((0,0)) == RED): # RED from constants/fallback
             warning(f"Assets Warning: Failed to load frames for state '{anim_state_name}' from existing file '{absolute_gif_path}'. RED Placeholder used.")

    if missing_files_log:
        warning("\n--- Assets: Missing Animation Files Detected ---")
        try: base_path_for_log = sys._MEIPASS
        except AttributeError: base_path_for_log = os.path.abspath(".")

        for name, rel_path, res_path in missing_files_log:
            warning(f"- State '{name}': Expected relative path: '{rel_path}', Resolved path checked: '{res_path}'")
        info(f"(Asset loading base path used by resource_path: '{base_path_for_log}')") # Can be info or debug
        warning("--------------------------------------------\n")

    # Check for critical 'idle' animation
    idle_anim_is_missing_or_placeholder = (
        'idle' not in animations_dict or
        not animations_dict['idle'] or
        (len(animations_dict['idle']) == 1 and
         animations_dict['idle'][0].get_size() == (30,40) and
         animations_dict['idle'][0].get_at((0,0)) == RED) # RED from constants/fallback
    )

    if idle_anim_is_missing_or_placeholder:
        idle_file_rel_path = os.path.join(relative_asset_folder, animation_filenames_map.get('idle', '__Idle.gif'))
        idle_file_abs_path_checked = resource_path(idle_file_rel_path)
        if 'idle' not in animations_dict or not animations_dict['idle']:
            critical(f"CRITICAL Assets Error: 'idle' animation file ('{idle_file_rel_path}') not found or empty. Checked: '{idle_file_abs_path_checked}'.")
        else: # It's the RED placeholder
            critical(f"CRITICAL Assets Error: 'idle' animation failed to load correctly (is RED placeholder) from '{idle_file_abs_path_checked}'.")
        warning("Assets: Returning None due to critical 'idle' animation failure.")
        return None

    # Provide blue placeholders for other missing/failed non-critical animations
    for anim_name_check in animation_filenames_map:
        if anim_name_check == 'idle': continue # Already handled

        animation_is_missing_or_placeholder = (
            anim_name_check not in animations_dict or
            not animations_dict[anim_name_check] or
            (len(animations_dict[anim_name_check]) == 1 and
             animations_dict[anim_name_check][0].get_size() == (30,40) and
             animations_dict[anim_name_check][0].get_at((0,0)) == RED) # RED from constants/fallback
        )

        if animation_is_missing_or_placeholder:
            if anim_name_check not in animations_dict or not animations_dict[anim_name_check]:
                 # This case means the file was missing (missing_files_log handled the print)
                 # and animations_dict[anim_name_check] was set to []
                 warning(f"Assets Warning: Animation state '{anim_name_check}' (file missing). Providing a BLUE placeholder.")
            else: # This case means file existed but load_gif_frames returned the RED placeholder
                 warning(f"Assets Warning: Animation state '{anim_name_check}' (load failed, is RED placeholder). Using a BLUE placeholder.")

            blue_placeholder = pygame.Surface((30, 40)).convert_alpha()
            blue_placeholder.fill(BLUE) # BLUE from constants/fallback
            pygame.draw.line(blue_placeholder, RED, (0,0), (30,40), 2) # RED for cross
            pygame.draw.line(blue_placeholder, RED, (0,40), (30,0), 2)
            animations_dict[anim_name_check] = [blue_placeholder]

    info(f"Assets Info: Finished loading animations. {len(animations_dict)} animation states processed for '{relative_asset_folder}'.")
    return animations_dict
# ------------------------------------------


# --- Example Usage (if assets.py is run directly for testing) ---
if __name__ == "__main__":
    info("Running assets.py directly for testing...")
    # Pygame init is needed for Surface creation, even for tests not drawing to screen
    pygame.init()
    # Note: If constants.py is in the same dir, 'import constants' should work here.
    # If it fails here too, the problem is more fundamental with constants.py visibility.

    info("\n--- Testing resource_path ---")
    test_relative_path = 'characters/player1/__Idle.gif'
    resolved_test_path = resource_path(test_relative_path)
    info(f"Resolved path for '{test_relative_path}': {resolved_test_path}")
    info(f"Does it exist? {os.path.exists(resolved_test_path)}")

    test_map_path_rel = os.path.join(MAPS_DIR, "test_map.py") # MAPS_DIR is defined at the top
    resolved_map_path = resource_path(test_map_path_rel)
    info(f"Resolved path for map '{test_map_path_rel}': {resolved_map_path}")
    # Create dummy map dir and file for testing resource_path with maps
    try:
        if not os.path.exists(MAPS_DIR): os.makedirs(MAPS_DIR)
        with open(resolved_map_path, "w") as f: f.write("# Test map file")
        info(f"Does map file exist after creation? {os.path.exists(resolved_map_path)}")
    except Exception as e_test_map:
        error(f"Error creating test map file/dir: {e_test_map}")


    test_character_asset_folder = 'characters/player1'
    info(f"\n--- Testing load_all_player_animations with relative folder: '{test_character_asset_folder}' ---")

    loaded_player_animations = load_all_player_animations(relative_asset_folder=test_character_asset_folder)

    if loaded_player_animations:
        info(f"\nAssets Test: Successfully loaded animation data dictionary.")
        if 'idle' in loaded_player_animations and loaded_player_animations['idle']:
            info(f"Idle animation loaded with {len(loaded_player_animations['idle'])} frames.")
            first_idle_frame = loaded_player_animations['idle'][0]
            if first_idle_frame.get_size() == (30, 40): # Standard placeholder size
                 # Check color using the RED defined at the top of this file (either from constants or fallback)
                 if first_idle_frame.get_at((0,0)) == RED:
                     warning("Assets Test WARNING: 'idle' animation appears to be the RED (load failure) placeholder!")
                 elif first_idle_frame.get_at((0,0)) == BLUE: # BLUE defined at top
                     warning("Assets Test WARNING: 'idle' animation appears to be a BLUE (non-critical missing) placeholder! (This shouldn't happen for idle due to critical check)")
        else:
            error("Assets Test ERROR: 'idle' animation missing or empty in the returned dictionary (after critical check).")
    else:
        error("\nAssets Test: Animation loading failed (load_all_player_animations returned None). Likely due to critical 'idle' animation issue.")

    pygame.quit()
    info("Assets.py direct run test finished.")

########## START OF FILE: autocrop1.py ##########

# autocropgif.py
from PIL import Image, ImageSequence
import os
import traceback  # For better error reporting
import pyperclip    # Import pyperclip
from collections import Counter # For summarizing results
import warnings # To potentially catch Pillow warnings if needed

# --- Helper Function to check for pyperclip ---
def check_pyperclip():
    """Checks if pyperclip is available."""
    try:
        import pyperclip # Attempt local import for this check
        pyperclip.paste() # Test if paste works (can sometimes fail on headless systems)
        print("Pyperclip library found and accessible.")
        return True
    except ImportError:
        print("Error: The 'pyperclip' library is not installed.")
        print("Please install it using: pip install pyperclip")
        return False
    except (pyperclip.PyperclipException, Exception) as e: # PyperclipException for its specific errors
        print(f"Error: Pyperclip could not access the clipboard.")
        print(f"Details: {e}")
        print("This might happen on systems without a clipboard manager (e.g., some servers).")
        return False

# --- analyze_gif_frames function (largely the same) ---
def analyze_gif_frames(im):
    """Analyzes GIF frames to find the overall content bounding box."""
    results = {
        'min_left': None, 'min_upper': None,
        'max_right': None, 'max_lower': None
    }
    frames_rgba = []
    durations = []
    disposal_methods = []
    loop_count = im.info.get('loop', 0) # Default loop 0 (infinite)
    frame_index = 0

    for frame_image in ImageSequence.Iterator(im):
        frame_rgba = frame_image.convert("RGBA") # Convert to RGBA for consistent alpha handling
        frames_rgba.append(frame_rgba)
        try:
            # Get bounding box of non-transparent pixels from alpha channel
            alpha_channel = frame_rgba.getchannel('A')
            frame_bbox = alpha_channel.getbbox()
        except ValueError: # If no alpha channel (e.g. mode "RGB" frame in a GIF)
            # Assume full frame is content if no alpha channel
            frame_bbox = (0, 0, frame_rgba.width, frame_rgba.height)

        if frame_bbox: # If content found in this frame
            left, upper, right, lower = frame_bbox
            if results['min_left'] is None or left < results['min_left']: results['min_left'] = left
            if results['min_upper'] is None or upper < results['min_upper']: results['min_upper'] = upper
            if results['max_right'] is None or right > results['max_right']: results['max_right'] = right
            if results['max_lower'] is None or lower < results['max_lower']: results['max_lower'] = lower

        durations.append(frame_image.info.get('duration', 100)) # Default duration 100ms
        disposal = frame_image.info.get('disposal', 2) 
        disposal_methods.append(disposal)
        frame_index += 1

    if None not in results.values(): # Check if any bounding box component was found
        overall_bbox = (results['min_left'], results['min_upper'], results['max_right'], results['max_lower'])
    else: 
        overall_bbox = None # Indicates no content found or GIF was empty
    return overall_bbox, frames_rgba, durations, loop_count, disposal_methods

# --- New function to auto-crop PNG images ---
def auto_crop_png(input_path, output_path):
    """
    Automatically crops a PNG image to its content, saving to output_path.
    The original input_path file is not modified or deleted.
    Returns 'CROPPED', 'SKIPPED', or 'ERROR'.
    """
    print("-" * 30)
    print(f"Processing PNG: '{os.path.basename(input_path)}'")
    img = None
    try:
        img = Image.open(input_path)
        original_info = img.info.copy() # Preserve metadata like DPI, comments

        img_rgba = img.convert("RGBA")
        
        bbox = img_rgba.getbbox() 

        if bbox is None:
            print("  Skipping: PNG is empty or fully transparent (no content found).")
            return 'SKIPPED'

        original_width, original_height = img.size 
        
        if bbox == (0, 0, original_width, original_height):
            print("  Skipping: PNG content already fills the entire frame (no cropping needed).")
            return 'SKIPPED'
        
        crop_width = bbox[2] - bbox[0]
        crop_height = bbox[3] - bbox[1]
        if crop_width <= 0 or crop_height <= 0:
            print(f"  Error: Calculated bounding box has zero or negative dimensions {bbox}. Cannot crop.")
            return 'ERROR'

        print(f"  Original dims: {original_width}x{original_height}")
        print(f"  Content BBox: {bbox}")
        print(f"  Cropped dims: {crop_width}x{crop_height}")

        cropped_img_rgba = img_rgba.crop(bbox)

        if os.path.abspath(input_path) == os.path.abspath(output_path):
            print(f"  Critical Error: Input and output paths are identical for PNG ('{output_path}'). Aborting save to prevent data loss.")
            return 'ERROR'

        if os.path.exists(output_path):
            try:
                os.remove(output_path)
            except OSError as e:
                print(f"  Warning: Could not remove existing target file '{os.path.basename(output_path)}': {e}")
                return 'ERROR' 

        cropped_img_rgba.save(output_path, **original_info)
        print(f"  Auto-cropped PNG saved successfully to '{os.path.basename(output_path)}'.")
        return 'CROPPED'

    except FileNotFoundError:
        print(f"Error: Input PNG file not found at '{input_path}'")
        return 'ERROR'
    except Exception as e:
        print(f"An unexpected error occurred processing PNG '{os.path.basename(input_path)}': {e}")
        traceback.print_exc()
        return 'ERROR'
    finally:
        if img:
            try:
                img.close()
            except Exception: 
                pass

# --- auto_crop_animated_gif function (UPDATED with fix for disposal/duration handling) ---
def auto_crop_animated_gif(input_path, output_path):
    """
    Automatically crops an animated GIF, preserving transparency and animation.
    Saves to output_path. Original input_path file is not modified or deleted.
    Returns 'CROPPED', 'SKIPPED', or 'ERROR'.
    """
    print("-" * 30)
    print(f"Processing GIF: '{os.path.basename(input_path)}'")
    original_gif = None 
    try:
        original_gif = Image.open(input_path)

        # --- Step 1: Analyze frames ---
        # overall_bbox_from_analysis, frames_rgba_from_analysis, durations_from_analysis, 
        # loop_count_from_analysis, disposal_methods_from_analysis
        overall_bbox, frames_rgba, durations, loop_count, disposal_methods = analyze_gif_frames(original_gif)

        if overall_bbox is None:
            print("  Skipping: GIF is empty, fully transparent, or bounding box could not be determined.")
            return 'SKIPPED' 

        original_width, original_height = original_gif.size
        bbox_width = overall_bbox[2] - overall_bbox[0]
        bbox_height = overall_bbox[3] - overall_bbox[1]

        if overall_bbox == (0, 0, original_width, original_height):
             print("  Skipping: GIF content already fills the entire frame (no cropping needed).")
             return 'SKIPPED'
        
        if bbox_width <= 0 or bbox_height <= 0:
             print(f"  Error: Calculated bounding box has zero or negative dimensions {overall_bbox}. Cannot crop.")
             return 'ERROR'

        print(f"  Original dims: {original_width}x{original_height}")
        print(f"  Content BBox: {overall_bbox}")
        print(f"  Cropped dims: {bbox_width}x{bbox_height}")

        # --- Step 2: Crop frames and prepare their info ---
        cropped_pil_frames = []
        for i, frame_rgba_source in enumerate(frames_rgba):
            cropped_img = frame_rgba_source.crop(overall_bbox)
            
            # Set per-frame info directly onto the cropped Image object's .info dictionary
            cropped_img.info['duration'] = durations[i]
            cropped_img.info['disposal'] = disposal_methods[i]
            
            cropped_pil_frames.append(cropped_img)

        if not cropped_pil_frames:
            print("  Error: No frames were generated after cropping attempt.")
            return 'ERROR'

        # --- Step 3: Save the cropped animation ---
        print(f"  Saving {len(cropped_pil_frames)} cropped frames to '{os.path.basename(output_path)}'...")

        save_kwargs = {
            "save_all": True,
            "append_images": cropped_pil_frames[1:] if len(cropped_pil_frames) > 1 else [],
            "loop": loop_count,
            "optimize": False, # Consider True for smaller files, but slower & can affect quality
            # Duration and disposal are now set in each frame's .info,
            # so they are not passed as top-level list arguments here.
            # Pillow will pick them up from each frame's .info.
        }
        
        # Add known global GIF properties from original if they exist and are safe
        if 'version' in original_gif.info:
            save_kwargs['version'] = original_gif.info['version']
        # 'background' color index can be tricky if palette changes.
        # For RGBA frames, Pillow usually manages background/transparency well.
        # if 'background' in original_gif.info:
        #     save_kwargs['background'] = original_gif.info['background']
        if 'comment' in original_gif.info: # Preserve comments if any
             save_kwargs['comment'] = original_gif.info['comment']
        # Let Pillow handle 'transparency' based on the RGBA alpha of the frames.
        # Explicitly setting original_gif.info.get('transparency') can be problematic.

        if os.path.abspath(input_path) == os.path.abspath(output_path):
            print(f"  Critical Error: Input and output paths are identical for GIF ('{output_path}'). Aborting save to prevent data loss.")
            return 'ERROR'
        
        if os.path.exists(output_path):
            try:
                os.remove(output_path)
            except OSError as e:
                print(f"  Warning: Could not remove existing target file '{os.path.basename(output_path)}': {e}")
                return 'ERROR'

        try:
            # The first frame (cropped_pil_frames[0]) saves, and appends the rest.
            # Each frame in cropped_pil_frames now has its .info['duration'] and .info['disposal'] set.
            cropped_pil_frames[0].save(output_path, **save_kwargs)
            print("  Auto-cropped GIF saved successfully.")
            return 'CROPPED'
        except Exception as e:
             print(f"  Error during final GIF save operation: {e}")
             traceback.print_exc()
             return 'ERROR'

    except FileNotFoundError:
        print(f"Error: Input GIF file not found at '{input_path}'")
        return 'ERROR'
    except Exception as e:
        print(f"An unexpected error occurred processing GIF '{os.path.basename(input_path)}': {e}")
        traceback.print_exc()
        return 'ERROR'
    finally:
        if original_gif:
            try:
                original_gif.close()
            except Exception as close_e:
                print(f"Warning: Error closing original GIF file: {close_e}")


# --- Main Execution Logic ---
def main():
    """
    Main function to handle clipboard input, find GIF/PNG files,
    and process them using respective auto-crop functions.
    """
    print("--- AutoCropGIF/PNG Script ---") 
    if not check_pyperclip():
        print("Exiting: Pyperclip is required and not functional.")
        return

    try:
        clipboard_content = pyperclip.paste().strip()
    except (pyperclip.PyperclipException, Exception) as e:
        print(f"Error reading from clipboard: {e}")
        print("Exiting.")
        return

    if not clipboard_content:
        print("Clipboard is empty. Please copy a file or folder path.")
        return

    if clipboard_content.startswith(('"', "'")) and clipboard_content.endswith(('"', "'")):
        clipboard_content = clipboard_content[1:-1]

    if not os.path.exists(clipboard_content):
        print(f"Error: The path from the clipboard does not exist: '{clipboard_content}'")
        return

    files_to_process = []
    supported_extensions = ('.gif', '.png')

    if os.path.isfile(clipboard_content):
        if clipboard_content.lower().endswith(supported_extensions):
            base, _ = os.path.splitext(clipboard_content)
            if base.lower().endswith("_c"):
                print(f"Skipping single file '{os.path.basename(clipboard_content)}' as it appears to be already cropped.")
            else:
                print("Processing single file from clipboard.")
                files_to_process.append(clipboard_content)
        else:
            print(f"Error: The file '{os.path.basename(clipboard_content)}' is not a supported type (GIF or PNG).")
    elif os.path.isdir(clipboard_content):
        print(f"Scanning folder from clipboard: '{clipboard_content}'")
        found_files_in_dir = []
        try:
            for filename in os.listdir(clipboard_content):
                if filename.lower().endswith(supported_extensions):
                    base, _ = os.path.splitext(filename)
                    if base.lower().endswith("_c"):
                        continue 
                    full_path = os.path.join(clipboard_content, filename)
                    if os.path.isfile(full_path):
                         found_files_in_dir.append(full_path)
        except OSError as e:
            print(f"Error reading directory '{clipboard_content}': {e}")
            return

        if not found_files_in_dir:
            print(f"No suitable image files ({', '.join(e.upper() for e in supported_extensions)}) found in '{clipboard_content}' (or they already end with '_c').")
        else:
            print(f"Found {len(found_files_in_dir)} image file(s) to process.")
            files_to_process.extend(found_files_in_dir)
    else:
        print(f"Error: The path '{clipboard_content}' is neither a file nor a directory.")
        return

    if not files_to_process:
        print("\nNo new image files selected for processing.")
        return
    
    print(f"\nStarting processing for {len(files_to_process)} image file(s)...")
    
    processed_details = [] 

    for input_path in files_to_process:
        base, ext = os.path.splitext(input_path)
        output_path = f"{base}_c{ext}"

        file_ext_lower = ext.lower()
        status = 'ERROR_UNKNOWN' 

        try:
            if file_ext_lower == '.gif':
                status = auto_crop_animated_gif(input_path, output_path)
            elif file_ext_lower == '.png':
                status = auto_crop_png(input_path, output_path)
            else:
                status = 'ERROR_UNSUPPORTED_TYPE'
                print(f"  Skipping unsupported file type: {os.path.basename(input_path)}")
        except Exception as e: 
            print(f"!! Critical error during processing dispatch for {os.path.basename(input_path)}: {e}")
            traceback.print_exc()
            status = 'ERROR_DISPATCH_CRASH'
            
        actual_output_path = output_path if status == 'CROPPED' else ""
        processed_details.append({'input': input_path, 'output': actual_output_path, 'status': status})

    print("-" * 30)
    print("\nProcessing Summary:")
    
    status_counts = Counter(item['status'] for item in processed_details)

    cropped_count = status_counts['CROPPED']
    skipped_no_crop_needed_count = status_counts['SKIPPED']
    
    failed_count = 0
    error_items = []
    for item in processed_details:
        if item['status'] not in ['CROPPED', 'SKIPPED']:
            failed_count += 1
            error_items.append(item)

    print(f"  Successfully cropped: {cropped_count}")
    if cropped_count > 0:
        for item in processed_details:
            if item['status'] == 'CROPPED':
                print(f"      - Saved: {os.path.basename(item['output'])} (from {os.path.basename(item['input'])})")
    
    print(f"  Skipped (no crop needed/empty): {skipped_no_crop_needed_count}")
    
    print(f"  Failed or other non-success statuses: {failed_count}")
    if failed_count > 0:
        for item in error_items:
            print(f"      - File: {os.path.basename(item['input'])} (Status: {item['status']})")
    
    print("-" * 30)

# --- Guard for Direct Execution ---
if __name__ == "__main__":
    main()

########## START OF FILE: camera.py ##########

# -*- coding: utf-8 -*-
"""
camera.py
Defines the Camera class for managing the game's viewport.
"""
# version 1.0.0.6 (All logging removed from this module)
import pygame

# --- No logging imports or camera-specific log switches needed ---

class Camera:
    def __init__(self, level_width: int, level_top_y_abs: int, level_bottom_y_abs: int,
                 screen_width: int, screen_height: int):
        """
        Initializes the camera.

        Args:
            level_width (int): The total width of the game level.
            level_top_y_abs (int): The absolute Y coordinate of the top of the level.
            level_bottom_y_abs (int): The absolute Y coordinate of the bottom of the level.
            screen_width (int): The width of the game screen/window.
            screen_height (int): The height of the game screen/window.
        """
        self.camera_rect = pygame.Rect(0, 0, screen_width, screen_height)
        self.level_width = level_width
        self.level_top_y_abs = level_top_y_abs
        self.level_bottom_y_abs = level_bottom_y_abs
        self.screen_width = screen_width
        self.screen_height = screen_height
        self.effective_level_height = self.level_bottom_y_abs - self.level_top_y_abs

        # No logging call here

    def apply(self, target):
        """
        Applies the camera offset to a target sprite or rect.

        Args:
            target (pygame.sprite.Sprite or pygame.Rect): The sprite or rect to offset.

        Returns:
            pygame.Rect: A new Rect representing the target's position on the screen.
        """
        if isinstance(target, pygame.sprite.Sprite):
            return target.rect.move(self.camera_rect.topleft)
        elif isinstance(target, pygame.Rect):
            return target.move(self.camera_rect.topleft)
        else:
            # This is a genuine error condition, so raise an exception
            raise TypeError("Camera.apply() target must be a Sprite or Rect.")

    def update(self, target_sprite):
        """
        Updates the camera's position to follow the target_sprite.

        Args:
            target_sprite (pygame.sprite.Sprite): The sprite the camera should follow.
        """
        if not target_sprite or not hasattr(target_sprite, 'rect'):
            self.static_update()
            return

        x = -target_sprite.rect.centerx + int(self.screen_width / 2)
        y = -target_sprite.rect.centery + int(self.screen_height / 2)

        x = min(0, x)
        if self.level_width > self.screen_width:
            x = max(-(self.level_width - self.screen_width), x)
        else:
            x = 0

        if self.effective_level_height <= self.screen_height:
            y = -(self.level_top_y_abs + self.effective_level_height / 2 - self.screen_height / 2)
        else:
            y = min(-self.level_top_y_abs, y)
            y = max(-(self.level_bottom_y_abs - self.screen_height), y)

        self.camera_rect.x = int(x)
        self.camera_rect.y = int(y)

        # No logging call here

    def static_update(self):
        """
        Called when there's no target to follow or if static camera behavior is desired.
        """
        pass # No action, no logging

    def get_pos(self):
        """ Returns the camera's current topleft offset. """
        return (self.camera_rect.x, self.camera_rect.y)

    def set_pos(self, x, y):
        """ Manually sets the camera's topleft offset. """
        self.camera_rect.x = int(x)
        self.camera_rect.y = int(y)
        # No logging call here

    def set_level_dimensions(self, level_width: int, level_top_y_abs: int, level_bottom_y_abs: int):
        """
        Updates the camera's knowledge of the level dimensions.
        """
        self.level_width = level_width
        self.level_top_y_abs = level_top_y_abs
        self.level_bottom_y_abs = level_bottom_y_abs
        self.effective_level_height = self.level_bottom_y_abs - self.level_top_y_abs
        # No logging call here

    def set_screen_dimensions(self, screen_width: int, screen_height: int):
        """
        Updates the camera's knowledge of the screen dimensions.
        """
        self.screen_width = screen_width
        self.screen_height = screen_height
        self.camera_rect.width = screen_width
        self.camera_rect.height = screen_height
        # No logging call here

########## START OF FILE: client_logic.py ##########

# client_logic.py
# -*- coding: utf-8 -*-
"""
version 1.0.0.2 (Integrated global logger)
Handles client-side game logic, connection to server, and LAN discovery.
"""
import pygame
import socket
import time
import traceback
import os # For os.path and os.makedirs
import importlib # For importlib.invalidate_caches()
from typing import Optional # Added import for Optional

# --- Import Logger ---
try:
    from logger import info, debug, warning, error, critical
except ImportError:
    print("CRITICAL CLIENT_LOGIC: logger.py not found. Falling back to print statements for logging.")
    def info(msg): print(f"INFO: {msg}")
    def debug(msg): print(f"DEBUG: {msg}")
    def warning(msg): print(f"WARNING: {msg}")
    def error(msg): print(f"ERROR: {msg}")
    def critical(msg): print(f"CRITICAL: {msg}")
# --- End Logger ---

import constants as C
from network_comms import get_local_ip, encode_data, decode_data_stream
from game_state_manager import set_network_game_state
from enemy import Enemy # For print_limiter access if needed, or for type hinting
from game_ui import draw_platformer_scene_on_surface, draw_download_dialog # For drawing client's view
from game_setup import initialize_game_elements # To re-init after map download

class ClientState:
    """
    A simple class to hold client-specific state used by the client's
    main loop and helper functions.
    """
    def __init__(self):
        self.client_tcp_socket = None        # TCP socket for communication with the server
        self.server_state_buffer = b""       # Buffer for accumulating data from the server
        self.last_received_server_state = None # Stores the most recent complete game state from server
        self.app_running = True              # Global flag: True if the application is running (controlled by main.py)

        # Configuration for LAN discovery (can be loaded from constants.py)
        self.service_name = getattr(C, "SERVICE_NAME", "platformer_adventure_lan_v1")
        self.discovery_port_udp = getattr(C, "DISCOVERY_PORT_UDP", 5556)
        self.client_search_timeout_s = getattr(C, "CLIENT_SEARCH_TIMEOUT_S", 5.0)
        self.buffer_size = getattr(C, "BUFFER_SIZE", 8192)

        # Map download state
        self.server_selected_map_name: Optional[str] = None
        self.map_download_status: str = "unknown" # "unknown", "checking", "missing", "downloading", "present", "error"
        self.map_download_progress: float = 0.0 # 0.0 to 100.0
        self.map_total_size_bytes: int = 0
        self.map_received_bytes: int = 0
        self.map_file_buffer: bytes = b""


def find_server_on_lan(screen: pygame.Surface, fonts: dict,
                       clock_obj: pygame.time.Clock, client_state_obj: ClientState): # Changed clock to clock_obj
    """
    Searches for a game server on the LAN by listening for UDP broadcasts.
    Displays a "Searching..." message on the screen.
    Returns (found_server_ip, found_server_port) or (None, None) if not found or cancelled.
    """
    debug("Client (find_server_on_lan): Starting LAN server search.")
    pygame.display.set_caption("Platformer - Searching for Server on LAN...")
    current_width, current_height = screen.get_size()
    search_text_surf = fonts.get("large", pygame.font.Font(None, 30)).render( # Fallback font
        "Searching for server on LAN...", True, C.WHITE
    )

    listen_socket, found_server_ip, found_server_port = None, None, None

    try:
        # Create and configure the UDP socket for listening to broadcasts
        listen_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
        listen_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        # Bind to all available interfaces on the specified discovery port
        listen_socket.bind(('', client_state_obj.discovery_port_udp))
        listen_socket.settimeout(0.5) # Non-blocking recvfrom
        debug(f"Client (find_server_on_lan): UDP listen socket bound to port {client_state_obj.discovery_port_udp}.")
    except socket.error as e_socket:
        error(f"Client Error: Failed to bind UDP listen socket on port {client_state_obj.discovery_port_udp}: {e_socket}")
        screen.fill(C.BLACK)
        err_msg = f"Error: Cannot listen on UDP port {client_state_obj.discovery_port_udp}."
        if fonts.get("small"):
            err_surf = fonts["small"].render(err_msg, True, C.RED)
            screen.blit(err_surf, err_surf.get_rect(center=(current_width//2, current_height // 2)))
        pygame.display.flip(); time.sleep(4)
        return None, None

    start_search_time = time.time()
    client_local_ip = get_local_ip()
    debug(f"Client (find_server_on_lan): Searching for LAN servers (Service: '{client_state_obj.service_name}'). My IP: {client_local_ip}. Timeout: {client_state_obj.client_search_timeout_s}s.")

    # Loop for the duration of the search timeout or until app quits/server found
    while time.time() - start_search_time < client_state_obj.client_search_timeout_s and \
          client_state_obj.app_running and not found_server_ip:

        # Handle Pygame events (Quit, Resize, Escape to cancel search)
        for event in pygame.event.get():
             if event.type == pygame.QUIT: client_state_obj.app_running = False; break
             if event.type == pygame.VIDEORESIZE:
                if not screen.get_flags() & pygame.FULLSCREEN:
                    current_width,current_height=max(320,event.w),max(240,event.h)
                    screen=pygame.display.set_mode((current_width,current_height), pygame.RESIZABLE|pygame.DOUBLEBUF)
                    search_text_surf = fonts.get("large", pygame.font.Font(None,30)).render(
                        "Searching for server on LAN...", True, C.WHITE) # Re-render if size changes
             if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
                 debug("Client (find_server_on_lan): LAN server search cancelled by user.")
                 if listen_socket: listen_socket.close()
                 return None, None # Exit search and return to menu
        if not client_state_obj.app_running: break

        # Update "Searching..." display
        screen.fill(C.BLACK)
        screen.blit(search_text_surf, search_text_surf.get_rect(center=(current_width//2, current_height//2)))
        pygame.display.flip()
        clock_obj.tick(10) # Low FPS during search # Used clock_obj here

        raw_udp_data, decoded_udp_message = None, None
        try:
            raw_udp_data, sender_address = listen_socket.recvfrom(client_state_obj.buffer_size)
            # debug(f"Client (find_server_on_lan): Received UDP data from {sender_address}: {raw_udp_data[:60]}...") # DEBUG - noisy
            decoded_messages_list, _ = decode_data_stream(raw_udp_data)
            if not decoded_messages_list: continue

            decoded_udp_message = decoded_messages_list[0]
            # debug(f"Client (find_server_on_lan): Decoded UDP message: {decoded_udp_message}")
            if (isinstance(decoded_udp_message, dict) and
                decoded_udp_message.get("service") == client_state_obj.service_name and
                isinstance(decoded_udp_message.get("tcp_ip"), str) and
                isinstance(decoded_udp_message.get("tcp_port"), int)):

                server_ip = decoded_udp_message["tcp_ip"]
                server_port = decoded_udp_message["tcp_port"]
                info(f"Client (find_server_on_lan): Found server '{client_state_obj.service_name}' at {server_ip}:{server_port}")
                found_server_ip, found_server_port = server_ip, server_port
        except socket.timeout:
            continue
        except Exception as e_udp:
            error(f"Client: Error processing received UDP broadcast: {e_udp}", exc_info=True)

    if listen_socket: listen_socket.close()

    if not found_server_ip and client_state_obj.app_running:
        info(f"Client (find_server_on_lan): No server found for '{client_state_obj.service_name}' after timeout.")
        screen.fill(C.BLACK)
        if fonts.get("large"):
            fail_surf = fonts["large"].render("Server Not Found!", True, C.RED)
            screen.blit(fail_surf, fail_surf.get_rect(center=(current_width//2, current_height//2)))
        pygame.display.flip(); time.sleep(3)
    elif not client_state_obj.app_running:
        info("Client (find_server_on_lan): LAN server search aborted because application is quitting.")

    return found_server_ip, found_server_port


def run_client_mode(screen: pygame.Surface, clock: pygame.time.Clock,
                    fonts: dict, game_elements_ref: dict,
                    client_state_obj: ClientState, target_ip_port_str: Optional[str] = None):
    """
    Main function to run the game in client mode.
    Connects to a server (either specified or found via LAN) and synchronizes game state.
    """
    info("Client (run_client_mode): Entering client mode.")
    client_state_obj.app_running = True
    current_width, current_height = screen.get_size()

    server_ip_to_connect, server_port_to_connect = None, C.SERVER_PORT_TCP

    if target_ip_port_str:
        info(f"Client (run_client_mode): Direct IP specified: {target_ip_port_str}")
        ip_parts = target_ip_port_str.rsplit(':', 1)
        server_ip_to_connect = ip_parts[0]
        if len(ip_parts) > 1:
            try: server_port_to_connect = int(ip_parts[1])
            except ValueError:
                warning(f"Client Warning: Invalid port in '{target_ip_port_str}'. Using default {C.SERVER_PORT_TCP}.")
    else:
        info("Client (run_client_mode): No direct IP, attempting LAN discovery.")
        server_ip_to_connect, found_server_port = find_server_on_lan(screen, fonts, clock, client_state_obj)
        if found_server_port: server_port_to_connect = found_server_port

    if not server_ip_to_connect:
        info("Client (run_client_mode): Exiting client mode (no server target).")
        return
    if not client_state_obj.app_running:
        info("Client (run_client_mode): Exiting client mode (application closed).")
        return

    if client_state_obj.client_tcp_socket:
        try: client_state_obj.client_tcp_socket.close()
        except: pass
    client_state_obj.client_tcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

    connection_succeeded, connection_error_msg = False, "Unknown Connection Error"
    try:
        info(f"Client (run_client_mode): Attempting to connect to server at {server_ip_to_connect}:{server_port_to_connect}...")
        pygame.display.set_caption(f"Platformer - Connecting to {server_ip_to_connect}...")
        draw_download_dialog(screen, fonts, "Connecting to server...", f"{server_ip_to_connect}:{server_port_to_connect}", 0)


        client_state_obj.client_tcp_socket.settimeout(10.0)
        client_state_obj.client_tcp_socket.connect((server_ip_to_connect, server_port_to_connect))
        client_state_obj.client_tcp_socket.settimeout(0.05) # Short timeout for non-blocking recv
        info("Client (run_client_mode): TCP Connection to server successful!")
        connection_succeeded = True
    except socket.timeout: connection_error_msg = "Connection Timed Out"
    except socket.error as e_sock: connection_error_msg = f"Connection Error ({e_sock.strerror if hasattr(e_sock, 'strerror') else e_sock})"
    except Exception as e_conn: connection_error_msg = f"Unexpected Connection Error: {e_conn}"

    if not connection_succeeded:
        error(f"Client (run_client_mode): Failed to connect to server: {connection_error_msg}")
        draw_download_dialog(screen, fonts, "Connection Failed", connection_error_msg, -1) # -1 for error indication
        time.sleep(3)
        if client_state_obj.client_tcp_socket: client_state_obj.client_tcp_socket.close()
        client_state_obj.client_tcp_socket = None
        return

    # --- Map Synchronization Phase ---
    client_state_obj.map_download_status = "waiting_map_info"
    client_state_obj.server_state_buffer = b"" # Clear buffer for fresh messages

    map_sync_phase_active = True
    while map_sync_phase_active and client_state_obj.app_running:
        current_width, current_height = screen.get_size() # Handle resize during this phase
        for event in pygame.event.get():
            if event.type == pygame.QUIT: client_state_obj.app_running = False; map_sync_phase_active = False; break
            if event.type == pygame.VIDEORESIZE:
                if not screen.get_flags() & pygame.FULLSCREEN:
                    current_width, current_height = max(320,event.w), max(240,event.h)
                    screen = pygame.display.set_mode((current_width,current_height), pygame.RESIZABLE|pygame.DOUBLEBUF)
            if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
                 client_state_obj.app_running = False; map_sync_phase_active = False; break
        if not client_state_obj.app_running: break

        dialog_title = "Synchronizing"
        dialog_message = "Waiting for map information from server..."
        dialog_progress = -1 # Indicates waiting, not progress value

        if client_state_obj.map_download_status == "checking":
            dialog_message = f"Checking for map: {client_state_obj.server_selected_map_name}..."
        elif client_state_obj.map_download_status == "missing":
            dialog_message = f"Map '{client_state_obj.server_selected_map_name}' missing. Requesting download..."
        elif client_state_obj.map_download_status == "downloading":
            dialog_title = f"Downloading Map: {client_state_obj.server_selected_map_name}"
            dialog_message = f"Received {client_state_obj.map_received_bytes / 1024:.1f} / {client_state_obj.map_total_size_bytes / 1024:.1f} KB"
            dialog_progress = client_state_obj.map_download_progress
        elif client_state_obj.map_download_status == "error":
            dialog_title = "Map Download Error"
            dialog_message = f"Failed to download map: {client_state_obj.server_selected_map_name}"
            dialog_progress = -1 # Error indication

        draw_download_dialog(screen, fonts, dialog_title, dialog_message, dialog_progress)

        try:
            server_data_chunk = client_state_obj.client_tcp_socket.recv(client_state_obj.buffer_size)
            if not server_data_chunk:
                info("Client: Server disconnected during map sync."); map_sync_phase_active = False; break
            client_state_obj.server_state_buffer += server_data_chunk

            decoded_messages, client_state_obj.server_state_buffer = decode_data_stream(client_state_obj.server_state_buffer)

            for msg in decoded_messages:
                command = msg.get("command")
                if command == "set_map":
                    client_state_obj.server_selected_map_name = msg.get("name")
                    info(f"Client: Received map name from server: {client_state_obj.server_selected_map_name}")
                    client_state_obj.map_download_status = "checking"

                    map_file_path = os.path.join(C.MAPS_DIR, client_state_obj.server_selected_map_name + ".py")
                    if os.path.exists(map_file_path):
                        info(f"Client: Map '{client_state_obj.server_selected_map_name}' found locally.")
                        client_state_obj.map_download_status = "present"
                        client_state_obj.client_tcp_socket.sendall(encode_data({"command": "report_map_status", "name": client_state_obj.server_selected_map_name, "status": "present"}))
                        map_sync_phase_active = False # Ready to start game
                    else:
                        info(f"Client: Map '{client_state_obj.server_selected_map_name}' MISSING. Requesting file.")
                        client_state_obj.map_download_status = "missing" # UI will show this briefly
                        client_state_obj.client_tcp_socket.sendall(encode_data({"command": "report_map_status", "name": client_state_obj.server_selected_map_name, "status": "missing"}))
                        client_state_obj.client_tcp_socket.sendall(encode_data({"command": "request_map_file", "name": client_state_obj.server_selected_map_name}))
                        client_state_obj.map_download_status = "downloading" # Switch to downloading state
                        client_state_obj.map_received_bytes = 0
                        client_state_obj.map_total_size_bytes = 0
                        client_state_obj.map_file_buffer = b""

                elif command == "map_file_info" and client_state_obj.map_download_status == "downloading":
                    client_state_obj.map_total_size_bytes = msg.get("size", 0)
                    debug(f"Client: Expecting map file of size {client_state_obj.map_total_size_bytes} bytes.")

                elif command == "map_data_chunk" and client_state_obj.map_download_status == "downloading":
                    chunk_data_str = msg.get("data", "")
                    chunk_data_bytes = chunk_data_str.encode('utf-8') # Server sends as string, client decodes to bytes
                    client_state_obj.map_file_buffer += chunk_data_bytes
                    client_state_obj.map_received_bytes = len(client_state_obj.map_file_buffer)
                    if client_state_obj.map_total_size_bytes > 0:
                        client_state_obj.map_download_progress = (client_state_obj.map_received_bytes / client_state_obj.map_total_size_bytes) * 100
                    client_state_obj.client_tcp_socket.sendall(encode_data({"command": "report_download_progress", "progress": client_state_obj.map_download_progress}))

                elif command == "map_transfer_end" and client_state_obj.map_download_status == "downloading":
                    if client_state_obj.map_received_bytes == client_state_obj.map_total_size_bytes:
                        map_file_to_save = os.path.join(C.MAPS_DIR, client_state_obj.server_selected_map_name + ".py")
                        try:
                            # Ensure maps directory exists
                            if not os.path.exists(C.MAPS_DIR): os.makedirs(C.MAPS_DIR)
                            with open(map_file_to_save, "wb") as f: # write bytes
                                f.write(client_state_obj.map_file_buffer)
                            info(f"Client: Map '{client_state_obj.server_selected_map_name}' downloaded and saved to '{map_file_to_save}'.")
                            client_state_obj.map_download_status = "present"
                            importlib.invalidate_caches() # Important for re-importing
                            client_state_obj.client_tcp_socket.sendall(encode_data({"command": "report_map_status", "name": client_state_obj.server_selected_map_name, "status": "present"})) # Inform server map is now present
                            map_sync_phase_active = False # Ready to start game
                        except Exception as e_save:
                            error(f"Client Error: Failed to save downloaded map '{map_file_to_save}': {e_save}")
                            client_state_obj.map_download_status = "error"
                            # Optionally send error status to server
                    else:
                        error(f"Client Error: Map download size mismatch. Expected {client_state_obj.map_total_size_bytes}, got {client_state_obj.map_received_bytes}.")
                        client_state_obj.map_download_status = "error"

                elif command == "start_game_now": # Server signals game can start
                    if client_state_obj.map_download_status == "present":
                        info(f"Client: Received start_game_now. Map is present. Proceeding.")
                        map_sync_phase_active = False
                    else:
                        info(f"Client: Received start_game_now, but map status is '{client_state_obj.map_download_status}'. Waiting.")


        except socket.timeout: pass # No data received, continue loop
        except socket.error as e_sock_map:
            error(f"Client: Socket error during map sync: {e_sock_map}. Server might have disconnected.")
            map_sync_phase_active = False; break
        except Exception as e_map_sync:
            error(f"Client: Error processing data during map sync: {e_map_sync}", exc_info=True)
            map_sync_phase_active = False; break

        clock.tick(C.FPS) # Keep UI responsive

    if not client_state_obj.app_running or client_state_obj.map_download_status != "present":
        info(f"Client: Exiting client mode (app closed or map not ready: {client_state_obj.map_download_status}).")
        if client_state_obj.client_tcp_socket: client_state_obj.client_tcp_socket.close(); client_state_obj.client_tcp_socket = None
        return

    # --- Re-initialize game elements with the correct map ---
    info(f"Client: Map '{client_state_obj.server_selected_map_name}' is present. Initializing game elements...")
    current_screen_width, current_screen_height = screen.get_size()
    updated_game_elements = initialize_game_elements(
        current_screen_width, current_screen_height,
        for_game_mode="join_ip", # Or "join_lan", doesn't matter much here for element creation
        existing_sprites_groups=game_elements_ref, # Pass existing groups to preserve instances
        map_module_name=client_state_obj.server_selected_map_name
    )
    if updated_game_elements is None:
        critical(f"Client CRITICAL: Failed to initialize game elements with map '{client_state_obj.server_selected_map_name}'.")
        # Show error on screen
        draw_download_dialog(screen, fonts, "Error", f"Failed to load map: {client_state_obj.server_selected_map_name}", -1)
        time.sleep(3)
        if client_state_obj.client_tcp_socket: client_state_obj.client_tcp_socket.close(); client_state_obj.client_tcp_socket = None
        return

    game_elements_ref.update(updated_game_elements)
    # Ensure camera is updated if it was re-created
    if game_elements_ref.get("camera"):
        cam_instance = game_elements_ref["camera"]
        if hasattr(cam_instance, "set_screen_dimensions"):
            cam_instance.set_screen_dimensions(current_screen_width, current_screen_height)

    # --- Main Game Loop (starts after map sync) ---
    pygame.display.set_caption("Platformer - CLIENT (You are P2: WASD+VB | Self-Harm: H | Heal: G | Reset: Enter)")

    p2_controlled_by_client = game_elements_ref.get("player2")
    p1_remote_on_client = game_elements_ref.get("player1")
    debug(f"Client (run_client_mode): P1 (remote) instance: {p1_remote_on_client}, P2 (local) instance: {p2_controlled_by_client}")
    if p1_remote_on_client: debug(f"Client: P1 Valid: {p1_remote_on_client._valid_init}, P1 Pos: {p1_remote_on_client.pos if hasattr(p1_remote_on_client, 'pos') else 'N/A'}")
    if p2_controlled_by_client: debug(f"Client: P2 Valid: {p2_controlled_by_client._valid_init}, P2 Pos: {p2_controlled_by_client.pos if hasattr(p2_controlled_by_client, 'pos') else 'N/A'}")


    p2_client_key_map = {
        'left': pygame.K_a, 'right': pygame.K_d, 'up': pygame.K_w, 'down': pygame.K_s,
        'attack1': pygame.K_v, 'attack2': pygame.K_b, 'dash': pygame.K_LSHIFT,
        'roll': pygame.K_LCTRL, 'interact': pygame.K_e,
    }

    client_game_active = True
    client_state_obj.server_state_buffer = b""
    client_state_obj.last_received_server_state = None

    while client_game_active and client_state_obj.app_running:
        dt_sec = clock.tick(C.FPS) / 1000.0
        now_ticks_client = pygame.time.get_ticks()

        client_initiated_actions = {'action_reset': False, 'action_self_harm': False, 'action_heal': False}
        server_indicated_game_over = False
        if client_state_obj.last_received_server_state and \
           'game_over' in client_state_obj.last_received_server_state:
            server_indicated_game_over = client_state_obj.last_received_server_state['game_over']

        pygame_events_client = pygame.event.get()
        keys_pressed_client = pygame.key.get_pressed()
        for event in pygame_events_client:
            if event.type == pygame.QUIT: client_game_active = False; client_state_obj.app_running = False; break
            if event.type == pygame.VIDEORESIZE:
                if not screen.get_flags() & pygame.FULLSCREEN:
                    current_width,current_height=max(320,event.w),max(240,event.h)
                    screen=pygame.display.set_mode((current_width,current_height), pygame.RESIZABLE|pygame.DOUBLEBUF)
                    if game_elements_ref.get("camera"):
                        game_elements_ref["camera"].screen_width = current_width
                        game_elements_ref["camera"].screen_height = current_height
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE: client_game_active = False
                if event.key == pygame.K_RETURN and server_indicated_game_over :
                    client_initiated_actions['action_reset'] = True
                if event.key == pygame.K_h: client_initiated_actions['action_self_harm'] = True
                if event.key == pygame.K_g: client_initiated_actions['action_heal'] = True

        if not client_state_obj.app_running or not client_game_active: break

        p2_input_state_for_server = {}
        if p2_controlled_by_client and hasattr(p2_controlled_by_client, 'get_input_state_for_network'):
             p2_input_state_for_server = p2_controlled_by_client.get_input_state_for_network(
                 keys_pressed_client, pygame_events_client, p2_client_key_map
             )
        p2_input_state_for_server.update(client_initiated_actions)

        if client_state_obj.client_tcp_socket:
            client_input_payload = {"input": p2_input_state_for_server}
            encoded_client_payload = encode_data(client_input_payload)
            if encoded_client_payload:
                try:
                    # debug(f"Client: Sending input to server: {client_input_payload}") # Noisy
                    client_state_obj.client_tcp_socket.sendall(encoded_client_payload)
                except socket.error as e_send:
                    error(f"Client: Send to server failed: {e_send}. Server might have disconnected.")
                    client_game_active = False; break

        if client_state_obj.client_tcp_socket:
            try:
                server_data_chunk = client_state_obj.client_tcp_socket.recv(client_state_obj.buffer_size * 2)
                if not server_data_chunk:
                    info("Client: Server disconnected (received empty data from recv).")
                    client_game_active = False; break

                # debug(f"Client: Received chunk from server: {server_data_chunk[:100]}...") # Noisy
                client_state_obj.server_state_buffer += server_data_chunk
                decoded_server_states, client_state_obj.server_state_buffer = \
                    decode_data_stream(client_state_obj.server_state_buffer)

                if decoded_server_states:
                    client_state_obj.last_received_server_state = decoded_server_states[-1]
                    # debug(f"Client: Received new game state. P1 pos: {client_state_obj.last_received_server_state.get('p1', {}).get('pos')}, P2 pos: {client_state_obj.last_received_server_state.get('p2', {}).get('pos')}")
                    set_network_game_state(client_state_obj.last_received_server_state, game_elements_ref, client_player_id=2)
                    # p1_after_update = game_elements_ref.get("player1")
                    # p2_after_update = game_elements_ref.get("player2")
                    # if p1_after_update: debug(f"Client: P1 after state update. Pos: {p1_after_update.pos if hasattr(p1_after_update, 'pos') else 'N/A'}, Valid: {p1_after_update._valid_init}, Alive: {p1_after_update.alive() if hasattr(p1_after_update, 'alive') else 'N/A'}")
                    # if p2_after_update: debug(f"Client: P2 after state update. Pos: {p2_after_update.pos if hasattr(p2_after_update, 'pos') else 'N/A'}, Valid: {p2_after_update._valid_init}, Alive: {p2_after_update.alive() if hasattr(p2_after_update, 'alive') else 'N/A'}")


            except socket.timeout: pass
            except socket.error as e_recv:
                error(f"Client: Recv error from server: {e_recv}. Server might have disconnected.")
                client_game_active = False; break
            except Exception as e_process_server:
                error(f"Client: Error processing data from server: {e_process_server}", exc_info=True)
                client_game_active = False; break

        if p1_remote_on_client and p1_remote_on_client.alive() and p1_remote_on_client._valid_init and \
           hasattr(p1_remote_on_client, 'animate'):
            p1_remote_on_client.animate()

        if p2_controlled_by_client and p2_controlled_by_client.alive() and \
           p2_controlled_by_client._valid_init and hasattr(p2_controlled_by_client, 'animate'):
            p2_controlled_by_client.animate()

        for enemy_client in game_elements_ref.get("enemy_list", []):
            if enemy_client.alive() and enemy_client._valid_init and hasattr(enemy_client, 'animate'):
                enemy_client.animate()
            if enemy_client.is_dead and hasattr(enemy_client, 'death_animation_finished') and \
               enemy_client.death_animation_finished and enemy_client.alive():
                # Use global logger; Enemy.print_limiter will be handled when enemy.py is updated
                debug(f"Client: Visually removing enemy {enemy_client.enemy_id} as death anim finished.")
                enemy_client.kill()

        for proj_client in game_elements_ref.get("projectile_sprites", pygame.sprite.Group()):
            if proj_client.alive() and hasattr(proj_client, 'animate'):
                proj_client.animate()

        game_elements_ref.get("collectible_sprites", pygame.sprite.Group()).update(dt_sec)

        client_camera = game_elements_ref.get("camera")
        if client_camera:
            camera_focus_target_client = None
            if p2_controlled_by_client and p2_controlled_by_client.alive() and \
               p2_controlled_by_client._valid_init and not p2_controlled_by_client.is_dead :
                camera_focus_target_client = p2_controlled_by_client
            elif p1_remote_on_client and p1_remote_on_client.alive() and \
                 p1_remote_on_client._valid_init and not p1_remote_on_client.is_dead:
                camera_focus_target_client = p1_remote_on_client

            if camera_focus_target_client: client_camera.update(camera_focus_target_client)
            else: client_camera.static_update()

        try:
            draw_platformer_scene_on_surface(screen, game_elements_ref, fonts, now_ticks_client)
        except Exception as e_draw:
            error(f"Client draw error: {e_draw}", exc_info=True)
            client_game_active=False; break
        pygame.display.flip()

    info("Client: Exiting active game loop.")
    if client_state_obj.client_tcp_socket:
        info("Client: Closing TCP socket to server.")
        try: client_state_obj.client_tcp_socket.shutdown(socket.SHUT_RDWR)
        except: pass
        try: client_state_obj.client_tcp_socket.close()
        except: pass
        client_state_obj.client_tcp_socket = None
    info("Client: Client mode finished and returned to caller.")

########## START OF FILE: constants.py ##########

# constants.py
# -*- coding: utf-8 -*-
"""
Stores constant values used throughout the game.
"""
# version 1.0.0.3 (Added collision-specific constants)

# --- Gameplay / Physics ---
FPS = 60
PLAYER_ACCEL = 0.5
PLAYER_FRICTION = -0.15  # Negative value!
PLAYER_GRAVITY = 0.7
PLAYER_JUMP_STRENGTH = -15
PLAYER_RUN_SPEED_LIMIT = 7
PLAYER_DASH_SPEED = 15
PLAYER_ROLL_SPEED = 9
PLAYER_WALL_SLIDE_SPEED = 2
PLAYER_WALL_CLIMB_SPEED = -4    # Negative for upward movement
PLAYER_LADDER_CLIMB_SPEED = 3
PLAYER_MAX_HEALTH = 100
CHARACTER_BOUNCE_VELOCITY = 2.5 # Pixels per frame push back on character-character collision
PLAYER_STOMP_BOUNCE_STRENGTH = -8.0 # Upwards velocity after stomping an enemy
PLAYER_STOMP_LAND_ON_ENEMY_GRACE_PX = 8 # Pixel grace for landing on enemy's head for stomp
TERMINAL_VELOCITY_Y = 18 # Maximum downward speed

# Collision Specifics
MIN_WALL_OVERLAP_PX = 5                # Minimum vertical overlap to consider a side collision a "wall touch"
MIN_PLATFORM_OVERLAP_RATIO_FOR_LANDING = 0.15 # Player width ratio for landing on platform
MIN_PLATFORM_OVERLAP_RATIO_FOR_CEILING = 0.15 # Player width ratio for hitting ceiling
LANDING_FRICTION_MULTIPLIER = 0.8      # Multiplier for X-velocity on landing (e.g., 0.8 = 20% reduction)
GROUND_SNAP_THRESHOLD = 5.0            # Used in older collision logic, might be useful for some scenarios
CEILING_SNAP_THRESHOLD = 2.0           # Used in older collision logic
MIN_SIGNIFICANT_FALL_VEL = 1.5       # Minimum Y velocity to be considered "falling significantly"

# --- Animation ---
ANIM_FRAME_DURATION = 80 # ms per frame for most animations

# Player Attack Specifics
PLAYER_ATTACK1_DAMAGE = 10
PLAYER_ATTACK2_DAMAGE = 5
PLAYER_COMBO_ATTACK_DAMAGE = 20
PLAYER_CROUCH_ATTACK_DAMAGE = 5
PLAYER_ATTACK2_FRAME_DURATION_MULTIPLIER = 1.5 # If attack2 animation is slower/faster

CHARACTER_ATTACK_STATE_DURATION = 480 # ms, general duration for an attack state if not animation-driven

# --- Projectile Constants ---
FIREBALL_DAMAGE = 50
FIREBALL_SPEED = 9
FIREBALL_COOLDOWN = 750 # ms
FIREBALL_LIFESPAN = 2500 # ms
FIREBALL_SPRITE_PATH = "characters/weapons/fire.gif"
FIREBALL_DIMENSIONS = (61, 58) # width, height

# --- Enemy Constants ---
ENEMY_MAX_HEALTH = 80
ENEMY_RUN_SPEED_LIMIT = 5
ENEMY_ACCEL = 0.4
ENEMY_FRICTION = -0.12
ENEMY_DETECTION_RANGE = 250 # Increased for better AI reaction
ENEMY_ATTACK_RANGE = 70   # Slightly increased
ENEMY_ATTACK_DAMAGE = 10
ENEMY_ATTACK_COOLDOWN = 1500 # ms
ENEMY_PATROL_DIST = 150
ENEMY_HIT_STUN_DURATION = 300 # ms
ENEMY_HIT_COOLDOWN = 500 # ms (invulnerability after being hit)
ENEMY_HIT_BOUNCE_Y = PLAYER_JUMP_STRENGTH * 0.3 # Upward bounce when enemy is hit

# --- Colors ---
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
RED = (255, 0, 0)
DARK_RED = (139, 0, 0)
GREEN = (0, 255, 0)
DARK_GREEN = (0, 100, 0)
BLUE = (0, 0, 255)
LIGHT_BLUE = (173, 216, 230)
YELLOW = (255, 255, 0)
GRAY = (128, 128, 128)
DARK_GRAY = (50, 50, 50)
LIGHT_GRAY = (200, 200, 200)
ORANGE_RED = (255, 69, 0)
MAGENTA = (255, 0, 255)
PURPLE_BACKGROUND = (75, 0, 130) # Default map background if not specified

# --- UI ---
HEALTH_BAR_WIDTH = 50
HEALTH_BAR_HEIGHT = 8
HEALTH_BAR_OFFSET_ABOVE = 5 # Pixels above character's head

# --- Map ---
TILE_SIZE = 40
LAVA_PATCH_HEIGHT = 20 # Default height for lava tiles if not specified by map
LAVA_DAMAGE = 25       # Damage per hit from lava (can be time-based via hit cooldown)
MAPS_DIR = "maps"

# --- Network Constants ---
SERVER_IP_BIND = '0.0.0.0'
SERVER_PORT_TCP = 5555
SERVICE_NAME = "platformer_adventure_lan_v1"
DISCOVERY_PORT_UDP = 5556
BUFFER_SIZE = 8192
BROADCAST_INTERVAL_S = 1.0
CLIENT_SEARCH_TIMEOUT_S = 5.0
MAP_DOWNLOAD_CHUNK_SIZE = 4096

# --- Other ---
PLAYER_SELF_DAMAGE = 10 # For debug purposes

########## START OF FILE: couch_play_logic.py ##########

# couch_play_logic.py
# -*- coding: utf-8 -*-
"""
version 1.0.0.4 (Fixed AttributeError for Enemy.print_limiter)
Handles the game logic for the local couch co-op (two players on one machine) mode.
"""
import pygame
import traceback # For detailed error logging if needed

# --- Import Logger ---
try:
    from logger import info, debug, warning, error, critical
except ImportError:
    print("CRITICAL COUCH_PLAY_LOGIC: logger.py not found. Falling back to print statements for logging.")
    def info(msg): print(f"INFO: {msg}")
    def debug(msg): print(f"DEBUG: {msg}")
    def warning(msg): print(f"WARNING: {msg}")
    def error(msg): print(f"ERROR: {msg}")
    def critical(msg): print(f"CRITICAL: {msg}")
# --- End Logger ---

import constants as C
from game_state_manager import reset_game_state # For resetting the game
from enemy import Enemy # For potential type hinting
from items import Chest # For type checking if Chest is valid
from game_ui import draw_platformer_scene_on_surface # For drawing the game scene

def run_couch_play_mode(screen: pygame.Surface, clock: pygame.time.Clock,
                        fonts: dict, game_elements_ref: dict, app_status_obj):
    """
    Main loop for the couch co-op game mode.
    Manages input for two local players and updates the game state.

    Args:
        screen: The main Pygame display surface.
        clock: The Pygame clock for managing FPS.
        fonts: A dictionary of loaded Pygame font objects.
        game_elements_ref: A dictionary containing references to game objects
                           (players, sprite groups, camera, etc.).
        app_status_obj: An object (like main's AppStatus) with an 'app_running' attribute
                        to signal if the whole application should quit.
    """
    pygame.display.set_caption("Platformer - Couch Co-op (P1:WASD+VB, P2:IJKL+OP | Harm:H,N | Heal:G,M | Reset:Q)") # Updated caption
    current_width, current_height = screen.get_size()

    # Get player instances from the game_elements dictionary
    p1 = game_elements_ref.get("player1")
    p2 = game_elements_ref.get("player2")

    # Define key mappings for Player 1 and Player 2
    p1_key_map_config = {
        'left': pygame.K_a, 'right': pygame.K_d, 'up': pygame.K_w, 'down': pygame.K_s,
        'attack1': pygame.K_v, 'attack2': pygame.K_b, 'dash': pygame.K_LSHIFT,
        'roll': pygame.K_LCTRL, 'interact': pygame.K_e
    }
    p2_key_map_config = {
        'left': pygame.K_j, 'right': pygame.K_l, 'up': pygame.K_i, 'down': pygame.K_k,
        'attack1': pygame.K_o, 'attack2': pygame.K_p,
        'dash': pygame.K_SEMICOLON,
        'roll': pygame.K_QUOTE,
        'interact': pygame.K_BACKSLASH
    }

    couch_game_active = True
    while couch_game_active and app_status_obj.app_running:
        dt_sec = clock.tick(C.FPS) / 1000.0
        now_ticks_couch = pygame.time.get_ticks()

        pygame_events = pygame.event.get()
        keys_pressed = pygame.key.get_pressed()

        host_requested_reset_couch = False

        for event in pygame_events:
            if event.type == pygame.QUIT:
                couch_game_active = False
                app_status_obj.app_running = False
                break
            if event.type == pygame.VIDEORESIZE:
                if not screen.get_flags() & pygame.FULLSCREEN:
                    current_width, current_height = max(320,event.w), max(240,event.h)
                    screen = pygame.display.set_mode((current_width,current_height), pygame.RESIZABLE|pygame.DOUBLEBUF)
                    if game_elements_ref.get("camera"):
                        game_elements_ref["camera"].screen_width = current_width
                        game_elements_ref["camera"].screen_height = current_height
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    couch_game_active = False
                    break
                if event.key == pygame.K_q:
                    host_requested_reset_couch = True

                if p1 and p1._valid_init:
                    if event.key == pygame.K_h and hasattr(p1, 'self_inflict_damage'):
                        p1.self_inflict_damage(C.PLAYER_SELF_DAMAGE)
                    if event.key == pygame.K_g and hasattr(p1, 'heal_to_full'):
                        p1.heal_to_full()

                if p2 and p2._valid_init:
                    if event.key == pygame.K_n and hasattr(p2, 'self_inflict_damage'):
                        p2.self_inflict_damage(C.PLAYER_SELF_DAMAGE)
                    if event.key == pygame.K_m and hasattr(p2, 'heal_to_full'):
                        p2.heal_to_full()

        if not app_status_obj.app_running or not couch_game_active: break

        if p1 and p1._valid_init and not p1.is_dead:
            if hasattr(p1, 'handle_mapped_input'):
                p1.handle_mapped_input(keys_pressed, pygame_events, p1_key_map_config)

        if p2 and p2._valid_init and not p2.is_dead:
            if hasattr(p2, 'handle_mapped_input'):
                p2.handle_mapped_input(keys_pressed, pygame_events, p2_key_map_config)

        if host_requested_reset_couch:
            info("Couch Play: Game state reset triggered by 'Q' key.")
            game_elements_ref["current_chest"] = reset_game_state(game_elements_ref)

        if p1 and p1._valid_init:
            other_players_for_p1_update = [char for char in [p2] if char and char._valid_init and char.alive() and char is not p1]
            p1.update(dt_sec, game_elements_ref["platform_sprites"], game_elements_ref["ladder_sprites"],
                      game_elements_ref["hazard_sprites"], other_players_for_p1_update, game_elements_ref["enemy_list"])

        if p2 and p2._valid_init:
            other_players_for_p2_update = [char for char in [p1] if char and char._valid_init and char.alive() and char is not p2]
            p2.update(dt_sec, game_elements_ref["platform_sprites"], game_elements_ref["ladder_sprites"],
                      game_elements_ref["hazard_sprites"], other_players_for_p2_update, game_elements_ref["enemy_list"])

        active_players_for_enemy_ai_couch = [char for char in [p1, p2] if char and char._valid_init and not char.is_dead and char.alive()]
        for enemy_couch in list(game_elements_ref.get("enemy_list", [])):
            if enemy_couch._valid_init:
                enemy_couch.update(dt_sec, active_players_for_enemy_ai_couch,
                                   game_elements_ref["platform_sprites"], game_elements_ref["hazard_sprites"])
                if enemy_couch.is_dead and hasattr(enemy_couch, 'death_animation_finished') and \
                   enemy_couch.death_animation_finished and enemy_couch.alive():
                    # Enemy.print_limiter was removed or changed.
                    # Directly log the debug message now.
                    debug(f"Couch Play: Auto-killing enemy {enemy_couch.enemy_id} as death anim finished.")
                    enemy_couch.kill()

        hittable_characters_couch_group = pygame.sprite.Group()
        if p1 and p1.alive() and p1._valid_init: hittable_characters_couch_group.add(p1)
        if p2 and p2.alive() and p2._valid_init: hittable_characters_couch_group.add(p2)
        for enemy_inst_proj_couch in game_elements_ref.get("enemy_list", []):
            if enemy_inst_proj_couch and enemy_inst_proj_couch.alive() and enemy_inst_proj_couch._valid_init:
                hittable_characters_couch_group.add(enemy_inst_proj_couch)
        game_elements_ref.get("projectile_sprites", pygame.sprite.Group()).update(
            dt_sec, game_elements_ref["platform_sprites"], hittable_characters_couch_group
        )

        game_elements_ref.get("collectible_sprites", pygame.sprite.Group()).update(dt_sec)
        couch_current_chest = game_elements_ref.get("current_chest")
        if Chest and couch_current_chest and couch_current_chest.alive():
            player_who_collected_chest_couch = None
            if p1 and p1._valid_init and not p1.is_dead and p1.alive() and \
               pygame.sprite.collide_rect(p1, couch_current_chest):
                player_who_collected_chest_couch = p1
            elif p2 and p2._valid_init and not p2.is_dead and p2.alive() and \
                 pygame.sprite.collide_rect(p2, couch_current_chest):
                player_who_collected_chest_couch = p2

            if player_who_collected_chest_couch:
                couch_current_chest.collect(player_who_collected_chest_couch)
                game_elements_ref["current_chest"] = None

        couch_camera = game_elements_ref.get("camera")
        if couch_camera:
            camera_focus_target_couch = None
            if p1 and p1.alive() and p1._valid_init and not p1.is_dead:
                camera_focus_target_couch = p1
            elif p2 and p2.alive() and p2._valid_init and not p2.is_dead:
                camera_focus_target_couch = p2

            if camera_focus_target_couch: couch_camera.update(camera_focus_target_couch)
            else: couch_camera.static_update()

        try:
            draw_platformer_scene_on_surface(screen, game_elements_ref, fonts, now_ticks_couch)
        except Exception as e_draw:
            error(f"Couch Play draw error: {e_draw}", exc_info=True)
            couch_game_active=False; break
        pygame.display.flip()

    info("Exiting Couch Play mode.")

########## START OF FILE: editor\__init__.py ##########



########## START OF FILE: editor\editor.py ##########

# editor/editor.py
# -*- coding: utf-8 -*-
"""
## version 1.0.0.20 (Adapted for main.py integration)
Level Editor for the Platformer Game (Pygame Only).
Allows creating, loading, and saving game levels visually.
"""
import pygame
import sys
import os
from typing import Tuple, Dict, Optional, Any, List, Callable
import traceback
import math
import logging
import editor_drawing

# --- Logger Setup ---
logger = None
log_file_path_for_error_msg = "Not determined"
try:
    current_script_dir = os.path.dirname(os.path.abspath(__file__))
    logs_dir = os.path.join(current_script_dir, 'logs')

    if not os.path.exists(logs_dir):
        # print(f"Attempting to create logs directory: {logs_dir}") # Reduced console spam
        os.makedirs(logs_dir)
        # print(f"Logs directory created (or already existed at {logs_dir}).")
    # else: # Reduced console spam
        # print(f"Logs directory already exists at: {logs_dir}")

    log_file_path_for_error_msg = os.path.join(logs_dir, 'editor_debug.log')
    # print(f"Attempting to configure logging to file: {log_file_path_for_error_msg}")

    for handler in logging.root.handlers[:]:
        logging.root.removeHandler(handler)

    logging.basicConfig(
        level=logging.DEBUG,
        format='%(asctime)s - %(levelname)s - %(filename)s:%(lineno)d - %(funcName)s - %(message)s',
        handlers=[
            logging.FileHandler(log_file_path_for_error_msg, mode='w'),
        ],
        force=True # Added force=True for reliability in re-configuration
    )
    logger = logging.getLogger(__name__)
    logger.info("Editor session started. Logging initialized successfully to file.")
    # print(f"LOGGING INITIALIZED. Log file should be at: {log_file_path_for_error_msg}")

except Exception as e_log:
    print(f"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
    print(f"CRITICAL ERROR DURING LOGGING SETUP: {e_log}")
    print(f"Traceback for logging error:")
    traceback.print_exc()
    print(f"Log file might not be created due to this error.")
    print(f"Attempted log file path was: {log_file_path_for_error_msg}")
    print(f"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
    logging.basicConfig(level=logging.DEBUG, format='CONSOLE LOG (File log failed): %(asctime)s - %(levelname)s - %(message)s', force=True)
    logger = logging.getLogger(__name__)
    logger.error("File logging setup failed. Switched to console logging only for this session.")
# --- End Logger Setup ---

# --- sys.path modification and constants import ---
try:
    project_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    if project_root not in sys.path:
        sys.path.insert(0, project_root)
        if logger: logger.debug(f"Added project root '{project_root}' to sys.path.")
    # else: # Reduced console spam
        # if logger: logger.debug(f"Project root '{project_root}' already in sys.path.")

    import constants as C_imported
    if logger: logger.info(f"Successfully imported 'constants as C_imported'. TILE_SIZE: {getattr(C_imported, 'TILE_SIZE', 'NOT FOUND')}")

except ImportError as e_imp:
    if logger:
        logger.critical(f"Failed to import 'constants'. Error: {e_imp}", exc_info=True)
        logger.critical(f"Current sys.path: {sys.path}")
        logger.critical(f"Calculated project_root: {project_root if 'project_root' in locals() else 'Not calculated'}")
    print("ERROR: Could not import 'constants.py'. Ensure it is in the project root directory, one level above the 'editor' directory.")
    # sys.exit("ImportError for constants.py") # Don't sys.exit from module level
    raise # Re-raise to indicate failure to load module
except Exception as e_gen_imp:
    if logger: logger.critical(f"An unexpected error occurred during constants import: {e_gen_imp}", exc_info=True)
    # sys.exit("Generic error during constants import.") # Don't sys.exit
    raise # Re-raise
# --- End sys.path modification and constants import ---

# --- Editor module imports ---
try:
    import editor_config as ED_CONFIG
    from editor_state import EditorState
    import editor_ui
    import editor_assets
    import editor_map_utils
    from editor_handlers_global import handle_global_events
    from editor_handlers_dialog import handle_dialog_events
    from editor_handlers_menu import handle_menu_events # Removed start_rename_map_flow as it's likely internal to handler
    from editor_handlers_map_editing import handle_editing_map_events
    from editor_updates import update_continuous_camera_pan, update_asset_palette_scroll_momentum
    if logger: logger.debug("Successfully imported all editor-specific modules.")
except ImportError as e_editor_mod:
    if logger: logger.critical(f"Failed to import an editor-specific module. Error: {e_editor_mod}", exc_info=True)
    print(f"ERROR: Failed to import an editor module. Check sys.path and module names. Current sys.path: {sys.path}")
    # sys.exit("ImportError for editor module - exiting.") # Don't sys.exit
    raise # Re-raise
# --- End Editor module imports ---


# This is the main entry point when called from main.py
def run_editor_loop(main_screen_surface: pygame.Surface, 
                    main_clock_obj: pygame.time.Clock, 
                    main_fonts_dict: Dict[str, Optional[pygame.font.Font]], # Currently unused by editor, uses its own
                    main_app_status_obj: Any, # Expected to have an 'app_running' attribute
                    game_maps_dir_path: str):
    
    if logger: logger.info("run_editor_loop() started.")
    
    try:
        # Pygame and font initialization are typically handled by main.py
        # but calling them again is safe.
        pygame.init() 
        if logger: logger.debug("pygame.init() called (or re-called).")
        if not pygame.font.get_init():
            if logger: logger.debug("pygame.font not initialized, calling pygame.font.init()")
            pygame.font.init()
        if not pygame.font.get_init():
             if logger: logger.critical("pygame.font.init() failed after explicit call! Fonts will not work.")
        # else: # Reduced console spam
            # if logger: logger.debug("pygame.font.init() confirmed or already initialized.")

        # Ensure maps directory exists using the path from main.py
        # IMPORTANT: Assumes editor_map_utils.ensure_maps_directory_exists is modified to take a path
        if not editor_map_utils.ensure_maps_directory_exists(game_maps_dir_path):
            if logger: logger.critical(f"Maps directory '{game_maps_dir_path}' issue. Exiting editor loop.")
            # Don't quit pygame or sys.exit, just return
            return

        pygame.display.set_caption("Platformer Level Editor - Menu") # Editor sets its own caption
        
        # IMPORTANT: Assumes EditorState is modified to accept game_maps_dir_path
        editor_state = EditorState(game_maps_dir_path) # Pass the maps directory path
        editor_assets.load_editor_palette_assets(editor_state)

        # Editor uses its own font configuration
        fonts: Dict[str, Optional[pygame.font.Font]] = ED_CONFIG.FONT_CONFIG
        if not fonts.get("small") or not fonts.get("medium") or not fonts.get("large"):
            if logger: logger.critical("Essential editor fonts (small, medium, or large) are None. Exiting editor loop.")
            return 
        if logger: logger.debug(f"Fonts from ED_CONFIG.FONT_CONFIG loaded: small={fonts['small'] is not None}, medium={fonts['medium'] is not None}, large={fonts['large'] is not None}, tooltip={fonts['tooltip'] is not None}")

        def calculate_layout_rects(screen_width: int, screen_height: int, current_mode: str) -> Tuple[pygame.Rect, pygame.Rect, pygame.Rect]:
            menu_rect = pygame.Rect(ED_CONFIG.SECTION_PADDING, ED_CONFIG.SECTION_PADDING,
                                     ED_CONFIG.MENU_SECTION_WIDTH, screen_height - (ED_CONFIG.SECTION_PADDING * 2))
            menu_rect.width = max(ED_CONFIG.BUTTON_WIDTH_STANDARD + ED_CONFIG.SECTION_PADDING * 2, menu_rect.width)
            menu_rect.height = max(menu_rect.height, ED_CONFIG.MENU_SECTION_HEIGHT)

            asset_palette_rect = pygame.Rect(ED_CONFIG.SECTION_PADDING, ED_CONFIG.SECTION_PADDING,
                                            ED_CONFIG.ASSET_PALETTE_SECTION_WIDTH, screen_height - (ED_CONFIG.SECTION_PADDING * 2))
            map_view_x_start = ED_CONFIG.SECTION_PADDING
            map_view_width_available = screen_width - (ED_CONFIG.SECTION_PADDING * 2)

            if current_mode == "menu":
                map_view_x_start = menu_rect.right + ED_CONFIG.SECTION_PADDING
                map_view_width_available = screen_width - map_view_x_start - ED_CONFIG.SECTION_PADDING
            elif current_mode == "editing_map":
                asset_palette_rect.left = ED_CONFIG.SECTION_PADDING # Ensure it's on the left
                map_view_x_start = asset_palette_rect.right + ED_CONFIG.SECTION_PADDING
                map_view_width_available = screen_width - map_view_x_start - ED_CONFIG.SECTION_PADDING

            map_view_rect = pygame.Rect(map_view_x_start, ED_CONFIG.SECTION_PADDING,
                                        map_view_width_available, screen_height - (ED_CONFIG.SECTION_PADDING * 2))
            map_view_rect.width = max(map_view_rect.width, ED_CONFIG.DEFAULT_GRID_SIZE * 10)
            map_view_rect.height = max(map_view_rect.height, ED_CONFIG.DEFAULT_GRID_SIZE * 10)
            return menu_rect, asset_palette_rect, map_view_rect

        current_screen_width, current_screen_height = main_screen_surface.get_size()
        menu_section_rect, asset_palette_section_rect, map_view_section_rect = calculate_layout_rects(
            current_screen_width, current_screen_height, editor_state.current_editor_mode
        )
        if logger: logger.debug(f"Initial Layout - Menu={menu_section_rect}, Assets={asset_palette_section_rect}, Map={map_view_section_rect}")

        running_editor_locally = True # Local control for the editor's loop
        if logger: logger.info("Entering editor's main loop.")
        
        while running_editor_locally and main_app_status_obj.app_running:
            dt = main_clock_obj.tick(ED_CONFIG.C.FPS if hasattr(ED_CONFIG.C, 'FPS') else 60) / 1000.0
            dt = min(dt, 0.1) # Cap dt

            mouse_pos = pygame.mouse.get_pos()
            events = pygame.event.get()

            editor_state.update_status_message(dt)
            previous_mode = editor_state.current_editor_mode
            previous_dialog_type = editor_state.active_dialog_type
            layout_needs_recalc = False

            # --- Continuous Updates ---
            if editor_state.current_editor_mode == "editing_map" and not editor_state.active_dialog_type:
                update_continuous_camera_pan(editor_state, map_view_section_rect, mouse_pos, dt)
                asset_list_visible_height = (
                    asset_palette_section_rect.height
                    - ED_CONFIG.MINIMAP_AREA_HEIGHT
                    - (ED_CONFIG.BUTTON_HEIGHT_STANDARD * 0.8 + ED_CONFIG.ASSET_PALETTE_ITEM_PADDING * 2) # Approx title height
                )
                update_asset_palette_scroll_momentum(
                    editor_state,
                    dt,
                    asset_list_visible_height,
                    editor_state.total_asset_palette_content_height
                )

            # --- Event Processing ---
            for event in events:
                if event.type == pygame.VIDEORESIZE:
                    if logger: logger.info(f"EDITOR: VIDEORESIZE event to {event.w}x{event.h}")
                    current_screen_width, current_screen_height = event.w, event.h
                    # main_screen_surface is already resized by Pygame internally when main.py's screen is resizable.
                    # No need to call pygame.display.set_mode() here again.
                    layout_needs_recalc = True
                    editor_state.set_status_message(f"Resized to {event.w}x{event.h}", 2.0)
                    editor_state.minimap_needs_regeneration = True
                
                # Pass main_app_status_obj to global event handler if it needs to set app_running = False
                # For now, assume handle_global_events only returns True/False for local editor loop.
                # If handle_global_events needs to signal a full app quit, it should directly modify main_app_status_obj.app_running
                if not handle_global_events(event, editor_state, main_screen_surface): # Removed , main_app_status_obj
                    if logger: logger.info("handle_global_events returned False (QUIT). Setting running_editor_locally=False.")
                    running_editor_locally = False
                    # If it's a QUIT event, it might be good for handle_global_events to also set main_app_status_obj.app_running = False
                    if event.type == pygame.QUIT:
                         main_app_status_obj.app_running = False # Ensure main app also knows
                    break 
                if not running_editor_locally or not main_app_status_obj.app_running: break


                if editor_state.active_dialog_type:
                    handle_dialog_events(event, editor_state) # This might change editor_state.current_editor_mode
                    if editor_state.active_dialog_type != previous_dialog_type:
                        if logger: logger.debug(f"Dialog type changed from '{previous_dialog_type}' to '{editor_state.active_dialog_type}' after handle_dialog_events.")
                        if editor_state.current_editor_mode != previous_mode:
                            if logger: logger.debug(f"Mode changed (likely via dialog callback) from '{previous_mode}' to '{editor_state.current_editor_mode}'. Triggering layout recalc.")
                            layout_needs_recalc = True
                else: # No active dialog
                    if editor_state.current_editor_mode == "menu":
                        if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
                            if logger: logger.info("Escape pressed in editor menu. Exiting editor.")
                            running_editor_locally = False # Exit editor, return to main menu
                            # Not posting QUIT, as that might shut down the whole app.
                            # Main.py will decide if Esc from editor's menu quits the app.
                            continue
                        handle_menu_events(event, editor_state, main_screen_surface)
                    elif editor_state.current_editor_mode == "editing_map":
                        handle_editing_map_events(event, editor_state, asset_palette_section_rect, map_view_section_rect, main_screen_surface)

                if editor_state.current_editor_mode != previous_mode:
                    if logger: logger.debug(f"Mode changed from '{previous_mode}' to '{editor_state.current_editor_mode}' after specific event handlers. Triggering layout recalc.")
                    layout_needs_recalc = True
            
            if not running_editor_locally or not main_app_status_obj.app_running: break
            # --- End Event Processing ---

            # --- Camera Momentum --- (logic seems fine, uses editor_state and dt)
            if editor_state.current_editor_mode == "editing_map" and \
               not editor_state.active_dialog_type and \
               not editor_state.is_mouse_over_map_view and \
               (abs(editor_state.camera_momentum_pan[0]) > ED_CONFIG.CAMERA_MOMENTUM_MIN_SPEED_THRESHOLD or \
                abs(editor_state.camera_momentum_pan[1]) > ED_CONFIG.CAMERA_MOMENTUM_MIN_SPEED_THRESHOLD) and \
                not (pygame.key.get_pressed()[pygame.K_a] or pygame.key.get_pressed()[pygame.K_d] or \
                     pygame.key.get_pressed()[pygame.K_w] or pygame.key.get_pressed()[pygame.K_s]) :

                cam_vx, cam_vy = editor_state.camera_momentum_pan
                damping_this_frame = ED_CONFIG.CAMERA_MOMENTUM_DAMPING_FACTOR ** (dt * 60.0) # Frame-rate independent damping
                cam_vx *= damping_this_frame
                cam_vy *= damping_this_frame
                editor_state.camera_offset_x += cam_vx * dt * ED_CONFIG.CAMERA_KEY_PAN_SPEED # Apply speed factor if momentum is in pixels/sec
                editor_state.camera_offset_y += cam_vy * dt * ED_CONFIG.CAMERA_KEY_PAN_SPEED

                max_cam_x = max(0, editor_state.get_map_pixel_width() - map_view_section_rect.width)
                max_cam_y = max(0, editor_state.get_map_pixel_height() - map_view_section_rect.height)
                boundary_hit = False
                if editor_state.camera_offset_x <= 0:
                    editor_state.camera_offset_x = 0; cam_vx = 0; boundary_hit = True
                elif editor_state.camera_offset_x >= max_cam_x:
                    editor_state.camera_offset_x = max_cam_x; cam_vx = 0; boundary_hit = True
                if editor_state.camera_offset_y <= 0:
                    editor_state.camera_offset_y = 0; cam_vy = 0; boundary_hit = True
                elif editor_state.camera_offset_y >= max_cam_y:
                    editor_state.camera_offset_y = max_cam_y; cam_vy = 0; boundary_hit = True

                editor_state.camera_offset_x = int(editor_state.camera_offset_x)
                editor_state.camera_offset_y = int(editor_state.camera_offset_y)

                if math.sqrt(cam_vx**2 + cam_vy**2) < ED_CONFIG.CAMERA_MOMENTUM_MIN_SPEED_THRESHOLD or boundary_hit:
                    editor_state.camera_momentum_pan = (0.0, 0.0)
                else:
                    editor_state.camera_momentum_pan = (cam_vx, cam_vy)

            if layout_needs_recalc:
                if logger: logger.debug(f"Recalculating layout. Current Mode: '{editor_state.current_editor_mode}', Screen: {current_screen_width}x{current_screen_height}")
                menu_section_rect, asset_palette_section_rect, map_view_section_rect = calculate_layout_rects(
                    current_screen_width, current_screen_height, editor_state.current_editor_mode
                )
                if logger: logger.debug(f"New Layout - Menu={menu_section_rect}, Assets={asset_palette_section_rect}, Map={map_view_section_rect}")
                if editor_state.current_editor_mode == "editing_map" and editor_state.map_content_surface:
                    map_px_w = editor_state.get_map_pixel_width(); map_px_h = editor_state.get_map_pixel_height()
                    view_w = map_view_section_rect.width; view_h = map_view_section_rect.height
                    if view_w > 0 and view_h > 0 : # Prevent division by zero or negative rects
                        max_cx = max(0, map_px_w - view_w); max_cy = max(0, map_px_h - view_h)
                        prev_cx, prev_cy = editor_state.camera_offset_x, editor_state.camera_offset_y
                        editor_state.camera_offset_x = max(0,min(editor_state.camera_offset_x,max_cx))
                        editor_state.camera_offset_y = max(0,min(editor_state.camera_offset_y,max_cy))
                        if prev_cx!=editor_state.camera_offset_x or prev_cy!=editor_state.camera_offset_y:
                             if logger: logger.debug(f"Camera clamped after resize/layout from ({prev_cx},{prev_cy}) to ({editor_state.camera_offset_x},{editor_state.camera_offset_y}). Max: ({max_cx},{max_cy})")
                    # else: # Reduced console spam
                        # if logger: logger.warning(f"Map view rect zero/negative W/H ({view_w}x{view_h}). Camera not adjusted.")


            # --- Drawing ---
            main_screen_surface.fill(ED_CONFIG.C.DARK_GRAY if hasattr(ED_CONFIG.C, 'DARK_GRAY') else (50,50,50))

            if editor_state.current_editor_mode == "menu":
                editor_drawing.draw_menu_ui(main_screen_surface, editor_state, menu_section_rect, fonts, mouse_pos)
                # Placeholder for map area when in menu
                ph_rect = pygame.Rect(menu_section_rect.right + ED_CONFIG.SECTION_PADDING, ED_CONFIG.SECTION_PADDING,
                                      current_screen_width - menu_section_rect.right - ED_CONFIG.SECTION_PADDING*2,
                                      current_screen_height - ED_CONFIG.SECTION_PADDING*2)
                if ph_rect.width > 10 and ph_rect.height > 10: # Draw only if reasonably sized
                    pygame.draw.rect(main_screen_surface, (20,20,20), ph_rect)
                    f_large = fonts.get("large")
                    if f_large:
                        text_surf = f_large.render("Map Editor Area",True,(60,60,60))
                        main_screen_surface.blit(text_surf, text_surf.get_rect(center=ph_rect.center))
            elif editor_state.current_editor_mode == "editing_map":
                editor_drawing.draw_asset_palette_ui(main_screen_surface, editor_state, asset_palette_section_rect, fonts, mouse_pos, map_view_section_rect)
                editor_drawing.draw_map_view_ui(main_screen_surface, editor_state, map_view_section_rect, fonts, mouse_pos)

            if editor_state.active_dialog_type:
                editor_ui.draw_active_dialog(main_screen_surface, editor_state, fonts)

            f_tooltip = fonts.get("tooltip")
            if f_tooltip:
                editor_ui.draw_tooltip(main_screen_surface, editor_state, f_tooltip)

            f_small = fonts.get("small")
            if f_small:
                editor_ui.draw_status_message(main_screen_surface, editor_state, f_small)

            pygame.display.flip()
            # --- End Drawing ---

    except Exception as e:
        if logger: logger.critical(f"CRITICAL ERROR in run_editor_loop: {e}", exc_info=True)
        else: print(f"CRITICAL ERROR in run_editor_loop (logger not available): {e}")
        traceback.print_exc()
        # Optionally, signal main app to quit on critical editor error
        # main_app_status_obj.app_running = False
    finally:
        # DO NOT call pygame.quit() or sys.exit() here. Main.py handles that.
        if logger: logger.info("Exiting run_editor_loop.")
        # Reset Pygame caption back to something generic or let main.py handle it
        # pygame.display.set_caption("Platformer Adventure LAN") # main.py will do this

# The if __name__ == "__main__": block is removed as this script is now a module.
# If you want to test the editor independently, you can create a separate test_editor.py
# or temporarily re-add it for testing:
#
# if __name__ == "__main__":
#     print("--- editor.py execution started (__name__ == '__main__') for testing ---")
#     # Minimal setup for standalone testing
#     pygame.init()
#     pygame.font.init()
#     screen_test = pygame.display.set_mode((ED_CONFIG.EDITOR_SCREEN_INITIAL_WIDTH, ED_CONFIG.EDITOR_SCREEN_INITIAL_HEIGHT), pygame.RESIZABLE)
#     clock_test = pygame.time.Clock()
#     class TestAppStatus: app_running = True
#     app_status_test = TestAppStatus()
#     maps_dir_test = os.path.join(project_root, "maps") # Adjust if needed
#     if not os.path.exists(maps_dir_test): os.makedirs(maps_dir_test)
# 
#     # Ensure logger is set up if not already
#     if logger is None:
#          logging.basicConfig(level=logging.DEBUG, format='TEST CONSOLE: %(asctime)s - %(levelname)s - %(message)s')
#          logger = logging.getLogger(__name__)
#          logger.info("Logger re-initialized for standalone test.")
#
#     try:
#         run_editor_loop(screen_test, clock_test, {}, app_status_test, maps_dir_test)
#     except Exception as e_test:
#         if logger: logger.critical(f"Error during standalone test: {e_test}", exc_info=True)
#         else: print(f"Error during standalone test: {e_test}")
#     finally:
#         pygame.quit()
#         if logger: logger.info("Standalone test finished.")
#         sys.exit()

########## START OF FILE: editor\editor_assets.py ##########

# editor_assets.py
# -*- coding: utf-8 -*-
"""
## version 1.0.0.7 (Adjust palette height calculation for minimap)
Handles loading and managing assets for the editor's palette.
"""
import pygame
import os
import sys
import traceback
from typing import Optional, List, Dict, Any

# --- (Sys.path manipulation and assets import - keeping essential prints) ---
current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
if parent_dir not in sys.path:
    sys.path.insert(0, parent_dir)
    # print(f"INFO ASSETS: Added '{parent_dir}' to sys.path for 'assets' module import.")

try:
    from assets import load_gif_frames, resource_path # Assuming this is in your project root/assets.py
except ImportError:
    print("CRITICAL: 'assets' module not found. Using dummy functions.")
    def load_gif_frames(path): return []
    def resource_path(path): return os.path.join(parent_dir, path) # Basic fallback


import editor_config as ED_CONFIG
from editor_state import EditorState


def load_editor_palette_assets(editor_state: EditorState):
    editor_state.assets_palette.clear()
    # print("INFO ASSETS: Loading editor palette assets...")
    successful_loads = 0; failed_loads = 0
    ts = ED_CONFIG.DEFAULT_GRID_SIZE

    for asset_key, asset_info in ED_CONFIG.EDITOR_PALETTE_ASSETS.items():
        surf: Optional[pygame.Surface] = None
        tooltip = asset_info.get("tooltip", asset_key)
        game_type_id = asset_info.get("game_type_id", asset_key)
        category = asset_info.get("category", "unknown")
        original_w, original_h = ts, ts

        if "source_file" in asset_info:
            source_file_path = asset_info["source_file"]
            try:
                full_path = resource_path(source_file_path)
                if not os.path.exists(full_path):
                    print(f"Assets Error: File NOT FOUND at '{full_path}' for asset '{asset_key}'")
                else:
                    frames = load_gif_frames(full_path)
                    if frames: surf = frames[0]
                    # else: print(f"Warning ASSETS: load_gif_frames returned empty list for '{asset_key}' from '{full_path}'.")
            except Exception as e: print(f"Error ASSETS: Loading '{asset_key}' from '{source_file_path}': {e}");
        elif "surface_params" in asset_info:
            try:
                w, h, color = asset_info["surface_params"]
                original_w, original_h = w, h
                surf = pygame.Surface((max(1, w), max(1, h))); surf.fill(color)
            except Exception as e: print(f"Error ASSETS: Creating surface for '{asset_key}': {e}");
        elif "render_mode" in asset_info and asset_info["render_mode"] == "half_tile":
            try:
                surf = pygame.Surface((ts, ts), pygame.SRCALPHA)
                surf.fill((0,0,0,0))
                color = asset_info.get("base_color_tuple", getattr(ED_CONFIG.C, "MAGENTA", (255,0,255)))
                half_type = asset_info.get("half_type", "left")
                rect_to_draw = pygame.Rect(0,0,0,0)
                if half_type == "left": rect_to_draw = pygame.Rect(0, 0, ts // 2, ts)
                elif half_type == "right": rect_to_draw = pygame.Rect(ts // 2, 0, ts // 2, ts)
                elif half_type == "top": rect_to_draw = pygame.Rect(0, 0, ts, ts // 2)
                elif half_type == "bottom": rect_to_draw = pygame.Rect(0, ts // 2, ts, ts // 2)
                pygame.draw.rect(surf, color, rect_to_draw)
                original_w, original_h = ts, ts
            except Exception as e: print(f"Error ASSETS: Creating half_tile surface for '{asset_key}': {e}");
        elif "icon_type" in asset_info:
            try:
                surf = pygame.Surface((ts, ts), pygame.SRCALPHA)
                surf.fill((0,0,0,0))
                color = asset_info.get("base_color_tuple", getattr(ED_CONFIG.C, "YELLOW", (255,255,0)))
                icon_type = asset_info["icon_type"]
                if icon_type == "2x2_placer":
                    pygame.draw.rect(surf, color, (ts*0.1, ts*0.1, ts*0.35, ts*0.35))
                    pygame.draw.rect(surf, color, (ts*0.55, ts*0.1, ts*0.35, ts*0.35))
                    pygame.draw.rect(surf, color, (ts*0.1, ts*0.55, ts*0.35, ts*0.35))
                    pygame.draw.rect(surf, color, (ts*0.55, ts*0.55, ts*0.35, ts*0.35))
                    pygame.draw.rect(surf, getattr(ED_CONFIG.C, "BLACK", (0,0,0)), (0,0,ts,ts), 1)
                # Removed "triangle_tool" as it was for the color picker asset
                original_w, original_h = ts, ts
            except Exception as e: print(f"Error ASSETS: Creating icon surface for '{asset_key}': {e}");

        if not surf:
            # print(f"Warning ASSETS: Surface for '{asset_key}' is None. Creating fallback.")
            surf = pygame.Surface((ts, ts))
            surf.fill(getattr(ED_CONFIG.C, 'RED', (255,0,0)))
            pygame.draw.line(surf, getattr(ED_CONFIG.C, 'BLACK', (0,0,0)), (0,0), surf.get_size(), 1)
            pygame.draw.line(surf, getattr(ED_CONFIG.C, 'BLACK', (0,0,0)), (0,surf.get_height()-1), (surf.get_width()-1,0), 1)
            tooltip += " (Load Error)"; failed_loads += 1
        else:
            if asset_info.get("source_file"):
                 original_w, original_h = surf.get_size()
            successful_loads +=1

        scaled_surf = surf
        if (asset_info.get("source_file") and (original_w > ED_CONFIG.ASSET_THUMBNAIL_MAX_WIDTH or original_h > ED_CONFIG.ASSET_THUMBNAIL_MAX_HEIGHT)) or \
           (not asset_info.get("source_file") and (original_w != ED_CONFIG.ASSET_THUMBNAIL_MAX_WIDTH or original_h != ED_CONFIG.ASSET_THUMBNAIL_MAX_HEIGHT) and \
            (original_w > ED_CONFIG.ASSET_THUMBNAIL_MAX_WIDTH or original_h > ED_CONFIG.ASSET_THUMBNAIL_MAX_HEIGHT)):
            if original_w > ED_CONFIG.ASSET_THUMBNAIL_MAX_WIDTH or original_h > ED_CONFIG.ASSET_THUMBNAIL_MAX_HEIGHT:
                ratio = min(ED_CONFIG.ASSET_THUMBNAIL_MAX_WIDTH / original_w if original_w > 0 else 1,
                            ED_CONFIG.ASSET_THUMBNAIL_MAX_HEIGHT / original_h if original_h > 0 else 1)
                new_w, new_h = max(1, int(original_w * ratio)), max(1, int(original_h * ratio))
                try:
                    scaled_surf = pygame.transform.smoothscale(surf, (new_w, new_h))
                except Exception:
                    # print(f"Error ASSETS: Scaling '{asset_key}' failed. Using original.");
                    scaled_surf = surf
        try:
            final_surf_to_store = scaled_surf.convert_alpha() if scaled_surf.get_flags() & pygame.SRCALPHA else scaled_surf.convert()
        except pygame.error as e:
            # print(f"Error ASSETS: Converting surface for '{asset_key}' failed: {e}. Using unoptimized surface.");
            final_surf_to_store = scaled_surf

        editor_state.assets_palette[asset_key] = {
            "image": final_surf_to_store, "game_type_id": game_type_id,
            "tooltip": tooltip, "category": category,
            "original_size_pixels": (original_w, original_h),
            "places_asset_key": asset_info.get("places_asset_key"),
            "colorable": asset_info.get("colorable", False), 
            "render_mode": asset_info.get("render_mode"),
            "half_type": asset_info.get("half_type"),
            "base_color_tuple": asset_info.get("base_color_tuple"),
            "surface_params_dims_color": asset_info.get("surface_params")
        }
    # print(f"INFO ASSETS: Palette loading done. Success: {successful_loads}, Failed: {failed_loads}.")
    _calculate_asset_palette_total_height(editor_state)


def _calculate_asset_palette_total_height(editor_state: EditorState):
    # This calculates the height of the *scrollable content* below the minimap
    current_calc_y = ED_CONFIG.ASSET_PALETTE_ITEM_PADDING # Start padding for the first category

    font_category = ED_CONFIG.FONT_CONFIG.get("medium")
    font_tooltip = ED_CONFIG.FONT_CONFIG.get("small")
    cat_font_h = font_category.get_height() if font_category else 28
    tip_font_h = font_tooltip.get_height() if font_tooltip else 20

    tooltip_text_v_offset = getattr(ED_CONFIG, 'ASSET_PALETTE_TOOLTIP_TEXT_V_OFFSET', 2)

    categories_in_order = getattr(ED_CONFIG, 'EDITOR_PALETTE_ASSETS_CATEGORIES_ORDER',
                                  ["tool", "tile", "hazard", "item", "enemy", "spawn", "unknown"])

    categorized_assets_present: Dict[str, List[Dict[str, Any]]] = {cat_name: [] for cat_name in categories_in_order}
    # Ensure all expected keys exist
    for cat_name in ["tool", "tile", "hazard", "item", "enemy", "spawn", "unknown"]:
        if cat_name not in categorized_assets_present:
            categorized_assets_present[cat_name] = []


    for asset_key, data in editor_state.assets_palette.items():
        category_name = data.get("category", "unknown")
        categorized_assets_present.get(category_name, categorized_assets_present["unknown"]).append(data)

    for category_name in categories_in_order:
        assets_in_this_category = categorized_assets_present.get(category_name, [])
        if not assets_in_this_category:
            continue

        current_calc_y += cat_font_h + ED_CONFIG.ASSET_PALETTE_ITEM_PADDING # Height for category title

        if category_name == "spawn" and \
           any(d.get("game_type_id") == "player1_spawn" for d in assets_in_this_category) and \
           any(d.get("game_type_id") == "player2_spawn" for d in assets_in_this_category):
            # ... (spawn specific layout logic, already uses asset_data["image"].get_height()) ...
            p1_data = next((d for d in assets_in_this_category if d.get("game_type_id") == "player1_spawn"), None)
            p2_data = next((d for d in assets_in_this_category if d.get("game_type_id") == "player2_spawn"), None)
            max_img_h = 0
            if p1_data and p1_data.get("image"): max_img_h = max(max_img_h, p1_data["image"].get_height())
            if p2_data and p2_data.get("image"): max_img_h = max(max_img_h, p2_data["image"].get_height())

            if max_img_h > 0:
                current_calc_y += max_img_h
                current_calc_y += tip_font_h + tooltip_text_v_offset
                current_calc_y += ED_CONFIG.ASSET_PALETTE_ITEM_PADDING
            assets_in_this_category = [d for d in assets_in_this_category if d.get("game_type_id") not in ["player1_spawn", "player2_spawn"]]


        for asset_data in assets_in_this_category: # Process remaining or all other items
            asset_img = asset_data.get("image")
            if not asset_img:
                continue
            current_calc_y += asset_img.get_height()
            current_calc_y += tip_font_h + tooltip_text_v_offset
            current_calc_y += ED_CONFIG.ASSET_PALETTE_ITEM_PADDING

        current_calc_y += ED_CONFIG.ASSET_PALETTE_ITEM_PADDING # Extra padding after the entire category block

    asset_palette_bottom_overhang_px = getattr(ED_CONFIG, 'ASSET_PALETTE_BOTTOM_OVERHANG_PX', 72)
    current_calc_y += asset_palette_bottom_overhang_px

    editor_state.total_asset_palette_content_height = current_calc_y # This is for the scrollable part
    # print(f"INFO ASSETS: Calculated total asset palette SCROLLABLE content height: {editor_state.total_asset_palette_content_height}")

########## START OF FILE: editor\editor_config.py ##########

# editor_config.py
# -*- coding: utf-8 -*-
"""
## version 1.0.0.9 (Added Asset Palette Fling Scroll Config)
Configuration constants for the Platformer Level Editor.
"""
import pygame
import sys
import os
import traceback
from typing import Dict, Optional, Tuple, Any

# --- Add parent directory to sys.path ---
current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
if parent_dir not in sys.path:
    sys.path.insert(0, parent_dir)

try:
    import constants as C
except ImportError as e:
    print(f"CRITICAL CONFIG ERROR: Failed to import 'constants as C' from '{parent_dir}'. Error: {e}")
    class FallbackConstants:
        TILE_SIZE = 32; WHITE = (255,255,255); BLACK = (0,0,0); RED = (255,0,0); GREEN = (0,255,0)
        BLUE = (0,0,255); GRAY = (128,128,128); DARK_GRAY = (50,50,50); YELLOW = (255,255,0)
        LIGHT_BLUE = (173,216,230); DARK_GREEN = (0,100,0); ORANGE_RED = (255,69,0)
        LIGHT_GRAY = (200,200,200); FPS = 60
        MAGENTA = (255, 0, 255)
    C = FallbackConstants()
    print("CRITICAL CONFIG ERROR: Using fallback constants. Editor functionality will be impaired.")
except Exception as e_gen:
    print(f"CRITICAL CONFIG ERROR: Unexpected error importing 'constants': {e_gen}"); traceback.print_exc()
    sys.exit("Failed to initialize constants in editor_config.py")


# --- Editor Window Dimensions ---
EDITOR_SCREEN_INITIAL_WIDTH = 1280
EDITOR_SCREEN_INITIAL_HEIGHT = 720

MENU_SECTION_WIDTH = 280
MENU_SECTION_HEIGHT = 250

ASSET_PALETTE_SECTION_WIDTH = 220

SECTION_PADDING = 10

MAP_VIEW_SECTION_DEFAULT_WIDTH = EDITOR_SCREEN_INITIAL_WIDTH - MENU_SECTION_WIDTH - ASSET_PALETTE_SECTION_WIDTH - (SECTION_PADDING * 3)
MAP_VIEW_SECTION_DEFAULT_HEIGHT = EDITOR_SCREEN_INITIAL_HEIGHT - (SECTION_PADDING * 2)


# --- Camera Control ---
KEY_PAN_SPEED_PIXELS_PER_SECOND = 300
EDGE_SCROLL_ZONE_THICKNESS = 30
EDGE_SCROLL_SPEED_PIXELS_PER_SECOND = 250
CAMERA_MOMENTUM_INITIAL_MULTIPLIER = 1.5
CAMERA_MOMENTUM_DAMPING_FACTOR = 0.96
CAMERA_MOMENTUM_MIN_SPEED_THRESHOLD = 5.0
CAMERA_MOMENTUM_BOUNDARY_DAMP_FACTOR = 0.5


# --- Minimap Configuration ---
MINIMAP_AREA_HEIGHT = 120
MINIMAP_PADDING = 5
MINIMAP_BG_COLOR: Tuple[int,int,int] = (10, 10, 10)
MINIMAP_BORDER_COLOR: Tuple[int,int,int] = getattr(C, 'GRAY', (128,128,128))
MINIMAP_CAMERA_VIEW_RECT_COLOR: Tuple[int,int,int] = getattr(C, 'YELLOW', (255,255,0))
MINIMAP_CAMERA_VIEW_RECT_ALPHA = 100

# --- UI Element Sizes & Colors ---
BUTTON_WIDTH_STANDARD = 200
BUTTON_HEIGHT_STANDARD = 50
BUTTON_TEXT_COLOR: Tuple[int,int,int] = getattr(C, 'WHITE', (255,255,255))
BUTTON_COLOR_NORMAL: Tuple[int,int,int] = getattr(C, 'BLUE', (0,0,255))
BUTTON_COLOR_HOVER: Tuple[int,int,int] = getattr(C, 'GREEN', (0,255,0))
BUTTON_COLOR_BORDER: Tuple[int,int,int] = getattr(C, 'BLACK', (0,0,0))
BUTTON_BORDER_WIDTH = 2

ASSET_THUMBNAIL_MAX_WIDTH = getattr(C, 'TILE_SIZE', 32) * 2
ASSET_THUMBNAIL_MAX_HEIGHT = getattr(C, 'TILE_SIZE', 32) * 2
ASSET_PALETTE_ITEM_PADDING = 5
ASSET_PALETTE_BG_COLOR: Tuple[int,int,int] = (30, 30, 30)
ASSET_PALETTE_CATEGORY_TEXT_COLOR: Tuple[int,int,int] = getattr(C, 'YELLOW', (255,255,0))
ASSET_PALETTE_TOOLTIP_COLOR: Tuple[int,int,int] = getattr(C, 'LIGHT_GRAY', (200,200,200))
ASSET_PALETTE_HOVER_BG_COLOR: Tuple[int,int,int] = (50, 80, 50)
ASSET_PALETTE_BOTTOM_OVERHANG_PX = 72
ASSET_PALETTE_TOOLTIP_TEXT_V_OFFSET = 2

# --- Asset Palette Scroll ---
ASSET_PALETTE_SCROLL_KICK_MULTIPLIER = 2000.0  # Speed (pixels/sec like) added on mouse wheel tick (WAS 250.0)
ASSET_PALETTE_FLING_DAMPING_FACTOR = 0.92     # Closer to 1.0 = longer fling (e.g., 0.9 means 10% speed loss per frame)
ASSET_PALETTE_FLING_MIN_SPEED_THRESHOLD = 50 # Momentum (pixels/sec) below which fling stops
ASSET_PALETTE_MAX_MOMENTUM = 2000.0          # Max scroll speed (pixels/sec)

MAP_VIEW_GRID_COLOR: Tuple[int,int,int] = getattr(C, 'GRAY', (128,128,128))
MAP_VIEW_BORDER_COLOR: Tuple[int,int,int] = getattr(C, 'GRAY', (128,128,128))

DIALOG_BG_COLOR: Tuple[int,int,int] = (60, 60, 70)
DIALOG_INPUT_BOX_COLOR: Tuple[int,int,int] = getattr(C, 'WHITE', (255,255,255))
DIALOG_INPUT_TEXT_COLOR: Tuple[int,int,int] = getattr(C, 'BLACK', (0,0,0))
DIALOG_PROMPT_COLOR: Tuple[int,int,int] = getattr(C, 'WHITE', (255,255,255))
DIALOG_CURSOR_COLOR: Tuple[int,int,int] = getattr(C, 'BLACK', (0,0,0))

COLOR_PICKER_BUTTON_SIZE = 40
COLOR_PICKER_PADDING = 8
COLOR_PICKER_COLS = 5
COLOR_PICKER_BG_COLOR: Tuple[int,int,int] = (40, 40, 50)
COLOR_PICKER_TITLE_COLOR: Tuple[int,int,int] = getattr(C, 'WHITE', (255,255,255))
COLOR_PICKER_HOVER_BORDER_COLOR: Tuple[int,int,int] = getattr(C, 'YELLOW', (255,255,0))

MAPS_DIRECTORY = "maps"

TS = getattr(C, 'TILE_SIZE', 32)

EDITOR_PALETTE_ASSETS: Dict[str, Dict[str, Any]] = {
    "player1_spawn": {
        "source_file": "characters/player1/__Idle.gif", "game_type_id": "player1_spawn",
        "tooltip": "P1", "category": "spawn"
    },
    "player2_spawn": {
        "source_file": "characters/player2/__Idle.gif", "game_type_id": "player2_spawn",
        "tooltip": "P2", "category": "spawn"
    },
    "enemy_cyan": {"source_file": "characters/cyan/__Idle.gif", "game_type_id": "enemy_cyan", "tooltip": "", "category": "enemy"},
    "enemy_green": { "source_file": "characters/green/__Idle.gif", "game_type_id": "enemy_green", "tooltip": "", "category": "enemy"},
    "enemy_pink": { "source_file": "characters/pink/__Idle.gif", "game_type_id": "enemy_pink", "tooltip": "", "category": "enemy"},
    "enemy_purple": { "source_file": "characters/purple/__Idle.gif", "game_type_id": "enemy_purple", "tooltip": "", "category": "enemy"},
    "enemy_red": { "source_file": "characters/red/__Idle.gif", "game_type_id": "enemy_red", "tooltip": "", "category": "enemy"},
    "enemy_yellow": { "source_file": "characters/yellow/__Idle.gif", "game_type_id": "enemy_yellow", "tooltip": "", "category": "enemy"},
    "chest": {"source_file": "characters/items/chest.gif", "game_type_id": "chest", "tooltip": "Chest", "category": "item"},
    "platform_wall_gray": {"surface_params": (TS, TS, getattr(C, 'GRAY', (128,128,128))), "colorable": True, "game_type_id": "platform_wall_gray", "tooltip": "Wall (Gray)", "category": "tile"},
    "platform_wall_gray_2x2_placer": {"icon_type": "2x2_placer", "base_color_tuple": getattr(C, 'GRAY', (128,128,128)), "places_asset_key": "platform_wall_gray", "game_type_id": "tool_wall_2x2_placer", "tooltip": "Wall 2x2 (Gray)", "category": "tool"},
    "platform_ledge_green": {"surface_params": (TS, TS // 4, getattr(C, 'DARK_GREEN', (0,100,0))), "colorable": True, "game_type_id": "platform_ledge_green", "tooltip": "Ledge (Green)", "category": "tile"},
    "platform_wall_gray_left_half": {"render_mode": "half_tile", "half_type": "left", "base_color_tuple": getattr(C, 'GRAY', (128,128,128)), "colorable": True, "game_type_id": "platform_wall_gray_left_half", "tooltip": "Wall L-Half (Gray)", "category": "tile"},
    "platform_wall_gray_right_half": {"render_mode": "half_tile", "half_type": "right", "base_color_tuple": getattr(C, 'GRAY', (128,128,128)), "colorable": True, "game_type_id": "platform_wall_gray_right_half", "tooltip": "Wall R-Half (Gray)", "category": "tile"},
    "platform_wall_gray_top_half": {"render_mode": "half_tile", "half_type": "top", "base_color_tuple": getattr(C, 'GRAY', (128,128,128)), "colorable": True, "game_type_id": "platform_wall_gray_top_half", "tooltip": "Wall T-Half (Gray)", "category": "tile"},
    "platform_wall_gray_bottom_half": {"render_mode": "half_tile", "half_type": "bottom", "base_color_tuple": getattr(C, 'GRAY', (128,128,128)), "colorable": True, "game_type_id": "platform_wall_gray_bottom_half", "tooltip": "Wall B-Half (Gray)", "category": "tile"},
    "platform_ledge_green_left_half": {"render_mode": "half_tile", "half_type": "left", "base_color_tuple": getattr(C, 'DARK_GREEN', (0,100,0)), "colorable": True, "game_type_id": "platform_ledge_green_left_half", "tooltip": "Ledge L-Half (Green)", "category": "tile"},
    "platform_ledge_green_right_half": {"render_mode": "half_tile", "half_type": "right", "base_color_tuple": getattr(C, 'DARK_GREEN', (0,100,0)), "colorable": True, "game_type_id": "platform_ledge_green_right_half", "tooltip": "Ledge R-Half (Green)", "category": "tile"},
    "platform_ledge_green_top_half": {"render_mode": "half_tile", "half_type": "top", "base_color_tuple": getattr(C, 'DARK_GREEN', (0,100,0)), "colorable": True, "game_type_id": "platform_ledge_green_top_half", "tooltip": "Ledge T-Half (Green)", "category": "tile"},
    "platform_ledge_green_bottom_half": {"render_mode": "half_tile", "half_type": "bottom", "base_color_tuple": getattr(C, 'DARK_GREEN', (0,100,0)), "colorable": True, "game_type_id": "platform_ledge_green_bottom_half", "tooltip": "Ledge B-Half (Green)", "category": "tile"},
    "hazard_lava_tile": {"surface_params": (TS, TS, getattr(C, 'ORANGE_RED', (255,69,0))), "colorable": True, "game_type_id": "hazard_lava", "tooltip": "Lava Tile", "category": "hazard"},
}

EDITOR_PALETTE_ASSETS_CATEGORIES_ORDER = ["tool", "tile", "hazard", "item", "enemy", "spawn", "unknown"]

DEFAULT_MAP_WIDTH_TILES = 30
DEFAULT_MAP_HEIGHT_TILES = 20
DEFAULT_GRID_SIZE = TS
DEFAULT_BACKGROUND_COLOR: Tuple[int,int,int] = getattr(C, 'LIGHT_BLUE', (173,216,230))

LEVEL_EDITOR_SAVE_FORMAT_EXTENSION = ".json"
GAME_LEVEL_FILE_EXTENSION = ".py"

TOOLTIP_FONT_SIZE = 18
TOOLTIP_TEXT_COLOR: Tuple[int,int,int] = getattr(C, 'BLACK', (0,0,0))
TOOLTIP_BG_COLOR: Tuple[int,int,int] = (240, 240, 210)
TOOLTIP_PADDING = 5
TOOLTIP_OFFSET_Y = 25

COLOR_PICKER_PRESETS: Dict[str, Tuple[int,int,int]] = {
    "Light Blue": getattr(C, 'LIGHT_BLUE', (173,216,230)), "White": getattr(C, 'WHITE', (255,255,255)),
    "Black": getattr(C, 'BLACK', (0,0,0)), "Gray": getattr(C, 'GRAY', (128,128,128)),
    "Dark Gray": getattr(C, 'DARK_GRAY', (50,50,50)), "Red": getattr(C, 'RED', (255,0,0)),
    "Green": getattr(C, 'GREEN', (0,255,0)), "Blue": getattr(C, 'BLUE', (0,0,255)),
    "Yellow": getattr(C, 'YELLOW', (255,255,0)), "Orange": getattr(C, 'ORANGE_RED', (255,69,0)),
    "Purple": (128, 0, 128), "Brown": (139, 69, 19),
    "Dark Green": getattr(C, 'DARK_GREEN', (0,100,0)), "Sky Blue": (100, 150, 255),
    "Dark Purple": (75,0,130), "Sand": (244,164,96),
    "Magenta": getattr(C, 'MAGENTA', (255, 0, 255))
}

FONT_CONFIG: Dict[str, Optional[pygame.font.Font]] = {
    "small": None, "medium": None, "large": None, "tooltip": None
}
try:
    if not pygame.font.get_init():
        pygame.font.init()
    if pygame.font.get_init():
        FONT_CONFIG["small"] = pygame.font.Font(None, 22)
        FONT_CONFIG["medium"] = pygame.font.Font(None, 28)
        FONT_CONFIG["large"] = pygame.font.Font(None, 36)
        FONT_CONFIG["tooltip"] = pygame.font.Font(None, TOOLTIP_FONT_SIZE)
except pygame.error as e:
    print(f"CRITICAL CONFIG ERROR: Pygame error initializing fonts: {e}"); traceback.print_exc()
except Exception as e_font:
    print(f"CRITICAL CONFIG ERROR: Generic error initializing fonts: {e_font}"); traceback.print_exc()

########## START OF FILE: editor\editor_drawing.py ##########

# editor_drawing.py
# -*- coding: utf-8 -*-
"""
## version 1.0.0.18 (Added menu button for Rename Map)
Contains functions for drawing the different sections and elements
of the Platformer Level Editor UI using Pygame.
"""
import pygame
from typing import Dict, Tuple, Any, Optional
import traceback

import editor_config as ED_CONFIG
from editor_state import EditorState
from editor_ui import draw_button


def draw_menu_ui(surface: pygame.Surface, editor_state: EditorState, menu_section_rect: pygame.Rect,
                 fonts: Dict[str, Optional[pygame.font.Font]], mouse_pos: Tuple[int, int]):
    try:
        pygame.draw.rect(surface, getattr(ED_CONFIG.C, 'BLACK', (0,0,0)), menu_section_rect)
        title_font = fonts.get("large") or ED_CONFIG.FONT_CONFIG.get("large")
        button_font = fonts.get("medium") or ED_CONFIG.FONT_CONFIG.get("medium")

        if title_font:
            title_surf = title_font.render("Level Editor", True, getattr(ED_CONFIG.C, 'WHITE', (255,255,255)))
            title_rect = title_surf.get_rect(centerx=menu_section_rect.centerx, top=menu_section_rect.top + 20)
            surface.blit(title_surf, title_rect)

        button_w = ED_CONFIG.BUTTON_WIDTH_STANDARD
        button_h = ED_CONFIG.BUTTON_HEIGHT_STANDARD
        spacing = 12 # Adjusted spacing to fit new button
        num_buttons = 5 # New total (New, Load, Rename, Delete, Quit)
        total_button_h = (num_buttons * button_h) + ((num_buttons - 1) * spacing)
        title_h_approx = title_font.get_height() if title_font else 40
        content_start_y = menu_section_rect.top + title_h_approx + 30

        # Adjust start_y if menu height is fixed or allow dynamic centering
        if menu_section_rect.height < total_button_h + (content_start_y - menu_section_rect.top) + 20 : # check if content overflows
             start_y = content_start_y # Start from top if no room to center
        else:
             remaining_h = menu_section_rect.height - (content_start_y - menu_section_rect.top)
             start_y = content_start_y + (remaining_h - total_button_h) // 2
        start_y = max(start_y, menu_section_rect.top + title_h_approx + 20)


        if not hasattr(editor_state, 'ui_elements_rects') or editor_state.ui_elements_rects is None:
            editor_state.ui_elements_rects = {}
        for k in [key for key in editor_state.ui_elements_rects if key.startswith("menu_")]:
            del editor_state.ui_elements_rects[k]

        if button_font:
            rect_params = [
                (start_y, "menu_new_map", "New Map"),
                (start_y + button_h + spacing, "menu_load_map", "Load Map"),
                (start_y + 2 * (button_h + spacing), "menu_rename_map", "Rename Map"), # Added Rename Map button
                (start_y + 3 * (button_h + spacing), "menu_delete_map", "Delete Map"),
                (start_y + 4 * (button_h + spacing), "menu_quit", "Quit Editor")
            ]
            for top_y, key, text in rect_params:
                btn_r = pygame.Rect(0,0,button_w,button_h)
                btn_r.centerx = menu_section_rect.centerx
                btn_r.top = top_y
                editor_state.ui_elements_rects[key] = btn_r
                draw_button(surface, btn_r, text, button_font, mouse_pos)
        else:
            print("Warning DRAW: Menu button font missing.")
    except Exception as e:
        print(f"ERROR DRAW: Exception in draw_menu_ui: {e}")
        traceback.print_exc()

def _regenerate_minimap_surface(editor_state: EditorState, available_width: int, available_height: int):
    if not editor_state.map_content_surface:
        editor_state.minimap_surface = None
        return

    map_px_w = editor_state.get_map_pixel_width()
    map_px_h = editor_state.get_map_pixel_height()

    if map_px_w <= 0 or map_px_h <= 0:
        editor_state.minimap_surface = None
        return

    scale_w = available_width / map_px_w if map_px_w > 0 else 0
    scale_h = available_height / map_px_h if map_px_h > 0 else 0
    scale = min(scale_w, scale_h) if scale_w > 0 and scale_h > 0 else 0

    minimap_w = int(map_px_w * scale)
    minimap_h = int(map_px_h * scale)

    if minimap_w <=0 or minimap_h <=0:
        editor_state.minimap_surface = pygame.Surface((1,1))
        editor_state.minimap_surface.fill(ED_CONFIG.MINIMAP_BG_COLOR)
        return

    minimap_content_surf = pygame.Surface((map_px_w, map_px_h))
    minimap_content_surf.fill(editor_state.background_color)

    ts = editor_state.grid_size
    for obj in editor_state.placed_objects:
        asset_key = obj.get("asset_editor_key")
        world_x, world_y = obj.get("world_x"), obj.get("world_y")
        if asset_key is None or world_x is None or world_y is None: continue

        asset_palette_info = editor_state.assets_palette.get(asset_key)
        if not asset_palette_info: continue

        obj_color_override = obj.get("override_color")

        final_color_for_minimap_obj = getattr(ED_CONFIG.C, "LIGHT_GRAY", (200,200,200))
        is_colorable = asset_palette_info.get("colorable", False)

        if is_colorable and obj_color_override:
            final_color_for_minimap_obj = obj_color_override
        elif asset_palette_info.get("surface_params_dims_color"):
            final_color_for_minimap_obj = asset_palette_info["surface_params_dims_color"][2]
        elif asset_palette_info.get("base_color_tuple"):
            final_color_for_minimap_obj = asset_palette_info["base_color_tuple"]

        draw_w, draw_h = ts, ts
        draw_x, draw_y = world_x, world_y

        original_dims = asset_palette_info.get("original_size_pixels")
        if original_dims:
            draw_w, draw_h = original_dims[0], original_dims[1]

        if asset_palette_info.get("render_mode") == "half_tile":
            half_type = asset_palette_info.get("half_type")
            if half_type == "left": draw_w = ts // 2
            elif half_type == "right": draw_x = world_x + ts // 2; draw_w = ts // 2
            elif half_type == "top": draw_h = ts // 2
            elif half_type == "bottom": draw_y = world_y + ts // 2; draw_h = ts // 2

        obj_rect_on_map = pygame.Rect(draw_x, draw_y, draw_w, draw_h)

        if asset_palette_info.get("surface_params_dims_color") or \
           asset_palette_info.get("render_mode") == "half_tile" or \
           (is_colorable and obj_color_override):
            try:
                pygame.draw.rect(minimap_content_surf, final_color_for_minimap_obj, obj_rect_on_map)
            except TypeError:
                 pygame.draw.rect(minimap_content_surf, getattr(ED_CONFIG.C, "MAGENTA", (255,0,255)), obj_rect_on_map)
        elif asset_palette_info.get("image"):
            # For images on minimap, you might want to draw a simplified representation
            # or skip them if they are too detailed or slow to render at small scale.
            # For now, let's draw a colored rect if no simple color is available.
            if not (is_colorable and obj_color_override) and \
               not asset_palette_info.get("surface_params_dims_color") and \
               not asset_palette_info.get("base_color_tuple"):
                pygame.draw.rect(minimap_content_surf, getattr(ED_CONFIG.C, "GRAY", (128,128,128)), obj_rect_on_map)


    if editor_state.show_grid:
        grid_color_minimap = (50,50,50)
        for x_coord in range(0, map_px_w, ts):
            pygame.draw.line(minimap_content_surf, grid_color_minimap, (x_coord,0), (x_coord, map_px_h))
        for y_coord in range(0, map_px_h, ts):
            pygame.draw.line(minimap_content_surf, grid_color_minimap, (0, y_coord), (map_px_w, y_coord))


    try:
        editor_state.minimap_surface = pygame.transform.smoothscale(minimap_content_surf, (minimap_w, minimap_h))
    except pygame.error as e:
        print(f"ERROR DRAW: Minimap smoothscale failed: {e}. Using simple scale.")
        try:
            editor_state.minimap_surface = pygame.transform.scale(minimap_content_surf, (minimap_w, minimap_h))
        except pygame.error as e_simple:
            print(f"ERROR DRAW: Minimap simple scale also failed: {e_simple}.")
            editor_state.minimap_surface = pygame.Surface((minimap_w if minimap_w > 0 else 1, minimap_h if minimap_h > 0 else 1))
            editor_state.minimap_surface.fill(ED_CONFIG.MINIMAP_BG_COLOR)

    editor_state.minimap_needs_regeneration = False


def _draw_minimap(surface: pygame.Surface, editor_state: EditorState, palette_section_rect: pygame.Rect, map_view_rect: pygame.Rect):
    if not editor_state.map_content_surface: return

    minimap_outer_rect_width = palette_section_rect.width - (ED_CONFIG.MINIMAP_PADDING * 2)
    minimap_outer_rect_height = ED_CONFIG.MINIMAP_AREA_HEIGHT - (ED_CONFIG.MINIMAP_PADDING * 2)

    minimap_outer_rect = pygame.Rect(
        palette_section_rect.left + ED_CONFIG.MINIMAP_PADDING,
        palette_section_rect.top + ED_CONFIG.MINIMAP_PADDING,
        minimap_outer_rect_width,
        minimap_outer_rect_height
    )
    pygame.draw.rect(surface, ED_CONFIG.MINIMAP_BG_COLOR, minimap_outer_rect)

    minimap_draw_area_width = minimap_outer_rect.width
    minimap_draw_area_height = minimap_outer_rect.height

    if editor_state.minimap_needs_regeneration:
        _regenerate_minimap_surface(editor_state, minimap_draw_area_width, minimap_draw_area_height)

    if editor_state.minimap_surface:
        minimap_blit_x = minimap_outer_rect.left + (minimap_outer_rect.width - editor_state.minimap_surface.get_width()) // 2
        minimap_blit_y = minimap_outer_rect.top + (minimap_outer_rect.height - editor_state.minimap_surface.get_height()) // 2

        actual_minimap_screen_rect = editor_state.minimap_surface.get_rect(topleft=(minimap_blit_x, minimap_blit_y))
        editor_state.minimap_rect_in_palette = actual_minimap_screen_rect

        surface.blit(editor_state.minimap_surface, actual_minimap_screen_rect.topleft)
        pygame.draw.rect(surface, ED_CONFIG.MINIMAP_BORDER_COLOR, actual_minimap_screen_rect, 1)

        map_px_w = editor_state.get_map_pixel_width()
        map_px_h = editor_state.get_map_pixel_height()
        if map_px_w > 0 and map_px_h > 0 and editor_state.minimap_surface.get_width() > 0:
            scale_x = editor_state.minimap_surface.get_width() / map_px_w
            scale_y = editor_state.minimap_surface.get_height() / map_px_h
            cam_rect_mm_x = editor_state.camera_offset_x * scale_x
            cam_rect_mm_y = editor_state.camera_offset_y * scale_y
            cam_rect_mm_w = map_view_rect.width * scale_x
            cam_rect_mm_h = map_view_rect.height * scale_y
            cam_view_on_minimap = pygame.Rect(
                actual_minimap_screen_rect.left + cam_rect_mm_x,
                actual_minimap_screen_rect.top + cam_rect_mm_y,
                max(1, cam_rect_mm_w), max(1, cam_rect_mm_h)
            )
            s = pygame.Surface(cam_view_on_minimap.size, pygame.SRCALPHA)
            s.fill((*ED_CONFIG.MINIMAP_CAMERA_VIEW_RECT_COLOR, ED_CONFIG.MINIMAP_CAMERA_VIEW_RECT_ALPHA))
            surface.blit(s, cam_view_on_minimap.topleft)
            pygame.draw.rect(surface, ED_CONFIG.MINIMAP_CAMERA_VIEW_RECT_COLOR, cam_view_on_minimap, 1)


def _draw_single_palette_item(scroll_surf: pygame.Surface,
                              editor_state: EditorState,
                              palette_section_rect: pygame.Rect,
                              asset_key: str, asset_data: Dict[str, Any],
                              item_x: int, item_y_on_scroll: int,
                              tip_font: Optional[pygame.font.Font],
                              mouse_pos: Tuple[int, int]) -> int:
    img = asset_data.get("image")
    tooltip_text = asset_data.get("tooltip", asset_key)
    if not img: return 0

    scrollable_content_y_start_on_screen = palette_section_rect.top + ED_CONFIG.MINIMAP_AREA_HEIGHT
    item_rect_on_screen = pygame.Rect(
        palette_section_rect.left + item_x,
        scrollable_content_y_start_on_screen + item_y_on_scroll - int(editor_state.asset_palette_scroll_y), # scroll_y is float
        img.get_width(), img.get_height()
    )
    editor_state.ui_elements_rects['asset_palette_items'][asset_key] = item_rect_on_screen

    asset_list_visible_area_on_screen = pygame.Rect(
        palette_section_rect.left,
        scrollable_content_y_start_on_screen,
        palette_section_rect.width,
        palette_section_rect.height - ED_CONFIG.MINIMAP_AREA_HEIGHT - (ED_CONFIG.BUTTON_HEIGHT_STANDARD*0.8 + ED_CONFIG.ASSET_PALETTE_ITEM_PADDING*2) # type: ignore
    )
    is_hovered = item_rect_on_screen.collidepoint(mouse_pos) and asset_list_visible_area_on_screen.collidepoint(mouse_pos)
    is_selected = editor_state.selected_asset_editor_key == asset_key

    if is_hovered:
        editor_state.hovered_tooltip_text = tooltip_text
        editor_state.hovered_tooltip_pos = mouse_pos
        hover_bg_r = pygame.Rect(item_x - 2, item_y_on_scroll - 2, img.get_width() + 4, img.get_height() + 4)
        pygame.draw.rect(scroll_surf, ED_CONFIG.ASSET_PALETTE_HOVER_BG_COLOR, hover_bg_r, border_radius=2)
    if is_selected:
        select_b_r = pygame.Rect(item_x - 3, item_y_on_scroll - 3, img.get_width() + 6, img.get_height() + 6)
        pygame.draw.rect(scroll_surf, ED_CONFIG.C.YELLOW, select_b_r, 2, border_radius=3) # type: ignore

    scroll_surf.blit(img, (item_x, item_y_on_scroll))
    current_item_total_height = img.get_height()

    if tip_font:
        name_s = tip_font.render(tooltip_text, True, ED_CONFIG.ASSET_PALETTE_TOOLTIP_COLOR)
        text_x = item_x + (img.get_width() - name_s.get_width()) // 2
        scroll_surf.blit(name_s, (max(item_x, text_x), item_y_on_scroll + img.get_height() + ED_CONFIG.ASSET_PALETTE_TOOLTIP_TEXT_V_OFFSET))
        current_item_total_height += name_s.get_height() + ED_CONFIG.ASSET_PALETTE_TOOLTIP_TEXT_V_OFFSET
    return current_item_total_height


def draw_asset_palette_ui(surface: pygame.Surface, editor_state: EditorState, palette_section_rect: pygame.Rect,
                          fonts: Dict[str, Optional[pygame.font.Font]], mouse_pos: Tuple[int, int],
                          map_view_rect: pygame.Rect):
    try:
        _draw_minimap(surface, editor_state, palette_section_rect, map_view_rect)

        scrollable_assets_y_start = palette_section_rect.top + ED_CONFIG.MINIMAP_AREA_HEIGHT
        scrollable_assets_height = palette_section_rect.height - ED_CONFIG.MINIMAP_AREA_HEIGHT \
                                   - (ED_CONFIG.BUTTON_HEIGHT_STANDARD * 0.8 + ED_CONFIG.ASSET_PALETTE_ITEM_PADDING * 2) # type: ignore

        scrollable_assets_rect_on_screen = pygame.Rect(
            palette_section_rect.left, scrollable_assets_y_start,
            palette_section_rect.width, scrollable_assets_height
        )
        pygame.draw.rect(surface, ED_CONFIG.ASSET_PALETTE_BG_COLOR, scrollable_assets_rect_on_screen)

        if editor_state.total_asset_palette_content_height <= 0:
            font_small = fonts.get("small") or ED_CONFIG.FONT_CONFIG.get("small")
            if font_small:
                no_assets_text = "Assets Loading..."
                if not ED_CONFIG.EDITOR_PALETTE_ASSETS: no_assets_text = "No assets defined."
                elif not editor_state.assets_palette : no_assets_text = "Asset palette empty."
                msg_surf = font_small.render(no_assets_text, True, getattr(ED_CONFIG.C, 'WHITE', (255,255,255)))
                surface.blit(msg_surf, msg_surf.get_rect(center=scrollable_assets_rect_on_screen.center))

        if editor_state.total_asset_palette_content_height > 0:
            scroll_surf = pygame.Surface((palette_section_rect.width, editor_state.total_asset_palette_content_height), pygame.SRCALPHA)
            scroll_surf.fill((0,0,0,0)) # Transparent background for scroll surface
            current_y_on_scroll_surf = ED_CONFIG.ASSET_PALETTE_ITEM_PADDING
            cat_font = fonts.get("medium") or ED_CONFIG.FONT_CONFIG.get("medium")
            tip_font = fonts.get("small") or ED_CONFIG.FONT_CONFIG.get("small")
            editor_state.hovered_tooltip_text = None
            if not hasattr(editor_state, 'ui_elements_rects') or editor_state.ui_elements_rects is None:
                editor_state.ui_elements_rects = {}
            editor_state.ui_elements_rects['asset_palette_items'] = {}
            categories_order = getattr(ED_CONFIG, 'EDITOR_PALETTE_ASSETS_CATEGORIES_ORDER',
                                    ["tool", "tile", "hazard", "item", "enemy", "spawn", "unknown"])
            for cat_name in categories_order:
                assets_in_category_tuples = [(k, d) for k, d in editor_state.assets_palette.items() if d.get("category", "unknown") == cat_name]
                if not assets_in_category_tuples: continue
                if cat_font:
                    cat_surf = cat_font.render(cat_name.title(), True, ED_CONFIG.ASSET_PALETTE_CATEGORY_TEXT_COLOR)
                    scroll_surf.blit(cat_surf, (ED_CONFIG.ASSET_PALETTE_ITEM_PADDING, current_y_on_scroll_surf))
                    current_y_on_scroll_surf += cat_surf.get_height() + ED_CONFIG.ASSET_PALETTE_ITEM_PADDING
                row_start_y_for_current_items = current_y_on_scroll_surf
                if cat_name == "spawn":
                    p1 = next(((k,d) for k,d in assets_in_category_tuples if k == "player1_spawn"), None)
                    p2 = next(((k,d) for k,d in assets_in_category_tuples if k == "player2_spawn"), None)
                    other = [i for i in assets_in_category_tuples if i[0] not in ["player1_spawn", "player2_spawn"]]
                    curr_x, max_h = ED_CONFIG.ASSET_PALETTE_ITEM_PADDING, 0
                    if p1:
                        h = _draw_single_palette_item(scroll_surf, editor_state, palette_section_rect, p1[0], p1[1], curr_x, row_start_y_for_current_items, tip_font, mouse_pos)
                        max_h = max(max_h, h); curr_x += (p1[1]["image"].get_width() + ED_CONFIG.ASSET_PALETTE_ITEM_PADDING) if p1[1].get("image") else 0
                    if p2:
                        p2_img = p2[1].get("image")
                        if p2_img and curr_x + p2_img.get_width() > palette_section_rect.width - ED_CONFIG.ASSET_PALETTE_ITEM_PADDING:
                            current_y_on_scroll_surf = row_start_y_for_current_items + max_h + ED_CONFIG.ASSET_PALETTE_ITEM_PADDING
                            row_start_y_for_current_items = current_y_on_scroll_surf; curr_x = ED_CONFIG.ASSET_PALETTE_ITEM_PADDING; max_h = 0
                        h = _draw_single_palette_item(scroll_surf, editor_state, palette_section_rect, p2[0], p2[1], curr_x, row_start_y_for_current_items, tip_font, mouse_pos)
                        max_h = max(max_h, h)
                    if max_h > 0: current_y_on_scroll_surf = row_start_y_for_current_items + max_h + ED_CONFIG.ASSET_PALETTE_ITEM_PADDING
                    assets_to_draw_this_category_loop = other
                else:
                    assets_to_draw_this_category_loop = assets_in_category_tuples
                for asset_key, asset_data in assets_to_draw_this_category_loop:
                    item_h = _draw_single_palette_item(scroll_surf, editor_state, palette_section_rect, asset_key, asset_data, ED_CONFIG.ASSET_PALETTE_ITEM_PADDING, current_y_on_scroll_surf, tip_font, mouse_pos)
                    current_y_on_scroll_surf += item_h + ED_CONFIG.ASSET_PALETTE_ITEM_PADDING
                if assets_in_category_tuples: current_y_on_scroll_surf += ED_CONFIG.ASSET_PALETTE_ITEM_PADDING

            # Blit the scrollable surface with the current scroll_y offset
            surface.blit(scroll_surf, scrollable_assets_rect_on_screen.topleft,
                        (0, int(editor_state.asset_palette_scroll_y), scrollable_assets_rect_on_screen.width, scrollable_assets_rect_on_screen.height)) # scroll_y is float

        pygame.draw.rect(surface, getattr(ED_CONFIG.C, 'GRAY', (128,128,128)), scrollable_assets_rect_on_screen, 1)

        btn_font = fonts.get("small") or ED_CONFIG.FONT_CONFIG.get("small")
        if btn_font:
            btn_h = ED_CONFIG.BUTTON_HEIGHT_STANDARD*0.8
            cp_btn_r = pygame.Rect(palette_section_rect.left+ED_CONFIG.ASSET_PALETTE_ITEM_PADDING,
                                   palette_section_rect.bottom-btn_h-ED_CONFIG.ASSET_PALETTE_ITEM_PADDING,
                                   palette_section_rect.width-ED_CONFIG.ASSET_PALETTE_ITEM_PADDING*2, int(btn_h))
            editor_state.ui_elements_rects["palette_bg_color_button"] = cp_btn_r
            bg_lum = sum(editor_state.background_color)/3
            txt_col = getattr(ED_CONFIG.C, 'BLACK', (0,0,0)) if bg_lum > 192 else getattr(ED_CONFIG.C, 'WHITE', (255,255,255)) # type: ignore
            draw_button(surface,cp_btn_r,"BG Color",btn_font,mouse_pos,text_color=txt_col,button_color_normal=editor_state.background_color,button_color_hover=pygame.Color(editor_state.background_color).lerp(getattr(ED_CONFIG.C, 'WHITE', (255,255,255)),0.3),border_color=getattr(ED_CONFIG.C, 'BLACK', (0,0,0))) # type: ignore

        pygame.draw.rect(surface, getattr(ED_CONFIG.C, 'DARK_GRAY', (50,50,50)), palette_section_rect, 2)
    except Exception as e:
        print(f"ERROR DRAW: draw_asset_palette_ui: {e}")
        traceback.print_exc()


def draw_map_view_ui(surface: pygame.Surface, editor_state: EditorState, map_view_rect: pygame.Rect,
                     fonts: Dict[str, Optional[pygame.font.Font]], mouse_pos: Tuple[int, int]):
    try:
        if not editor_state.map_content_surface:
            pygame.draw.rect(surface, getattr(ED_CONFIG.C, 'DARK_GRAY', (50,50,50)), map_view_rect)
            ph_font = fonts.get("medium") or ED_CONFIG.FONT_CONFIG.get("medium")
            if ph_font:
                txt_surf = ph_font.render("No Map/Surface Error", True, getattr(ED_CONFIG.C, 'WHITE', (255,255,255)))
                surface.blit(txt_surf, txt_surf.get_rect(center=map_view_rect.center))
            pygame.draw.rect(surface, ED_CONFIG.MAP_VIEW_BORDER_COLOR, map_view_rect, 2)
            return

        editor_state.map_content_surface.fill(editor_state.background_color)
        ts = editor_state.grid_size
        for obj in editor_state.placed_objects:
            asset_key = obj.get("asset_editor_key")
            world_x, world_y = obj.get("world_x"), obj.get("world_y")
            if asset_key is None or world_x is None or world_y is None: continue
            asset_palette_info = editor_state.assets_palette.get(asset_key)
            if not asset_palette_info:
                pygame.draw.rect(editor_state.map_content_surface, getattr(ED_CONFIG.C, 'RED', (255,0,0)), (world_x,world_y,ts,ts),1)
                continue

            image_to_draw_from_palette = asset_palette_info.get("image")
            override_color = obj.get("override_color")
            final_image_for_map = None

            is_colorable = asset_palette_info.get("colorable", False)
            current_color = override_color if is_colorable and override_color else None

            if asset_palette_info.get("render_mode") == "half_tile":
                color_to_use = current_color if current_color else asset_palette_info.get("base_color_tuple")
                if color_to_use:
                    temp_half_surf = pygame.Surface((ts, ts), pygame.SRCALPHA); temp_half_surf.fill((0,0,0,0))
                    half_type = asset_palette_info.get("half_type", "left")
                    rect_to_draw = pygame.Rect(0,0,0,0)
                    if half_type == "left": rect_to_draw = pygame.Rect(0, 0, ts // 2, ts)
                    elif half_type == "right": rect_to_draw = pygame.Rect(ts // 2, 0, ts // 2, ts)
                    elif half_type == "top": rect_to_draw = pygame.Rect(0, 0, ts, ts // 2)
                    elif half_type == "bottom": rect_to_draw = pygame.Rect(0, ts // 2, ts, ts // 2)
                    pygame.draw.rect(temp_half_surf, color_to_use, rect_to_draw)
                    final_image_for_map = temp_half_surf
            elif asset_palette_info.get("surface_params_dims_color"):
                w, h, default_color_from_def = asset_palette_info["surface_params_dims_color"]
                color_to_use = current_color if current_color else default_color_from_def
                temp_param_surf = pygame.Surface((w,h)); temp_param_surf.fill(color_to_use) # type: ignore
                final_image_for_map = temp_param_surf
            elif image_to_draw_from_palette :
                if current_color:
                    tinted_surf = image_to_draw_from_palette.copy()
                    color_surface = pygame.Surface(tinted_surf.get_size(), pygame.SRCALPHA)
                    color_surface.fill((*current_color, 128))
                    tinted_surf.blit(color_surface, (0,0), special_flags=pygame.BLEND_RGBA_MULT) # type: ignore
                    final_image_for_map = tinted_surf
                else:
                    final_image_for_map = image_to_draw_from_palette

            if final_image_for_map:
                editor_state.map_content_surface.blit(final_image_for_map, (world_x, world_y))
            else:
                 pygame.draw.rect(editor_state.map_content_surface, getattr(ED_CONFIG.C, 'MAGENTA', (255,0,255)), (world_x,world_y,ts,ts),1)

        if editor_state.show_grid:
            draw_grid_on_map_surface(editor_state.map_content_surface, editor_state)

        surface.blit(editor_state.map_content_surface, map_view_rect.topleft, (int(editor_state.camera_offset_x), int(editor_state.camera_offset_y), map_view_rect.width, map_view_rect.height))
        pygame.draw.rect(surface, ED_CONFIG.MAP_VIEW_BORDER_COLOR, map_view_rect, 2)

        if editor_state.selected_asset_image_for_cursor:
            img = editor_state.selected_asset_image_for_cursor
            pos_on_screen = img.get_rect(center=mouse_pos).topleft
            if map_view_rect.collidepoint(mouse_pos):
                world_mx = mouse_pos[0]-map_view_rect.left+editor_state.camera_offset_x
                world_my = mouse_pos[1]-map_view_rect.top+editor_state.camera_offset_y
                grid_wx = (world_mx//editor_state.grid_size)*editor_state.grid_size
                grid_wy = (world_my//editor_state.grid_size)*editor_state.grid_size
                pos_on_screen = (grid_wx-int(editor_state.camera_offset_x)+map_view_rect.left, grid_wy-int(editor_state.camera_offset_y)+map_view_rect.top)

            clip_orig = surface.get_clip(); surface.set_clip(map_view_rect)
            surface.blit(img,pos_on_screen); surface.set_clip(clip_orig)

        _draw_map_view_info_text(surface, editor_state, map_view_rect, fonts, mouse_pos)
    except Exception as e:
        print(f"ERROR DRAW: draw_map_view_ui: {e}")
        traceback.print_exc()

def _draw_map_view_info_text(surface: pygame.Surface, editor_state: EditorState, map_view_rect: pygame.Rect,
                             fonts: Dict[str, Optional[pygame.font.Font]], general_mouse_pos: Tuple[int, int]):
    info_font = fonts.get("small") or ED_CONFIG.FONT_CONFIG.get("small")
    if not info_font: return

    coords_text_str = f"Cam:({int(editor_state.camera_offset_x)},{int(editor_state.camera_offset_y)})"
    if map_view_rect.collidepoint(general_mouse_pos):
        world_mx = general_mouse_pos[0]-map_view_rect.left+editor_state.camera_offset_x
        world_my = general_mouse_pos[1]-map_view_rect.top+editor_state.camera_offset_y
        tx,ty = world_mx//editor_state.grid_size, world_my//editor_state.grid_size
        coords_text_str += f" MouseW:({int(world_mx)},{int(world_my)}) Tile:({tx},{ty})"

    coords_surf = info_font.render(coords_text_str,True,getattr(ED_CONFIG.C, 'WHITE', (255,255,255)))
    coords_x_pos = map_view_rect.left + 5

    coords_y_pos = map_view_rect.top - coords_surf.get_height() - 4
    if coords_y_pos < 5:
        coords_y_pos = map_view_rect.bottom + 4
        if coords_y_pos + coords_surf.get_height() > surface.get_height() - 5:
            coords_y_pos = surface.get_height() - 5 - coords_surf.get_height()

    surface.blit(coords_surf, (coords_x_pos, coords_y_pos))

def draw_grid_on_map_surface(map_content_surface: pygame.Surface, editor_state: EditorState):
    if not (editor_state.show_grid and editor_state.map_content_surface and editor_state.grid_size > 0): return
    w,h,gs = editor_state.get_map_pixel_width(), editor_state.get_map_pixel_height(), editor_state.grid_size
    gc = getattr(ED_CONFIG, 'MAP_VIEW_GRID_COLOR', (128,128,128))
    try:
        for x_coord in range(0, w + gs, gs):
            pygame.draw.line(map_content_surface,gc,(x_coord,0),(x_coord,h))
        for y_coord in range(0, h + gs, gs):
            pygame.draw.line(map_content_surface,gc,(0,y_coord),(w,y_coord))
    except Exception as e:
        print(f"ERROR DRAW: draw_grid_on_map_surface: {e}")
        traceback.print_exc()

########## START OF FILE: editor\editor_handlers_dialog.py ##########

# editor/editor_handlers_dialog.py
# -*- coding: utf-8 -*-
"""
Handles Pygame events for active dialogs in the editor.
"""
import pygame
import os
import logging
from typing import Optional, Tuple

import editor_config as ED_CONFIG 
from editor_state import EditorState

logger = logging.getLogger(__name__)

def handle_dialog_events(event: pygame.event.Event, editor_state: EditorState):
    """
    Processes events when a dialog is active.
    Modifies editor_state based on interactions.
    """
    if not editor_state.active_dialog_type: 
        return

    confirmed, cancelled, selected_value = False, False, None
    dialog_type = editor_state.active_dialog_type

    if event.type == pygame.KEYDOWN:
        if event.key == pygame.K_ESCAPE: 
            cancelled = True
            editor_state.dialog_input_text_selected = False 
        elif event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
            if dialog_type=="text_input": 
                confirmed=True
                selected_value=editor_state.dialog_input_text
                editor_state.dialog_input_text_selected = False 
            elif dialog_type=="file_load" and editor_state.dialog_selected_file_index != -1 and \
                 0 <= editor_state.dialog_selected_file_index < len(editor_state.dialog_file_list):
                confirmed=True; selected_value=os.path.join(ED_CONFIG.MAPS_DIRECTORY, editor_state.dialog_file_list[editor_state.dialog_selected_file_index])
            elif dialog_type=="file_load": editor_state.set_status_message("No file selected.", 2.5)
        
        if dialog_type=="text_input":
            if event.key==pygame.K_BACKSPACE: 
                if editor_state.dialog_input_text_selected:
                    editor_state.dialog_input_text = ""
                    editor_state.dialog_input_text_selected = False
                else:
                    editor_state.dialog_input_text=editor_state.dialog_input_text[:-1]
            elif event.unicode.isprintable()and(event.unicode.isalnum()or event.unicode in ['.','_','-',' ',',','/','\\']): 
                if editor_state.dialog_input_text_selected:
                    editor_state.dialog_input_text = event.unicode
                    editor_state.dialog_input_text_selected = False
                else:
                    editor_state.dialog_input_text+=event.unicode
        elif dialog_type=="file_load" and editor_state.dialog_file_list:
            ll=len(editor_state.dialog_file_list)
            if ll>0:
                if event.key==pygame.K_UP: editor_state.dialog_selected_file_index=(editor_state.dialog_selected_file_index-1+ll)%ll
                elif event.key==pygame.K_DOWN: editor_state.dialog_selected_file_index=(editor_state.dialog_selected_file_index+1)%ll
            else: editor_state.dialog_selected_file_index=-1
            if editor_state.dialog_selected_file_index != -1:
                editor_state.dialog_input_text = editor_state.dialog_file_list[editor_state.dialog_selected_file_index]
            else:
                editor_state.dialog_input_text = ""
    elif event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
        if editor_state.dialog_rect and editor_state.dialog_rect.collidepoint(event.pos):
            if dialog_type=="color_picker":
                for name,rect in editor_state.color_picker_rects.items():
                    abs_rect=rect.move(editor_state.dialog_rect.left,editor_state.dialog_rect.top)
                    if abs_rect.collidepoint(event.pos): selected_value=ED_CONFIG.COLOR_PICKER_PRESETS.get(name); confirmed=bool(selected_value); break
            elif dialog_type=="file_load":
                ok_rect = editor_state.ui_elements_rects.get("dialog_file_load_ok")
                cancel_rect = editor_state.ui_elements_rects.get("dialog_file_load_cancel")
                if ok_rect and ok_rect.collidepoint(event.pos) and editor_state.dialog_selected_file_index != -1:
                    confirmed=True; selected_value=os.path.join(ED_CONFIG.MAPS_DIRECTORY, editor_state.dialog_file_list[editor_state.dialog_selected_file_index])
                elif cancel_rect and cancel_rect.collidepoint(event.pos): cancelled=True
                else:
                    for item_info in editor_state.ui_elements_rects.get('dialog_file_item_rects', []): 
                        if item_info["rect"].collidepoint(event.pos):
                            editor_state.dialog_selected_file_index=item_info["index"]
                            editor_state.dialog_input_text=item_info["text"]; break
                    scrollbar_handle_rect = editor_state.ui_elements_rects.get('file_dialog_scrollbar_handle')
                    if scrollbar_handle_rect and scrollbar_handle_rect.collidepoint(event.pos):
                        editor_state.is_dragging_scrollbar=True
                        editor_state.scrollbar_drag_mouse_offset_y=event.pos[1]-scrollbar_handle_rect.top
            elif dialog_type == "text_input": 
                input_box = editor_state.ui_elements_rects.get('dialog_text_input_box')
                if input_box and not input_box.collidepoint(event.pos): 
                    editor_state.dialog_input_text_selected = False
                elif input_box and input_box.collidepoint(event.pos): 
                    editor_state.dialog_input_text_selected = False 
        elif dialog_type!="text_input": 
            if not (editor_state.dialog_rect and editor_state.dialog_rect.collidepoint(event.pos)):
                 cancelled = True 
        elif dialog_type == "text_input": 
             if not (editor_state.dialog_rect and editor_state.dialog_rect.collidepoint(event.pos)):
                editor_state.dialog_input_text_selected = False
                cancelled = True


    elif event.type == pygame.MOUSEBUTTONUP and event.button == 1: editor_state.is_dragging_scrollbar=False
    elif event.type == pygame.MOUSEMOTION and editor_state.is_dragging_scrollbar:
        area,handle=editor_state.ui_elements_rects.get('file_dialog_scrollbar_area'), editor_state.ui_elements_rects.get('file_dialog_scrollbar_handle')
        if area and handle and editor_state.dialog_file_list:
            my_area=event.pos[1]-area.top; h_pos_y=my_area-editor_state.scrollbar_drag_mouse_offset_y
            font=ED_CONFIG.FONT_CONFIG.get("small"); item_h=(font.get_height()+6)if font else 22 
            content_h=len(editor_state.dialog_file_list)*item_h; display_h=area.height 
            track_h=max(1,display_h-handle.height); scroll_px=max(0,content_h-display_h) 
            if track_h>0 and scroll_px>0: clamped_y=max(0,min(h_pos_y,track_h)); ratio=clamped_y/track_h; editor_state.dialog_file_scroll_y=ratio*scroll_px
    elif event.type == pygame.MOUSEWHEEL and dialog_type=="file_load" and editor_state.dialog_rect and editor_state.dialog_rect.collidepoint(pygame.mouse.get_pos()):
        font_s=ED_CONFIG.FONT_CONFIG.get("small");item_h=(font_s.get_height()+6)if font_s else 22 
        scroll_v=event.y*item_h;content_h=len(editor_state.dialog_file_list)*item_h 
        font_m=ED_CONFIG.FONT_CONFIG.get("medium");prompt_h=(font_m.get_height()+25)if font_m else 55 
        btns_h=40;display_h=editor_state.dialog_rect.height-prompt_h-btns_h-10
        max_s=max(0,content_h-display_h);editor_state.dialog_file_scroll_y-=scroll_v;editor_state.dialog_file_scroll_y=max(0,min(editor_state.dialog_file_scroll_y,max_s))

    if confirmed or cancelled:
        logger.debug(f"Dialog '{dialog_type}' outcome: {'CONFIRMED' if confirmed else 'CANCELLED'}")
        cb_confirm, cb_cancel = editor_state.dialog_callback_confirm, editor_state.dialog_callback_cancel
        editor_state.active_dialog_type = None # This also sets dialog_input_text_selected to False
        if confirmed and cb_confirm:
            val_pass = selected_value
            logger.debug(f"Calling confirm_callback for '{dialog_type}' with value: '{val_pass}'")
            try: cb_confirm(val_pass) # type: ignore
            except Exception as e:logger.error(f"Err Confirm CB for {dialog_type}:{e}", exc_info=True)
        elif cancelled and cb_cancel:
            logger.debug(f"Calling cancel_callback for '{dialog_type}'.")
            try: cb_cancel()
            except Exception as e:logger.error(f"Err Cancel CB for {dialog_type}:{e}", exc_info=True)
        
        if editor_state.active_dialog_type is None: # Should always be true after setting above
            logger.debug("No new dialog active. Cleaning up dialog state.")
            editor_state.dialog_callback_confirm, editor_state.dialog_callback_cancel = None,None
            editor_state.dialog_input_text, editor_state.dialog_selected_file_index = "",-1
            editor_state.is_dragging_scrollbar = False

########## START OF FILE: editor\editor_handlers_global.py ##########

# editor/editor_handlers_global.py
# -*- coding: utf-8 -*-
"""
Handles global Pygame events for the editor (QUIT, RESIZE).
"""
import pygame
import logging
from editor_state import EditorState # Assuming EditorState is in the same directory or sys.path is set

logger = logging.getLogger(__name__)

def handle_global_events(event: pygame.event.Event, editor_state: EditorState, main_screen: pygame.Surface) -> bool:
    """
    Handles global events like QUIT and VIDEORESIZE.
    Returns False if a QUIT event is fully processed (application should exit), True otherwise.
    """
    if event.type == pygame.QUIT:
        logger.info("pygame.QUIT event received.")
        if editor_state.unsaved_changes:
            if not getattr(editor_state, '_quit_attempted_with_unsaved_changes', False):
                editor_state.set_status_message("Unsaved changes! Quit again to exit without saving, or save your map.", 5.0)
                setattr(editor_state, '_quit_attempted_with_unsaved_changes', True)
                return True  # Continue running, first quit attempt
            else:
                logger.info("Second quit attempt with unsaved changes. Proceeding to quit.")
                if hasattr(editor_state, '_quit_attempted_with_unsaved_changes'):
                    delattr(editor_state, '_quit_attempted_with_unsaved_changes')
                return False # Signal to quit
        else:
            if hasattr(editor_state, '_quit_attempted_with_unsaved_changes'):
                delattr(editor_state, '_quit_attempted_with_unsaved_changes')
            return False # Signal to quit

    if event.type == pygame.VIDEORESIZE:
        logger.info(f"pygame.VIDEORESIZE to {event.w}x{event.h}")
        # The main loop in editor.py will handle screen resizing and layout recalculation.
        # This function just acknowledges the event for logging or specific state changes if needed.
        editor_state.set_status_message(f"Resized to {event.w}x{event.h}", 2.0)
        editor_state.minimap_needs_regeneration = True # Flag for minimap to redraw
    
    # If any other event type clears the quit attempt flag
    if event.type != pygame.QUIT and hasattr(editor_state, '_quit_attempted_with_unsaved_changes'):
        delattr(editor_state, '_quit_attempted_with_unsaved_changes')
        logger.debug("Quit attempt flag cleared due to other event.")

    return True # Continue running

########## START OF FILE: editor\editor_handlers_map_editing.py ##########

# editor/editor_handlers_map_editing.py
# -*- coding: utf-8 -*-
"""
Handles Pygame events specifically for the map editing mode.
"""
import pygame
import os
import logging
from typing import Optional, Tuple

import editor_config as ED_CONFIG
from editor_state import EditorState
from editor_ui import start_color_picker_dialog # For BG color
from editor_map_utils import save_map_to_json, export_map_to_game_python_script
# _is_asset_colorable and _perform_flood_fill_color_change are not needed as tile color tool is removed

logger = logging.getLogger(__name__)

def SicherDelAttr(obj, name): # Utility
    if hasattr(obj, name): delattr(obj, name)

# --- Helper functions for map editing actions ---
def _place_single_tile_at_grid(editor_state: EditorState, asset_key_to_place: str, grid_coords: Tuple[int, int]):
    logger.debug(f"_place_single_tile_at_grid: Placing '{asset_key_to_place}' at {grid_coords}")
    gx, gy = grid_coords; wx, wy = gx * editor_state.grid_size, gy * editor_state.grid_size
    asset_data = editor_state.assets_palette.get(asset_key_to_place)
    if not asset_data: 
        logger.error(f"ERR PlaceSingle: No asset data for {asset_key_to_place}"); return
    
    game_id = asset_data["game_type_id"]
    is_spawn = asset_data.get("category")=="spawn"

    # Prevent duplicate non-spawn items at the same grid cell (based on game_type_id)
    if not is_spawn:
        for obj in editor_state.placed_objects:
            if obj.get("world_x")==wx and obj.get("world_y")==wy and obj.get("game_type_id")==game_id:
                logger.debug(f"Duplicate tile '{game_id}' at {grid_coords}, not placing.")
                return
    
    # If placing a spawn point, remove any existing spawn point of the same type
    if is_spawn: 
        editor_state.placed_objects = [o for o in editor_state.placed_objects if o.get("game_type_id")!=game_id]

    editor_state.placed_objects.append({
        "asset_editor_key":asset_key_to_place,
        "world_x":wx, "world_y":wy,
        "game_type_id":game_id
    })
    editor_state.unsaved_changes=True
    editor_state.minimap_needs_regeneration=True
    pygame.display.set_caption(f"Editor - {editor_state.map_name_for_function}.py*")

def _place_tile_at_grid(editor_state: EditorState, grid_coords: Tuple[int, int]):
    sel_key = editor_state.selected_asset_editor_key
    logger.debug(f"_place_tile_at_grid: current selected_asset_editor_key = '{sel_key}' for grid {grid_coords}")

    if not sel_key:
        logger.debug(f"_place_tile_at_grid: Bailing out. sel_key is None.")
        return

    sel_info = editor_state.assets_palette.get(sel_key)
    if not sel_info:
        logger.error(f"_place_tile_at_grid: No asset info for selected key '{sel_key}'")
        return

    # Handle special placer tools
    if sel_info.get("places_asset_key"): # e.g., 2x2 placer
        base_key_to_place = sel_info["places_asset_key"]
        if not base_key_to_place: 
            logger.error(f"ERR PlaceTile: Placer tool '{sel_key}' has no 'places_asset_key' defined."); return
        
        # Example for a 2x2 placer, can be generalized if more placers exist
        if sel_key == "platform_wall_gray_2x2_placer": # Example specific ID
            logger.debug(f"_place_tile_at_grid: Handling 2x2 placer for base_key '{base_key_to_place}' at {grid_coords}")
            for row_offset in range(2):
                for col_offset in range(2):
                    _place_single_tile_at_grid(editor_state, base_key_to_place, (grid_coords[0]+col_offset, grid_coords[1]+row_offset))
            return # Placer handled
        # Add other placer logic here if needed
    
    # Default: place the selected asset itself
    logger.debug(f"_place_tile_at_grid: Proceeding to place single tile for '{sel_key}' at {grid_coords}")
    _place_single_tile_at_grid(editor_state, sel_key, grid_coords)


def _erase_tile_at_grid(editor_state: EditorState, grid_coords: Tuple[int, int]):
    wx,wy = grid_coords[0]*editor_state.grid_size, grid_coords[1]*editor_state.grid_size
    erased_count = 0
    
    # Iterate backwards to safely remove items from the list
    for i in range(len(editor_state.placed_objects)-1,-1,-1):
        obj=editor_state.placed_objects[i]
        # Check if the object's bounding box (approximated by grid cell for simplicity here) contains the click
        # For more precise erase of larger objects, you'd need actual object dimensions
        if obj.get("world_x")==wx and obj.get("world_y")==wy:
            logger.info(f"Erasing object at {grid_coords}: {obj}")
            editor_state.placed_objects.pop(i)
            erased_count += 1
            # For now, erase only the first found object in a cell. 
            # If multiple objects can stack and need individual erase, this logic would need adjustment.
            break 
            
    if erased_count > 0:
        editor_state.unsaved_changes=True
        editor_state.minimap_needs_regeneration=True
        pygame.display.set_caption(f"Editor - {editor_state.map_name_for_function}.py*")
        editor_state.set_status_message(f"Erased {erased_count} object(s) @ ({grid_coords[0]},{grid_coords[1]})",1.5)


def _pan_camera_via_minimap_click(editor_state: EditorState, screen_click_pos: Tuple[int,int],
                                  map_view_rect: pygame.Rect, asset_palette_rect: pygame.Rect): # asset_palette_rect might not be needed
    if not editor_state.minimap_rect_in_palette or not editor_state.minimap_surface: return
    
    click_x_rel = screen_click_pos[0] - editor_state.minimap_rect_in_palette.left
    click_y_rel = screen_click_pos[1] - editor_state.minimap_rect_in_palette.top
    
    minimap_w = editor_state.minimap_surface.get_width(); minimap_h = editor_state.minimap_surface.get_height()
    if minimap_w == 0 or minimap_h == 0: return

    # Clamp click to be within the minimap surface dimensions
    click_x_rel = max(0, min(click_x_rel, minimap_w -1))
    click_y_rel = max(0, min(click_y_rel, minimap_h -1))

    map_px_w, map_px_h = editor_state.get_map_pixel_width(), editor_state.get_map_pixel_height()
    
    target_world_x = (click_x_rel / minimap_w) * map_px_w
    target_world_y = (click_y_rel / minimap_h) * map_px_h
    
    # Center the map view on the clicked world position
    new_cam_x = target_world_x - map_view_rect.width / 2
    new_cam_y = target_world_y - map_view_rect.height / 2
    
    max_cam_x = max(0, map_px_w - map_view_rect.width)
    max_cam_y = max(0, map_px_h - map_view_rect.height)
    
    editor_state.camera_offset_x = int(max(0, min(new_cam_x, max_cam_x)))
    editor_state.camera_offset_y = int(max(0, min(new_cam_y, max_cam_y)))
    editor_state.camera_momentum_pan = (0.0, 0.0) # Stop any existing camera pan momentum
    logger.debug(f"Minimap click: Panned camera to center around world ({target_world_x:.0f},{target_world_y:.0f}). New offset: ({editor_state.camera_offset_x},{editor_state.camera_offset_y})")


# --- Main event handler for map editing mode ---
def handle_editing_map_events(event: pygame.event.Event, editor_state: EditorState,
                              palette_section_rect: pygame.Rect, map_view_rect: pygame.Rect,
                              main_screen: pygame.Surface): # main_screen might not be needed
    general_mouse_pos = pygame.mouse.get_pos()

    if event.type == pygame.MOUSEWHEEL:
        asset_list_rect = pygame.Rect(
            palette_section_rect.left, 
            palette_section_rect.top + ED_CONFIG.MINIMAP_AREA_HEIGHT,
            palette_section_rect.width, 
            palette_section_rect.height - ED_CONFIG.MINIMAP_AREA_HEIGHT - (ED_CONFIG.BUTTON_HEIGHT_STANDARD*0.8+ED_CONFIG.ASSET_PALETTE_ITEM_PADDING*2) 
        )
        if asset_list_rect.collidepoint(general_mouse_pos):
            kick_value = -event.y * ED_CONFIG.ASSET_PALETTE_SCROLL_KICK_MULTIPLIER
            editor_state.asset_palette_scroll_momentum += kick_value
            
            current_momentum = editor_state.asset_palette_scroll_momentum
            max_momentum = ED_CONFIG.ASSET_PALETTE_MAX_MOMENTUM
            editor_state.asset_palette_scroll_momentum = max(-max_momentum, min(current_momentum, max_momentum))
            
            logger.debug(f"Asset palette MOUSEWHEEL: event.y={event.y}, kick={kick_value}, new momentum={editor_state.asset_palette_scroll_momentum}")

    elif event.type == pygame.MOUSEBUTTONDOWN:
        mouse_pos_click = event.pos
        logger.debug(f"MOUSEBUTTONDOWN event.button={event.button} at {mouse_pos_click}. Selected asset: '{editor_state.selected_asset_editor_key}'")
        
        if palette_section_rect.collidepoint(mouse_pos_click):
            editor_state.asset_palette_scroll_momentum = 0.0 # Stop fling on click in palette

        if event.button == 1: # Left Mouse Button
            if editor_state.minimap_rect_in_palette and editor_state.minimap_rect_in_palette.collidepoint(mouse_pos_click):
                logger.debug("Left click on minimap area.")
                editor_state.is_dragging_minimap_view = True
                _pan_camera_via_minimap_click(editor_state, mouse_pos_click, map_view_rect, palette_section_rect)
                return # Minimap click handled
            
            elif palette_section_rect.collidepoint(mouse_pos_click):
                logger.debug("Left click in asset palette section.")
                bg_btn = editor_state.ui_elements_rects.get("palette_bg_color_button")
                if bg_btn and bg_btn.collidepoint(mouse_pos_click):
                    logger.info("BG Color button clicked.")
                    def on_bg_sel(nc:Optional[Tuple[int,int,int]]):
                        if nc: 
                            editor_state.background_color=nc
                            editor_state.unsaved_changes=True
                            editor_state.minimap_needs_regeneration=True
                            pygame.display.set_caption(f"Editor - {editor_state.map_name_for_function}.py*")
                            editor_state.set_status_message(f"BG Color set to: {nc}")
                        else:
                            editor_state.set_status_message("BG Color selection cancelled.")
                    start_color_picker_dialog(editor_state,on_confirm=on_bg_sel,on_cancel=lambda: editor_state.set_status_message("BG Color selection cancelled."))
                    return # BG Color button handled
                
                # Check asset palette item clicks
                for key,rect in editor_state.ui_elements_rects.get('asset_palette_items',{}).items():
                    if rect.collidepoint(mouse_pos_click):
                        logger.info(f"Asset palette item '{key}' clicked.")
                        editor_state.selected_asset_editor_key = key
                        asset_data = editor_state.assets_palette.get(key)
                        if asset_data:
                             editor_state.set_status_message(f"Selected: {asset_data['tooltip']}")
                        else:
                             logger.error(f"Could not find asset data for key '{key}' in palette after selection.")
                        return # Asset selected
            
            elif map_view_rect.collidepoint(mouse_pos_click):
                logger.debug("Left click in map view section.")
                wx,wy=mouse_pos_click[0]-map_view_rect.left+editor_state.camera_offset_x, mouse_pos_click[1]-map_view_rect.top+editor_state.camera_offset_y
                tx,ty=wx//editor_state.grid_size, wy//editor_state.grid_size
                logger.debug(f"Map click at grid ({tx},{ty}). Current asset: '{editor_state.selected_asset_editor_key}'")
                
                if editor_state.selected_asset_editor_key: 
                    logger.debug(f"Attempting to place asset '{editor_state.selected_asset_editor_key}' at grid ({tx},{ty})")
                    editor_state.is_painting_tiles=True; editor_state.last_painted_tile_coords=(tx,ty); _place_tile_at_grid(editor_state,(tx,ty))
                
                else: # No asset selected, try dragging an existing object
                    logger.debug("No asset selected, attempting to drag object.")
                    editor_state.dragging_object_index=None
                    for i,obj in reversed(list(enumerate(editor_state.placed_objects))):
                        info=editor_state.assets_palette.get(obj.get("asset_editor_key"))
                        if info and "original_size_pixels" in info:
                            obj_w,obj_h=info["original_size_pixels"]; obj_r=pygame.Rect(obj["world_x"],obj["world_y"],obj_w,obj_h) 
                            if obj_r.collidepoint(wx,wy):
                                editor_state.dragging_object_index=i;editor_state.drag_start_mouse_map_x=wx;editor_state.drag_start_mouse_map_y=wy
                                editor_state.drag_object_original_x=obj["world_x"];editor_state.drag_object_original_y=obj["world_y"];editor_state.set_status_message(f"Dragging {info['tooltip']}");break
        
        elif event.button == 3: # Right Mouse Button
            if map_view_rect.collidepoint(mouse_pos_click):
                wx,wy=mouse_pos_click[0]-map_view_rect.left+editor_state.camera_offset_x, mouse_pos_click[1]-map_view_rect.top+editor_state.camera_offset_y
                tx,ty=wx//editor_state.grid_size, wy//editor_state.grid_size
                if pygame.key.get_mods()&(pygame.KMOD_LSHIFT|pygame.KMOD_RSHIFT):
                    logger.info("Shift+RMB click on map: Save All attempt.")
                    if editor_state.map_name_for_function and editor_state.map_name_for_function!="untitled_map":
                        if save_map_to_json(editor_state)and export_map_to_game_python_script(editor_state):
                            pygame.display.set_caption(f"Editor - {editor_state.map_name_for_function}.py")
                    else: 
                        editor_state.set_status_message("Cannot save: Map not named.",4)
                else:
                    logger.info(f"RMB click on map at grid ({tx},{ty}): Erase attempt.")
                    editor_state.is_erasing_tiles=True;editor_state.last_erased_tile_coords=(tx,ty);_erase_tile_at_grid(editor_state,(tx,ty))

    elif event.type == pygame.MOUSEBUTTONUP:
        if event.button==1:
            editor_state.is_painting_tiles=False;editor_state.last_painted_tile_coords=None
            if editor_state.dragging_object_index is not None: 
                editor_state.dragging_object_index=None;editor_state.set_status_message("Drag complete")
            if editor_state.is_dragging_minimap_view: 
                logger.debug("Minimap drag released."); editor_state.is_dragging_minimap_view = False
        elif event.button==3: 
            editor_state.is_erasing_tiles=False;editor_state.last_erased_tile_coords=None
        
        if editor_state.is_dragging_scrollbar: # This is for file dialog scrollbar
            editor_state.is_dragging_scrollbar=False

    elif event.type == pygame.MOUSEMOTION:
        mouse_pos_motion = event.pos
        if editor_state.is_dragging_minimap_view:
            _pan_camera_via_minimap_click(editor_state, mouse_pos_motion, map_view_rect, palette_section_rect)
            return # Minimap drag motion handled
        
        if editor_state.dragging_object_index is not None and 0<=editor_state.dragging_object_index<len(editor_state.placed_objects):
            obj_drag=editor_state.placed_objects[editor_state.dragging_object_index]
            map_mx,map_my = mouse_pos_motion[0]-map_view_rect.left+editor_state.camera_offset_x, mouse_pos_motion[1]-map_view_rect.top+editor_state.camera_offset_y
            new_x,new_y = editor_state.drag_object_original_x+(map_mx-editor_state.drag_start_mouse_map_x), editor_state.drag_object_original_y+(map_my-editor_state.drag_start_mouse_map_y)
            snap_x,snap_y=(new_x//editor_state.grid_size)*editor_state.grid_size, (new_y//editor_state.grid_size)*editor_state.grid_size
            if obj_drag["world_x"]!=snap_x or obj_drag["world_y"]!=snap_y:
                obj_drag["world_x"],obj_drag["world_y"]=snap_x,snap_y
                editor_state.unsaved_changes=True;editor_state.minimap_needs_regeneration=True;pygame.display.set_caption(f"Editor - {editor_state.map_name_for_function}.py*")
        elif map_view_rect.collidepoint(mouse_pos_motion): # Mouse is over map view (but not dragging an object)
            map_mx,map_my = mouse_pos_motion[0]-map_view_rect.left+editor_state.camera_offset_x, mouse_pos_motion[1]-map_view_rect.top+editor_state.camera_offset_y
            curr_tx,curr_ty=map_mx//editor_state.grid_size, map_my//editor_state.grid_size; curr_grid=(curr_tx,curr_ty)
            btns=pygame.mouse.get_pressed()
            
            if editor_state.is_painting_tiles and btns[0] and editor_state.selected_asset_editor_key and curr_grid!=editor_state.last_painted_tile_coords:
                _place_tile_at_grid(editor_state,curr_grid); editor_state.last_painted_tile_coords=curr_grid
            elif editor_state.is_erasing_tiles and btns[2] and curr_grid!=editor_state.last_erased_tile_coords:
                _erase_tile_at_grid(editor_state,curr_grid); editor_state.last_erased_tile_coords=curr_grid
        elif not map_view_rect.collidepoint(mouse_pos_motion): # Mouse moved out of map view
            if editor_state.is_painting_tiles: 
                editor_state.is_painting_tiles=False; editor_state.last_painted_tile_coords=None
            if editor_state.is_erasing_tiles: 
                editor_state.is_erasing_tiles=False; editor_state.last_erased_tile_coords=None

    elif event.type == pygame.KEYDOWN:
        if event.key==pygame.K_ESCAPE:
            if editor_state.selected_asset_editor_key: 
                logger.info("Escape pressed: Deselecting asset."); 
                editor_state.selected_asset_editor_key=None
                editor_state.set_status_message("Asset deselected")
            else: # No asset selected, try to go to menu
                logger.info("Escape pressed: No asset selected, attempting to go to menu.")
                if editor_state.unsaved_changes:
                    if not getattr(editor_state,'_esc_exit_attempted',False): 
                        editor_state.set_status_message("Unsaved! Esc again to discard.",4)
                        setattr(editor_state,'_esc_exit_attempted',True)
                    else: 
                        editor_state.current_editor_mode="menu"
                        editor_state.reset_map_context()
                        pygame.display.set_caption("Editor - Menu")
                        SicherDelAttr(editor_state,'_esc_exit_attempted')
                else: 
                    editor_state.current_editor_mode="menu"
                    editor_state.reset_map_context()
                    pygame.display.set_caption("Editor - Menu")
                    SicherDelAttr(editor_state,'_esc_exit_attempted')
        elif event.key!=pygame.K_ESCAPE and hasattr(editor_state,'_esc_exit_attempted'): 
            SicherDelAttr(editor_state,'_esc_exit_attempted')
        elif event.key==pygame.K_g: 
            logger.info("G key pressed: Toggling grid."); 
            editor_state.show_grid = not editor_state.show_grid
            editor_state.minimap_needs_regeneration=True
            editor_state.set_status_message(f"Grid {'ON'if editor_state.show_grid else 'OFF'}")
        elif event.key==pygame.K_s and (pygame.key.get_mods()&pygame.KMOD_CTRL):
            logger.info("Ctrl+S pressed: Save All attempt.")
            if editor_state.map_name_for_function and editor_state.map_name_for_function!="untitled_map":
                if save_map_to_json(editor_state)and export_map_to_game_python_script(editor_state):
                    pygame.display.set_caption(f"Editor - {editor_state.map_name_for_function}.py")
            else:
                editor_state.set_status_message("Cannot save: Map not named.",4)

########## START OF FILE: editor\editor_handlers_menu.py ##########

# editor/editor_handlers_menu.py
# -*- coding: utf-8 -*-
"""
Handles Pygame events for the main menu of the editor.
Ensures correct filename handling for rename operations.
"""
import pygame
import os
import logging
from typing import Optional

import editor_config as ED_CONFIG
from editor_state import EditorState
from editor_ui import start_text_input_dialog, start_file_load_dialog
from editor_map_utils import (init_new_map_state, save_map_to_json,
                              load_map_from_json, export_map_to_game_python_script,
                              delete_map_files)

logger = logging.getLogger(__name__)

# --- Callbacks for the rename dialogs ---
def _handle_rename_get_new_name(new_name_str: str, old_base_filename_no_ext: str, editor_state: EditorState):
    """
    Called when the user confirms the new name in the text input dialog.
    old_base_filename_no_ext is the original filename without path and without .json extension (e.g., "my_map")
    """
    logger.info(f"Attempting to rename '{old_base_filename_no_ext}' to '{new_name_str}'")
    new_name_str = new_name_str.strip()

    if not new_name_str or new_name_str == old_base_filename_no_ext:
        editor_state.set_status_message("Rename cancelled or name unchanged/empty.", 2)
        logger.info("Rename cancelled: name unchanged or empty.")
        return

    # Basic validation for new_name_str
    invalid_chars = ['/', '\\', ':', '*', '?', '"', '<', '>', '|']
    if any(char in new_name_str for char in invalid_chars):
        editor_state.set_status_message("New name contains invalid characters.", 3)
        logger.warning(f"Invalid new name provided: '{new_name_str}'")
        # Re-open dialog for new name
        start_text_input_dialog(
            editor_state,
            prompt=f"Invalid name. New name for '{old_base_filename_no_ext}':",
            default_text=new_name_str, # Keep the invalid text for user to correct
            on_confirm=lambda new_val: _handle_rename_get_new_name(new_val, old_base_filename_no_ext, editor_state),
            on_cancel=lambda: editor_state.set_status_message("Rename cancelled.", 1),
            is_initially_selected=True # Re-select the text
        )
        return

    # Construct full paths for old and new files
    old_json_filename = old_base_filename_no_ext + ED_CONFIG.LEVEL_EDITOR_SAVE_FORMAT_EXTENSION
    old_py_filename = old_base_filename_no_ext + ED_CONFIG.GAME_LEVEL_FILE_EXTENSION

    old_full_path_json = os.path.join(ED_CONFIG.MAPS_DIRECTORY, old_json_filename)
    old_full_path_py = os.path.join(ED_CONFIG.MAPS_DIRECTORY, old_py_filename)

    new_json_filename = new_name_str + ED_CONFIG.LEVEL_EDITOR_SAVE_FORMAT_EXTENSION
    new_py_filename = new_name_str + ED_CONFIG.GAME_LEVEL_FILE_EXTENSION

    new_full_path_json = os.path.join(ED_CONFIG.MAPS_DIRECTORY, new_json_filename)
    new_full_path_py = os.path.join(ED_CONFIG.MAPS_DIRECTORY, new_py_filename)


    if not os.path.exists(old_full_path_json):
        editor_state.set_status_message(f"Error: Original map JSON '{old_json_filename}' not found.", 3)
        logger.error(f"Original map JSON for rename not found: {old_full_path_json}")
        return

    # Check if new filenames already exist (excluding the old ones if name is just case change)
    if os.path.normcase(old_full_path_json) != os.path.normcase(new_full_path_json) and os.path.exists(new_full_path_json):
        editor_state.set_status_message(f"Error: JSON file '{new_json_filename}' already exists.", 3)
        logger.warning(f"Target JSON rename path already exists: {new_full_path_json}")
        start_text_input_dialog(
            editor_state,
            prompt=f"Name '{new_name_str}' (JSON) exists. New name for '{old_base_filename_no_ext}':",
            default_text=new_name_str,
            on_confirm=lambda new_val: _handle_rename_get_new_name(new_val, old_base_filename_no_ext, editor_state),
            on_cancel=lambda: editor_state.set_status_message("Rename cancelled.", 1),
            is_initially_selected=True # Re-select the text
        )
        return

    if os.path.normcase(old_full_path_py) != os.path.normcase(new_full_path_py) and os.path.exists(new_full_path_py):
        editor_state.set_status_message(f"Error: Python file '{new_py_filename}' already exists.", 3)
        logger.warning(f"Target PY rename path already exists: {new_full_path_py}")
        start_text_input_dialog(
            editor_state,
            prompt=f"Name '{new_name_str}' (PY) exists. New name for '{old_base_filename_no_ext}':",
            default_text=new_name_str,
            on_confirm=lambda new_val: _handle_rename_get_new_name(new_val, old_base_filename_no_ext, editor_state),
            on_cancel=lambda: editor_state.set_status_message("Rename cancelled.", 1),
            is_initially_selected=True # Re-select the text
        )
        return

    try:
        # Rename JSON file
        os.rename(old_full_path_json, new_full_path_json)
        logger.info(f"Successfully renamed '{old_full_path_json}' to '{new_full_path_json}'")

        # Rename corresponding PY file if it exists
        if os.path.exists(old_full_path_py):
            os.rename(old_full_path_py, new_full_path_py)
            logger.info(f"Successfully renamed '{old_full_path_py}' to '{new_full_path_py}'")
        else:
            logger.info(f"Original PY file '{old_full_path_py}' not found, skipping its rename.")

        editor_state.set_status_message(f"Map '{old_base_filename_no_ext}' renamed to '{new_name_str}'.", 3)

        # If the currently loaded map was renamed
        if editor_state.current_loaded_map_path and \
           os.path.normpath(editor_state.current_loaded_map_path) == os.path.normpath(old_full_path_json):
            editor_state.current_loaded_map_path = new_full_path_json
            editor_state.current_map_filename = new_py_filename # Update to new .py filename
            editor_state.map_name_for_function = new_name_str # This should be the base name
            if editor_state.current_editor_mode == "editing_map":
                pygame.display.set_caption(f"Editor - {editor_state.map_name_for_function}.py")
            logger.info(f"Updated current_loaded_map_path to new name: {new_full_path_json}")

    except OSError as e:
        editor_state.set_status_message(f"Error renaming map: {e}", 4)
        logger.error(f"OSError during rename: {e}", exc_info=True)
    finally:
        editor_state.active_dialog_type = None # Ensure dialog is closed

def _handle_rename_select_map(selected_path_from_dialog: str, editor_state: EditorState):
    """
    Called when the user selects a map to rename from the file dialog.
    selected_path_from_dialog is the path to the file (e.g., "maps/my_map.json")
    """
    logger.info(f"Map selected for rename (path from dialog): '{selected_path_from_dialog}'")

    if not selected_path_from_dialog:
        editor_state.set_status_message("Rename cancelled: No map selected.", 1)
        logger.info("Rename cancelled: no map selected from dialog.")
        return

    # Get the actual filename (e.g., "my_map.json") from the path
    filename_with_ext = os.path.basename(selected_path_from_dialog)

    # Get the name without the .json extension for the prompt and default text
    base_name_no_ext = os.path.splitext(filename_with_ext)[0]

    start_text_input_dialog(
        editor_state,
        prompt=f"Enter new name for '{base_name_no_ext}':",      # Use just the base name (e.g., 'yes')
        default_text=base_name_no_ext,                          # Use just the base name (e.g., 'yes')
        # Pass the original base name (without extension) to the next step
        on_confirm=lambda new_name: _handle_rename_get_new_name(new_name, base_name_no_ext, editor_state),
        on_cancel=lambda: editor_state.set_status_message("Rename cancelled.", 1),
        is_initially_selected=True
    )

def start_rename_map_flow(editor_state: EditorState):
    """
    Initiates the map renaming process by showing the file selection dialog.
    """
    logger.info("Starting rename map flow.")
    start_file_load_dialog(
        editor_state,
        # The 'path_from_dialog' lambda parameter will receive the full path from the file dialog
        on_confirm=lambda path_from_dialog: _handle_rename_select_map(path_from_dialog, editor_state),
        on_cancel=lambda: editor_state.set_status_message("Rename map cancelled.", 1),
        prompt_override="Select Map to Rename",
        file_extension=ED_CONFIG.LEVEL_EDITOR_SAVE_FORMAT_EXTENSION # Ensure we list .json files
    )

def handle_menu_events(event: pygame.event.Event, editor_state: EditorState, main_screen: pygame.Surface):
    """
    Processes events when in the main menu mode.
    """
    if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
        mouse_pos = event.pos
        ui_rects = editor_state.ui_elements_rects

        if ui_rects.get("menu_new_map",pygame.Rect(0,0,0,0)).collidepoint(mouse_pos):
            logger.info("Menu: 'New Map' button clicked.")
            def on_new_map_name(name:str):
                name=name.strip()
                if not name:
                    editor_state.set_status_message("Map name empty.",3)
                    start_text_input_dialog(editor_state,"Name:","",on_new_map_name,lambda:None, is_initially_selected=True)
                    return
                # Basic validation for new map name (similar to rename)
                invalid_chars = ['/', '\\', ':', '*', '?', '"', '<', '>', '|']
                if any(char in name for char in invalid_chars):
                    editor_state.set_status_message("Map name contains invalid characters.", 3)
                    logger.warning(f"Invalid new map name provided: '{name}'")
                    start_text_input_dialog(editor_state, "Invalid Name. New Map Name:", name, on_new_map_name, lambda: None, is_initially_selected=True)
                    return

                # Check if map already exists
                potential_json_path = os.path.join(ED_CONFIG.MAPS_DIRECTORY, name + ED_CONFIG.LEVEL_EDITOR_SAVE_FORMAT_EXTENSION)
                potential_py_path = os.path.join(ED_CONFIG.MAPS_DIRECTORY, name + ED_CONFIG.GAME_LEVEL_FILE_EXTENSION)
                if os.path.exists(potential_json_path) or os.path.exists(potential_py_path):
                    editor_state.set_status_message(f"Map '{name}' already exists.", 3)
                    logger.warning(f"Attempt to create new map with existing name: '{name}'")
                    start_text_input_dialog(editor_state, f"Name '{name}' exists. New Map Name:", name, on_new_map_name, lambda:None, is_initially_selected=True)
                    return

                editor_state.map_name_for_function_input=name # Store the validated name
                def on_map_size(size_str:str):
                    try:
                        w,h=map(int,size_str.replace(" ","").split(','))
                        # Assuming MAX_MAP_WIDTH_TILES and MAX_MAP_HEIGHT_TILES are defined in ED_CONFIG
                        max_w = getattr(ED_CONFIG, "MAX_MAP_WIDTH_TILES", 500) 
                        max_h = getattr(ED_CONFIG, "MAX_MAP_HEIGHT_TILES", 500)
                        if not(w>0 and h>0 and w <= max_w and h <= max_h):
                             raise ValueError(f"Dims must be >0 and <= max ({max_w}x{max_h})")
                        init_new_map_state(editor_state,editor_state.map_name_for_function_input,w,h)
                        if save_map_to_json(editor_state)and export_map_to_game_python_script(editor_state):
                            editor_state.set_status_message(f"Map '{editor_state.map_name_for_function}' auto-saved.",3)
                            pygame.display.set_caption(f"Editor - {editor_state.map_name_for_function}.py")
                        else:
                            editor_state.set_status_message(f"Auto-save fail for '{editor_state.map_name_for_function}'.",4)
                            editor_state.unsaved_changes=True
                            pygame.display.set_caption(f"Editor - {editor_state.map_name_for_function}.py*")
                        editor_state.current_editor_mode="editing_map"
                    except Exception as e:
                        editor_state.set_status_message(f"Invalid size:{e}",3.5)
                        start_text_input_dialog(editor_state,"Size (W,H):",f"{ED_CONFIG.DEFAULT_MAP_WIDTH_TILES},{ED_CONFIG.DEFAULT_MAP_HEIGHT_TILES}",on_map_size,lambda:None, is_initially_selected=True)
                start_text_input_dialog(editor_state,"Size (W,H):",f"{ED_CONFIG.DEFAULT_MAP_WIDTH_TILES},{ED_CONFIG.DEFAULT_MAP_HEIGHT_TILES}",on_map_size,lambda:None, is_initially_selected=True)
            start_text_input_dialog(editor_state,"New Map Name:","my_map",on_new_map_name,lambda:None, is_initially_selected=True)

        elif ui_rects.get("menu_load_map",pygame.Rect(0,0,0,0)).collidepoint(mouse_pos):
            logger.info("Menu: 'Load Map' button clicked.")
            def on_file_sel(path_from_dialog:str): # path_from_dialog is the full path (e.g., "maps/ok.json")
                # load_map_from_json expects the full path, so path_from_dialog is used directly.
                logger.debug(f"Attempting to load map from: {path_from_dialog}")
                if load_map_from_json(editor_state, path_from_dialog):
                    editor_state.current_editor_mode="editing_map"
                    pygame.display.set_caption(f"Editor - {editor_state.map_name_for_function}.py")
                else:
                    logger.error(f"Failed to load map from {path_from_dialog}")
                    # Status message is set within load_map_from_json on failure
            start_file_load_dialog(editor_state,on_confirm=on_file_sel,on_cancel=lambda:None)

        elif ui_rects.get("menu_rename_map", pygame.Rect(0,0,0,0)).collidepoint(mouse_pos):
            logger.info("Menu: 'Rename Map' button clicked.")
            start_rename_map_flow(editor_state) # This flow correctly handles paths now

        elif ui_rects.get("menu_delete_map", pygame.Rect(0,0,0,0)).collidepoint(mouse_pos):
            logger.info("Menu: 'Delete Map' button clicked.")
            def on_delete_file_selected(path_from_dialog: str): # path_from_dialog is full path e.g., "maps/ok.json"
                if path_from_dialog:
                    # delete_map_files expects the full path to the .json file
                    map_name_to_delete = os.path.splitext(os.path.basename(path_from_dialog))[0]
                    logger.info(f"Attempting deletion of map: {map_name_to_delete} (Path: {path_from_dialog})")

                    if delete_map_files(editor_state, path_from_dialog):
                        editor_state.set_status_message(f"Map '{map_name_to_delete}' deleted.", 3)
                        current_map_base_name_if_loaded = ""
                        if editor_state.current_loaded_map_path:
                             current_map_base_name_if_loaded = os.path.splitext(os.path.basename(editor_state.current_loaded_map_path))[0]

                        if editor_state.map_name_for_function == map_name_to_delete or \
                           current_map_base_name_if_loaded == map_name_to_delete:
                            logger.info(f"Map '{map_name_to_delete}' which might have been active was deleted. Resetting map context.")
                            editor_state.reset_map_context()
                            if editor_state.current_editor_mode == "editing_map":
                                editor_state.current_editor_mode = "menu"
                                pygame.display.set_caption("Platformer Level Editor - Menu")
                else:
                    editor_state.set_status_message("No map selected for deletion.", 2)

            start_file_load_dialog(editor_state,
                                   prompt_override="Select Map to PERMANENTLY DELETE",
                                   on_confirm=on_delete_file_selected,
                                   on_cancel=lambda: editor_state.set_status_message("Delete operation cancelled.", 2),
                                   file_extension=ED_CONFIG.LEVEL_EDITOR_SAVE_FORMAT_EXTENSION)

        elif ui_rects.get("menu_quit",pygame.Rect(0,0,0,0)).collidepoint(mouse_pos):
            logger.info("Menu: 'Quit' button clicked.")
            pygame.event.post(pygame.event.Event(pygame.QUIT))

########## START OF FILE: editor\editor_map_utils.py ##########

# editor_map_utils.py
# -*- coding: utf-8 -*-
"""
## version 1.0.0.8 (Added delete_map_files utility)
Utility functions for map operations in the Level Editor,
including initializing new maps, saving/loading editor-specific
map data (JSON), and exporting maps to game-compatible Python scripts.
"""
import pygame
import sys
import os
import json
import traceback
from typing import Optional, Dict, List, Tuple, Any
import logging 

import editor_config as ED_CONFIG
from editor_state import EditorState

import constants as C
from tiles import Platform, Ladder, Lava

logger = logging.getLogger(__name__) 


def init_new_map_state(editor_state: EditorState, map_name_for_function: str,
                       map_width_tiles: int, map_height_tiles: int):
    logger.info(f"Initializing new map state. Name: '{map_name_for_function}', Size: {map_width_tiles}x{map_height_tiles}")

    clean_map_name = map_name_for_function.lower().replace(" ", "_").replace("-", "_")
    if not clean_map_name:
        clean_map_name = "untitled_map"
        logger.warning(f"map_name_for_function was empty after cleaning, defaulting to '{clean_map_name}'")

    editor_state.map_name_for_function = clean_map_name
    editor_state.map_width_tiles = map_width_tiles
    editor_state.map_height_tiles = map_height_tiles
    editor_state.placed_objects = []
    editor_state.background_color = ED_CONFIG.DEFAULT_BACKGROUND_COLOR
    editor_state.camera_offset_x = 0
    editor_state.camera_offset_y = 0
    editor_state.unsaved_changes = True

    py_filename = editor_state.map_name_for_function + ED_CONFIG.GAME_LEVEL_FILE_EXTENSION
    editor_state.current_map_filename = os.path.join(ED_CONFIG.MAPS_DIRECTORY, py_filename)

    editor_state.recreate_map_content_surface()

    logger.info(f"Editor state initialized for new map. map_name_for_function='{editor_state.map_name_for_function}', "
                f"current_map_filename='{editor_state.current_map_filename}', unsaved_changes={editor_state.unsaved_changes}")


def ensure_maps_directory_exists() -> bool:
    maps_dir = ED_CONFIG.MAPS_DIRECTORY
    if not os.path.exists(maps_dir):
        logger.info(f"Maps directory '{maps_dir}' does not exist. Attempting to create.")
        try:
            os.makedirs(maps_dir)
            logger.info(f"Successfully created directory: {maps_dir}")
            return True
        except OSError as e:
            logger.error(f"Error creating directory {maps_dir}: {e}", exc_info=True)
            return False
    return True


def save_map_to_json(editor_state: EditorState) -> bool:
    logger.info(f"Saving map to JSON. Map name: '{editor_state.map_name_for_function}'")
    if not editor_state.map_name_for_function or editor_state.map_name_for_function == "untitled_map":
        msg = "Map name is not set or is 'untitled_map'. Cannot save JSON."
        editor_state.set_status_message(f"Error: {msg}", 3)
        logger.error(msg)
        return False

    if not ensure_maps_directory_exists():
        msg = "Could not create or access maps directory."
        editor_state.set_status_message(f"Error: {msg}", 3)
        logger.error(f"{msg} JSON save aborted.")
        return False

    json_filename = editor_state.map_name_for_function + ED_CONFIG.LEVEL_EDITOR_SAVE_FORMAT_EXTENSION
    json_filepath = os.path.join(ED_CONFIG.MAPS_DIRECTORY, json_filename)
    logger.debug(f"Attempting to save JSON to: '{json_filepath}'")

    serializable_objects = []
    for i, obj in enumerate(editor_state.placed_objects):
        asset_key = obj.get("asset_editor_key")
        game_id = obj.get("game_type_id")
        world_x = obj.get("world_x")
        world_y = obj.get("world_y")
        override_color = obj.get("override_color")

        if not all([asset_key, game_id is not None, world_x is not None, world_y is not None]):
             logger.warning(f"Object at index {i} has missing data, skipping for JSON: {obj}")
             continue

        s_obj = {
            "asset_editor_key": asset_key,
            "world_x": world_x,
            "world_y": world_y,
            "game_type_id": game_id
        }
        if override_color: 
            s_obj["override_color"] = list(override_color)

        serializable_objects.append(s_obj)

    data_to_save = {
        "map_name_for_function": editor_state.map_name_for_function,
        "map_width_tiles": editor_state.map_width_tiles,
        "map_height_tiles": editor_state.map_height_tiles,
        "grid_size": editor_state.grid_size,
        "background_color": list(editor_state.background_color),
        "placed_objects": serializable_objects,
        "camera_offset_x": editor_state.camera_offset_x,
        "camera_offset_y": editor_state.camera_offset_y,
        "show_grid": editor_state.show_grid
    }
    logger.debug(f"Data to save (first object example): {serializable_objects[0] if serializable_objects else 'No objects'}")

    try:
        with open(json_filepath, "w") as f:
            json.dump(data_to_save, f, indent=4)
        success_msg = f"Editor data saved to: {json_filename}"
        logger.info(success_msg)
        editor_state.set_status_message(success_msg)
        return True
    except IOError as e:
        error_msg = f"IOError saving map to JSON '{json_filepath}': {e}"
        logger.error(error_msg, exc_info=True)
    except Exception as e:
        error_msg = f"Unexpected error saving map to JSON '{json_filepath}': {e}"
        logger.error(error_msg, exc_info=True)
        traceback.print_exc()

    editor_state.set_status_message(error_msg, 4)
    return False


def load_map_from_json(editor_state: EditorState, json_filepath: str) -> bool:
    logger.info(f"Loading map from JSON: '{json_filepath}'")
    if not os.path.exists(json_filepath) or not os.path.isfile(json_filepath):
        error_msg = f"JSON map file not found or is not a file: '{json_filepath}'"
        logger.error(error_msg)
        editor_state.set_status_message(error_msg, 3)
        return False

    try:
        with open(json_filepath, 'r') as f:
            data = json.load(f)
        logger.debug(f"Successfully read JSON data from '{json_filepath}'.")

        editor_state.map_name_for_function = data.get("map_name_for_function", "loaded_map_error_name")
        editor_state.map_width_tiles = data.get("map_width_tiles", ED_CONFIG.DEFAULT_MAP_WIDTH_TILES)
        editor_state.map_height_tiles = data.get("map_height_tiles", ED_CONFIG.DEFAULT_MAP_HEIGHT_TILES)
        editor_state.grid_size = data.get("grid_size", ED_CONFIG.DEFAULT_GRID_SIZE)

        bg_color_data = data.get("background_color", ED_CONFIG.DEFAULT_BACKGROUND_COLOR)
        if isinstance(bg_color_data, list) and len(bg_color_data) == 3:
            editor_state.background_color = tuple(bg_color_data) # type: ignore
        else:
            editor_state.background_color = ED_CONFIG.DEFAULT_BACKGROUND_COLOR
            logger.warning(f"Invalid background_color format in JSON, using default. Got: {bg_color_data}")

        temp_placed_objects_from_json: List[Dict[str, Any]] = []
        loaded_placed_objects_data = data.get("placed_objects", [])
        logger.debug(f"Loading {len(loaded_placed_objects_data)} objects from JSON.")
        for i, obj_data in enumerate(loaded_placed_objects_data):
            asset_key = obj_data.get("asset_editor_key")
            game_type_id_from_json = obj_data.get("game_type_id")
            world_x = obj_data.get("world_x")
            world_y = obj_data.get("world_y")
            override_color_data = obj_data.get("override_color")

            if not all([asset_key, game_type_id_from_json is not None, world_x is not None, world_y is not None]):
                logger.warning(f"Loaded object at index {i} has missing core data, skipping: {obj_data}")
                continue

            if asset_key in ED_CONFIG.EDITOR_PALETTE_ASSETS:
                new_obj = {
                    "asset_editor_key": asset_key,
                    "world_x": world_x,
                    "world_y": world_y,
                    "game_type_id": game_type_id_from_json
                }
                if override_color_data and isinstance(override_color_data, list) and len(override_color_data) == 3:
                    new_obj["override_color"] = tuple(override_color_data) # type: ignore
                temp_placed_objects_from_json.append(new_obj)
            else:
                logger.warning(f"Asset key '{asset_key}' from loaded object (JSON type: '{game_type_id_from_json}') "
                               f"not found in current ED_CONFIG.EDITOR_PALETTE_ASSETS. Object at ({world_x},{world_y}) skipped.")
        
        corrected_objects: List[Dict[str, Any]] = []
        lava_coords_to_check = set()
        corrections_made = False

        for obj in temp_placed_objects_from_json:
            if obj.get("game_type_id") == "hazard_lava":
                if obj.get("world_x") is not None and obj.get("world_y") is not None: 
                    lava_coords_to_check.add((obj["world_x"], obj["world_y"]))
        
        logger.debug(f"Auto-correction: Found {len(lava_coords_to_check)} lava coordinates for checking: {lava_coords_to_check}")

        for obj in temp_placed_objects_from_json:
            obj_wx, obj_wy = obj.get("world_x"), obj.get("world_y")
            obj_game_type_id = obj.get("game_type_id", "")
            
            is_solid_platform_game_type = (
                obj_game_type_id == "platform_wall_gray" or
                ("platform_wall_gray_" in obj_game_type_id and "_half" in obj_game_type_id) or
                obj_game_type_id == "platform_ledge_green" or
                ("platform_ledge_green_" in obj_game_type_id and "_half" in obj_game_type_id)
            )
            
            if is_solid_platform_game_type and obj_wx is not None and obj_wy is not None and (obj_wx, obj_wy) in lava_coords_to_check:
                logger.info(f"Auto-correcting: Removing solid platform '{obj.get('asset_editor_key')}' ({obj_game_type_id}) "
                            f"at lava location ({obj_wx},{obj_wy}).")
                corrections_made = True
            else:
                corrected_objects.append(obj)
        
        editor_state.placed_objects = corrected_objects
        if corrections_made:
            editor_state.unsaved_changes = True
            editor_state.set_status_message("Map auto-corrected: Removed solid platforms under lava.", 4.0)
            logger.info("Map auto-corrected due to lava/platform conflict. Unsaved changes flag set.")

        editor_state.camera_offset_x = data.get("camera_offset_x", 0)
        editor_state.camera_offset_y = data.get("camera_offset_y", 0)
        editor_state.show_grid = data.get("show_grid", True)

        py_filename = editor_state.map_name_for_function + ED_CONFIG.GAME_LEVEL_FILE_EXTENSION
        editor_state.current_map_filename = os.path.join(ED_CONFIG.MAPS_DIRECTORY, py_filename)

        editor_state.recreate_map_content_surface()
        if not corrections_made: 
            editor_state.unsaved_changes = False 
        
        success_msg = f"Map '{editor_state.map_name_for_function}' loaded from {os.path.basename(json_filepath)}."
        if corrections_made: success_msg += " (Auto-corrected)"
        
        logger.info(f"{success_msg}. unsaved_changes={editor_state.unsaved_changes}, current_map_filename='{editor_state.current_map_filename}'")
        editor_state.set_status_message(success_msg)
        return True

    except json.JSONDecodeError as e:
        error_msg = f"Error: Could not decode JSON from map file '{json_filepath}': {e}"
        logger.error(error_msg, exc_info=True)
    except Exception as e:
        error_msg = f"Unexpected error loading map from JSON '{json_filepath}': {e}"
        logger.error(error_msg, exc_info=True)
        traceback.print_exc()

    editor_state.set_status_message(error_msg, 4)
    return False


def export_map_to_game_python_script(editor_state: EditorState) -> bool:
    logger.info(f"Exporting map '{editor_state.map_name_for_function}' to Python script.")
    ts = editor_state.grid_size

    if not editor_state.map_name_for_function or editor_state.map_name_for_function == "untitled_map":
        msg = "Map name not set or is 'untitled_map'. Cannot export .py."
        editor_state.set_status_message(f"Error: {msg}", 3)
        logger.error(msg)
        return False

    if not editor_state.current_map_filename:
        py_filename = editor_state.map_name_for_function + ED_CONFIG.GAME_LEVEL_FILE_EXTENSION
        editor_state.current_map_filename = os.path.join(ED_CONFIG.MAPS_DIRECTORY, py_filename)
        logger.warning(f"current_map_filename was not set, derived as '{editor_state.current_map_filename}' for export.")

    if not ensure_maps_directory_exists():
        msg = "Could not create or access maps directory for .py export."
        editor_state.set_status_message(f"Error: {msg}", 3)
        logger.error(f"{msg} PY export aborted.")
        return False

    function_name = f"load_map_{editor_state.map_name_for_function}"
    logger.debug(f"Exporting to function '{function_name}' in file '{editor_state.current_map_filename}'")

    platforms_code_lines = []
    ladders_code_lines = []
    hazards_code_lines = []
    enemy_spawns_code_lines = []
    collectible_spawns_code_lines = []

    default_spawn_tile_x = editor_state.map_width_tiles // 2
    default_spawn_tile_y = editor_state.map_height_tiles // 2
    default_spawn_world_x = default_spawn_tile_x * ts + ts // 2
    default_spawn_world_y = (default_spawn_tile_y + 1) * ts
    player1_spawn_str = f"player1_spawn = ({default_spawn_world_x}, {default_spawn_world_y}) # Default P1 Spawn"

    all_placed_world_rects_for_bounds: List[pygame.Rect] = []
    logger.debug(f"Processing {len(editor_state.placed_objects)} objects for .py export.")
    
    lava_occupied_coords = set()
    for obj_data in editor_state.placed_objects:
        if obj_data.get("game_type_id") == "hazard_lava":
            world_x = obj_data.get("world_x")
            world_y = obj_data.get("world_y")
            if world_x is not None and world_y is not None:
                lava_occupied_coords.add((world_x, world_y))
    logger.debug(f"Export: Identified {len(lava_occupied_coords)} lava-occupied coordinates: {lava_occupied_coords}")

    for i, obj_data in enumerate(editor_state.placed_objects):
        game_type_id = obj_data.get("game_type_id")
        world_x = obj_data.get("world_x")
        world_y = obj_data.get("world_y")
        asset_editor_key = obj_data.get("asset_editor_key")
        override_color = obj_data.get("override_color")

        if not all([game_type_id, world_x is not None, world_y is not None, asset_editor_key]):
             logger.warning(f"Export - Object at index {i} missing data, skipping: {obj_data}")
             continue

        asset_palette_entry = editor_state.assets_palette.get(asset_editor_key)
        if not asset_palette_entry:
            logger.warning(f"Asset key '{asset_editor_key}' not in palette. Skipping object export for obj: {obj_data}")
            continue
        
        obj_w_px, obj_h_px = ts, ts 
        default_color_tuple = getattr(C, 'MAGENTA', (255,0,255)) 

        if asset_palette_entry.get("surface_params_dims_color"):
            w, h, c = asset_palette_entry["surface_params_dims_color"]
            obj_w_px, obj_h_px = w, h
            default_color_tuple = c
        elif asset_palette_entry.get("render_mode") == "half_tile":
            half_type = asset_palette_entry.get("half_type")
            default_color_tuple = asset_palette_entry.get("base_color_tuple", default_color_tuple)
            if half_type in ["left", "right"]: obj_w_px = ts // 2; obj_h_px = ts
            elif half_type in ["top", "bottom"]: obj_w_px = ts; obj_h_px = ts // 2
        elif asset_palette_entry.get("original_size_pixels"): 
             obj_w_px, obj_h_px = asset_palette_entry["original_size_pixels"]
        
        current_color_tuple = override_color if override_color else default_color_tuple
        current_color_str = f"({current_color_tuple[0]},{current_color_tuple[1]},{current_color_tuple[2]})" if isinstance(current_color_tuple, (list, tuple)) else str(current_color_tuple)

        export_x, export_y = world_x, world_y
        if asset_palette_entry.get("render_mode") == "half_tile":
            half_type = asset_palette_entry.get("half_type")
            if half_type == "right": export_x = world_x + ts // 2
            elif half_type == "bottom": export_y = world_y + ts // 2
        
        current_obj_rect = pygame.Rect(export_x, export_y, obj_w_px, obj_h_px)
        all_placed_world_rects_for_bounds.append(current_obj_rect)

        is_platform_type = (
            game_type_id == "platform_wall_gray" or
            ("platform_wall_gray_" in game_type_id and "_half" in game_type_id) or
            game_type_id == "platform_ledge_green" or
            ("platform_ledge_green_" in game_type_id and "_half" in game_type_id)
        )

        if is_platform_type and (world_x, world_y) in lava_occupied_coords:
            logger.info(f"Export: Skipping platform '{game_type_id}' at ({world_x},{world_y}) because it's occupied by lava.")
            continue 

        if game_type_id == "platform_wall_gray" or "platform_wall_gray_" in game_type_id and "_half" in game_type_id:
            platforms_code_lines.append(f"    platforms.add(Platform({export_x}, {export_y}, {obj_w_px}, {obj_h_px}, {current_color_str}, platform_type='wall'))")
        elif game_type_id == "platform_ledge_green" or "platform_ledge_green_" in game_type_id and "_half" in game_type_id:
            if game_type_id == "platform_ledge_green": 
                 platforms_code_lines.append(f"    platforms.add(Platform({export_x}, {export_y}, {obj_w_px}, {obj_h_px}, {current_color_str}, platform_type='ledge'))")
            else: 
                 platforms_code_lines.append(f"    platforms.add(Platform({export_x}, {export_y}, {obj_w_px}, {obj_h_px}, {current_color_str}, platform_type='ledge'))")
        elif game_type_id == "hazard_lava":
            hazards_code_lines.append(f"    hazards.add(Lava({export_x}, {export_y}, {obj_w_px}, {obj_h_px}, {current_color_str}))")
        elif game_type_id == "player1_spawn":
            spawn_mid_x = world_x + obj_w_px // 2 
            spawn_bottom_y = world_y + obj_h_px
            player1_spawn_str = f"player1_spawn = ({spawn_mid_x}, {spawn_bottom_y})"
        elif "enemy" in game_type_id:
            specific_enemy_color_id = game_type_id.split('_')[-1] if '_' in game_type_id else "unknown_enemy_color"
            spawn_mid_x = world_x + obj_w_px // 2
            spawn_bottom_y = world_y + obj_h_px
            enemy_spawns_code_lines.append(f"    enemy_spawns_data.append({{'pos': ({spawn_mid_x}, {spawn_bottom_y}), 'patrol': None, 'enemy_color_id': '{specific_enemy_color_id}'}})")
        elif game_type_id == "chest":
            chest_spawn_x_midbottom = world_x + obj_w_px // 2
            chest_spawn_y_midbottom = world_y + obj_h_px
            collectible_spawns_code_lines.append(f"    collectible_spawns_data.append({{'type': 'chest', 'pos': ({chest_spawn_x_midbottom}, {chest_spawn_y_midbottom})}})")
        else:
            if not game_type_id.startswith("tool_"): 
                logger.warning(f"Unknown game_type_id '{game_type_id}' for object at ({world_x},{world_y}). Not exported to .py.")

    platforms_code_str = "\n".join(platforms_code_lines)
    ladders_code_str = "\n".join(ladders_code_lines)
    hazards_code_str = "\n".join(hazards_code_lines)
    enemy_spawns_code_str = "\n".join(enemy_spawns_code_lines)
    collectible_spawns_code_str = "\n".join(collectible_spawns_code_lines)
    logger.debug(f"Generated code lines - Platforms: {len(platforms_code_lines)}, Hazards: {len(hazards_code_lines)}, Enemies: {len(enemy_spawns_code_lines)}, Collectibles: {len(collectible_spawns_code_lines)}")

    if not all_placed_world_rects_for_bounds:
        logger.debug("No objects placed, using editor map dimensions for export boundaries.")
        map_min_x_content, map_max_x_content = 0, editor_state.get_map_pixel_width()
        map_min_y_content, map_max_y_content = 0, editor_state.get_map_pixel_height()
    else:
        map_min_x_content = min(r.left for r in all_placed_world_rects_for_bounds)
        map_max_x_content = max(r.right for r in all_placed_world_rects_for_bounds)
        map_min_y_content = min(r.top for r in all_placed_world_rects_for_bounds)
        map_max_y_content = max(r.bottom for r in all_placed_world_rects_for_bounds)

    padding_px = C.TILE_SIZE * 2
    game_map_total_width_pixels = int(max(ED_CONFIG.EDITOR_SCREEN_INITIAL_WIDTH, (map_max_x_content - map_min_x_content) + 2 * padding_px))
    game_level_min_y_absolute = int(map_min_y_content - padding_px)
    game_level_max_y_absolute = int(map_max_y_content + padding_px)
    game_main_ground_y_reference = int(map_max_y_content)
    game_main_ground_height_reference = int(C.TILE_SIZE)

    if game_level_min_y_absolute >= game_level_max_y_absolute:
        logger.warning(f"Calculated min_y_abs ({game_level_min_y_absolute}) >= max_y_abs ({game_level_max_y_absolute}). Adjusting max_y_abs.")
        game_level_max_y_absolute = game_level_min_y_absolute + C.TILE_SIZE * 5

    logger.debug(f"Export boundaries - TotalWidthPx: {game_map_total_width_pixels}, MinYAbs: {game_level_min_y_absolute}, MaxYAbs: {game_level_max_y_absolute}")

    script_content = f"""# Level: {editor_state.map_name_for_function}
# Generated by Platformer Level Editor
import pygame
from tiles import Platform, Ladder, Lava 
import constants as C

LEVEL_SPECIFIC_BACKGROUND_COLOR = {editor_state.background_color}

def {function_name}(initial_screen_width, initial_screen_height):
    \"\"\"
    Loads the '{editor_state.map_name_for_function}' level.
    \"\"\"
    print(f"Loading map: {function_name}...")
    platforms = pygame.sprite.Group()
    ladders = pygame.sprite.Group() 
    hazards = pygame.sprite.Group()
    enemy_spawns_data = []
    collectible_spawns_data = []

    {player1_spawn_str}

    # --- Placed Objects ---
{platforms_code_str if platforms_code_str else "    # No platforms placed."}
{ladders_code_str if ladders_code_str else "    # No ladders placed."}
{hazards_code_str if hazards_code_str else "    # No hazards placed."}
{enemy_spawns_code_str if enemy_spawns_code_str else "    # No enemy spawns defined."}
{collectible_spawns_code_str if collectible_spawns_code_str else "    # No collectible spawns defined."}

    # --- Level Dimensions for Game Camera & Boundaries ---
    map_total_width_pixels = {game_map_total_width_pixels}
    level_min_y_absolute = {game_level_min_y_absolute}
    level_max_y_absolute = {game_level_max_y_absolute}
    main_ground_y_reference = {game_main_ground_y_reference}
    main_ground_height_reference = {game_main_ground_height_reference}

    _boundary_thickness = C.TILE_SIZE * 2
    _boundary_wall_height = level_max_y_absolute - level_min_y_absolute + (2 * _boundary_thickness)
    _boundary_color = getattr(C, 'DARK_GRAY', (50,50,50)) 

    platforms.add(Platform(0, level_min_y_absolute - _boundary_thickness, map_total_width_pixels, _boundary_thickness, _boundary_color, platform_type="boundary_wall_top"))
    platforms.add(Platform(0, level_max_y_absolute, map_total_width_pixels, _boundary_thickness, _boundary_color, platform_type="boundary_wall_bottom"))
    platforms.add(Platform(-_boundary_thickness, level_min_y_absolute - _boundary_thickness, _boundary_thickness, _boundary_wall_height, _boundary_color, platform_type="boundary_wall_left"))
    platforms.add(Platform(map_total_width_pixels, level_min_y_absolute - _boundary_thickness, _boundary_thickness, _boundary_wall_height, _boundary_color, platform_type="boundary_wall_right"))

    print(f"Map '{function_name}' loaded with: {{len(platforms)}} platforms, {{len(ladders)}} ladders, {{len(hazards)}} hazards.")
    return (platforms, ladders, hazards, enemy_spawns_data, collectible_spawns_data,
            player1_spawn,
            map_total_width_pixels, level_min_y_absolute, level_max_y_absolute,
            main_ground_y_reference, main_ground_height_reference,
            LEVEL_SPECIFIC_BACKGROUND_COLOR)
"""
    py_filepath = editor_state.current_map_filename
    logger.debug(f"Final .py script content (first 500 chars):\n{script_content[:500]}...")

    try:
        with open(py_filepath, "w") as f:
            f.write(script_content)
        success_msg = f"Map exported to game script: {os.path.basename(py_filepath)}"
        logger.info(success_msg)
        editor_state.set_status_message(success_msg)
        editor_state.unsaved_changes = False
        logger.debug("unsaved_changes set to False after .py export.")
        return True
    except IOError as e:
        error_msg = f"IOError exporting map to .py '{py_filepath}': {e}"
        logger.error(error_msg, exc_info=True)
    except Exception as e:
        error_msg = f"Unexpected error during .py export to '{py_filepath}': {e}"
        logger.error(error_msg, exc_info=True)
        traceback.print_exc()

    editor_state.set_status_message(error_msg, 4)
    return False

def delete_map_files(editor_state: EditorState, json_filepath: str) -> bool:
    logger.info(f"Attempting to delete map files for: {json_filepath}")
    if not json_filepath.endswith(ED_CONFIG.LEVEL_EDITOR_SAVE_FORMAT_EXTENSION):
        msg = f"Invalid file type for deletion: {json_filepath}. Expected .json"
        logger.error(msg)
        editor_state.set_status_message(msg, 3)
        return False

    map_name_base = os.path.basename(json_filepath).replace(ED_CONFIG.LEVEL_EDITOR_SAVE_FORMAT_EXTENSION, "")
    py_filename = map_name_base + ED_CONFIG.GAME_LEVEL_FILE_EXTENSION
    py_filepath = os.path.join(os.path.dirname(json_filepath), py_filename)

    deleted_json = False
    deleted_py = False
    action_performed = False # To track if we even tried to delete existing files

    try:
        if os.path.exists(json_filepath):
            action_performed = True
            os.remove(json_filepath)
            logger.info(f"Deleted editor map file: {json_filepath}")
            deleted_json = True
        else:
            logger.warning(f"Editor map file not found for deletion: {json_filepath}")
    except OSError as e:
        action_performed = True
        msg = f"Error deleting editor map file '{json_filepath}': {e}"
        logger.error(msg, exc_info=True)
        editor_state.set_status_message(msg, 4)
        # Don't return yet, try to delete .py too

    try:
        if os.path.exists(py_filepath):
            action_performed = True
            os.remove(py_filepath)
            logger.info(f"Deleted game level file: {py_filepath}")
            deleted_py = True
        else:
            logger.warning(f"Game level file not found for deletion: {py_filepath}")
    except OSError as e:
        action_performed = True
        msg = f"Error deleting game level file '{py_filepath}': {e}"
        logger.error(msg, exc_info=True)
        editor_state.set_status_message(msg, 4)

    if deleted_json or deleted_py:
        editor_state.set_status_message(f"Map '{map_name_base}' files deleted (JSON: {deleted_json}, PY: {deleted_py}).", 3)
        return True
    elif not action_performed and not os.path.exists(json_filepath) and not os.path.exists(py_filepath): # Files were already gone
        editor_state.set_status_message(f"Map '{map_name_base}' files already gone or not found.", 2)
        return True 
    elif action_performed and not deleted_json and not deleted_py: # Attempted but failed for both
        editor_state.set_status_message(f"Failed to delete any files for map '{map_name_base}'. Check logs.", 4)
        return False
    else: # No action performed, but one or both files might still exist if only one deletion was attempted and failed
        editor_state.set_status_message(f"No files found or action taken for map '{map_name_base}'.", 3)
        return False

########## START OF FILE: editor\editor_state.py ##########

# editor_state.py
# -*- coding: utf-8 -*-
"""
## version 1.0.0.15 (Added dialog_input_text_selected flag)
Defines the EditorState class, which holds all the dynamic state
and data for the level editor.
"""
import pygame
from typing import Optional, Dict, List, Tuple, Any, Callable
import traceback
import logging

import editor_config as ED_CONFIG

logger = logging.getLogger(__name__)

class EditorState:
    def __init__(self):
        logger.debug("Initializing EditorState...")
        self.current_map_data: Dict[str, Any] = {}
        self.current_map_filename: Optional[str] = None
        self.map_name_for_function: str = "untitled_map"
        self.map_width_tiles: int = ED_CONFIG.DEFAULT_MAP_WIDTH_TILES
        self.map_height_tiles: int = ED_CONFIG.DEFAULT_MAP_HEIGHT_TILES
        self.grid_size: int = ED_CONFIG.DEFAULT_GRID_SIZE
        self.background_color: Tuple[int, int, int] = ED_CONFIG.DEFAULT_BACKGROUND_COLOR
        self.map_content_surface: Optional[pygame.Surface] = None

        self.minimap_surface: Optional[pygame.Surface] = None
        self.minimap_needs_regeneration: bool = True
        self.minimap_rect_in_palette: Optional[pygame.Rect] = None
        self.is_dragging_minimap_view: bool = False

        self.placed_objects: List[Dict[str, Any]] = []
        self.assets_palette: Dict[str, Dict[str, Any]] = {}
        self._selected_asset_editor_key: Optional[str] = None
        self.selected_asset_image_for_cursor: Optional[pygame.Surface] = None 
        self.asset_palette_scroll_y: float = 0.0 
        self.asset_palette_scroll_momentum: float = 0.0 
        self.total_asset_palette_content_height: int = 0


        self.camera_offset_x: int = 0
        self.camera_offset_y: int = 0
        self.show_grid: bool = True

        self.last_mouse_pos_map_view: Optional[Tuple[int, int]] = None
        self.mouse_velocity_map_view: Tuple[float, float] = (0.0, 0.0)
        self.camera_momentum_pan: Tuple[float, float] = (0.0, 0.0)
        self.is_mouse_over_map_view: bool = False

        self.dragging_object_index: Optional[int] = None
        self.drag_start_mouse_map_x: int = 0
        self.drag_start_mouse_map_y: int = 0
        self.drag_object_original_x: int = 0
        self.drag_object_original_y: int = 0
        self.is_painting_tiles: bool = False
        self.last_painted_tile_coords: Optional[Tuple[int, int]] = None
        self.is_erasing_tiles: bool = False
        self.last_erased_tile_coords: Optional[Tuple[int, int]] = None

        self._current_editor_mode: str = "menu"
        self.unsaved_changes: bool = False
        self.hovered_tooltip_text: Optional[str] = None
        self.hovered_tooltip_pos: Optional[Tuple[int, int]] = None
        self.ui_elements_rects: Dict[str, Any] = {}
        self._active_dialog_type: Optional[str] = None
        self.dialog_input_text: str = ""
        self.dialog_prompt_message: str = ""
        self.dialog_input_default: str = ""
        self.dialog_input_text_selected: bool = False # New flag for text highlighting
        self.dialog_callback_confirm: Optional[Callable[..., None]] = None
        self.dialog_callback_cancel: Optional[Callable[[], None]] = None
        self.dialog_rect: Optional[pygame.Rect] = None
        self.color_picker_rects: Dict[str, pygame.Rect] = {} 
        self.dialog_file_list: List[str] = []
        self.dialog_file_scroll_y: int = 0
        self.dialog_selected_file_index: int = -1
        self.is_dragging_scrollbar: bool = False
        self.scrollbar_drag_mouse_offset_y: int = 0
        self.map_name_for_function_input: str = ""
        self.status_message: Optional[str] = None
        self.status_message_timer: float = 0.0
        self.status_message_duration: float = 3.0
        self.recreate_map_content_surface()
        logger.debug("EditorState initialized.")


    @property
    def current_editor_mode(self) -> str:
        return self._current_editor_mode

    @current_editor_mode.setter
    def current_editor_mode(self, value: str):
        if self._current_editor_mode != value:
            logger.debug(f"Changing editor mode from '{self._current_editor_mode}' to '{value}'")
            self._current_editor_mode = value
            if value == "editing_map":
                self.minimap_needs_regeneration = True
                self.camera_momentum_pan = (0.0, 0.0)
                self.asset_palette_scroll_momentum = 0.0 
            if value == "menu":
                self.camera_momentum_pan = (0.0, 0.0)
                self.asset_palette_scroll_momentum = 0.0 


    @property
    def active_dialog_type(self) -> Optional[str]:
        return self._active_dialog_type

    @active_dialog_type.setter
    def active_dialog_type(self, value: Optional[str]):
        if self._active_dialog_type != value:
            logger.debug(f"Changing active_dialog_type from '{self._active_dialog_type}' to '{value}'")
            old_dialog_type = self._active_dialog_type
            self._active_dialog_type = value
            if value is not None: # If any dialog is opening
                self.camera_momentum_pan = (0.0, 0.0)
                self.asset_palette_scroll_momentum = 0.0 
            else: # Dialog is closing
                self.dialog_input_text_selected = False # Ensure deselected when any dialog closes

            if value is None or (old_dialog_type is not None and old_dialog_type != value):
                keys_to_remove = []
                if old_dialog_type == "file_load":
                    keys_to_remove.extend(['dialog_file_item_rects', 'file_dialog_scrollbar_handle',
                                           'file_dialog_scrollbar_area', 'dialog_file_load_ok', 'dialog_file_load_cancel'])
                elif old_dialog_type == "color_picker": self.color_picker_rects.clear()
                elif old_dialog_type == "text_input":
                    if 'dialog_text_input_box' in self.ui_elements_rects:
                        keys_to_remove.append('dialog_text_input_box')

                for key in keys_to_remove:
                    if key in self.ui_elements_rects:
                        try: del self.ui_elements_rects[key]
                        except KeyError: pass
            if value is None: self.dialog_rect = None

    @property
    def selected_asset_editor_key(self) -> Optional[str]:
        return self._selected_asset_editor_key

    @selected_asset_editor_key.setter
    def selected_asset_editor_key(self, value: Optional[str]):
        logger.debug(f"Attempting to set selected_asset_editor_key from '{self._selected_asset_editor_key}' to '{value}'")
        if self._selected_asset_editor_key != value or \
           (value is not None and value in self.assets_palette and self.selected_asset_image_for_cursor is None):

            self._selected_asset_editor_key = value
            logger.info(f"selected_asset_editor_key changed to: '{value}'")

            if value is None:
                self.selected_asset_image_for_cursor = None
                logger.debug("No asset selected. selected_asset_image_for_cursor set to None.")
            elif value in self.assets_palette:
                asset_data = self.assets_palette[value]
                if "image" in asset_data and asset_data["image"] is not None:
                    self.selected_asset_image_for_cursor = asset_data["image"].copy()
                    logger.debug(f"Asset '{value}' selected. Cursor image set from palette.")
                else:
                    self.selected_asset_image_for_cursor = None
                    logger.warning(f"Asset '{value}' selected, but has no image in palette. Cursor image set to None.")
            else: 
                self.selected_asset_image_for_cursor = None
                logger.warning(f"Asset key '{value}' not found in assets_palette during selection. Cursor image set to None.")
        else:
            logger.debug(f"selected_asset_editor_key already '{value}', no change needed for key or cursor state.")


    def recreate_map_content_surface(self):
        map_pixel_width = self.map_width_tiles * self.grid_size
        map_pixel_height = self.map_height_tiles * self.grid_size
        safe_width, safe_height = max(1, map_pixel_width), max(1, map_pixel_height)
        try:
            self.map_content_surface = pygame.Surface((safe_width, safe_height))
            self.minimap_needs_regeneration = True
            logger.debug(f"Recreated map_content_surface: {safe_width}x{safe_height}")
        except pygame.error as e:
            logger.error(f"Failed to create map_content_surface: {e}", exc_info=True)
            try: self.map_content_surface = pygame.Surface((ED_CONFIG.DEFAULT_GRID_SIZE, ED_CONFIG.DEFAULT_GRID_SIZE))
            except Exception as e_fallback: self.map_content_surface = None; logger.critical(f"Fallback surface failed: {e_fallback}", exc_info=True)


    def get_map_pixel_width(self) -> int: return self.map_width_tiles * self.grid_size
    def get_map_pixel_height(self) -> int: return self.map_height_tiles * self.grid_size

    def set_status_message(self, message: str, duration: float = 3.0):
        self.status_message, self.status_message_duration, self.status_message_timer = message, duration, duration
        logger.info(f"Status message set: '{message}' for {duration}s")

    def update_status_message(self, dt: float):
        if self.status_message and self.status_message_timer > 0:
            self.status_message_timer -= dt
            if self.status_message_timer <= 0: self.status_message, self.status_message_timer = None, 0.0

    def reset_map_context(self):
        logger.debug("Resetting map context.")
        self.map_name_for_function = "untitled_map"; self.current_map_filename = None
        self.placed_objects = []; self.map_width_tiles = ED_CONFIG.DEFAULT_MAP_WIDTH_TILES
        self.map_height_tiles = ED_CONFIG.DEFAULT_MAP_HEIGHT_TILES; self.background_color = ED_CONFIG.DEFAULT_BACKGROUND_COLOR
        self.camera_offset_x, self.camera_offset_y = 0, 0; self.unsaved_changes = False
        self.selected_asset_editor_key, self.selected_asset_image_for_cursor = None, None
        self.is_painting_tiles, self.last_painted_tile_coords = False, None
        self.is_erasing_tiles, self.last_erased_tile_coords = False, None
        self.minimap_needs_regeneration = True
        self.last_mouse_pos_map_view = None
        self.mouse_velocity_map_view = (0.0, 0.0)
        self.camera_momentum_pan = (0.0, 0.0)
        self.asset_palette_scroll_momentum = 0.0 
        self.asset_palette_scroll_y = 0.0
        self.dialog_input_text_selected = False # Reset this flag
        self.is_mouse_over_map_view = False
        self.is_dragging_minimap_view = False
        logger.debug(f"Map context reset. Map name: '{self.map_name_for_function}'.")

########## START OF FILE: editor\editor_ui.py ##########

# editor_ui.py
# -*- coding: utf-8 -*-
"""
## version 1.0.0.10 (Ensured start_file_load_dialog populates list with basenames only)
Pygame-based UI functions for the Level Editor.
Includes buttons, input dialogs, color pickers, and tooltips.
"""
import pygame
import os
from typing import Optional, Dict, Tuple, Any, Callable, List
import traceback

import editor_config as ED_CONFIG
from editor_state import EditorState


def draw_button(surface: pygame.Surface,
                rect: pygame.Rect,
                text: str,
                font: Optional[pygame.font.Font],
                mouse_pos: Tuple[int, int],
                text_color: Tuple[int, int, int] = ED_CONFIG.BUTTON_TEXT_COLOR,
                button_color_normal: Tuple[int, int, int] = ED_CONFIG.BUTTON_COLOR_NORMAL,
                button_color_hover: Tuple[int, int, int] = ED_CONFIG.BUTTON_COLOR_HOVER,
                border_color: Tuple[int, int, int] = ED_CONFIG.BUTTON_COLOR_BORDER,
                border_width: int = ED_CONFIG.BUTTON_BORDER_WIDTH,
                is_active: bool = True) -> bool:
    is_hovered = False
    if is_active and rect.collidepoint(mouse_pos):
        is_hovered = True

    current_button_color = button_color_normal
    current_text_color = text_color

    if not is_active:
        current_button_color = tuple(int(c * 0.67) for c in button_color_normal)
        current_text_color = tuple(int(c * 0.67) for c in text_color)
    elif is_hovered:
        current_button_color = button_color_hover

    try:
        pygame.draw.rect(surface, current_button_color, rect)
        if border_width > 0:
            pygame.draw.rect(surface, border_color, rect, border_width)

        if font:
            text_surf = font.render(text, True, current_text_color)
            text_rect = text_surf.get_rect(center=rect.center)
            surface.blit(text_surf, text_rect)
        else:
            # Use a default font if None is provided, or log a more prominent warning
            try:
                default_font = pygame.font.Font(None, 24) # Example default
                text_surf = default_font.render(text, True, current_text_color)
                text_rect = text_surf.get_rect(center=rect.center)
                surface.blit(text_surf, text_rect)
                print(f"Warning UI_DRAW: draw_button called with no font for text '{text}'. Used default font.")
            except Exception as font_e:
                 print(f"CRITICAL UI_DRAW: draw_button no font for '{text}' AND default font failed: {font_e}")

    except Exception as e:
        print(f"ERROR UI_DRAW: Exception in draw_button for '{text}': {e}")
        traceback.print_exc()

    return is_hovered

def draw_tooltip(surface: pygame.Surface,
                 editor_state: EditorState,
                 font: Optional[pygame.font.Font]):
    if editor_state.hovered_tooltip_text and editor_state.hovered_tooltip_pos and font:
        try:
            text_surf = font.render(editor_state.hovered_tooltip_text, True, ED_CONFIG.TOOLTIP_TEXT_COLOR)
            text_rect = text_surf.get_rect(
                topleft=(editor_state.hovered_tooltip_pos[0] + 15,
                         editor_state.hovered_tooltip_pos[1] + 15)
            )
            bg_rect = text_rect.inflate(ED_CONFIG.TOOLTIP_PADDING * 2, ED_CONFIG.TOOLTIP_PADDING * 2)

            bg_rect.clamp_ip(surface.get_rect())
            text_rect.clamp_ip(bg_rect.inflate(-ED_CONFIG.TOOLTIP_PADDING, -ED_CONFIG.TOOLTIP_PADDING))

            pygame.draw.rect(surface, ED_CONFIG.TOOLTIP_BG_COLOR, bg_rect, border_radius=3)
            pygame.draw.rect(surface, ED_CONFIG.BUTTON_COLOR_BORDER, bg_rect, 1, border_radius=3)
            surface.blit(text_surf, text_rect)
        except Exception as e:
            print(f"ERROR UI_DRAW: Exception in draw_tooltip for '{editor_state.hovered_tooltip_text}': {e}")
            traceback.print_exc()

def draw_status_message(surface: pygame.Surface, editor_state: EditorState, font: Optional[pygame.font.Font]):
    if editor_state.status_message and font:
        try:
            message_surf = font.render(editor_state.status_message, True, getattr(ED_CONFIG.C, 'YELLOW', (255,255,0)))
            message_rect = message_surf.get_rect(centerx=surface.get_width() // 2,
                                                  bottom=surface.get_height() - 10)
            bg_padding = 5
            bg_rect = message_rect.inflate(bg_padding * 2, bg_padding * 2)
            bg_rect.clamp_ip(surface.get_rect())
            message_rect.clamp_ip(bg_rect)

            s = pygame.Surface(bg_rect.size, pygame.SRCALPHA)
            s.fill((50, 50, 50, 180))
            surface.blit(s, bg_rect.topleft)
            surface.blit(message_surf, message_rect)
        except Exception as e:
            print(f"ERROR UI_DRAW: Exception in draw_status_message for '{editor_state.status_message}': {e}")
            traceback.print_exc()


def start_text_input_dialog(editor_state: EditorState,
                            prompt: str,
                            default_text: str = "",
                            on_confirm: Optional[Callable[[str], None]] = None,
                            on_cancel: Optional[Callable[[], None]] = None,
                            is_initially_selected: bool = True):
    print(f"DEBUG UI_DIALOG: start_text_input_dialog. Prompt: '{prompt}', Default: '{default_text}', Selected: {is_initially_selected}")
    editor_state.active_dialog_type = "text_input"
    editor_state.dialog_prompt_message = prompt
    editor_state.dialog_input_text = default_text
    editor_state.dialog_input_default = default_text
    editor_state.dialog_input_text_selected = is_initially_selected
    editor_state.dialog_callback_confirm = on_confirm
    editor_state.dialog_callback_cancel = on_cancel
    editor_state.dialog_rect = None

def start_color_picker_dialog(editor_state: EditorState,
                              on_confirm: Optional[Callable[[Tuple[int,int,int]], None]] = None,
                              on_cancel: Optional[Callable[[], None]] = None):
    print(f"DEBUG UI_DIALOG: start_color_picker_dialog.")
    editor_state.active_dialog_type = "color_picker"
    editor_state.dialog_prompt_message = "Select Background Color (Esc to Cancel)"
    editor_state.color_picker_rects.clear()

    cols = ED_CONFIG.COLOR_PICKER_COLS
    button_size = ED_CONFIG.COLOR_PICKER_BUTTON_SIZE
    padding = ED_CONFIG.COLOR_PICKER_PADDING

    start_x_in_dialog = padding * 2
    current_y_in_dialog = 50
    current_x_in_dialog = start_x_in_dialog
    idx = 0
    for name in ED_CONFIG.COLOR_PICKER_PRESETS.keys():
        rect = pygame.Rect(current_x_in_dialog, current_y_in_dialog, button_size, button_size)
        editor_state.color_picker_rects[name] = rect
        current_x_in_dialog += button_size + padding
        idx += 1
        if idx % cols == 0:
            current_x_in_dialog = start_x_in_dialog
            current_y_in_dialog += button_size + padding

    editor_state.dialog_callback_confirm = on_confirm
    editor_state.dialog_callback_cancel = on_cancel
    editor_state.dialog_rect = None

def start_file_load_dialog(editor_state: EditorState,
                           on_confirm: Optional[Callable[[str], None]] = None,
                           on_cancel: Optional[Callable[[], None]] = None,
                           initial_path: str = ED_CONFIG.MAPS_DIRECTORY,
                           file_extension: str = ED_CONFIG.LEVEL_EDITOR_SAVE_FORMAT_EXTENSION,
                           prompt_override: Optional[str] = None):
    print(f"DEBUG UI_DIALOG: start_file_load_dialog. Path: '{initial_path}', Ext: '{file_extension}', Prompt: '{prompt_override}'")
    editor_state.active_dialog_type = "file_load"
    if prompt_override:
        editor_state.dialog_prompt_message = prompt_override
    else:
        # Use os.path.normpath to clean up the path for display if needed
        display_path = os.path.normpath(initial_path)
        editor_state.dialog_prompt_message = f"Select Map to Load (from ./{display_path})"

    editor_state.dialog_input_text = ""
    editor_state.dialog_file_list = []
    editor_state.dialog_file_scroll_y = 0
    editor_state.dialog_selected_file_index = -1
    editor_state.dialog_rect = None

    if 'dialog_file_item_rects' not in editor_state.ui_elements_rects:
        editor_state.ui_elements_rects['dialog_file_item_rects'] = []
    else:
        editor_state.ui_elements_rects['dialog_file_item_rects'].clear()

    if not os.path.exists(initial_path):
        try:
            os.makedirs(initial_path)
            editor_state.set_status_message(f"Created maps dir '{initial_path}'. No files yet.", 2)
        except OSError as e:
            err_msg = f"Error creating dir '{initial_path}': {e}"
            editor_state.set_status_message(err_msg, 3)
            print(f"ERROR UI_DIALOG: {err_msg}")
            if on_cancel: on_cancel()
            editor_state.active_dialog_type = None
            return

    try:
        # Ensure we are appending only the basename
        for item_name in os.listdir(initial_path):
            # Check if it's a file and has the correct extension
            if item_name.endswith(file_extension) and os.path.isfile(os.path.join(initial_path, item_name)):
                # item_name is already the basename as returned by os.listdir()
                editor_state.dialog_file_list.append(item_name)
        editor_state.dialog_file_list.sort()
        print(f"DEBUG UI_DIALOG: Populated dialog_file_list: {editor_state.dialog_file_list}") # Debug print
    except OSError as e:
        err_msg = f"Error listing files in '{initial_path}': {e}"
        editor_state.set_status_message(err_msg, 3)
        print(f"ERROR UI_DIALOG: {err_msg}")
        if on_cancel: on_cancel()
        editor_state.active_dialog_type = None
        return

    if not editor_state.dialog_file_list:
        editor_state.set_status_message(f"No '{file_extension}' files found in ./{os.path.normpath(initial_path)}", 2.5)

    editor_state.dialog_callback_confirm = on_confirm
    editor_state.dialog_callback_cancel = on_cancel


def draw_active_dialog(surface: pygame.Surface, editor_state: EditorState, fonts: Dict[str, Optional[pygame.font.Font]]):
    if not editor_state.active_dialog_type:
        return

    try:
        screen_center_x, screen_center_y = surface.get_rect().center
        dialog_width, dialog_height = 450, 350

        if editor_state.active_dialog_type == "text_input":
            dialog_width, dialog_height = 400, 200
        elif editor_state.active_dialog_type == "color_picker":
            num_colors = len(ED_CONFIG.COLOR_PICKER_PRESETS)
            cols = ED_CONFIG.COLOR_PICKER_COLS
            rows = (num_colors + cols - 1) // cols
            content_w = cols * ED_CONFIG.COLOR_PICKER_BUTTON_SIZE + (cols -1 if cols > 0 else 0) * ED_CONFIG.COLOR_PICKER_PADDING
            content_h = rows * ED_CONFIG.COLOR_PICKER_BUTTON_SIZE + (rows -1 if rows > 0 else 0) * ED_CONFIG.COLOR_PICKER_PADDING
            dialog_width = max(300, content_w + ED_CONFIG.COLOR_PICKER_PADDING * 4)
            title_space = 60
            dialog_height = max(200, content_h + title_space + ED_CONFIG.COLOR_PICKER_PADDING * 2)
        elif editor_state.active_dialog_type == "file_load":
            dialog_width, dialog_height = 400, 350

        current_dialog_rect = pygame.Rect(0, 0, dialog_width, dialog_height)
        current_dialog_rect.center = screen_center_x, screen_center_y
        editor_state.dialog_rect = current_dialog_rect

        pygame.draw.rect(surface, ED_CONFIG.DIALOG_BG_COLOR, current_dialog_rect, border_radius=5)
        pygame.draw.rect(surface, getattr(ED_CONFIG.C, 'BLACK', (0,0,0)), current_dialog_rect, 2, border_radius=5)

        prompt_font = fonts.get("medium") or ED_CONFIG.FONT_CONFIG.get("medium")
        if prompt_font and editor_state.dialog_prompt_message:
            prompt_surf = prompt_font.render(editor_state.dialog_prompt_message, True, ED_CONFIG.DIALOG_PROMPT_COLOR)
            prompt_draw_rect = prompt_surf.get_rect(midtop=(current_dialog_rect.centerx, current_dialog_rect.top + 15))
            surface.blit(prompt_surf, prompt_draw_rect)

        if editor_state.active_dialog_type == "text_input":
            _draw_text_input_content(surface, editor_state, current_dialog_rect, fonts)
        elif editor_state.active_dialog_type == "color_picker":
            _draw_color_picker_content(surface, editor_state, current_dialog_rect, fonts)
        elif editor_state.active_dialog_type == "file_load":
            _draw_file_load_content(surface, editor_state, current_dialog_rect, fonts)

    except Exception as e:
        print(f"ERROR UI_DRAW_DIALOG: Exception in draw_active_dialog for type '{editor_state.active_dialog_type}': {e}")
        traceback.print_exc()
        error_font = fonts.get("small")
        if error_font and editor_state.dialog_rect:
            err_surf = error_font.render(f"Dialog Error! See console.", True, getattr(ED_CONFIG.C, 'RED', (255,0,0)))
            surface.blit(err_surf, err_surf.get_rect(center=editor_state.dialog_rect.center))


def _draw_text_input_content(surface: pygame.Surface, editor_state: EditorState, dialog_rect: pygame.Rect, fonts: Dict[str, Optional[pygame.font.Font]]):
    input_box_rect = pygame.Rect(0, 0, dialog_rect.width - 40, 40)
    input_box_rect.center = dialog_rect.centerx, dialog_rect.centery + 10
    editor_state.ui_elements_rects['dialog_text_input_box'] = input_box_rect

    pygame.draw.rect(surface, ED_CONFIG.DIALOG_INPUT_BOX_COLOR, input_box_rect)
    pygame.draw.rect(surface, getattr(ED_CONFIG.C, 'BLACK', (0,0,0)), input_box_rect, 2)

    text_font = fonts.get("medium") or ED_CONFIG.FONT_CONFIG.get("medium")
    current_text_to_render = str(editor_state.dialog_input_text) if editor_state.dialog_input_text is not None else ""

    if text_font:
        if editor_state.dialog_input_text_selected:
            text_surf_for_highlight = text_font.render(current_text_to_render, True, ED_CONFIG.DIALOG_INPUT_TEXT_COLOR)
            highlight_width = text_surf_for_highlight.get_width()
            highlight_height = text_surf_for_highlight.get_height()

            text_padding_x = 6
            highlight_rect = pygame.Rect(
                input_box_rect.left + text_padding_x,
                input_box_rect.centery - highlight_height // 2,
                highlight_width,
                highlight_height
            )
            clip_area_for_highlight = input_box_rect.inflate(-text_padding_x*2, -8)
            highlight_rect = highlight_rect.clip(clip_area_for_highlight)

            pygame.draw.rect(surface, getattr(ED_CONFIG.C, 'LIGHT_BLUE', (173,216,230)), highlight_rect)


        input_text_surf = text_font.render(current_text_to_render, True, ED_CONFIG.DIALOG_INPUT_TEXT_COLOR)
        text_clip_area_rect = input_box_rect.inflate(-12, -12)
        text_surf_width = input_text_surf.get_width()
        blit_area = None
        text_draw_pos_on_surface_x = text_clip_area_rect.left

        if text_surf_width > text_clip_area_rect.width:
            text_draw_pos_on_surface_x = text_clip_area_rect.right - text_surf_width
            blit_source_x_offset = text_surf_width - text_clip_area_rect.width
            blit_area = pygame.Rect(blit_source_x_offset, 0, text_clip_area_rect.width, input_text_surf.get_height())

        blit_destination_topleft = (text_draw_pos_on_surface_x,
                                    text_clip_area_rect.top + (text_clip_area_rect.height - input_text_surf.get_height()) // 2)

        original_clip = surface.get_clip()
        surface.set_clip(text_clip_area_rect)
        surface.blit(input_text_surf, blit_destination_topleft, area=blit_area)
        surface.set_clip(original_clip)

        if not editor_state.dialog_input_text_selected:
            if blit_area:
                cursor_render_x = text_clip_area_rect.right -1
            else:
                cursor_render_x = text_clip_area_rect.left + input_text_surf.get_width() + 1

            cursor_render_x = max(text_clip_area_rect.left, min(cursor_render_x, text_clip_area_rect.right -1))

            if int(pygame.time.get_ticks() / 500) % 2 == 0:
                 pygame.draw.line(surface, ED_CONFIG.DIALOG_CURSOR_COLOR,
                                 (cursor_render_x, input_box_rect.top + 5),
                                 (cursor_render_x, input_box_rect.bottom - 5), 2)

    info_font = fonts.get("small") or ED_CONFIG.FONT_CONFIG.get("small")
    if info_font:
        info_surf = info_font.render("Enter: Confirm, Esc: Cancel", True, getattr(ED_CONFIG.C, 'LIGHT_GRAY', (200,200,200)))
        surface.blit(info_surf, info_surf.get_rect(midbottom=(dialog_rect.centerx, dialog_rect.bottom - 10)))

def _draw_color_picker_content(surface: pygame.Surface, editor_state: EditorState, dialog_rect: pygame.Rect, fonts: Dict[str, Optional[pygame.font.Font]]):
    mouse_pos_dialog = pygame.mouse.get_pos()
    default_fallback_color = (255, 0, 255)

    for name, swatch_rect_relative in editor_state.color_picker_rects.items():
        absolute_swatch_rect = swatch_rect_relative.move(dialog_rect.left, dialog_rect.top)

        magenta_default = getattr(ED_CONFIG.C, 'MAGENTA', default_fallback_color)
        color_val = ED_CONFIG.COLOR_PICKER_PRESETS.get(name, magenta_default)

        pygame.draw.rect(surface, color_val, absolute_swatch_rect)
        border_col = getattr(ED_CONFIG.C, 'BLACK', (0,0,0))
        border_w = 1
        if absolute_swatch_rect.collidepoint(mouse_pos_dialog):
            border_col = getattr(ED_CONFIG, 'COLOR_PICKER_HOVER_BORDER_COLOR', getattr(ED_CONFIG.C, 'YELLOW', (255,255,0)))
            border_w = 3
        pygame.draw.rect(surface, border_col, absolute_swatch_rect, border_w)

def _draw_file_load_content(surface: pygame.Surface, editor_state: EditorState, dialog_rect: pygame.Rect, fonts: Dict[str, Optional[pygame.font.Font]]):
    prompt_font = fonts.get("medium") or ED_CONFIG.FONT_CONFIG.get("medium")
    title_height = prompt_font.get_height() + 25 if prompt_font else 55
    buttons_panel_height = ED_CONFIG.BUTTON_HEIGHT_STANDARD // 2 + 20

    list_area_y_start = dialog_rect.top + title_height
    list_area_height = dialog_rect.height - title_height - buttons_panel_height

    list_area_rect = pygame.Rect(dialog_rect.left + 10, list_area_y_start, dialog_rect.width - 20, list_area_height)
    pygame.draw.rect(surface, ED_CONFIG.DIALOG_INPUT_BOX_COLOR, list_area_rect)
    pygame.draw.rect(surface, getattr(ED_CONFIG.C, 'BLACK', (0,0,0)), list_area_rect, 1)

    item_font = fonts.get("small") or ED_CONFIG.FONT_CONFIG.get("small")
    item_line_height = (item_font.get_height() + 6) if item_font else 22

    if 'dialog_file_item_rects' not in editor_state.ui_elements_rects:
        editor_state.ui_elements_rects['dialog_file_item_rects'] = []
    else:
        editor_state.ui_elements_rects['dialog_file_item_rects'].clear()

    list_clip_rect = list_area_rect.inflate(-8, -8)
    total_content_height_pixels = len(editor_state.dialog_file_list) * item_line_height
    scrollbar_width_drawn = 0

    if total_content_height_pixels > list_clip_rect.height:
        scrollbar_width_drawn = 15
        scrollbar_track_rect = pygame.Rect(list_clip_rect.right + 2, list_clip_rect.top,
                                          scrollbar_width_drawn, list_clip_rect.height)
        pygame.draw.rect(surface, getattr(ED_CONFIG.C, 'DARK_GRAY', (50,50,50)), scrollbar_track_rect)
        handle_height_ratio = min(1.0, list_clip_rect.height / total_content_height_pixels if total_content_height_pixels > 0 else 1.0)
        handle_height = max(20, scrollbar_track_rect.height * handle_height_ratio)
        scrollable_content_outside_view = max(0, total_content_height_pixels - list_clip_rect.height)
        current_scroll_ratio_of_hidden = editor_state.dialog_file_scroll_y / scrollable_content_outside_view if scrollable_content_outside_view > 0 else 0
        handle_y_pos_on_track = (scrollbar_track_rect.height - handle_height) * current_scroll_ratio_of_hidden
        scrollbar_handle_rect = pygame.Rect(scrollbar_track_rect.left,
                                            scrollbar_track_rect.top + handle_y_pos_on_track,
                                            scrollbar_width_drawn, handle_height)
        pygame.draw.rect(surface, getattr(ED_CONFIG.C, 'GRAY', (128,128,128)), scrollbar_handle_rect, border_radius=3)
        editor_state.ui_elements_rects['file_dialog_scrollbar_handle'] = scrollbar_handle_rect
        editor_state.ui_elements_rects['file_dialog_scrollbar_area'] = scrollbar_track_rect

    list_item_text_render_width = list_clip_rect.width - (scrollbar_width_drawn + 2 if scrollbar_width_drawn > 0 else 0)
    original_clip_pygame = surface.get_clip()
    surface.set_clip(list_clip_rect)
    current_y_offset_in_clip_rect = 0

    for i, filename in enumerate(editor_state.dialog_file_list): # filename here is already basename
        item_draw_y_on_surface = list_clip_rect.top + current_y_offset_in_clip_rect - editor_state.dialog_file_scroll_y
        item_full_rect_on_screen = pygame.Rect(list_clip_rect.left, item_draw_y_on_surface,
                                           list_item_text_render_width, item_line_height)
        if list_clip_rect.colliderect(item_full_rect_on_screen):
            editor_state.ui_elements_rects['dialog_file_item_rects'].append(
                {"text": filename, "rect": item_full_rect_on_screen, "index": i}
            )
            if item_font:
                text_color = getattr(ED_CONFIG.C, 'BLACK', (0,0,0))
                bg_color_item = ED_CONFIG.DIALOG_INPUT_BOX_COLOR
                if editor_state.dialog_selected_file_index == i:
                    bg_color_item = getattr(ED_CONFIG.C, 'BLUE', (0,0,255))
                    text_color = getattr(ED_CONFIG.C, 'WHITE', (255,255,255))
                pygame.draw.rect(surface, bg_color_item, item_full_rect_on_screen)
                text_surf = item_font.render(filename, True, text_color) # Render the basename
                text_draw_pos = (item_full_rect_on_screen.left + 5,
                                 item_full_rect_on_screen.centery - text_surf.get_height() // 2)
                surface.blit(text_surf, text_draw_pos)
        current_y_offset_in_clip_rect += item_line_height
    surface.set_clip(original_clip_pygame)

    button_font = fonts.get("small") or ED_CONFIG.FONT_CONFIG.get("small")
    if button_font:
        btn_width = ED_CONFIG.BUTTON_WIDTH_STANDARD // 2 - 15
        btn_height = ED_CONFIG.BUTTON_HEIGHT_STANDARD // 2 + 5
        buttons_y_pos = list_area_rect.bottom + 10

        ok_text = "Load"
        if editor_state.dialog_prompt_message:
            prompt_lower = editor_state.dialog_prompt_message.lower()
            if "delete" in prompt_lower or "rename" in prompt_lower: # Combined condition
                ok_text = "Select"

        ok_button_rect = pygame.Rect(dialog_rect.centerx - btn_width - 5, buttons_y_pos, btn_width, btn_height)
        cancel_button_rect = pygame.Rect(dialog_rect.centerx + 5, buttons_y_pos, btn_width, btn_height)
        mouse_pos = pygame.mouse.get_pos()
        ok_is_active = (editor_state.dialog_selected_file_index != -1 and
                        0 <= editor_state.dialog_selected_file_index < len(editor_state.dialog_file_list))
        draw_button(surface, ok_button_rect, ok_text, button_font, mouse_pos, is_active=ok_is_active)
        draw_button(surface, cancel_button_rect, "Cancel", button_font, mouse_pos)
        editor_state.ui_elements_rects["dialog_file_load_ok"] = ok_button_rect
        editor_state.ui_elements_rects["dialog_file_load_cancel"] = cancel_button_rect

########## START OF FILE: editor\editor_updates.py ##########

# editor/editor_updates.py
# -*- coding: utf-8 -*-
"""
Continuous update functions for the editor state, called each frame.
"""
import pygame
import math
import logging
from typing import Tuple

import editor_config as ED_CONFIG
from editor_state import EditorState

logger = logging.getLogger(__name__)

def update_continuous_camera_pan(editor_state: EditorState, map_view_rect: pygame.Rect, mouse_pos: Tuple[int,int], dt: float):
    """
    Handles continuous camera panning via WASD keys and edge scrolling.
    Also manages camera momentum when mouse leaves map view.
    """
    if editor_state.active_dialog_type: 
        editor_state.camera_momentum_pan=(0.0,0.0)
        return

    keys = pygame.key.get_pressed()
    pan_px_sec = ED_CONFIG.KEY_PAN_SPEED_PIXELS_PER_SECOND
    edge_pan_px_sec = ED_CONFIG.EDGE_SCROLL_SPEED_PIXELS_PER_SECOND
    pan_amount, edge_pan_amount = pan_px_sec * dt, edge_pan_px_sec * dt
    
    cam_moved_by_direct_input = False
    dx, dy = 0.0, 0.0

    if keys[pygame.K_a]: dx -= pan_amount; cam_moved_by_direct_input=True
    if keys[pygame.K_d]: dx += pan_amount; cam_moved_by_direct_input=True
    if keys[pygame.K_w]: dy -= pan_amount; cam_moved_by_direct_input=True
    if keys[pygame.K_s] and not (keys[pygame.K_LCTRL]or keys[pygame.K_RCTRL]): dy+=pan_amount; cam_moved_by_direct_input=True
    
    prev_is_mouse_over_map = editor_state.is_mouse_over_map_view
    editor_state.is_mouse_over_map_view = map_view_rect.collidepoint(mouse_pos)

    if editor_state.is_mouse_over_map_view:
        editor_state.camera_momentum_pan = (0.0, 0.0) # Stop momentum if mouse re-enters
        if editor_state.last_mouse_pos_map_view and dt > 0.0001: # Calculate mouse velocity
            vel_x = (mouse_pos[0] - editor_state.last_mouse_pos_map_view[0]) / dt
            vel_y = (mouse_pos[1] - editor_state.last_mouse_pos_map_view[1]) / dt
            editor_state.mouse_velocity_map_view = (vel_x, vel_y)
        else:
            editor_state.mouse_velocity_map_view = (0.0, 0.0)
        editor_state.last_mouse_pos_map_view = mouse_pos

        # Edge scrolling if mouse is over map and no key pan
        if not cam_moved_by_direct_input:
            zone=ED_CONFIG.EDGE_SCROLL_ZONE_THICKNESS
            if mouse_pos[0]<map_view_rect.left+zone: dx-=edge_pan_amount; cam_moved_by_direct_input=True # Treat edge scroll as direct input for momentum
            elif mouse_pos[0]>map_view_rect.right-zone: dx+=edge_pan_amount; cam_moved_by_direct_input=True
            if mouse_pos[1]<map_view_rect.top+zone: dy-=edge_pan_amount; cam_moved_by_direct_input=True
            elif mouse_pos[1]>map_view_rect.bottom-zone: dy+=edge_pan_amount; cam_moved_by_direct_input=True
            
    elif prev_is_mouse_over_map and not editor_state.is_mouse_over_map_view: # Mouse just left map view
        if not cam_moved_by_direct_input and \
           (abs(editor_state.mouse_velocity_map_view[0]) > ED_CONFIG.CAMERA_MOMENTUM_MIN_SPEED_THRESHOLD or \
            abs(editor_state.mouse_velocity_map_view[1]) > ED_CONFIG.CAMERA_MOMENTUM_MIN_SPEED_THRESHOLD) :
            
            # Changed: Removed negative sign to make camera pan in direction of swipe
            fling_vx = editor_state.mouse_velocity_map_view[0] * ED_CONFIG.CAMERA_MOMENTUM_INITIAL_MULTIPLIER
            fling_vy = editor_state.mouse_velocity_map_view[1] * ED_CONFIG.CAMERA_MOMENTUM_INITIAL_MULTIPLIER
            editor_state.camera_momentum_pan = (fling_vx, fling_vy)
            logger.debug(f"Mouse exited map view. Initiated camera fling with momentum: ({fling_vx:.2f}, {fling_vy:.2f}) based on mouse velocity {editor_state.mouse_velocity_map_view}")
        
        editor_state.last_mouse_pos_map_view = None
        editor_state.mouse_velocity_map_view = (0.0,0.0)

    if cam_moved_by_direct_input: # Keys or edge scroll
        editor_state.camera_momentum_pan = (0.0, 0.0) # Stop momentum if there's direct input
        editor_state.camera_offset_x += dx
        editor_state.camera_offset_y += dy

    # Clamp camera
    max_cam_x = max(0, editor_state.get_map_pixel_width() - map_view_rect.width)
    max_cam_y = max(0, editor_state.get_map_pixel_height() - map_view_rect.height)
    editor_state.camera_offset_x = max(0, min(editor_state.camera_offset_x, max_cam_x))
    editor_state.camera_offset_y = max(0, min(editor_state.camera_offset_y, max_cam_y))


def update_asset_palette_scroll_momentum(editor_state: EditorState, dt: float,
                                         asset_list_visible_height: float,
                                         total_asset_content_height: float):
    """
    Updates the asset palette scroll position based on momentum.
    """
    if not hasattr(editor_state, 'asset_palette_scroll_momentum'):
        editor_state.asset_palette_scroll_momentum = 0.0

    if editor_state.asset_palette_scroll_momentum != 0.0:
        delta_scroll = editor_state.asset_palette_scroll_momentum * dt
        editor_state.asset_palette_scroll_y += delta_scroll

        # Dampen momentum (more frame-rate independent)
        # The (dt * 60.0) part scales damping as if it's happening 60 times a second
        editor_state.asset_palette_scroll_momentum *= (ED_CONFIG.ASSET_PALETTE_FLING_DAMPING_FACTOR ** (dt * 60.0)) 
        
        if abs(editor_state.asset_palette_scroll_momentum) < ED_CONFIG.ASSET_PALETTE_FLING_MIN_SPEED_THRESHOLD:
            editor_state.asset_palette_scroll_momentum = 0.0

        max_scroll = max(0, total_asset_content_height - asset_list_visible_height)
        
        boundary_hit = False
        if editor_state.asset_palette_scroll_y < 0:
            editor_state.asset_palette_scroll_y = 0
            boundary_hit = True
        elif editor_state.asset_palette_scroll_y > max_scroll:
            editor_state.asset_palette_scroll_y = max_scroll
            boundary_hit = True
        
        if boundary_hit:
            editor_state.asset_palette_scroll_momentum = 0.0 # Stop dead at boundary

########## START OF FILE: editor_logging.py ##########

# editor/editor_logging.py
# -*- coding: utf-8 -*-
"""
Centralized logging setup for the Platformer Level Editor.
Allows enabling/disabling file logging and console logging.
"""
import logging
import os
import traceback
from typing import Optional

# --- USER CONFIGURABLE LOGGING SETTINGS ---
ENABLE_FILE_LOGGING = True  # Set to False to disable writing logs to a file
ENABLE_CONSOLE_DEBUG_LOGGING = True # Set to False to disable DEBUG level messages to console (INFO and above will still show if file logging also fails)
# If ENABLE_FILE_LOGGING is False, console logging will be used as a fallback,
# respecting ENABLE_CONSOLE_DEBUG_LOGGING for DEBUG messages.

# --- Constants ---
LOG_DIRECTORY_NAME = 'logs'
LOG_FILE_NAME = 'editor_debug.log'

# --- Global Logger Variable ---
# This will be set by setup_logging() and can be imported by other modules.
logger: Optional[logging.Logger] = None

def setup_logging(script_main_dir: Optional[str] = None) -> logging.Logger:
    """
    Configures the root logger for the application.

    Args:
        script_main_dir (Optional[str]): The directory of the main script (e.g., editor.py).
                                         If None, it attempts to use the directory of this logging script.

    Returns:
        logging.Logger: The configured logger instance.
    """
    global logger # Allow modification of the global logger variable

    # Determine base directory for logs
    if script_main_dir:
        base_dir = script_main_dir
    else:
        base_dir = os.path.dirname(os.path.abspath(__file__)) # Directory of this logging script

    log_file_path = "Not determined" # Default for error messages

    # Remove any existing handlers from the root logger to avoid duplicate logs
    for handler in logging.root.handlers[:]:
        logging.root.removeHandler(handler)

    log_level = logging.DEBUG if ENABLE_CONSOLE_DEBUG_LOGGING else logging.INFO
    
    handlers_to_add = []
    log_to_file_successful = False

    if ENABLE_FILE_LOGGING:
        try:
            logs_dir_path = os.path.join(base_dir, LOG_DIRECTORY_NAME)
            if not os.path.exists(logs_dir_path):
                print(f"Attempting to create logs directory: {logs_dir_path}")
                os.makedirs(logs_dir_path)
                print(f"Logs directory created (or already existed at {logs_dir_path}).")
            else:
                print(f"Logs directory already exists at: {logs_dir_path}")

            log_file_path = os.path.join(logs_dir_path, LOG_FILE_NAME)
            print(f"Attempting to configure file logging to: {log_file_path}")
            
            file_handler = logging.FileHandler(log_file_path, mode='w')
            file_formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(filename)s:%(lineno)d - %(funcName)s - %(message)s')
            file_handler.setFormatter(file_formatter)
            file_handler.setLevel(logging.DEBUG) # Always log DEBUG to file if file logging is on
            handlers_to_add.append(file_handler)
            log_to_file_successful = True
            print(f"File logging configured. Log file should be at: {log_file_path}")
        except Exception as e_log_file:
            print(f"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
            print(f"CRITICAL ERROR DURING FILE LOGGING SETUP: {e_log_file}")
            print(f"Traceback for file logging error:")
            traceback.print_exc()
            print(f"Log file might not be created. Attempted log file path was: {log_file_path}")
            print(f"Falling back to console logging only.")
            print(f"!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
            log_to_file_successful = False

    # Always add a console handler, its level depends on settings
    console_handler = logging.StreamHandler() # Defaults to sys.stderr
    console_formatter = logging.Formatter('CONSOLE: %(levelname)s - %(filename)s:%(lineno)d - %(message)s')
    console_handler.setFormatter(console_formatter)
    
    if log_to_file_successful and not ENABLE_CONSOLE_DEBUG_LOGGING:
        # If file logging is working and user wants less console verbosity, set console to INFO
        console_handler.setLevel(logging.INFO)
    else:
        # Otherwise (file logging off, or file logging failed, or console debug is on), set console by ENABLE_CONSOLE_DEBUG_LOGGING
        console_handler.setLevel(logging.DEBUG if ENABLE_CONSOLE_DEBUG_LOGGING else logging.INFO)
        
    handlers_to_add.append(console_handler)

    logging.basicConfig(
        level=logging.DEBUG, # Root logger set to DEBUG to allow handlers to filter
        handlers=handlers_to_add
    )

    logger = logging.getLogger("PlatformerEditor") # Get a named logger for the application

    if log_to_file_successful:
        logger.info("Logging initialized. File logging is ON.")
    else:
        logger.info("Logging initialized. File logging is OFF or failed. Using console logging.")
    
    if ENABLE_CONSOLE_DEBUG_LOGGING:
        logger.info("Console DEBUG logging is ON.")
    else:
        logger.info("Console DEBUG logging is OFF (INFO and above will still show on console if file logging is off/failed).")
        
    return logger

# Example of how to get the logger in other modules:
# from editor_logging import logger
# if logger:
# logger.info("This is an info message from another_module.py")

########## START OF FILE: enemy.py ##########

# enemy.py
# -*- coding: utf-8 -*-
## version 1.0.0.10 (Integrated global logger, removed internal PrintLimiter)
"""
Defines the Enemy class, a CPU-controlled character.
Handles AI-driven movement (via enemy_ai_handler), animations, states,
combat (via enemy_combat_handler), and network synchronization
(via enemy_network_handler).
Each instance randomly selects a color variant for its animations if configured.
"""
import pygame
import random
import math
import os

# --- Import Logger ---
try:
    from logger import info, debug, warning, error, critical
except ImportError:
    print("CRITICAL ENEMY: logger.py not found. Falling back to print statements for logging.")
    def info(msg): print(f"INFO: {msg}")
    def debug(msg): print(f"DEBUG: {msg}")
    def warning(msg): print(f"WARNING: {msg}")
    def error(msg): print(f"ERROR: {msg}")
    def critical(msg): print(f"CRITICAL: {msg}")
# --- End Logger ---

import constants as C
from assets import load_all_player_animations
from tiles import Lava

from enemy_ai_handler import set_enemy_new_patrol_target, enemy_ai_update
from enemy_combat_handler import check_enemy_attack_collisions, enemy_take_damage
from enemy_network_handler import get_enemy_network_data, set_enemy_network_data


class Enemy(pygame.sprite.Sprite):
    # Note: Class-level PrintLimiter was removed. Use global logger functions (debug, info, warning, etc.)

    def __init__(self, start_x, start_y, patrol_area=None, enemy_id=None):
        super().__init__()
        self.spawn_pos = pygame.math.Vector2(start_x, start_y)
        self.patrol_area = patrol_area
        self.enemy_id = enemy_id if enemy_id is not None else id(self)
        self._valid_init = True
        character_base_asset_folder = 'characters'
        available_enemy_colors = ['cyan', 'green', 'pink', 'purple', 'red', 'yellow']
        if not available_enemy_colors:
             warning(f"Enemy Warning (ID: {self.enemy_id}): No enemy colors defined! Defaulting to 'player1' assets.")
             available_enemy_colors = ['player1']
        self.color_name = random.choice(available_enemy_colors)
        chosen_enemy_asset_folder = os.path.join(character_base_asset_folder, self.color_name)

        self.animations = load_all_player_animations(relative_asset_folder=chosen_enemy_asset_folder)
        if self.animations is None:
            critical(f"Enemy CRITICAL (ID: {self.enemy_id}, Color: {self.color_name}): Failed loading animations from '{chosen_enemy_asset_folder}'.")
            self.image = pygame.Surface((30, 40)).convert_alpha(); self.image.fill(C.BLUE)
            self.rect = self.image.get_rect(midbottom=(start_x, start_y))
            self._valid_init = False; self.is_dead = True; return

        self._last_facing_right = True
        self._last_state_for_debug = "init" # Can be removed if not actively debugging state machine
        self.state = 'idle'
        self.current_frame = 0
        self.last_anim_update = pygame.time.get_ticks()

        initial_idle_animation = self.animations.get('idle')
        if not initial_idle_animation:
             warning(f"Enemy Warning (ID: {self.enemy_id}, Color: {self.color_name}): 'idle' animation missing. Attempting fallback.")
             first_anim_key = next(iter(self.animations), None)
             initial_idle_animation = self.animations.get(first_anim_key) if first_anim_key and self.animations.get(first_anim_key) else None

        if initial_idle_animation and len(initial_idle_animation) > 0:
            self.image = initial_idle_animation[0]
        else:
            self.image = pygame.Surface((30, 40)).convert_alpha(); self.image.fill(C.BLUE)
            critical(f"Enemy CRITICAL (ID: {self.enemy_id}): No suitable initial animation found after fallbacks.")
            self._valid_init = False; self.is_dead = True; return

        self.rect = self.image.get_rect(midbottom=(start_x, start_y))
        self.pos = pygame.math.Vector2(start_x, start_y)
        self.vel = pygame.math.Vector2(0, 0)
        self.acc = pygame.math.Vector2(0, getattr(C, 'ENEMY_GRAVITY', getattr(C, 'PLAYER_GRAVITY', 0.8)))
        self.facing_right = random.choice([True, False])
        self.on_ground = False
        self.ai_state = 'patrolling'
        self.patrol_target_x = start_x
        set_enemy_new_patrol_target(self)
        self.is_attacking = False; self.attack_timer = 0
        self.attack_duration = getattr(C, 'ENEMY_ATTACK_STATE_DURATION', getattr(C, 'CHARACTER_ATTACK_STATE_DURATION', 500))
        self.attack_type = 0
        self.attack_cooldown_timer = 0
        self.post_attack_pause_timer = 0
        self.post_attack_pause_duration = getattr(C, 'ENEMY_POST_ATTACK_PAUSE_DURATION', 200)
        self.is_taking_hit = False; self.hit_timer = 0
        self.hit_duration = getattr(C, 'ENEMY_HIT_STUN_DURATION', 300)
        self.hit_cooldown = getattr(C, 'ENEMY_HIT_COOLDOWN', 500)
        self.is_dead = False
        self.death_animation_finished = False
        self.state_timer = 0
        self.max_health = getattr(C, 'ENEMY_MAX_HEALTH', 100)
        self.current_health = self.max_health
        self.attack_hitbox = pygame.Rect(0, 0, 50, 35)
        try: self.standard_height = self.animations['idle'][0].get_height() if self.animations.get('idle') else 60
        except (KeyError, IndexError, TypeError): self.standard_height = 60

        # Stomp death attributes
        self.is_stomp_dying = False
        self.stomp_death_start_time = 0
        self.original_stomp_death_image = None
        self.original_stomp_facing_right = True


    def set_state(self, new_state: str):
        if not self._valid_init: return

        # If being stomp-killed, visual state is handled by is_stomp_dying in animate()
        if self.is_stomp_dying and new_state != 'stomp_death': # Allow setting to 'stomp_death' if needed by logic
            return

        animation_key_to_validate = new_state
        valid_direct_animation_states = ['idle', 'run', 'attack', 'attack_nm', 'hit', 'death', 'death_nm', 'fall', 'stomp_death']

        if new_state not in valid_direct_animation_states:
            if new_state in ['chasing', 'patrolling']:
                animation_key_to_validate = 'run'
            elif 'attack' in new_state:
                animation_key_to_validate = new_state
            else:
                animation_key_to_validate = 'idle'

        # For stomp_death, there's no dedicated animation sheet, it's procedural
        if new_state == 'stomp_death':
            pass # No animation frames to validate for stomp_death
        elif animation_key_to_validate not in self.animations or not self.animations[animation_key_to_validate]:
            warning(f"Enemy Warning (ID: {self.enemy_id}): Animation for key '{animation_key_to_validate}' (from logical: '{new_state}') missing. Trying 'idle'.")
            animation_key_to_validate = 'idle'
            if 'idle' not in self.animations or not self.animations['idle']:
                 critical(f"Enemy CRITICAL (ID: {self.enemy_id}): Cannot find valid 'idle' animation. Halting state change for '{new_state}'.")
                 return

        can_change_state_now = (self.state != new_state or new_state in ['death', 'stomp_death']) and \
                               not (self.is_dead and not self.death_animation_finished and new_state not in ['death', 'stomp_death'])

        if can_change_state_now:
            self._last_state_for_debug = new_state # Keep if still useful for your own debugging
            if 'attack' not in new_state: self.is_attacking = False; self.attack_type = 0
            if new_state != 'hit': self.is_taking_hit = False

            self.state = new_state
            self.current_frame = 0
            current_ticks_ms = pygame.time.get_ticks()
            self.last_anim_update = current_ticks_ms
            self.state_timer = current_ticks_ms

            if 'attack' in new_state:
                self.is_attacking = True; self.attack_type = 1
                self.attack_timer = current_ticks_ms; self.vel.x = 0
            elif new_state == 'hit':
                 self.is_taking_hit = True; self.hit_timer = self.state_timer
                 self.vel.x *= -0.5
                 self.vel.y = getattr(C, 'ENEMY_HIT_BOUNCE_Y', getattr(C, 'PLAYER_JUMP_STRENGTH', -10) * 0.3)
                 self.is_attacking = False
            elif new_state == 'death' or new_state == 'stomp_death':
                 self.is_dead = True; self.vel.x = 0; self.vel.y = 0
                 self.acc.xy = 0, 0; self.current_health = 0
                 self.death_animation_finished = False
                 if new_state == 'stomp_death' and not self.is_stomp_dying: # Ensure stomp flags are set if directly setting this state
                     self.stomp_kill() # This will correctly initialize stomp death

            self.animate()
        elif not self.is_dead:
             self._last_state_for_debug = self.state

    def animate(self):
        if not self._valid_init or not hasattr(self, 'animations') or not self.animations: return
        # Allow animation if alive() OR if is_dead and death animation not finished (covers normal and stomp death)
        if not (self.alive() or (self.is_dead and not self.death_animation_finished)):
            return

        current_time_ms = pygame.time.get_ticks()
        animation_frame_duration_ms = getattr(C, 'ANIM_FRAME_DURATION', 100)

        if self.is_stomp_dying:
            if not self.original_stomp_death_image:
                self.death_animation_finished = True
                self.is_stomp_dying = False
                # if self.alive(): self.kill() # Let external logic handle kill based on death_animation_finished
                return

            elapsed_time = current_time_ms - self.stomp_death_start_time
            stomp_death_total_duration = getattr(C, 'ENEMY_STOMP_DEATH_DURATION', 300)
            scale_factor = 0.0

            if elapsed_time >= stomp_death_total_duration:
                self.death_animation_finished = True
                self.is_stomp_dying = False
            else:
                scale_factor = 1.0 - (elapsed_time / stomp_death_total_duration)

            scale_factor = max(0.0, min(1.0, scale_factor))

            original_width = self.original_stomp_death_image.get_width()
            original_height = self.original_stomp_death_image.get_height()
            new_height = int(original_height * scale_factor)

            if new_height <= 1: # Make it effectively invisible or 1px high
                self.image = pygame.Surface((original_width, 1), pygame.SRCALPHA)
                self.image.fill((0,0,0,0)) # Transparent
                if not self.death_animation_finished: # Ensure flags are set if shrink makes it disappear early
                    self.death_animation_finished = True
                    self.is_stomp_dying = False
            else:
                self.image = pygame.transform.scale(self.original_stomp_death_image, (original_width, new_height))

            old_midbottom = self.rect.midbottom
            self.rect = self.image.get_rect(midbottom=old_midbottom)
            # self._last_facing_right is not strictly needed here as stomp image is fixed.
            return # Stomp death animation overrides other animation logic

        determined_animation_key = 'idle'

        if self.is_dead: # Regular death (not stomp)
            determined_animation_key = 'death_nm' if abs(self.vel.x) < 0.1 and abs(self.vel.y) < 0.1 and \
                                     self.animations.get('death_nm') else 'death'
            if not self.animations.get(determined_animation_key):
                determined_animation_key = 'death' if self.animations.get('death') else 'idle'
        elif self.post_attack_pause_timer > 0 and current_time_ms < self.post_attack_pause_timer:
            determined_animation_key = 'idle'
        elif self.state in ['patrolling', 'chasing'] or (self.state == 'run' and abs(self.vel.x) > 0.1):
             determined_animation_key = 'run' if abs(self.vel.x) > 0.1 else 'idle'
        elif self.is_attacking:
            determined_animation_key = 'attack_nm' if self.animations.get('attack_nm') else 'attack'
            if not self.animations.get(determined_animation_key): determined_animation_key = 'idle'
        elif self.is_taking_hit:
            determined_animation_key = 'hit' if self.animations.get('hit') else 'idle'
        elif not self.on_ground:
            determined_animation_key = 'fall' if self.animations.get('fall') else 'idle'
        elif self.state == 'idle':
            determined_animation_key = 'idle'
        elif self.state == 'run':
            determined_animation_key = 'run' if abs(self.vel.x) > 0.1 else 'idle'

        if not self.animations.get(determined_animation_key):
            warning(f"Enemy Animate Warning (ID: {self.enemy_id}): Key '{determined_animation_key}' invalid for state '{self.state}'. Defaulting to 'idle'.")
            determined_animation_key = 'idle'

        current_animation_frames_list = self.animations.get(determined_animation_key)

        if not current_animation_frames_list:
            if hasattr(self, 'image') and self.image: self.image.fill(C.BLUE)
            critical(f"Enemy CRITICAL Animate (ID: {self.enemy_id}): No frames for '{determined_animation_key}' (state: {self.state})")
            return

        if not (self.is_dead and self.death_animation_finished):
            if current_time_ms - self.last_anim_update > animation_frame_duration_ms:
                self.last_anim_update = current_time_ms
                self.current_frame += 1

                if self.current_frame >= len(current_animation_frames_list):
                    if self.is_dead: # Regular death animation finished
                        self.current_frame = len(current_animation_frames_list) - 1
                        self.death_animation_finished = True
                        final_death_image_surface = current_animation_frames_list[self.current_frame]
                        if not self.facing_right: final_death_image_surface = pygame.transform.flip(final_death_image_surface, True, False)
                        old_enemy_midbottom = self.rect.midbottom
                        self.image = final_death_image_surface
                        self.rect = self.image.get_rect(midbottom=old_enemy_midbottom)
                        return
                    elif self.state == 'hit':
                        self.set_state('idle' if self.on_ground else 'fall')
                        return
                    else:
                        self.current_frame = 0

                if self.current_frame >= len(current_animation_frames_list) and not self.is_dead : self.current_frame = 0

        if self.is_dead and self.death_animation_finished and not self.alive():
            return

        if not current_animation_frames_list or self.current_frame < 0 or \
           self.current_frame >= len(current_animation_frames_list):
            self.current_frame = 0
            if not current_animation_frames_list:
                if hasattr(self, 'image') and self.image: self.image.fill(C.BLUE); return

        image_for_this_frame = current_animation_frames_list[self.current_frame]
        current_facing_is_right_for_anim = self.facing_right
        if not current_facing_is_right_for_anim:
            image_for_this_frame = pygame.transform.flip(image_for_this_frame, True, False)

        if self.image is not image_for_this_frame or self._last_facing_right != current_facing_is_right_for_anim:
            old_enemy_midbottom_pos = self.rect.midbottom
            self.image = image_for_this_frame
            self.rect = self.image.get_rect(midbottom=old_enemy_midbottom_pos)
            self._last_facing_right = current_facing_is_right_for_anim

    def stomp_kill(self):
        if self.is_dead or self.is_stomp_dying:
            return
        debug(f"Enemy {self.enemy_id}: Stomp kill initiated.")
        self.current_health = 0
        self.is_dead = True
        self.is_stomp_dying = True
        self.stomp_death_start_time = pygame.time.get_ticks()

        self.original_stomp_death_image = self.image.copy()
        self.original_stomp_facing_right = self.facing_right

        self.vel.xy = 0,0
        self.acc.xy = 0,0

    def _ai_update(self, players_list_for_targeting):
        enemy_ai_update(self, players_list_for_targeting)

    def _check_attack_collisions(self, player_target_list_for_combat):
        check_enemy_attack_collisions(self, player_target_list_for_combat)

    def take_damage(self, damage_amount_taken):
        enemy_take_damage(self, damage_amount_taken)

    def get_network_data(self):
        return get_enemy_network_data(self)

    def set_network_data(self, received_network_data):
        set_enemy_network_data(self, received_network_data)


    def update(self, dt_sec, players_list_for_logic, platforms_group, hazards_group):
        if not self._valid_init: return

        if self.is_stomp_dying:
            self.animate() # Handles scaling and sets death_animation_finished
            return

        if self.is_dead and self.alive(): # Regular death (not stomp)
            if not self.death_animation_finished:
                if not self.on_ground:
                    self.vel.y += self.acc.y
                    self.vel.y = min(self.vel.y, getattr(C, 'TERMINAL_VELOCITY_Y', 18))
                    self.pos.y += self.vel.y
                    self.rect.bottom = round(self.pos.y)
                    self.on_ground = False
                    for platform_sprite in pygame.sprite.spritecollide(self, platforms_group, False):
                        if self.vel.y > 0 and self.rect.bottom > platform_sprite.rect.top and \
                           (self.pos.y - self.vel.y) <= platform_sprite.rect.top + 1:
                            self.rect.bottom = platform_sprite.rect.top
                            self.on_ground = True; self.vel.y = 0; self.acc.y = 0
                            self.pos.y = self.rect.bottom; break
            self.animate()
            return

        if self.is_dead and self.death_animation_finished: # Fully dead (stomp or regular)
            if self.alive(): self.kill()
            return

        current_time_ms = pygame.time.get_ticks()

        if self.post_attack_pause_timer > 0 and current_time_ms >= self.post_attack_pause_timer:
            self.post_attack_pause_timer = 0

        if self.is_taking_hit and current_time_ms - self.hit_timer > self.hit_cooldown:
            self.is_taking_hit = False

        self._ai_update(players_list_for_logic)

        if not self.is_dead:
            self.vel.y += self.acc.y

            enemy_friction_val = getattr(C, 'ENEMY_FRICTION', -0.12)
            enemy_run_speed_max = getattr(C, 'ENEMY_RUN_SPEED_LIMIT', 5)
            terminal_fall_speed_y = getattr(C, 'TERMINAL_VELOCITY_Y', 18)

            self.vel.x += self.acc.x

            apply_friction_to_enemy = self.on_ground and self.acc.x == 0
            if apply_friction_to_enemy:
                friction_force_on_enemy = self.vel.x * enemy_friction_val
                if abs(self.vel.x) > 0.1: self.vel.x += friction_force_on_enemy
                else: self.vel.x = 0

            self.vel.x = max(-enemy_run_speed_max, min(enemy_run_speed_max, self.vel.x))
            self.vel.y = min(self.vel.y, terminal_fall_speed_y)

            self.on_ground = False

            self.pos.x += self.vel.x
            self.rect.centerx = round(self.pos.x)
            self.check_platform_collisions('x', platforms_group)

            collided_horizontally_with_player = self.check_character_collision('x', players_list_for_logic)

            self.pos.y += self.vel.y
            self.rect.bottom = round(self.pos.y)
            self.check_platform_collisions('y', platforms_group)

            if not collided_horizontally_with_player:
                self.check_character_collision('y', players_list_for_logic)

            self.pos.x = self.rect.centerx
            self.pos.y = self.rect.bottom

            self.check_hazard_collisions(hazards_group)

            if self.is_attacking:
                self._check_attack_collisions(players_list_for_logic)

        self.animate()


    def check_platform_collisions(self, direction: str, platforms_group: pygame.sprite.Group):
        for platform_sprite in pygame.sprite.spritecollide(self, platforms_group, False):
            if direction == 'x':
                original_vel_x = self.vel.x
                if self.vel.x > 0: self.rect.right = platform_sprite.rect.left
                elif self.vel.x < 0: self.rect.left = platform_sprite.rect.right
                self.vel.x = 0
                if self.ai_state == 'patrolling':
                    if abs(original_vel_x) > 0.1 and \
                       (abs(self.rect.right - platform_sprite.rect.left) < 2 or \
                        abs(self.rect.left - platform_sprite.rect.right) < 2) :
                        set_enemy_new_patrol_target(self)
            elif direction == 'y':
                if self.vel.y > 0:
                    if self.rect.bottom > platform_sprite.rect.top and \
                       (self.pos.y - self.vel.y) <= platform_sprite.rect.top + 1:
                         self.rect.bottom = platform_sprite.rect.top
                         self.on_ground = True; self.vel.y = 0
                elif self.vel.y < 0:
                    if self.rect.top < platform_sprite.rect.bottom and \
                       ((self.pos.y - self.rect.height) - self.vel.y) >= platform_sprite.rect.bottom -1:
                         self.rect.top = platform_sprite.rect.bottom
                         self.vel.y = 0
            if direction == 'x': self.pos.x = self.rect.centerx
            else: self.pos.y = self.rect.bottom


    def check_character_collision(self, direction: str, player_list: list):
        if not self._valid_init or self.is_dead or not self.alive(): return False
        collision_with_player_occurred = False
        for player_char_sprite in player_list:
            if not (player_char_sprite and player_char_sprite._valid_init and \
                    not player_char_sprite.is_dead and player_char_sprite.alive()):
                continue
            if self.rect.colliderect(player_char_sprite.rect):
                collision_with_player_occurred = True
                bounce_vel_on_collision = getattr(C, 'CHARACTER_BOUNCE_VELOCITY', 2.5)
                if direction == 'x':
                    push_direction_for_enemy = -1 if self.rect.centerx < player_char_sprite.rect.centerx else 1
                    if push_direction_for_enemy == -1: self.rect.right = player_char_sprite.rect.left
                    else: self.rect.left = player_char_sprite.rect.right
                    self.vel.x = push_direction_for_enemy * bounce_vel_on_collision
                    if hasattr(player_char_sprite, 'vel'):
                        player_char_sprite.vel.x = -push_direction_for_enemy * bounce_vel_on_collision
                    if hasattr(player_char_sprite, 'pos') and hasattr(player_char_sprite, 'rect'):
                        player_char_sprite.pos.x += (-push_direction_for_enemy * 1.5)
                        player_char_sprite.rect.centerx = round(player_char_sprite.pos.x)
                    self.pos.x = self.rect.centerx
                elif direction == 'y':
                    if self.vel.y > 0 and self.rect.bottom > player_char_sprite.rect.top and \
                       self.rect.centery < player_char_sprite.rect.centery:
                        self.rect.bottom = player_char_sprite.rect.top; self.on_ground = True; self.vel.y = 0
                    elif self.vel.y < 0 and self.rect.top < player_char_sprite.rect.bottom and \
                         self.rect.centery > player_char_sprite.rect.centery:
                        self.rect.top = player_char_sprite.rect.bottom; self.vel.y = 0
                    self.pos.y = self.rect.bottom
        return collision_with_player_occurred


    def check_hazard_collisions(self, hazards_group: pygame.sprite.Group):
        current_time_ms = pygame.time.get_ticks()
        if not self._valid_init or self.is_dead or not self.alive() or \
           (self.is_taking_hit and current_time_ms - self.hit_timer < self.hit_cooldown):
            return
        damage_taken_from_hazard_this_frame = False
        hazard_check_point_enemy_feet = (self.rect.centerx, self.rect.bottom - 1)
        for hazard_sprite in hazards_group:
            if isinstance(hazard_sprite, Lava) and \
               hazard_sprite.rect.collidepoint(hazard_check_point_enemy_feet) and \
               not damage_taken_from_hazard_this_frame:
                self.take_damage(getattr(C, 'LAVA_DAMAGE', 50))
                damage_taken_from_hazard_this_frame = True
                if not self.is_dead:
                     self.vel.y = getattr(C, 'PLAYER_JUMP_STRENGTH', -15) * 0.3
                     push_dir_from_lava_hazard = 1 if self.rect.centerx < hazard_sprite.rect.centerx else -1
                     self.vel.x = -push_dir_from_lava_hazard * 4
                     self.on_ground = False
                break


    def reset(self):
        if not self._valid_init: return
        self.pos = self.spawn_pos.copy()
        self.rect.midbottom = (round(self.pos.x), round(self.pos.y))
        self.vel.xy = 0,0
        self.acc.xy = 0, getattr(C, 'ENEMY_GRAVITY', getattr(C, 'PLAYER_GRAVITY', 0.7))
        self.current_health = self.max_health
        self.is_dead = False
        self.death_animation_finished = False
        self.is_taking_hit = False
        self.is_attacking = False; self.attack_type = 0
        self.hit_timer = 0; self.attack_timer = 0; self.attack_cooldown_timer = 0
        self.post_attack_pause_timer = 0
        self.facing_right = random.choice([True, False])
        self.on_ground = False
        self.ai_state = 'patrolling'
        set_enemy_new_patrol_target(self)
        if hasattr(self.image, 'get_alpha') and self.image.get_alpha() is not None and \
           self.image.get_alpha() < 255:
            self.image.set_alpha(255)

        # Reset stomp death attributes
        self.is_stomp_dying = False
        self.stomp_death_start_time = 0
        self.original_stomp_death_image = None
        self.original_stomp_facing_right = self.facing_right

        self.set_state('idle')

########## START OF FILE: enemy_ai_handler.py ##########

# enemy_ai_handler.py
# -*- coding: utf-8 -*-
"""
version 1.0.0.2 (Corrected set_state logic for patrol/chase transitions)
Handles AI logic for enemies, including patrolling, chasing, and attacking decisions.
Functions here will typically take an 'enemy' instance as their first argument.
"""
import pygame
import random
import math
import constants as C # For accessing enemy-specific constants and general game constants

def set_enemy_new_patrol_target(enemy):
    """
    Sets a new patrol target X-coordinate for the enemy instance.
    If a patrol_area (pygame.Rect) is defined for the enemy, it patrols within that area.
    Otherwise, it patrols a set distance from its current position.

    Args:
        enemy (Enemy): The enemy instance for which to set a new patrol target.
    """
    # if not hasattr(enemy, 'rect') or not hasattr(enemy, 'pos'): # Guard against incomplete enemy object
    #     if hasattr(enemy, 'print_limiter') and enemy.print_limiter.can_print(f"enemy_patrol_target_no_rect_{enemy.enemy_id}"):
    #         print(f"ENEMY AI WARN ({enemy.enemy_id}): set_enemy_new_patrol_target called on enemy without rect/pos.")
        # return

    if enemy.patrol_area and isinstance(enemy.patrol_area, pygame.Rect):
         min_x_patrol = enemy.patrol_area.left + enemy.rect.width / 2
         max_x_patrol = enemy.patrol_area.right - enemy.rect.width / 2
         
         if min_x_patrol < max_x_patrol: 
             enemy.patrol_target_x = random.uniform(min_x_patrol, max_x_patrol)
         else: 
             enemy.patrol_target_x = enemy.patrol_area.centerx
    else: 
        patrol_direction = 1 if random.random() > 0.5 else -1
        enemy.patrol_target_x = enemy.pos.x + patrol_direction * getattr(C, 'ENEMY_PATROL_DIST', 150)


def enemy_ai_update(enemy, players_list_for_ai):
    """
    Updates the enemy's AI state (e.g., patrolling, chasing, attacking) and behavior
    based on player proximity and other conditions. Modifies the enemy instance directly.

    Args:
        enemy (Enemy): The enemy instance to update.
        players_list_for_ai (list): A list of player Sprites that the AI can target.
    """
    current_time_ms = pygame.time.get_ticks() 
    
    if enemy.post_attack_pause_timer > 0 and current_time_ms < enemy.post_attack_pause_timer:
        enemy.acc.x = 0 
        if enemy.state != 'idle': 
            enemy.set_state('idle') 
        return 

    if not enemy._valid_init or enemy.is_dead or not enemy.alive() or \
       (enemy.is_taking_hit and current_time_ms - enemy.hit_timer < enemy.hit_cooldown):
        enemy.acc.x = 0 
        return

    closest_target_player = None
    min_squared_distance_to_player = float('inf') 

    for player_candidate in players_list_for_ai:
        is_candidate_targetable = (
            player_candidate and player_candidate._valid_init and
            hasattr(player_candidate, 'pos') and hasattr(player_candidate, 'rect') and
            player_candidate.alive() and not getattr(player_candidate, 'is_dead', True) 
        )
        if is_candidate_targetable:
            squared_dist = (player_candidate.pos.x - enemy.pos.x)**2 + \
                           (player_candidate.pos.y - enemy.pos.y)**2
            if squared_dist < min_squared_distance_to_player:
                min_squared_distance_to_player = squared_dist
                closest_target_player = player_candidate
    
    if not closest_target_player: 
        enemy.ai_state = 'patrolling' 
        # If the AI decides to patrol, and the enemy's logical state isn't already
        # 'patrolling' or 'run' (which is used for patrol animation), then set it.
        # This allows transitioning from 'idle' to 'patrolling'.
        if enemy.state not in ['patrolling', 'run']: 
            enemy.set_state('patrolling') 
        
        if abs(enemy.pos.x - enemy.patrol_target_x) < 10: 
            set_enemy_new_patrol_target(enemy) 
        
        should_face_right_for_patrol = (enemy.patrol_target_x > enemy.pos.x)
        patrol_acceleration = getattr(C, 'ENEMY_ACCEL', 0.4) * 0.7 
        enemy.acc.x = patrol_acceleration * (1 if should_face_right_for_patrol else -1)
        
        if not enemy.is_attacking and enemy.facing_right != should_face_right_for_patrol:
            enemy.facing_right = should_face_right_for_patrol
        return 

    distance_to_target_player = math.sqrt(min_squared_distance_to_player) 
    enemy_attack_cooldown_duration = getattr(C, 'ENEMY_ATTACK_COOLDOWN', 1500) 
    enemy_attack_range = getattr(C, 'ENEMY_ATTACK_RANGE', 60) 
    enemy_detection_range = getattr(C, 'ENEMY_DETECTION_RANGE', 200) 
    enemy_standard_acceleration = getattr(C, 'ENEMY_ACCEL', 0.4)
    is_attack_off_cooldown = current_time_ms - enemy.attack_cooldown_timer > enemy_attack_cooldown_duration
    vertical_distance_to_player = abs(closest_target_player.rect.centery - enemy.rect.centery)
    has_vertical_line_of_sight = vertical_distance_to_player < enemy.rect.height * 1.0 
    is_player_in_attack_range = distance_to_target_player < enemy_attack_range and has_vertical_line_of_sight
    is_player_in_detection_range = distance_to_target_player < enemy_detection_range and has_vertical_line_of_sight

    if enemy.is_attacking and current_time_ms - enemy.attack_timer >= enemy.attack_duration:
         enemy.is_attacking = False; enemy.attack_type = 0      
         enemy.attack_cooldown_timer = current_time_ms 
         enemy.post_attack_pause_timer = current_time_ms + enemy.post_attack_pause_duration 
         enemy.set_state('idle'); enemy.acc.x = 0         
         return 

    if enemy.is_attacking:
        enemy.acc.x = 0 
        return

    current_target_acceleration_x = 0 
    current_target_facing_right = enemy.facing_right 

    if is_player_in_attack_range and is_attack_off_cooldown:
        enemy.ai_state = 'attacking'
        current_target_facing_right = (closest_target_player.pos.x > enemy.pos.x) 
        enemy.facing_right = current_target_facing_right
        attack_animation_key_to_use = 'attack_nm' if 'attack_nm' in enemy.animations and \
                                       enemy.animations['attack_nm'] else 'attack'
        enemy.set_state(attack_animation_key_to_use) 
        return 
    
    elif is_player_in_detection_range:
        enemy.ai_state = 'chasing'
        current_target_facing_right = (closest_target_player.pos.x > enemy.pos.x) 
        current_target_acceleration_x = enemy_standard_acceleration * (1 if current_target_facing_right else -1)
        # If AI decides to chase, and logical state isn't 'chasing' or 'run', set it.
        if enemy.state not in ['chasing', 'run']: 
            enemy.set_state('chasing') 
    
    else: 
        enemy.ai_state = 'patrolling'
        # If AI decides to patrol (because player is out of detection range),
        # and logical state isn't 'patrolling' or 'run', set it.
        if enemy.state not in ['patrolling', 'run']: 
            enemy.set_state('patrolling')
        
        if abs(enemy.pos.x - enemy.patrol_target_x) < 10: 
            set_enemy_new_patrol_target(enemy) 
        
        current_target_facing_right = (enemy.patrol_target_x > enemy.pos.x)
        current_target_acceleration_x = enemy_standard_acceleration * 0.7 * \
                                        (1 if current_target_facing_right else -1)

    enemy.acc.x = current_target_acceleration_x
    if not enemy.is_attacking and enemy.facing_right != current_target_facing_right:
         enemy.facing_right = current_target_facing_right

########## START OF FILE: enemy_combat_handler.py ##########

# enemy_combat_handler.py
# -*- coding: utf-8 -*-
"""
version 1.0000000.1
Handles enemy combat mechanics: checking attack collisions and processing damage taken.
Functions here will typically take an 'enemy' instance as their first argument.
"""
import pygame
import constants as C # For accessing damage values, hit stun duration, etc.

def check_enemy_attack_collisions(enemy, player_target_list):
    """
    Checks if the enemy's current attack (if any) hits any player in the target list.
    Applies damage to the player if a hit is registered.

    Args:
        enemy (Enemy): The attacking enemy instance.
        player_target_list (list): A list of Player sprites to check for collision.
    """
    # Enemy must be valid, actively attacking, and alive to deal damage
    if not enemy._valid_init or not enemy.is_attacking or enemy.is_dead or not enemy.alive():
        return

    # Position the enemy's attack hitbox based on its facing direction and current position.
    # It's assumed that enemy.attack_hitbox is a pygame.Rect attribute of the enemy instance,
    # and its size is defined in the Enemy class or constants.
    if enemy.facing_right:
        enemy.attack_hitbox.midleft = enemy.rect.midright # Position hitbox to the right
    else:
        enemy.attack_hitbox.midright = enemy.rect.midleft # Position hitbox to the left
    
    # Vertically align the hitbox with the enemy's center (can be adjusted if attacks are high/low)
    enemy.attack_hitbox.centery = enemy.rect.centery 
    
    current_time_ms = pygame.time.get_ticks()

    for player_sprite in player_target_list:
        # Ensure the player target is valid, alive, and not dead
        if not (player_sprite and player_sprite._valid_init and \
                not player_sprite.is_dead and player_sprite.alive()):
            continue

        # --- Check if the player target is currently invincible (e.g., recently hit) ---
        player_is_currently_invincible = False
        if hasattr(player_sprite, 'is_taking_hit') and hasattr(player_sprite, 'hit_timer') and \
           hasattr(player_sprite, 'hit_cooldown'):
            if player_sprite.is_taking_hit and \
               (current_time_ms - player_sprite.hit_timer < player_sprite.hit_cooldown):
                player_is_currently_invincible = True
        
        if player_is_currently_invincible:
            continue # Skip this player if they are invincible

        # --- Perform collision check between enemy's attack hitbox and player's rect ---
        if enemy.attack_hitbox.colliderect(player_sprite.rect):
            # A hit is registered!
            if hasattr(player_sprite, 'take_damage') and callable(player_sprite.take_damage):
                # Apply damage to the player
                damage_to_inflict_on_player = getattr(C, 'ENEMY_ATTACK_DAMAGE', 10) # Default damage
                # Future: Could have different damage based on enemy.attack_type if enemies have multiple attacks
                
                player_sprite.take_damage(damage_to_inflict_on_player)
                
                # Optional: Prevent the same attack swing from hitting the same player multiple times.
                # This might involve adding the player_sprite to a list of 'already_hit_this_swing'
                # on the enemy instance, and clearing that list when a new attack starts.
                # For simplicity here, one hit per check_attack_collisions call against a target.
                # If called every frame an attack is active, it might hit multiple frames.
                # Often, the attack state itself (is_attacking) is cleared after one successful hit check
                # or after a certain number of active frames.
                # For now, let's assume one hit is sufficient for this attack instance.
                # If the game design wants an attack to hit only once per animation,
                # the enemy.is_attacking flag or a specific hit flag should be managed carefully.
                
                # Example: If an attack should only connect once per animation, you might do:
                # if enemy.is_attacking and not getattr(enemy, '_has_hit_this_attack_swing', False):
                #     player_sprite.take_damage(damage_to_inflict_on_player)
                #     enemy._has_hit_this_attack_swing = True # Set a flag
                # (This flag would need to be reset when a new attack starts in enemy.set_state)
                
                # For now, simple damage application on collision.
                # If multiple players can be hit by one swing, this loop continues.
                # If only one player can be hit, you might 'return' here.

def enemy_take_damage(enemy, damage_amount):
    """
    Handles the enemy instance taking a specified amount of damage.
    Updates health and potentially triggers 'hit' or 'death' states for the enemy.

    Args:
        enemy (Enemy): The enemy instance receiving damage.
        damage_amount (int): The amount of damage to inflict.
    """
    current_time_ms = pygame.time.get_ticks()
    
    # Enemy cannot take damage if invalid, already dead, not in game world, or in hit cooldown
    if not enemy._valid_init or enemy.is_dead or not enemy.alive() or \
       (enemy.is_taking_hit and current_time_ms - enemy.hit_timer < enemy.hit_cooldown):
        # if enemy.print_limiter.can_print(f"enemy_{enemy.enemy_id}_damage_ignored_handler", limit=3): # Use enemy's limiter
        #     print(f"DEBUG Enemy {enemy.enemy_id} (CombatHandler): Damage IGNORED due to state/cooldown.")
        return

    enemy.current_health -= damage_amount
    enemy.current_health = max(0, enemy.current_health) # Clamp health at 0 (cannot be negative)

    # if enemy.print_limiter.can_print(f"enemy_{enemy.enemy_id}_health_update_handler", limit=5):
    #     print(f"DEBUG Enemy {enemy.enemy_id} (CombatHandler): Took {damage_amount} damage. New HP: {enemy.current_health}/{enemy.max_health}")

    if enemy.current_health <= 0: # Health has reached zero or below
        if not enemy.is_dead: # If not already marked as dead, transition to death state
            enemy.set_state('death') # This will trigger death animation and logic in Enemy class
    else: # Enemy is damaged but still alive
        # Transition to 'hit' state to show visual feedback and potentially interrupt actions,
        # but only if not already in a 'hit' state during its active stun duration.
        # ENEMY_HIT_STUN_DURATION is the duration the enemy is stunned and in 'hit' anim.
        # ENEMY_HIT_COOLDOWN is total invincibility time, which might be longer.
        if not (enemy.state == 'hit' and current_time_ms - enemy.state_timer < getattr(C, 'ENEMY_HIT_STUN_DURATION', 300)):
             enemy.set_state('hit') # Trigger hit animation and stun period

########## START OF FILE: enemy_network_handler.py ##########

########## START OF FILE: enemy_network_handler.py ##########

# enemy_network_handler.py
# -*- coding: utf-8 -*-
"""
version 1.0.0.2 (Updated stomp death networking and client-side image capture)
Handles network-related data serialization and deserialization for the Enemy class.
Functions here will typically take an 'enemy' instance as their first argument.
"""
import pygame
import constants as C # For any network-specific constants if needed in future
from assets import load_all_player_animations # For client-side enemy animation loading if color changes
import os # For os.path.join if needed for color sync (though GSM usually handles enemy creation)

def get_enemy_network_data(enemy):
    """
    Gathers essential enemy data into a dictionary for network transmission.
    This is typically called by the server to send enemy states to clients.

    Args:
        enemy (Enemy): The enemy instance whose data is being serialized.

    Returns:
        dict: A dictionary containing the enemy's network-relevant state.
    """
    # Ensure all serialized values are basic Python types for JSON compatibility
    data = {
        'enemy_id': enemy.enemy_id, 
        '_valid_init': enemy._valid_init, 
        
        'pos': (enemy.pos.x, enemy.pos.y), 
        'vel': (enemy.vel.x, enemy.vel.y), 
        'facing_right': enemy.facing_right, 
        
        'state': enemy.state, 
        'current_frame': enemy.current_frame, 
        'last_anim_update': enemy.last_anim_update, 
        
        'current_health': enemy.current_health, 
        'is_dead': enemy.is_dead,
        'death_animation_finished': enemy.death_animation_finished,
        
        'is_attacking': enemy.is_attacking, 
        'attack_type': enemy.attack_type, 
        
        'is_taking_hit': enemy.is_taking_hit, 
        'post_attack_pause_timer': enemy.post_attack_pause_timer, 
        'color_name': getattr(enemy, 'color_name', 'default_color'),

        # Stomp death specific fields
        'is_stomp_dying': getattr(enemy, 'is_stomp_dying', False), # Add getattr for safety
        'stomp_death_start_time': getattr(enemy, 'stomp_death_start_time', 0),
        'original_stomp_facing_right': getattr(enemy, 'original_stomp_facing_right', True),
    }
    return data

def set_enemy_network_data(enemy, network_data): 
    """
    Applies received network data to update the local enemy instance's state.
    This is primarily used on clients to reflect the server's authoritative state for each enemy.

    Args:
        enemy (Enemy): The enemy instance to be updated.
        network_data (dict): The dictionary of enemy state received over the network.
    """
    if network_data is None: return 
    
    enemy._valid_init = network_data.get('_valid_init', enemy._valid_init)
    if not enemy._valid_init:
        if enemy.alive(): enemy.kill()  
        return 

    pos_data = network_data.get('pos')
    if pos_data: enemy.pos.x, enemy.pos.y = pos_data
    
    vel_data = network_data.get('vel')
    if vel_data: enemy.vel.x, enemy.vel.y = vel_data
    
    enemy.facing_right = network_data.get('facing_right', enemy.facing_right) # General facing
    
    enemy.current_health = network_data.get('current_health', enemy.current_health)
    new_is_dead_from_net = network_data.get('is_dead', enemy.is_dead)
    enemy.death_animation_finished = network_data.get('death_animation_finished', enemy.death_animation_finished)

    # Stomp Death Handling
    new_is_stomp_dying_from_net = network_data.get('is_stomp_dying', False)
    if new_is_stomp_dying_from_net and not enemy.is_stomp_dying:
        enemy.is_stomp_dying = True
        enemy.stomp_death_start_time = network_data.get('stomp_death_start_time', pygame.time.get_ticks())
        # Use the server's facing direction at the moment of stomp for visual consistency
        enemy.original_stomp_facing_right = network_data.get('original_stomp_facing_right', enemy.facing_right)
        
        # Client needs to capture its current image (correctly oriented) as the base for scaling.
        # Ensure the enemy's state, frame, and facing are consistent with what the server *would have seen*
        # at the moment it decided to stomp_kill.
        # The server's `get_enemy_network_data` sends `state`, `current_frame`, and `facing_right`.
        # These should be applied *before* this stomp logic if they're part of the same network packet.
        
        # Temporarily set facing_right for image capture to match the server's view at stomp time
        original_facing = enemy.facing_right
        enemy.facing_right = enemy.original_stomp_facing_right
        
        # Animate once to get the correct base frame.
        # Temporarily disable stomp_dying during this animate call to ensure it uses regular animation logic.
        _temp_stomp_flag = enemy.is_stomp_dying
        enemy.is_stomp_dying = False
        enemy.animate() # This should set self.image based on current_frame and new facing_right
        enemy.is_stomp_dying = _temp_stomp_flag # Restore flag

        enemy.original_stomp_death_image = enemy.image.copy()
        enemy.facing_right = original_facing # Restore actual facing direction for subsequent logic if needed

        # Update other death-related states
        enemy.is_dead = True
        enemy.current_health = 0
        enemy.vel.xy = 0,0
        enemy.acc.xy = 0,0
        enemy.death_animation_finished = False # Stomp animation will handle this
        enemy.state = 'stomp_death' # Can be useful for client-side logic, though animation handles visual

    elif not new_is_stomp_dying_from_net and enemy.is_stomp_dying: # Stomp death ended/cancelled
        enemy.is_stomp_dying = False
        enemy.original_stomp_death_image = None
        # If the enemy is now considered alive by the server, the regular death logic below will handle it.

    # Regular Death Status (only if not currently stomp_dying)
    if not enemy.is_stomp_dying:
        if new_is_dead_from_net and not enemy.is_dead: 
            enemy.is_dead = True
            enemy.current_health = 0 
            enemy.set_state('death') 
        elif not new_is_dead_from_net and enemy.is_dead: # Revived
            enemy.is_dead = False
            enemy.death_animation_finished = False 
            if enemy.state in ['death', 'death_nm', 'stomp_death']: # Check stomp_death too
                enemy.set_state('idle') 
        else: 
            enemy.is_dead = new_is_dead_from_net 

    # Combat and Action States (only if not currently stomp_dying)
    if not enemy.is_stomp_dying:
        enemy.is_attacking = network_data.get('is_attacking', enemy.is_attacking)
        enemy.attack_type = network_data.get('attack_type', enemy.attack_type)
        
        new_is_taking_hit_from_net = network_data.get('is_taking_hit', enemy.is_taking_hit)
        if new_is_taking_hit_from_net and not enemy.is_taking_hit: 
            enemy.is_taking_hit = True
            enemy.hit_timer = pygame.time.get_ticks() 
            if enemy.state != 'hit' and not enemy.is_dead: enemy.set_state('hit') 
        elif not new_is_taking_hit_from_net and enemy.is_taking_hit: 
            enemy.is_taking_hit = False
            if enemy.state == 'hit' and not enemy.is_dead: enemy.set_state('idle') 

        enemy.post_attack_pause_timer = network_data.get('post_attack_pause_timer', enemy.post_attack_pause_timer)
        
        # Logical State (if not stomp_dying, as stomp_death state is managed above)
        new_logical_state_from_net = network_data.get('state', enemy.state)
        if enemy.state != 'stomp_death' and enemy.state != new_logical_state_from_net and \
           not (enemy.is_dead and new_logical_state_from_net in ['death', 'death_nm']):
             enemy.set_state(new_logical_state_from_net)
        else: # If state is the same, or it's a death/stomp_death state, just sync animation details
            enemy.current_frame = network_data.get('current_frame', enemy.current_frame)
            enemy.last_anim_update = network_data.get('last_anim_update', enemy.last_anim_update)
    
    enemy.rect.midbottom = (round(enemy.pos.x), round(enemy.pos.y)) 
    
    if enemy._valid_init and enemy.alive(): 
        enemy.animate() # This will correctly handle stomp animation if is_stomp_dying is true

########## START OF FILE: game_setup.py ##########

# game_setup.py
# -*- coding: utf-8 -*-
"""
Handles initialization of game elements, levels, and entities.
version 1.0.0.7 (Added debug prints for projectile group assignment)
"""
import sys
import pygame
import random
import traceback
import constants as C
from player import Player
from enemy import Enemy
from items import Chest 
import levels as LevelLoader 
from camera import Camera
from typing import Dict, Optional, Any, Tuple, List 
import importlib 

DEFAULT_LEVEL_MODULE_NAME = "level_default" 

def initialize_game_elements(current_width: int, current_height: int, 
                             for_game_mode: str = "unknown", 
                             existing_sprites_groups: Optional[Dict[str, Any]] = None,
                             map_module_name: Optional[str] = None) -> Optional[Dict[str, Any]]:
    print(f"DEBUG GameSetup: Initializing elements. Mode: '{for_game_mode}', Screen: {current_width}x{current_height}, Requested Map: '{map_module_name}'")

    platform_sprites = pygame.sprite.Group()
    ladder_sprites = pygame.sprite.Group()
    hazard_sprites = pygame.sprite.Group()
    enemy_sprites = pygame.sprite.Group()
    collectible_sprites = pygame.sprite.Group()
    
    projectile_sprites_from_existing = existing_sprites_groups.get('projectile_sprites') if existing_sprites_groups else None
    all_sprites_from_existing = existing_sprites_groups.get('all_sprites') if existing_sprites_groups else None

    projectile_sprites = projectile_sprites_from_existing if isinstance(projectile_sprites_from_existing, pygame.sprite.Group) else pygame.sprite.Group()
    all_sprites = all_sprites_from_existing if isinstance(all_sprites_from_existing, pygame.sprite.Group) else pygame.sprite.Group()
    
    print(f"DEBUG GameSetup: Initial projectile_sprites: {projectile_sprites} (Count: {len(projectile_sprites.sprites())})")
    print(f"DEBUG GameSetup: Initial all_sprites: {all_sprites} (Count: {len(all_sprites.sprites())})")


    print("DEBUG GameSetup: Clearing sprite groups (except projectile_sprites and all_sprites initially)...")
    player1_to_kill = existing_sprites_groups.get('player1') if existing_sprites_groups else None
    if player1_to_kill and hasattr(player1_to_kill, 'kill'): player1_to_kill.kill()
    player2_to_kill = existing_sprites_groups.get('player2') if existing_sprites_groups else None
    if player2_to_kill and hasattr(player2_to_kill, 'kill'): player2_to_kill.kill()
    current_chest_to_kill = existing_sprites_groups.get('current_chest') if existing_sprites_groups else None
    if current_chest_to_kill and hasattr(current_chest_to_kill, 'kill'): current_chest_to_kill.kill()
    
    for group in [platform_sprites, ladder_sprites, hazard_sprites, enemy_sprites, collectible_sprites]:
        if group is not None: group.empty()
    
    if all_sprites_from_existing: 
        for sprite in list(all_sprites.sprites()): # Iterate over a copy
             if sprite not in [player1_to_kill, player2_to_kill, current_chest_to_kill]:
                 if not isinstance(sprite, Player): 
                    sprite.kill() 
    
    if projectile_sprites_from_existing: 
        projectile_sprites.empty() 

    print(f"DEBUG GameSetup: After clearing, projectile_sprites: {projectile_sprites} (Count: {len(projectile_sprites.sprites())})")
    print(f"DEBUG GameSetup: After clearing, all_sprites: {all_sprites} (Count: {len(all_sprites.sprites())})")

            
    enemy_list: List[Enemy] = [] 

    level_data_loaded_successfully = False
    # If map_module_name is None (e.g. client initial call), we don't load level geometry yet.
    target_map_name_for_load = map_module_name if map_module_name else None
    
    # Default values if no map is loaded yet
    level_background_color = C.LIGHT_BLUE 
    local_enemy_spawns_data_list = [] 
    collectible_spawns_data_list = []
    player1_spawn_pos = (100, current_height - (C.TILE_SIZE * 2)) 
    player2_spawn_pos = (150, current_height - (C.TILE_SIZE * 2)) 
    level_pixel_width = current_width
    lvl_min_y_abs = 0
    lvl_max_y_abs = current_height
    ground_level_y = current_height - C.TILE_SIZE
    ground_platform_height = C.TILE_SIZE
    loaded_map_name_return = None # To return the name of the map that was actually loaded

    if target_map_name_for_load: # Only attempt to load map data if a name is provided
        safe_map_name_for_func = target_map_name_for_load.replace('-', '_').replace(' ', '_')
        expected_level_load_func_name = f"load_map_{safe_map_name_for_func}"
        
        print(f"DEBUG GameSetup: Attempting to load map module 'maps.{target_map_name_for_load}' and call function '{expected_level_load_func_name}'")

        try:
            map_module_full_path = f"maps.{target_map_name_for_load}"
            if map_module_full_path in sys.modules: # If already imported, reload for potential updates
                print(f"DEBUG GameSetup: Reloading map module '{map_module_full_path}'")
                map_module = importlib.reload(sys.modules[map_module_full_path])
            else:
                map_module = importlib.import_module(map_module_full_path)
            
            load_level_function = getattr(map_module, expected_level_load_func_name)
            level_data_tuple = load_level_function(current_width, current_height)
            
            if level_data_tuple and len(level_data_tuple) >= 11:
                (platform_data_group, ladder_data_group, hazard_data_group, 
                local_enemy_spawns_data_list_loaded, collectible_spawns_data_list_loaded, p1_spawn_tuple, 
                lvl_total_width_pixels_loaded, lvl_min_y_abs_loaded, lvl_max_y_abs_loaded, 
                main_ground_y_reference_loaded, main_ground_height_reference_loaded, 
                *optional_bg_color_list) = level_data_tuple

                platform_sprites.add(platform_data_group.sprites() if platform_data_group else [])
                ladder_sprites.add(ladder_data_group.sprites() if ladder_data_group else [])
                hazard_sprites.add(hazard_data_group.sprites() if hazard_data_group else [])
                
                local_enemy_spawns_data_list = local_enemy_spawns_data_list_loaded if local_enemy_spawns_data_list_loaded else []
                collectible_spawns_data_list = collectible_spawns_data_list_loaded if collectible_spawns_data_list_loaded else []

                player1_spawn_pos = p1_spawn_tuple
                p2_spawn_x = p1_spawn_tuple[0] + C.TILE_SIZE * 1.5
                if p2_spawn_x + (C.TILE_SIZE / 2) > lvl_total_width_pixels_loaded - C.TILE_SIZE: 
                    p2_spawn_x = lvl_total_width_pixels_loaded - C.TILE_SIZE * 2.5 
                if p2_spawn_x - (C.TILE_SIZE / 2) < C.TILE_SIZE:
                    p2_spawn_x = C.TILE_SIZE * 2.5
                player2_spawn_pos = (p2_spawn_x, p1_spawn_tuple[1])
                
                level_pixel_width = lvl_total_width_pixels_loaded
                lvl_min_y_abs = lvl_min_y_abs_loaded
                lvl_max_y_abs = lvl_max_y_abs_loaded
                ground_level_y = main_ground_y_reference_loaded
                ground_platform_height = main_ground_height_reference_loaded
                
                if optional_bg_color_list and isinstance(optional_bg_color_list[0], (tuple, list)) and len(optional_bg_color_list[0]) == 3:
                    level_background_color = optional_bg_color_list[0]
                    
                print(f"DEBUG GameSetup: Level geometry loaded. Width: {level_pixel_width}, MinY: {lvl_min_y_abs}, MaxY: {lvl_max_y_abs}, P1 Spawn: {player1_spawn_pos}, P2 Spawn: {player2_spawn_pos}, BG Color: {level_background_color}")
                level_data_loaded_successfully = True
                loaded_map_name_return = target_map_name_for_load
            else:
                print(f"CRITICAL GameSetup Error: Map '{target_map_name_for_load}' function '{expected_level_load_func_name}' did not return enough data elements.")

        except ImportError:
            print(f"CRITICAL GameSetup Error: Could not import map module 'maps.{target_map_name_for_load}'."); traceback.print_exc()
        except AttributeError:
            print(f"CRITICAL GameSetup Error: Map module 'maps.{target_map_name_for_load}' no func '{expected_level_load_func_name}'."); traceback.print_exc()
        except Exception as e:
            print(f"CRITICAL GameSetup Error: Unexpected error loading map '{target_map_name_for_load}': {e}"); traceback.print_exc()

        if not level_data_loaded_successfully:
            if target_map_name_for_load != DEFAULT_LEVEL_MODULE_NAME:
                print(f"GAME_SETUP Warning: Failed to load map '{target_map_name_for_load}'. Trying default '{DEFAULT_LEVEL_MODULE_NAME}'.")
                return initialize_game_elements(current_width, current_height, for_game_mode, existing_sprites_groups, DEFAULT_LEVEL_MODULE_NAME)
            else:
                print(f"GAME_SETUP FATAL: Default map '{DEFAULT_LEVEL_MODULE_NAME}' also failed. Cannot proceed."); return None
    else: # No map_module_name provided, e.g., client initial setup
        print("DEBUG GameSetup: No map module name provided, skipping level geometry loading. Only players/camera shells will be created if mode requires.")
        loaded_map_name_return = None # Explicitly none if no map loaded.

    all_sprites.add(platform_sprites.sprites(), ladder_sprites.sprites(), hazard_sprites.sprites())
    
    player1, player2 = None, None 

    if for_game_mode in ["host", "couch_play", "join_lan", "join_ip"]:
        player1 = Player(player1_spawn_pos[0], player1_spawn_pos[1], player_id=1) 
        if not player1._valid_init: print(f"CRITICAL GameSetup: P1 init failed."); return None
        all_sprites.add(player1)

    if for_game_mode == "couch_play":
        player2 = Player(player2_spawn_pos[0], player2_spawn_pos[1], player_id=2) 
        if not player2._valid_init: print(f"CRITICAL GameSetup: P2 (couch) init failed."); return None
        all_sprites.add(player2)
    elif for_game_mode in ["join_lan", "join_ip", "host"]: # Host also needs a P2 shell for network data
        player2 = Player(player2_spawn_pos[0], player2_spawn_pos[1], player_id=2) 
        if not player2._valid_init: print(f"CRITICAL GameSetup: P2 shell init failed."); return None
        all_sprites.add(player2)


    print(f"DEBUG GameSetup: Before setting proj groups for P1: projectile_sprites is {('set' if projectile_sprites is not None else 'None')}, all_sprites is {('set' if all_sprites is not None else 'None')}")
    if player1 and hasattr(player1, 'set_projectile_group_references'): 
        player1.set_projectile_group_references(projectile_sprites, all_sprites)
    
    print(f"DEBUG GameSetup: Before setting proj groups for P2: projectile_sprites is {('set' if projectile_sprites is not None else 'None')}, all_sprites is {('set' if all_sprites is not None else 'None')}")
    if player2 and hasattr(player2, 'set_projectile_group_references'): 
        player2.set_projectile_group_references(projectile_sprites, all_sprites)


    if (for_game_mode == "host" or for_game_mode == "couch_play") and local_enemy_spawns_data_list:
        print(f"DEBUG GameSetup: Spawning {len(local_enemy_spawns_data_list)} enemies...")
        from enemy import Enemy 
        for i, spawn_info in enumerate(local_enemy_spawns_data_list):
            try:
                patrol_rect = pygame.Rect(spawn_info['patrol']) if spawn_info.get('patrol') else None
                enemy = Enemy(start_x=spawn_info['pos'][0], start_y=spawn_info['pos'][1], 
                              patrol_area=patrol_rect, enemy_id=i) 
                if enemy._valid_init: 
                    all_sprites.add(enemy); enemy_sprites.add(enemy); enemy_list.append(enemy)
                else:
                    print(f"Warning GameSetup: Enemy {i} at {spawn_info['pos']} failed _valid_init.")
            except Exception as e: print(f"Error spawning enemy {i} with data {spawn_info}: {e}"); traceback.print_exc()
    
    current_chest = None
    if Chest and (for_game_mode == "host" or for_game_mode == "couch_play"): 
        if collectible_spawns_data_list:
            for item_data in collectible_spawns_data_list:
                if item_data.get('type') == 'chest':
                    try:
                        chest_midbottom_x, chest_midbottom_y = item_data['pos']
                        current_chest = Chest(chest_midbottom_x, chest_midbottom_y) 
                        if current_chest._valid_init:
                            all_sprites.add(current_chest); collectible_sprites.add(current_chest)
                            print(f"DEBUG GameSetup: Chest spawned from level data at {current_chest.rect.topleft}")
                            break 
                        else: print(f"Warning GameSetup: Chest from level data at {item_data['pos']} failed _valid_init.")
                    except Exception as e: print(f"Error spawning chest from level data: {e}")
        
        if not current_chest: 
            print("DEBUG GameSetup: No chest from level data, attempting random spawn on ledge...")
            current_chest = spawn_chest(platform_sprites, ground_level_y) 
            if current_chest:
                all_sprites.add(current_chest); collectible_sprites.add(current_chest)
                print(f"DEBUG GameSetup: Random chest spawned at {current_chest.rect.topleft}")
            else: print("DEBUG GameSetup: Random chest spawn also failed or returned None.")


    camera_instance = Camera(level_pixel_width, lvl_min_y_abs, lvl_max_y_abs, current_width, current_height)

    print(f"DEBUG GameSetup: Final counts before return - AllSprites: {len(all_sprites.sprites())}, Projectiles: {len(projectile_sprites.sprites())}")

    game_elements_dict = {
        "player1": player1, "player2": player2, "camera": camera_instance,
        "current_chest": current_chest, "enemy_list": enemy_list,
        "platform_sprites": platform_sprites, "ladder_sprites": ladder_sprites,
        "hazard_sprites": hazard_sprites, "enemy_sprites": enemy_sprites,
        "collectible_sprites": collectible_sprites, "projectile_sprites": projectile_sprites,
        "all_sprites": all_sprites,
        "level_pixel_width": level_pixel_width, "level_min_y_absolute": lvl_min_y_abs,
        "level_max_y_absolute": lvl_max_y_abs, "ground_level_y": ground_level_y,
        "ground_platform_height": ground_platform_height,
        "player1_spawn_pos": player1_spawn_pos, "player2_spawn_pos": player2_spawn_pos,
        "enemy_spawns_data_cache": local_enemy_spawns_data_list, 
        "level_background_color": level_background_color,
        "loaded_map_name": loaded_map_name_return # Return the name of the map loaded
    }
    return game_elements_dict

# RENAMED FUNCTION from spawn_chest_on_ledge to spawn_chest
def spawn_chest(all_platform_sprites_group: pygame.sprite.Group, main_ground_y_surface_level: int) -> Optional[Chest]:
    """
    Spawns a chest ONLY on platforms explicitly marked as 'ledge'.
    """
    if Chest is None: print("Warning GS (spawn_chest): Chest class is None, cannot spawn."); return None
    try:
        ledge_platforms = [p for p in all_platform_sprites_group if hasattr(p, 'platform_type') and p.platform_type == "ledge" and p.rect.width > C.TILE_SIZE * 1.25]
        if not ledge_platforms: print("Warning GS (spawn_chest): No 'ledge' platforms for chest."); return None
        
        moderate_y_min = main_ground_y_surface_level - C.TILE_SIZE * 4 
        moderate_y_max = main_ground_y_surface_level + C.TILE_SIZE * 1 
        candidate_platforms = [p for p in ledge_platforms if moderate_y_min <= p.rect.top <= moderate_y_max]
        if not candidate_platforms: candidate_platforms = list(ledge_platforms)
        if not candidate_platforms: print("Warning GS (spawn_chest): No suitable candidate ledges."); return None

        chosen_platform = random.choice(candidate_platforms)
        inset = C.TILE_SIZE * 0.5 
        min_cx, max_cx = chosen_platform.rect.left + inset, chosen_platform.rect.right - inset
        cx = random.randint(int(min_cx), int(max_cx)) if min_cx < max_cx else chosen_platform.rect.centerx
        cy = chosen_platform.rect.top 
        
        print(f"DEBUG GS (spawn_chest): Attempting to spawn chest at calculated pos: ({cx},{cy}) on platform {chosen_platform.rect}")
        new_chest = Chest(cx, cy) # Chest constructor expects midbottom X, Y for its rect.bottom
        if hasattr(new_chest, '_valid_init') and new_chest._valid_init:
            print(f"DEBUG GS (spawn_chest): Chest spawned on ledge at {new_chest.rect.midbottom}")
            return new_chest
        else:
            print(f"Warning GS (spawn_chest): New chest created at ({cx},{cy}) failed _valid_init.")
    except Exception as e:
        print(f"Error in spawn_chest: {e}"); traceback.print_exc()
    return None

########## START OF FILE: game_state_manager.py ##########

########## START OF FILE: game_state_manager.py ##########

# game_state_manager.py
# -*- coding: utf-8 -*-
"""
version 1.0.0.3 (Players always update from network state on client; enemy color sync)
Manages game state, including reset and network synchronization.
"""
import pygame
import traceback
import os # Added for os.path.join
from game_setup import spawn_chest # For respawning chest
from enemy import Enemy # For creating new enemies on client
from items import Chest # For type checking and creating new chests on client
from projectiles import Fireball # For creating projectiles on client
from assets import load_all_player_animations # Added for reloading enemy animations
import constants as C # Added for fallback color C.BLUE

def reset_game_state(game_elements):
    """Resets the state of players, enemies, and collectibles."""
    print("DEBUG GSM: --- Resetting Platformer Game State ---") # DEBUG
    player1 = game_elements.get("player1")
    player2 = game_elements.get("player2")
    enemy_list = game_elements.get("enemy_list", [])
    current_chest = game_elements.get("current_chest")
    player1_spawn_pos = game_elements.get("player1_spawn_pos")
    player2_spawn_pos = game_elements.get("player2_spawn_pos")
    all_sprites = game_elements.get("all_sprites")
    enemy_sprites = game_elements.get("enemy_sprites")
    collectible_sprites = game_elements.get("collectible_sprites")
    projectile_sprites = game_elements.get("projectile_sprites")
    camera = game_elements.get("camera")

    if player1 and hasattr(player1, 'reset_state'):
        print(f"DEBUG GSM: Resetting P1 at {player1_spawn_pos}") # DEBUG
        player1.reset_state(player1_spawn_pos)
        if not player1.alive() and player1._valid_init: all_sprites.add(player1) # Ensure in group
        print("DEBUG GSM: P1 Reset complete.") # DEBUG
    if player2 and hasattr(player2, 'reset_state'):
        print(f"DEBUG GSM: Resetting P2 at {player2_spawn_pos}") # DEBUG
        player2.reset_state(player2_spawn_pos)
        if not player2.alive() and player2._valid_init: all_sprites.add(player2) # Ensure in group
        print("DEBUG GSM: P2 Reset complete.") # DEBUG

    for enemy_instance in enemy_list:
        if hasattr(enemy_instance, 'reset'):
            enemy_instance.reset()
            if enemy_instance._valid_init and not enemy_instance.alive(): # If reset somehow made it not alive but valid
                all_sprites.add(enemy_instance) # Re-add to ensure it's drawn/updated if it revives
                enemy_sprites.add(enemy_instance)
    print(f"DEBUG GSM: {len(enemy_list)} enemies processed for reset.") # DEBUG

    if projectile_sprites:
        for proj in projectile_sprites: proj.kill()
        projectile_sprites.empty()
        print("DEBUG GSM: Projectiles cleared.") # DEBUG


    if current_chest and current_chest.alive(): current_chest.kill()
    print(f"DEBUG GSM: Existing chest killed (if any).") # DEBUG


    new_chest = spawn_chest(game_elements.get("platform_sprites"), game_elements.get("ground_level_y"))
    if new_chest:
        all_sprites.add(new_chest)
        collectible_sprites.add(new_chest)
        game_elements["current_chest"] = new_chest # Update the reference in game_elements
        print("DEBUG GSM: Chest respawned.") # DEBUG
    else:
        game_elements["current_chest"] = None # Ensure it's None if spawn fails
        print("DEBUG GSM: Failed to respawn chest or Chest class not available.") # DEBUG

    if camera: camera.set_pos(0,0) # Reset camera position to default
    print("DEBUG GSM: Camera position reset.") # DEBUG

    print("DEBUG GSM: --- Game State Reset Finished ---\n") # DEBUG
    return new_chest # Return the new chest so main can update its reference if needed

def get_network_game_state(game_elements):
    """Gathers all relevant game state for network transmission."""
    # print("DEBUG GSM (get_network_game_state): Gathering state...") # DEBUG
    player1 = game_elements.get("player1")
    player2 = game_elements.get("player2")
    enemy_list = game_elements.get("enemy_list", [])
    current_chest = game_elements.get("current_chest")
    projectile_sprites = game_elements.get("projectile_sprites", pygame.sprite.Group()) # Default to empty group

    state = {'p1': None, 'p2': None, 'enemies': {}, 'chest': None, 'game_over': False, 'projectiles': []}

    if player1 and hasattr(player1, 'get_network_data'):
        state['p1'] = player1.get_network_data()
        # print(f"DEBUG GSM (get_network_game_state): P1 data: {state['p1']}") # DEBUG
    if player2 and hasattr(player2, 'get_network_data'):
        state['p2'] = player2.get_network_data()
        # print(f"DEBUG GSM (get_network_game_state): P2 data: {state['p2']}") # DEBUG


    # Include enemies that are alive or in the process of dying (animation not finished)
    for enemy in enemy_list:
        if hasattr(enemy, 'enemy_id') and hasattr(enemy, 'get_network_data'):
            if enemy.alive() or (enemy.is_dead and not enemy.death_animation_finished):
                 state['enemies'][str(enemy.enemy_id)] = enemy.get_network_data()

    if current_chest and current_chest.alive() and hasattr(current_chest, 'rect'):
        state['chest'] = {
            'pos': (current_chest.rect.centerx, current_chest.rect.centery),
            'is_collected': getattr(current_chest, 'is_collected', False)
        }

    # Determine game_over based on P1's state (typical for host/P1 centric games)
    p1_truly_gone = True # Assume P1 is gone
    if player1 and player1._valid_init: # If P1 was properly initialized
        if player1.alive(): # Is in sprite groups (could be dead but animating)
            if hasattr(player1, 'is_dead') and player1.is_dead: # Logically dead
                if hasattr(player1, 'death_animation_finished') and not player1.death_animation_finished:
                    p1_truly_gone = False # Still animating death, so not truly gone for game over
            else: # Alive and not dead
                p1_truly_gone = False
    state['game_over'] = p1_truly_gone # True if P1 is invalid OR dead AND death animation finished

    state['projectiles'] = [proj.get_network_data() for proj in projectile_sprites if hasattr(proj, 'get_network_data')]
    # print(f"DEBUG GSM (get_network_game_state): Final state to send (P1 Pos: {state['p1'].get('pos') if state['p1'] else 'N/A'}, P2 Pos: {state['p2'].get('pos') if state['p2'] else 'N/A'}, Num Enemies: {len(state['enemies'])})") # DEBUG
    return state

def set_network_game_state(network_state_data, game_elements, client_player_id=None): # client_player_id kept for potential future use
    """
    Applies received network state to local game elements.
    On the client, this updates both remote players and the client's own player
    to reflect the server's authoritative state.
    """
    # print(f"DEBUG GSM (set_network_game_state): Applying network state. Client ID: {client_player_id}") # DEBUG
    # if network_state_data: # DEBUG
        # print(f"DEBUG GSM (set_network_game_state): Received P1 data: {network_state_data.get('p1')}") # DEBUG
        # print(f"DEBUG GSM (set_network_game_state): Received P2 data: {network_state_data.get('p2')}") # DEBUG
    # else: # DEBUG
        # print("DEBUG GSM (set_network_game_state): network_state_data is None.") # DEBUG
        # return # DEBUG

    player1 = game_elements.get("player1")
    player2 = game_elements.get("player2")
    enemy_list = game_elements.get("enemy_list", []) 
    current_chest = game_elements.get("current_chest") 
    all_sprites = game_elements.get("all_sprites")
    enemy_sprites = game_elements.get("enemy_sprites")
    collectible_sprites = game_elements.get("collectible_sprites")
    projectile_sprites = game_elements.get("projectile_sprites", pygame.sprite.Group())
    enemy_spawns_data_cache = game_elements.get("enemy_spawns_data_cache", [])


    # Update Player 1 state from network data
    if player1 and 'p1' in network_state_data and network_state_data['p1'] and hasattr(player1, 'set_network_data'):
        # print(f"DEBUG GSM (set_network_game_state): Applying state to P1. Current P1 valid: {player1._valid_init}, alive: {player1.alive() if hasattr(player1, 'alive') else 'N/A'}") # DEBUG
        p1_data = network_state_data['p1']
        # print(f"DEBUG GSM (set_network_game_state): P1 network data being applied: pos={p1_data.get('pos')}, state={p1_data.get('state')}, valid={p1_data.get('_valid_init')}") # DEBUG
        player1.set_network_data(p1_data)
        # print(f"DEBUG GSM (set_network_game_state): P1 after set_network_data. Valid: {player1._valid_init}, Alive: {player1.alive()}, Pos: {player1.pos if hasattr(player1, 'pos') else 'N/A'}") # DEBUG
        if player1._valid_init and not player1.is_dead and not player1.alive():
             # print(f"DEBUG GSM (set_network_game_state): P1 became valid/alive but not in all_sprites. Adding.") # DEBUG
             all_sprites.add(player1)
        # elif not player1._valid_init and player1.alive(): # Should be handled by player1.set_network_data
            # print(f"DEBUG GSM (set_network_game_state): P1 became INvalid but IS in all_sprites. kill() should have been called.") #DEBUG

    # Update Player 2 state from network data
    if player2 and 'p2' in network_state_data and network_state_data['p2'] and hasattr(player2, 'set_network_data'):
        # print(f"DEBUG GSM (set_network_game_state): Applying state to P2. Current P2 valid: {player2._valid_init}, alive: {player2.alive() if hasattr(player2, 'alive') else 'N/A'}") # DEBUG
        p2_data = network_state_data['p2']
        # print(f"DEBUG GSM (set_network_game_state): P2 network data being applied: pos={p2_data.get('pos')}, state={p2_data.get('state')}, valid={p2_data.get('_valid_init')}") # DEBUG
        player2.set_network_data(p2_data)
        # print(f"DEBUG GSM (set_network_game_state): P2 after set_network_data. Valid: {player2._valid_init}, Alive: {player2.alive()}, Pos: {player2.pos if hasattr(player2, 'pos') else 'N/A'}") # DEBUG
        if player2._valid_init and not player2.is_dead and not player2.alive():
             # print(f"DEBUG GSM (set_network_game_state): P2 became valid/alive but not in all_sprites. Adding.") # DEBUG
             all_sprites.add(player2)
        # elif not player2._valid_init and player2.alive(): # Should be handled by player2.set_network_data
            # print(f"DEBUG GSM (set_network_game_state): P2 became INvalid but IS in all_sprites. kill() should have been called.") #DEBUG


    # Enemy state synchronization (critical for clients)
    if 'enemies' in network_state_data:
        received_enemy_data_map = network_state_data['enemies']
        # print(f"DEBUG GSM (set_network_game_state): Syncing {len(received_enemy_data_map)} enemies from network.") # DEBUG
        current_client_enemies_map = {str(enemy.enemy_id): enemy for enemy in enemy_list if hasattr(enemy, 'enemy_id')}

        for enemy_id_str, enemy_data_from_server in received_enemy_data_map.items():
            enemy_id_int = int(enemy_id_str)
            # print(f"DEBUG GSM (set_network_game_state): Processing enemy ID {enemy_id_str} from network. Data: {enemy_data_from_server.get('pos')}, valid: {enemy_data_from_server.get('_valid_init')}") # DEBUG

            if enemy_data_from_server.get('_valid_init', False): 
                if enemy_id_str in current_client_enemies_map: 
                    client_enemy = current_client_enemies_map[enemy_id_str]
                    # print(f"DEBUG GSM (set_network_game_state): Updating existing enemy ID {enemy_id_str}.") # DEBUG
                    if hasattr(client_enemy, 'set_network_data'):
                        client_enemy.set_network_data(enemy_data_from_server)
                        if client_enemy._valid_init and not client_enemy.alive():
                            if (client_enemy.is_dead and not client_enemy.death_animation_finished) or \
                               (not client_enemy.is_dead):
                                 # print(f"DEBUG GSM (set_network_game_state): Re-adding enemy {enemy_id_str} to sprite groups.") # DEBUG
                                 all_sprites.add(client_enemy); enemy_sprites.add(client_enemy)
                else: 
                    # print(f"DEBUG GSM (set_network_game_state): Creating NEW enemy ID {enemy_id_str}.") # DEBUG
                    try:
                        spawn_pos_e_default = enemy_data_from_server.get('pos', (0,0)) 
                        patrol_area_e_obj = None
                        if enemy_id_int < len(enemy_spawns_data_cache):
                            original_spawn_info = enemy_spawns_data_cache[enemy_id_int]
                            spawn_pos_e_default = original_spawn_info.get('pos', spawn_pos_e_default)
                            patrol_data_from_level = original_spawn_info.get('patrol')
                            if patrol_data_from_level:
                                try: patrol_area_e_obj = pygame.Rect(patrol_data_from_level)
                                except TypeError: print(f"Client: Invalid patrol data from cache for new enemy {enemy_id_int}.")
                        else:
                            print(f"Client: No original spawn data in cache for new enemy_id {enemy_id_int}.")

                        new_enemy_instance = Enemy(spawn_pos_e_default[0], spawn_pos_e_default[1],
                                             patrol_area=patrol_area_e_obj, enemy_id=enemy_id_int)
                        # print(f"DEBUG GSM (set_network_game_state): New enemy {enemy_id_str} created. Valid: {new_enemy_instance._valid_init}") # DEBUG


                        if new_enemy_instance._valid_init:
                            server_color_name = enemy_data_from_server.get('color_name')
                            if server_color_name and hasattr(new_enemy_instance, 'color_name') and new_enemy_instance.color_name != server_color_name:
                                # print(f"DEBUG GSM (set_network_game_state): Enemy {enemy_id_str} color mismatch (local '{new_enemy_instance.color_name}', net '{server_color_name}'). Reloading animations.") # DEBUG
                                new_enemy_instance.color_name = server_color_name
                                enemy_asset_folder = os.path.join('characters', server_color_name)
                                new_enemy_instance.animations = load_all_player_animations(
                                    relative_asset_folder=enemy_asset_folder
                                )
                                if new_enemy_instance.animations is None:
                                    print(f"Client CRITICAL: Failed to reload animations for enemy {enemy_id_int} with server color {server_color_name} from '{enemy_asset_folder}'")
                                    new_enemy_instance._valid_init = False
                                    if hasattr(C, 'BLUE'):
                                        new_enemy_instance.image = pygame.Surface((30, 40)).convert_alpha()
                                        new_enemy_instance.image.fill(C.BLUE)
                                        new_enemy_instance.rect = new_enemy_instance.image.get_rect(midbottom=(spawn_pos_e_default[0], spawn_pos_e_default[1]))
                                else:
                                    initial_idle_animation_new_color = new_enemy_instance.animations.get('idle')
                                    if initial_idle_animation_new_color and len(initial_idle_animation_new_color) > 0:
                                        new_enemy_instance.image = initial_idle_animation_new_color[0]
                                    else:
                                        if hasattr(C, 'BLUE'):
                                            new_enemy_instance.image = pygame.Surface((30, 40)).convert_alpha()
                                            new_enemy_instance.image.fill(C.BLUE)
                                    new_enemy_instance.rect = new_enemy_instance.image.get_rect(midbottom=(spawn_pos_e_default[0], spawn_pos_e_default[1]))
                                # print(f"DEBUG GSM (set_network_game_state): Enemy {enemy_id_str} animations reloaded. New valid: {new_enemy_instance._valid_init}") # DEBUG


                        if new_enemy_instance._valid_init:
                            new_enemy_instance.set_network_data(enemy_data_from_server)
                            all_sprites.add(new_enemy_instance); enemy_sprites.add(new_enemy_instance)
                            enemy_list.append(new_enemy_instance)
                            # print(f"DEBUG GSM (set_network_game_state): New enemy {enemy_id_str} added to lists and groups.") # DEBUG
                        # else: # DEBUG
                            # print(f"DEBUG GSM (set_network_game_state): New enemy {enemy_id_str} was NOT valid after creation/color sync.") # DEBUG
                    except Exception as e:
                        print(f"Client: Error creating new instance of enemy {enemy_id_str}: {e}")
                        traceback.print_exc()

            elif enemy_id_str in current_client_enemies_map: # Server says enemy invalid, but client has it
                enemy_to_remove = current_client_enemies_map[enemy_id_str]
                # print(f"DEBUG GSM (set_network_game_state): Server marked enemy {enemy_id_str} as invalid. Removing from client.") # DEBUG
                if enemy_to_remove.alive(): enemy_to_remove.kill()
                if enemy_to_remove in enemy_list: enemy_list.remove(enemy_to_remove)

        server_enemy_ids_present_in_message = set(received_enemy_data_map.keys())
        client_enemy_ids_to_remove_fully = set(current_client_enemies_map.keys()) - server_enemy_ids_present_in_message
        for removed_id_str_fully in client_enemy_ids_to_remove_fully:
            if removed_id_str_fully in current_client_enemies_map:
                enemy_to_remove_fully = current_client_enemies_map[removed_id_str_fully]
                # print(f"DEBUG GSM (set_network_game_state): Enemy {removed_id_str_fully} not in server message. Removing from client.") # DEBUG
                if enemy_to_remove_fully.alive(): enemy_to_remove_fully.kill()
                if enemy_to_remove_fully in enemy_list: enemy_list.remove(enemy_to_remove_fully)


    # Chest state synchronization
    if 'chest' in network_state_data:
        chest_data_from_server = network_state_data['chest']
        # print(f"DEBUG GSM (set_network_game_state): Chest data from server: {chest_data_from_server}") # DEBUG
        if chest_data_from_server and Chest is not None: 
            chest_pos_center_server = chest_data_from_server.get('pos')
            chest_is_collected_server = chest_data_from_server.get('is_collected', False)

            if chest_is_collected_server: 
                if current_chest and current_chest.alive(): current_chest.kill()
                game_elements["current_chest"] = None 
                # print(f"DEBUG GSM (set_network_game_state): Server says chest collected. Cleared local chest.") # DEBUG
            elif chest_pos_center_server: 
                if not current_chest or not current_chest.alive(): 
                    # print(f"DEBUG GSM (set_network_game_state): Client needs to create chest at {chest_pos_center_server}.") # DEBUG
                    if current_chest: current_chest.kill() 
                    try:
                        temp_chest_surf_for_height = Chest(0,0).image
                        temp_chest_height_approx = temp_chest_surf_for_height.get_height() if temp_chest_surf_for_height else 30
                        chest_spawn_x_midbottom = chest_pos_center_server[0]
                        chest_spawn_y_midbottom = chest_pos_center_server[1] + temp_chest_height_approx / 2
                        new_chest_instance_client = Chest(chest_spawn_x_midbottom, chest_spawn_y_midbottom)
                        if hasattr(new_chest_instance_client, '_valid_init') and new_chest_instance_client._valid_init:
                            all_sprites.add(new_chest_instance_client)
                            collectible_sprites.add(new_chest_instance_client)
                            game_elements["current_chest"] = new_chest_instance_client
                            if hasattr(game_elements["current_chest"], 'is_collected'):
                                game_elements["current_chest"].is_collected = False
                            # print(f"DEBUG GSM (set_network_game_state): New client chest created: {new_chest_instance_client}") # DEBUG
                        else:
                            game_elements["current_chest"] = None
                            # print(f"DEBUG GSM (set_network_game_state): New client chest FAILED init.") # DEBUG
                    except Exception as e:
                        # print(f"DEBUG GSM (set_network_game_state): Exception creating client chest: {e}") # DEBUG
                        game_elements["current_chest"] = None
                elif current_chest: # Client has a chest, server has one uncollected - ensure local not marked collected
                    # print(f"DEBUG GSM (set_network_game_state): Client and server both have uncollected chest. Ensuring local is_collected is False.") # DEBUG
                    if hasattr(current_chest, 'is_collected'):
                        current_chest.is_collected = False

        elif not network_state_data.get('chest'): # Server says no chest
            if current_chest and current_chest.alive(): current_chest.kill()
            game_elements["current_chest"] = None
            # print(f"DEBUG GSM (set_network_game_state): Server says NO chest. Cleared local chest.") # DEBUG


    # Projectile state synchronization
    if 'projectiles' in network_state_data:
        received_proj_data_map = {p_data['id']: p_data for p_data in network_state_data.get('projectiles', []) if 'id' in p_data}
        # print(f"DEBUG GSM (set_network_game_state): Syncing {len(received_proj_data_map)} projectiles from network.") # DEBUG
        current_client_proj_map = {p.projectile_id: p for p in projectile_sprites if hasattr(p, 'projectile_id')}

        for proj_id_server, proj_data_server in received_proj_data_map.items():
            # print(f"DEBUG GSM (set_network_game_state): Processing projectile ID {proj_id_server} from network. Pos: {proj_data_server.get('pos')}") # DEBUG
            if proj_id_server in current_client_proj_map:
                existing_proj_client = current_client_proj_map[proj_id_server]
                if hasattr(existing_proj_client, 'set_network_data'):
                    existing_proj_client.set_network_data(proj_data_server)
            else: # New projectile for this client
                owner_instance_client = None
                owner_id_from_server = proj_data_server.get('owner_id')
                if owner_id_from_server is not None:
                    if owner_id_from_server == 1 and player1: owner_instance_client = player1
                    elif owner_id_from_server == 2 and player2: owner_instance_client = player2
                
                # print(f"DEBUG GSM (set_network_game_state): Attempting to create new projectile {proj_id_server}. Owner ID: {owner_id_from_server}, Owner instance client-side: {owner_instance_client}") # DEBUG


                if owner_instance_client and 'pos' in proj_data_server and 'vel' in proj_data_server:
                    direction_vec_server = pygame.math.Vector2(proj_data_server['vel'])
                    if direction_vec_server.length_squared() == 0:
                        direction_vec_server = pygame.math.Vector2(1,0) if owner_instance_client.facing_right else pygame.math.Vector2(-1,0)

                    try:
                        new_proj_client = Fireball(proj_data_server['pos'][0], proj_data_server['pos'][1],
                                             direction_vec_server, owner_instance_client)
                        new_proj_client.projectile_id = proj_id_server
                        if hasattr(new_proj_client, 'set_network_data'):
                            new_proj_client.set_network_data(proj_data_server)
                        projectile_sprites.add(new_proj_client)
                        all_sprites.add(new_proj_client)
                        # print(f"DEBUG GSM (set_network_game_state): New projectile {proj_id_server} created and added.") # DEBUG
                    except Exception as e:
                        print(f"DEBUG GSM (set_network_game_state): Error creating new projectile {proj_id_server}: {e}") # DEBUG
                        traceback.print_exc()
                # else: # DEBUG
                    # print(f"DEBUG GSM (set_network_game_state): Cannot create projectile {proj_id_server} - owner missing or data incomplete.") # DEBUG


        client_proj_ids_to_remove = set(current_client_proj_map.keys()) - set(received_proj_data_map.keys())
        for removed_proj_id_client in client_proj_ids_to_remove:
            if removed_proj_id_client in current_client_proj_map:
                proj_to_kill_client = current_client_proj_map[removed_proj_id_client]
                # print(f"DEBUG GSM (set_network_game_state): Projectile {removed_proj_id_client} not in server message. Removing from client.") # DEBUG
                if proj_to_kill_client.alive(): proj_to_kill_client.kill()
    # print(f"DEBUG GSM (set_network_game_state): Network state application finished. P1 alive: {player1.alive() if player1 else 'N/A'}, P2 alive: {player2.alive() if player2 else 'N/A'}") # DEBUG

########## END OF FILE: game_state_manager.py ##########

########## START OF FILE: game_ui.py ##########

# game_ui.py
# -*- coding: utf-8 -*-
## version 1.0.0.5 (Added Editor button option)
"""
Functions for drawing User Interface elements like health bars, player HUDs,
main menus, input dialogs, and the main game scene.
"""
import pygame
import time 
import os # Needed for listing map files
import constants as C 
from typing import Dict, Optional, Any, List # Added List

# --- (PYPERCLIP_AVAILABLE_UI_MODULE and SCRAP_INITIALIZED_UI_MODULE setup remains the same) ---
PYPERCLIP_AVAILABLE_UI_MODULE = False
try:
    import pyperclip
    PYPERCLIP_AVAILABLE_UI_MODULE = True
except ImportError:
    pass 

SCRAP_INITIALIZED_UI_MODULE = False 

def check_pygame_scrap_init_status():
    global SCRAP_INITIALIZED_UI_MODULE
    try:
        if pygame.scrap.get_init(): SCRAP_INITIALIZED_UI_MODULE = True
        else: SCRAP_INITIALIZED_UI_MODULE = False
    except (AttributeError, pygame.error): SCRAP_INITIALIZED_UI_MODULE = False
    return SCRAP_INITIALIZED_UI_MODULE

# --- Health Bar Drawing Function ---
def draw_health_bar(surface: pygame.Surface, x: int, y: int, 
                    width: int, height: int, 
                    current_hp: float, max_hp: float):
    if max_hp <= 0: return
    current_hp_clamped = max(0, min(current_hp, max_hp))
    bar_width = max(1, int(width)); bar_height = max(1, int(height))
    health_ratio = current_hp_clamped / max_hp
    color_red = getattr(C, 'RED', (255,0,0)); color_green = getattr(C, 'GREEN', (0,255,0))
    color_dark_gray = getattr(C, 'DARK_GRAY', (50,50,50)); color_black = getattr(C, 'BLACK', (0,0,0))
    try: health_color = pygame.Color(color_red).lerp(pygame.Color(color_green), health_ratio)
    except AttributeError:
        r = int(color_red[0] * (1 - health_ratio) + color_green[0] * health_ratio)
        g = int(color_red[1] * (1 - health_ratio) + color_green[1] * health_ratio)
        b = int(color_red[2] * (1 - health_ratio) + color_green[2] * health_ratio)
        health_color = (max(0, min(255, r)), max(0, min(255, g)), max(0, min(255, b)))
    background_rect = pygame.Rect(x, y, bar_width, bar_height)
    pygame.draw.rect(surface, color_dark_gray, background_rect)
    health_fill_width = int(bar_width * health_ratio)
    if health_fill_width > 0: pygame.draw.rect(surface, health_color, pygame.Rect(x, y, health_fill_width, bar_height))
    pygame.draw.rect(surface, color_black, background_rect, 1) 

def draw_player_hud(surface: pygame.Surface, x: int, y: int, player_instance: Any, 
                    player_number: int, hud_font_obj: Optional[pygame.font.Font]):
    if not player_instance or not hasattr(player_instance, 'current_health') or not hasattr(player_instance, 'max_health'): return
    player_label_text = f"P{player_number}"; label_height_offset = 0; color_white = getattr(C, 'WHITE', (255,255,255))
    if hud_font_obj: 
        try:
            label_surface = hud_font_obj.render(player_label_text, True, color_white) 
            surface.blit(label_surface, (x, y)); label_height_offset = label_surface.get_height() 
        except Exception as e: label_height_offset = getattr(hud_font_obj, 'get_height', lambda: 20)()
    health_bar_pos_x = x; health_bar_pos_y = y + label_height_offset + 5  
    hud_health_bar_width = getattr(C, 'HUD_HEALTH_BAR_WIDTH', getattr(C, 'HEALTH_BAR_WIDTH', 50) * 2)
    hud_health_bar_height = getattr(C, 'HUD_HEALTH_BAR_HEIGHT', getattr(C, 'HEALTH_BAR_HEIGHT', 8) + 4)
    draw_health_bar(surface, health_bar_pos_x, health_bar_pos_y, hud_health_bar_width, hud_health_bar_height,
                    player_instance.current_health, player_instance.max_health)
    if hud_font_obj: 
        try:
            health_value_text = f"{int(player_instance.current_health)}/{int(player_instance.max_health)}"
            health_text_surface = hud_font_obj.render(health_value_text, True, color_white)
            health_text_pos_x = health_bar_pos_x + hud_health_bar_width + 10 
            health_text_pos_y = health_bar_pos_y + (hud_health_bar_height - health_text_surface.get_height()) // 2
            surface.blit(health_text_surface, (health_text_pos_x, health_text_pos_y))
        except Exception as e: pass # Add logging here if desired

def draw_platformer_scene_on_surface(screen_surface: pygame.Surface, game_elements: Dict[str, Any], 
                                     fonts: Dict[str, Optional[pygame.font.Font]], current_game_time_ticks: int,
                                     download_status_message: Optional[str] = None,
                                     download_progress_percent: Optional[float] = None): 
    camera_instance = game_elements.get("camera"); all_sprites_group = game_elements.get("all_sprites") 
    enemy_list_for_health_bars = game_elements.get("enemy_list", [])
    player1_instance, player2_instance = game_elements.get("player1"), game_elements.get("player2")
    font_for_hud = fonts.get("medium") or (pygame.font.Font(None, 24) if pygame.font.get_init() else None)
    current_screen_width, current_screen_height = screen_surface.get_size(); bg_color = getattr(C, 'LIGHT_BLUE', (135, 206, 235))
    level_bg_color = game_elements.get("level_background_color", bg_color) 
    screen_surface.fill(level_bg_color) 
    if camera_instance and all_sprites_group:
        for entity_sprite in all_sprites_group: 
            if entity_sprite.alive() and hasattr(entity_sprite, 'image') and hasattr(entity_sprite, 'rect'):
                 screen_surface.blit(entity_sprite.image, camera_instance.apply(entity_sprite.rect))
        for enemy_sprite in enemy_list_for_health_bars:
            if enemy_sprite.alive() and getattr(enemy_sprite, '_valid_init', False) and not \
               (getattr(enemy_sprite, 'is_dead', False) and getattr(enemy_sprite, 'death_animation_finished', False)) and \
               hasattr(enemy_sprite, 'current_health') and hasattr(enemy_sprite, 'max_health'):
                enemy_rect_on_screen = camera_instance.apply(enemy_sprite.rect) 
                hb_w, hb_h = getattr(C, 'HEALTH_BAR_WIDTH', 50), getattr(C, 'HEALTH_BAR_HEIGHT', 8)
                hb_x, hb_y = enemy_rect_on_screen.centerx - hb_w // 2, enemy_rect_on_screen.top - hb_h - getattr(C, 'HEALTH_BAR_OFFSET_ABOVE', 5) 
                draw_health_bar(screen_surface, hb_x, hb_y, hb_w, hb_h, enemy_sprite.current_health, enemy_sprite.max_health)
    elif all_sprites_group: all_sprites_group.draw(screen_surface) # Fallback if no camera
    if player1_instance and getattr(player1_instance, '_valid_init', False) and player1_instance.alive():
        draw_player_hud(screen_surface, 10, 10, player1_instance, 1, font_for_hud)
    if player2_instance and getattr(player2_instance, '_valid_init', False) and player2_instance.alive():
        p2_hud_w = getattr(C, 'HUD_HEALTH_BAR_WIDTH', getattr(C, 'HEALTH_BAR_WIDTH',50)*2) + 120 
        draw_player_hud(screen_surface, current_screen_width - p2_hud_w - 10, 10, player2_instance, 2, font_for_hud)

    if download_status_message and font_for_hud:
        dialog_rect = pygame.Rect(0, 0, current_screen_width * 0.6, current_screen_height * 0.3)
        dialog_rect.center = (current_screen_width // 2, current_screen_height // 2)
        pygame.draw.rect(screen_surface, getattr(C, 'DARK_GRAY', (50,50,50)), dialog_rect, border_radius=10)
        pygame.draw.rect(screen_surface, getattr(C, 'WHITE', (255,255,255)), dialog_rect, 2, border_radius=10)

        status_surf = font_for_hud.render(download_status_message, True, getattr(C, 'WHITE', (255,255,255)))
        status_rect = status_surf.get_rect(centerx=dialog_rect.centerx, top=dialog_rect.top + 20)
        screen_surface.blit(status_surf, status_rect)

        if download_progress_percent is not None and download_progress_percent >= 0:
            bar_width = dialog_rect.width * 0.8
            bar_height = 30
            bar_x = dialog_rect.centerx - bar_width / 2
            bar_y = status_rect.bottom + 20
            
            pygame.draw.rect(screen_surface, getattr(C, 'GRAY', (128,128,128)), (bar_x, bar_y, bar_width, bar_height), border_radius=5)
            fill_width = (download_progress_percent / 100) * bar_width
            pygame.draw.rect(screen_surface, getattr(C, 'GREEN', (0,255,0)), (bar_x, bar_y, fill_width, bar_height), border_radius=5)
            pygame.draw.rect(screen_surface, getattr(C, 'WHITE', (255,255,255)), (bar_x, bar_y, bar_width, bar_height), 2, border_radius=5)

            progress_text = f"{download_progress_percent:.1f}%"
            font_small = fonts.get("small") or pygame.font.Font(None, 24)
            if font_small:
                text_surf = font_small.render(progress_text, True, getattr(C, 'BLACK', (0,0,0)))
                text_rect_prog = text_surf.get_rect(center=(bar_x + bar_width / 2, bar_y + bar_height / 2))
                screen_surface.blit(text_surf, text_rect_prog)


def show_main_menu(screen_surface: pygame.Surface, clock_obj: pygame.time.Clock, 
                   fonts: Dict[str, Optional[pygame.font.Font]], app_status_obj: Any) -> Optional[str]:
    button_w, button_h, spacing, title_gap = 350, 55, 20, 60 # Adjusted for potentially more buttons
    current_w, current_h = screen_surface.get_size()
    font_title = fonts.get("large") or (pygame.font.Font(None, 60) if pygame.font.get_init() else None)
    if not font_title: return "quit"
    title_surf = font_title.render("Platformer Adventure LAN", True, getattr(C, 'WHITE',(255,255,255)))
    
    menu_buttons = { # Using a dictionary to define buttons and their actions
        "host": {"text": "Host Game", "action": "host"}, 
        "join_lan": {"text": "Join LAN", "action": "join_lan"},
        "join_ip": {"text": "Join by IP", "action": "join_ip"}, 
        "couch_play": {"text": "Couch Play", "action": "couch_play"},
        "editor": {"text": "Level Editor", "action": "editor"}, # <-- ADDED EDITOR BUTTON
        "quit": {"text": "Quit", "action": "quit"}
    }
    
    font_button = fonts.get("medium") or (pygame.font.Font(None, 30) if pygame.font.get_init() else None)
    if not font_button: return "quit"
    
    title_rect = title_surf.get_rect(center=(current_w // 2, current_h // 5)) # Adjusted title position slightly higher

    # Calculate total height of buttons to center them better if many
    num_buttons = len(menu_buttons)
    total_buttons_height = (num_buttons * button_h) + ((num_buttons - 1) * spacing)
    start_y_offset = (current_h - total_buttons_height - title_rect.bottom - title_gap) // 2 # Center remaining space
    
    def update_btn_geo():
        nonlocal title_rect 
        current_w_local, current_h_local = screen_surface.get_size() 
        title_rect = title_surf.get_rect(center=(current_w_local // 2, current_h_local // 5)) # Keep consistent
        
        # Dynamically position buttons based on title and number of buttons
        btn_y = title_rect.bottom + title_gap + start_y_offset 
        if num_buttons > 5 : # If many buttons, reduce title_gap slightly or ensure start_y is adjusted
             btn_y = title_rect.bottom + max(20, title_gap - 20) + start_y_offset


        for key in menu_buttons: # Iterate in insertion order (Python 3.7+)
            props = menu_buttons[key]
            props["rect"] = pygame.Rect(0, 0, button_w, button_h)
            props["rect"].centerx = current_w_local // 2
            props["rect"].top = btn_y
            props["text_surf"] = font_button.render(props["text"], True, getattr(C, 'WHITE',(255,255,255)))
            props["text_rect"] = props["text_surf"].get_rect(center=props["rect"].center)
            btn_y += button_h + spacing
    update_btn_geo() # Initial setup
    
    selected_action = None
    while selected_action is None and app_status_obj.app_running:
        mouse_pos = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT: 
                app_status_obj.app_running = False; selected_action = "quit"
            if event.type == pygame.VIDEORESIZE and not (screen_surface.get_flags() & pygame.FULLSCREEN):
                try:
                    current_w, current_h = max(event.w, 800), max(event.h, 600) # Min size
                    screen_surface = pygame.display.set_mode((current_w,current_h), pygame.RESIZABLE|pygame.DOUBLEBUF)
                    update_btn_geo() # Recalculate button positions
                except pygame.error as e: 
                    print(f"UI Error: Menu resize error: {e}") # Use logger in future
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE: 
                    app_status_obj.app_running = False; selected_action = "quit"
            if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                for props in menu_buttons.values():
                    if "rect" in props and props["rect"].collidepoint(mouse_pos): 
                        selected_action = props["action"]; break
        
        if not app_status_obj.app_running: break

        screen_surface.fill(getattr(C, 'BLACK',(0,0,0)))
        screen_surface.blit(title_surf, title_rect)
        
        for props in menu_buttons.values():
            if "rect" in props:
                hover = props["rect"].collidepoint(mouse_pos)
                color_val_green = getattr(C, 'GREEN',(0,255,0))
                color_val_blue = getattr(C, 'BLUE',(0,0,255))
                color = color_val_green if hover else color_val_blue
                pygame.draw.rect(screen_surface, color, props["rect"], border_radius=8)
                if "text_surf" in props and "text_rect" in props: 
                    screen_surface.blit(props["text_surf"], props["text_rect"])
        
        pygame.display.flip()
        clock_obj.tick(C.FPS if hasattr(C, 'FPS') else 30) # Use constant FPS if available
        
    return selected_action


def get_server_ip_input_dialog(screen_surface: pygame.Surface, clock_obj: pygame.time.Clock, 
                               fonts: Dict[str, Optional[pygame.font.Font]], app_status_obj: Any, 
                               default_input_text: str = "") -> Optional[str]:
    current_input = default_input_text; active = True; cursor_visible = True; last_blink = time.time()
    current_w, current_h = screen_surface.get_size()
    box_w = max(300, current_w // 2.5); box_h = 50 # Made box slightly wider
    box_rect = pygame.Rect(0,0, box_w, box_h); box_rect.center = (current_w//2, current_h//2)
    
    pygame.key.set_repeat(250, 25); paste_msg = None; paste_time = 0
    check_pygame_scrap_init_status() # Ensure scrap status is up-to-date

    font_prompt = fonts.get("medium") or (pygame.font.Font(None,30) if pygame.font.get_init() else None)
    font_info = fonts.get("small") or (pygame.font.Font(None,20) if pygame.font.get_init() else None)
    font_input = fonts.get("medium") or (pygame.font.Font(None,30) if pygame.font.get_init() else None)

    if not all([font_prompt, font_info, font_input]): 
        pygame.key.set_repeat(0,0); return None # Cannot proceed without fonts

    while active and app_status_obj.app_running:
        now = time.time()
        if now - last_blink > 0.5: cursor_visible = not cursor_visible; last_blink = now
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT: 
                app_status_obj.app_running = False; active = False; current_input = None
            if event.type == pygame.VIDEORESIZE and not (screen_surface.get_flags() & pygame.FULLSCREEN):
                try:
                    current_w,current_h=max(event.w, 600),max(event.h, 400) # Min size for dialog
                    screen_surface=pygame.display.set_mode((current_w,current_h), pygame.RESIZABLE|pygame.DOUBLEBUF)
                    box_w = max(300, current_w // 2.5); box_rect.width = box_w # Update width
                    box_rect.center = (current_w//2, current_h//2) # Recenter
                except pygame.error as e: print(f"UI Error: IP Dialog resize error: {e}") # Use logger
            if event.type == pygame.KEYDOWN:
                paste_msg = None # Clear paste message on new key press
                if event.key == pygame.K_ESCAPE: 
                    active = False; current_input = None
                elif event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER: 
                    active = False
                elif event.key == pygame.K_BACKSPACE: 
                    current_input = current_input[:-1]
                elif event.key == pygame.K_v and (event.mod & pygame.KMOD_CTRL or event.mod & pygame.KMOD_META):
                    pasted_text = ""; paste_method = "None"
                    try:
                        if SCRAP_INITIALIZED_UI_MODULE: # Prioritize pygame.scrap if initialized
                            cb_bytes = pygame.scrap.get(pygame.SCRAP_TEXT)
                            if cb_bytes: pasted_text = cb_bytes.decode('utf-8','ignore').replace('\x00','').strip()
                            if pasted_text: paste_method = "pygame.scrap"
                        
                        if not pasted_text and PYPERCLIP_AVAILABLE_UI_MODULE: # Fallback to pyperclip
                            cb_str = pyperclip.paste()
                            if isinstance(cb_str,str): pasted_text = cb_str.replace('\x00','').strip()
                            if pasted_text: paste_method = "pyperclip"
                            
                    except Exception as e: print(f"UI Warning: Paste error (Method {paste_method}): {e}") # Use logger
                    
                    if pasted_text: current_input += pasted_text
                    else: paste_msg = "Paste Failed or Clipboard Empty"; paste_time = now
                elif event.unicode.isprintable() and (event.unicode.isalnum() or event.unicode in ['.',':','-','_']): # Allowed chars
                    current_input += event.unicode
        
        if not app_status_obj.app_running: break # Exit if app is no longer running

        screen_surface.fill(getattr(C,'BLACK',(0,0,0)))
        
        prompt_surf = font_prompt.render("Enter Host IP or IP:Port", True, getattr(C,'WHITE',(255,255,255)))
        screen_surface.blit(prompt_surf, prompt_surf.get_rect(center=(current_w//2, current_h//2-60)))
        
        info_text = "(Enter=OK, Esc=Cancel"
        if PYPERCLIP_AVAILABLE_UI_MODULE or SCRAP_INITIALIZED_UI_MODULE: info_text += ", Ctrl+V=Paste"
        info_text += ")"
        info_surf = font_info.render(info_text, True, getattr(C,'GRAY',(128,128,128)))
        screen_surface.blit(info_surf, info_surf.get_rect(center=(current_w//2, current_h-40)))
        
        pygame.draw.rect(screen_surface, getattr(C,'GRAY',(128,128,128)), box_rect,0,5) # Background
        pygame.draw.rect(screen_surface, getattr(C,'WHITE',(255,255,255)), box_rect,2,5) # Border
        
        input_surf = font_input.render(current_input, True, getattr(C,'BLACK',(0,0,0)))
        input_rect = input_surf.get_rect(midleft=(box_rect.left+10, box_rect.centery))
        
        # Clipping logic for text overflow
        clip_area = box_rect.inflate(-12,-12) # Inner area for text
        if input_rect.width > clip_area.width: 
            input_rect.right = clip_area.right # Align to right if overflowing
        else: 
            input_rect.left = clip_area.left # Align to left otherwise
        
        screen_surface.set_clip(clip_area)
        screen_surface.blit(input_surf, input_rect)
        screen_surface.set_clip(None) # Reset clipping
        
        if cursor_visible:
            cursor_x_offset = input_rect.width if input_rect.left == clip_area.left else 0 # Cursor at end of text
            cursor_x = max(clip_area.left, min(input_rect.left + cursor_x_offset + 2, clip_area.right-1))
            if input_rect.width > clip_area.width: # If text overflows, cursor is at the right edge of clip area
                 cursor_x = clip_area.right -1
            else: # Cursor at end of text within clip area
                 cursor_x = input_rect.left + input_surf.get_width() + 2
                 cursor_x = max(clip_area.left, min(cursor_x, clip_area.right -1))

            pygame.draw.line(screen_surface, getattr(C,'BLACK',(0,0,0)), 
                             (cursor_x,box_rect.top+5), (cursor_x,box_rect.bottom-5),2)
        
        if paste_msg and now - paste_time < 2.0: # Show paste status message for 2 seconds
            msg_surf = font_info.render(paste_msg, True, getattr(C,'RED',(255,0,0)))
            screen_surface.blit(msg_surf, msg_surf.get_rect(center=(current_w//2,box_rect.bottom+30)))
        elif paste_msg: paste_msg = None # Clear message after time
            
        pygame.display.flip()
        clock_obj.tick(C.FPS if hasattr(C, 'FPS') else 30)
        
    pygame.key.set_repeat(0,0) # Disable key repeat
    return current_input.strip() if current_input is not None else None


MAPS_DIRECTORY_GAME_UI = getattr(C, "MAPS_DIR", "maps")

def select_map_dialog(screen: pygame.Surface, clock: pygame.time.Clock, 
                      fonts: Dict[str, Optional[pygame.font.Font]], 
                      app_status: Any) -> Optional[str]:
    # print("GAME_UI: Opening select_map_dialog...") # Use logger in future
    map_module_names: List[str] = []
    if os.path.exists(MAPS_DIRECTORY_GAME_UI) and os.path.isdir(MAPS_DIRECTORY_GAME_UI):
        try:
            for f_name in os.listdir(MAPS_DIRECTORY_GAME_UI):
                if f_name.endswith(".py") and f_name != "__init__.py" and not f_name.startswith("_"): # Avoid private/utility files
                    map_module_names.append(f_name[:-3]) 
            map_module_names.sort()
            # print(f"GAME_UI: Found maps: {map_module_names}") # Use logger
        except OSError as e:
            print(f"GAME_UI Error: Could not read maps directory '{MAPS_DIRECTORY_GAME_UI}': {e}") # Use logger
            map_module_names = [] 
    else:
        print(f"GAME_UI Warning: Maps directory '{MAPS_DIRECTORY_GAME_UI}' not found.") # Use logger

    if not map_module_names:
        font_medium = fonts.get("medium") or (pygame.font.Font(None, 36) if pygame.font.get_init() else None)
        if font_medium:
            screen_w, screen_h = screen.get_size()
            screen.fill(getattr(C, 'BLACK', (0,0,0)))
            msg_surf = font_medium.render(f"No Maps Found in '{MAPS_DIRECTORY_GAME_UI}/' folder.", True, getattr(C, 'RED', (255,0,0)))
            screen.blit(msg_surf, msg_surf.get_rect(center=(screen_w//2, screen_h//2)))
            pygame.display.flip()
            pygame.time.wait(2500) 
        return None 

    selected_index = 0
    dialog_active = True
    
    font_title = fonts.get("large") or (pygame.font.Font(None, 60) if pygame.font.get_init() else None)
    font_item = fonts.get("medium") or (pygame.font.Font(None, 30) if pygame.font.get_init() else None)
    font_instr = fonts.get("small") or (pygame.font.Font(None, 24) if pygame.font.get_init() else None)

    if not all([font_title, font_item, font_instr]):
        print("GAME_UI Error: Essential fonts for map selection dialog missing.") # Use logger
        return map_module_names[0] if map_module_names else None 

    maps_per_page = 8 
    current_page = 0
    max_pages = (len(map_module_names) + maps_per_page - 1) // maps_per_page

    button_height = 45
    button_spacing = 10
    button_width_factor = 0.7 # Made buttons a bit wider for map names
    
    color_white = getattr(C, 'WHITE', (255,255,255))
    color_black = getattr(C, 'BLACK', (0,0,0))
    color_gray = getattr(C, 'GRAY', (128,128,128))
    color_button_normal_bg = getattr(C, 'BLUE', (0,0,255))
    color_button_hover_bg = (70, 70, 220) 
    color_button_selected_bg = getattr(C, 'GREEN', (0,255,0))
    color_button_selected_hover_bg = (70, 220, 70)
    color_text_normal = color_white
    color_text_selected = color_black

    while dialog_active and app_status.app_running:
        screen_w, screen_h = screen.get_size()
        mouse_pos = pygame.mouse.get_pos()

        frame_title_surf = font_title.render("Select a Map", True, color_white)
        frame_title_rect = frame_title_surf.get_rect(center=(screen_w // 2, screen_h * 0.15))

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                app_status.app_running = False; dialog_active = False
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    dialog_active = False; return None 
                elif event.key == pygame.K_RETURN or event.key == pygame.K_KP_ENTER:
                    if 0 <= selected_index < len(map_module_names):
                        # print(f"GAME_UI: Map selected by keyboard: {map_module_names[selected_index]}") # Use logger
                        return map_module_names[selected_index]
                elif event.key == pygame.K_UP:
                    selected_index = (selected_index - 1 + len(map_module_names)) % len(map_module_names)
                    current_page = selected_index // maps_per_page
                elif event.key == pygame.K_DOWN:
                    selected_index = (selected_index + 1) % len(map_module_names)
                    current_page = selected_index // maps_per_page
                elif event.key == pygame.K_PAGEUP or (event.key == pygame.K_LEFT and max_pages > 1) : 
                    current_page = max(0, current_page - 1)
                    selected_index = current_page * maps_per_page # Select first item on new page
                elif event.key == pygame.K_PAGEDOWN or (event.key == pygame.K_RIGHT and max_pages > 1): 
                    current_page = min(max_pages - 1, current_page + 1)
                    selected_index = current_page * maps_per_page # Select first item on new page
            
            if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                _start_idx_click = current_page * maps_per_page
                _end_idx_click = min(_start_idx_click + maps_per_page, len(map_module_names))
                _visible_maps_on_page_click = map_module_names[_start_idx_click:_end_idx_click]
                _current_btn_y_click = frame_title_rect.bottom + 60 

                for i, map_name in enumerate(_visible_maps_on_page_click):
                    item_rect_click = pygame.Rect(0, 0, screen_w * button_width_factor, button_height)
                    item_rect_click.centerx = screen_w // 2
                    item_rect_click.top = _current_btn_y_click
                    if item_rect_click.collidepoint(mouse_pos):
                        # print(f"GAME_UI: Map selected by click: {map_name}") # Use logger
                        selected_index = _start_idx_click + i 
                        return map_name 
                    _current_btn_y_click += button_height + button_spacing
        
        if not app_status.app_running: break

        screen.fill(color_black)
        screen.blit(frame_title_surf, frame_title_rect)

        instr_text = "UP/DOWN, Enter. PgUp/PgDn or LEFT/RIGHT for pages. ESC to cancel."
        instr_surf = font_instr.render(instr_text, True, color_gray)
        instr_rect = instr_surf.get_rect(center=(screen_w // 2, frame_title_rect.bottom + 25)) # Adjusted Y
        screen.blit(instr_surf, instr_rect)
        
        start_idx_draw = current_page * maps_per_page
        end_idx_draw = min(start_idx_draw + maps_per_page, len(map_module_names))
        visible_maps_on_page_draw = map_module_names[start_idx_draw:end_idx_draw]

        current_btn_y_draw = frame_title_rect.bottom + 60 

        for i, map_name in enumerate(visible_maps_on_page_draw):
            actual_map_index = start_idx_draw + i 
            item_text = f"{map_name}"
            item_rect_draw = pygame.Rect(0, 0, screen_w * button_width_factor, button_height)
            item_rect_draw.centerx = screen_w // 2
            item_rect_draw.top = current_btn_y_draw
            
            is_keyboard_selected = (actual_map_index == selected_index)
            is_mouse_hovered = item_rect_draw.collidepoint(mouse_pos)

            current_bg_color = color_button_normal_bg
            current_text_color = color_text_normal

            if is_keyboard_selected:
                current_text_color = color_text_selected
                current_bg_color = color_button_selected_hover_bg if is_mouse_hovered else color_button_selected_bg
            elif is_mouse_hovered: 
                current_bg_color = color_button_hover_bg
            
            pygame.draw.rect(screen, current_bg_color, item_rect_draw, border_radius=5)
            pygame.draw.rect(screen, color_white, item_rect_draw, 1, border_radius=5) 
            
            item_surf = font_item.render(item_text, True, current_text_color)
            text_rect = item_surf.get_rect(center=item_rect_draw.center)
            screen.blit(item_surf, text_rect)
            
            current_btn_y_draw += button_height + button_spacing

        if max_pages > 1:
            page_text = f"Page {current_page + 1} of {max_pages}"
            page_surf = font_instr.render(page_text, True, color_gray)
            page_rect = page_surf.get_rect(center=(screen_w // 2, screen_h - 30))
            screen.blit(page_surf, page_rect)

        pygame.display.flip()
        clock.tick(C.FPS if hasattr(C, 'FPS') else 30) 

    # print("GAME_UI: Exiting select_map_dialog.") # Use logger
    return None 


def draw_download_dialog(screen: pygame.Surface, fonts: dict, title: str, message: str, progress_percent: float = -1):
    screen_w, screen_h = screen.get_size()
    dialog_w = screen_w * 0.7
    dialog_h = screen_h * 0.4 if progress_percent >= 0 else screen_h * 0.3 # Smaller if no progress bar
    dialog_rect = pygame.Rect(0, 0, dialog_w, dialog_h)
    dialog_rect.center = (screen_w // 2, screen_h // 2)

    font_title_dialog = fonts.get("large") or pygame.font.Font(None, 48) # Renamed to avoid clash
    font_message_dialog = fonts.get("medium") or pygame.font.Font(None, 32) # Renamed

    # Dim background slightly instead of full black for less jarring transition
    dim_surface = pygame.Surface(screen.get_size(), pygame.SRCALPHA)
    dim_surface.fill((0, 0, 0, 150)) # Black with alpha
    screen.blit(dim_surface, (0,0))

    pygame.draw.rect(screen, getattr(C, 'DARK_GRAY', (50,50,50)), dialog_rect, border_radius=10)
    pygame.draw.rect(screen, getattr(C, 'WHITE', (255,255,255)), dialog_rect, 2, border_radius=10)

    current_y = dialog_rect.top + 20
    if font_title_dialog:
        title_surf = font_title_dialog.render(title, True, getattr(C, 'WHITE', (255,255,255)))
        title_rect_ui = title_surf.get_rect(centerx=dialog_rect.centerx, top=current_y)
        screen.blit(title_surf, title_rect_ui)
        current_y = title_rect_ui.bottom + 15
    
    if font_message_dialog:
        # Basic text wrapping for message
        words = message.split(' ')
        lines = []
        current_line = ""
        max_text_width = dialog_rect.width * 0.9 # 90% of dialog width for text
        for word in words:
            test_line = current_line + word + " "
            test_surf = font_message_dialog.render(test_line, True, getattr(C, 'LIGHT_GRAY', (200,200,200)))
            if test_surf.get_width() < max_text_width:
                current_line = test_line
            else:
                lines.append(current_line)
                current_line = word + " "
        lines.append(current_line)

        for line_text in lines:
            msg_surf = font_message_dialog.render(line_text.strip(), True, getattr(C, 'LIGHT_GRAY', (200,200,200)))
            msg_rect = msg_surf.get_rect(centerx=dialog_rect.centerx, top=current_y)
            screen.blit(msg_surf, msg_rect)
            current_y = msg_rect.bottom + 5


    if progress_percent >= 0:
        bar_width = dialog_rect.width * 0.8
        bar_height = 30
        bar_x = dialog_rect.centerx - bar_width / 2
        bar_y = current_y + 20 # Position below text
        
        pygame.draw.rect(screen, getattr(C, 'GRAY', (128,128,128)), (bar_x, bar_y, bar_width, bar_height), border_radius=5)
        fill_width = (progress_percent / 100.0) * bar_width
        pygame.draw.rect(screen, getattr(C, 'GREEN', (0,255,0)), (bar_x, bar_y, fill_width, bar_height), border_radius=5)
        pygame.draw.rect(screen, getattr(C, 'WHITE', (255,255,255)), (bar_x, bar_y, bar_width, bar_height), 2, border_radius=5)

        font_small_dialog = fonts.get("small") or pygame.font.Font(None, 24) # Renamed
        if font_small_dialog:
            progress_text = f"{progress_percent:.1f}%"
            text_surf_prog = font_small_dialog.render(progress_text, True, getattr(C, 'BLACK', (0,0,0)))
            text_rect_p = text_surf_prog.get_rect(center=(bar_x + bar_width / 2, bar_y + bar_height / 2))
            screen.blit(text_surf_prog, text_rect_p)
            
    pygame.display.flip()

########## START OF FILE: items.py ##########

# items.py
# -*- coding: utf-8 -*-
"""
Defines collectible items like Chests.
Uses resource_path helper for PyInstaller compatibility.
"""
# version 1.00000.1
import pygame
import os
import sys # Needed for resource_path logic (imported via assets)
import random

# Import necessary components
import constants as C
# Import BOTH the loader AND the path helper from assets.py
from assets import load_gif_frames, resource_path

class Chest(pygame.sprite.Sprite):
    """
    A chest that restores player health when collected.
    """
    def __init__(self, x, y):
        super().__init__()

        # --- Define the relative path to the asset ---
        # This path is relative to the project root (or wherever resource_path resolves from)
        relative_chest_path = os.path.join('characters', 'items', 'chest.gif')

        # --- Use resource_path to get the correct full path ---
        # resource_path figures out if we're running bundled or locally
        full_chest_path = resource_path(relative_chest_path)
        print(f"Attempting to load chest GIF from resolved path: {full_chest_path}") # Debug print resolved path

        # --- Load frames using the full path ---
        self.frames = load_gif_frames(full_chest_path)

        # --- Error Handling and Placeholder ---
        # Check if loading failed OR if load_gif_frames returned its standard red placeholder
        # (assuming the standard placeholder size is 30x40 from assets.py)
        is_placeholder = False
        if self.frames and len(self.frames) == 1:
             placeholder_check_surf = self.frames[0]
             # Basic check based on size and maybe color (adjust size if your placeholder is different)
             if placeholder_check_surf.get_size() == (30, 40) and placeholder_check_surf.get_at((0,0)) == C.RED:
                 is_placeholder = True

        if not self.frames or is_placeholder:
            # Provide a specific fallback surface for the chest if loading fails OR returns default placeholder
            if not self.frames:
                print(f"Error: Failed to load chest from '{full_chest_path}'. Using placeholder.")
            else: # It returned a placeholder
                print(f"Warning: Chest loaded as a default placeholder from '{full_chest_path}'. Check file/path.")

            self.image = pygame.Surface((30, 30)).convert_alpha()
            self.image.fill(C.YELLOW) # Use a distinct placeholder color for chest issues
            pygame.draw.rect(self.image, C.BLACK, self.image.get_rect(), 1)
            pygame.draw.line(self.image, C.BLACK, (0, 0), (30, 30), 1) # Add cross to placeholder
            pygame.draw.line(self.image, C.BLACK, (0, 30), (30, 0), 1)
            self.frames = [self.image] # Make frames list contain the specific chest placeholder
            self._valid_init = False # Indicate potential issue, though it might still draw
        else:
            # Successfully loaded actual frames
            self.image = self.frames[0] # Use the first frame
            self._valid_init = True
            print(f"Successfully loaded {len(self.frames)} frame(s) for chest.")

        self.rect = self.image.get_rect(midbottom=(x, y))
        self.pos = pygame.math.Vector2(x, y) # Store position if needed later

        # Animation state
        self.current_frame = 0
        self.last_anim_update = pygame.time.get_ticks()
        self.is_collected = False # Flag to prevent multiple collections

    def update(self, dt):
        """ Handles animation if the GIF has multiple frames. dt is not used here yet. """
        # Don't animate if initialization potentially failed or only 1 frame (placeholder/static)
        if not self._valid_init or len(self.frames) <= 1:
            return

        now = pygame.time.get_ticks()
        # Adjust ANIM_FRAME_DURATION if chest animation speed should differ
        anim_speed_multiplier = 2 # Example: make chest animation slower than player/enemy
        if now - self.last_anim_update > C.ANIM_FRAME_DURATION * anim_speed_multiplier:
            self.last_anim_update = now
            self.current_frame = (self.current_frame + 1) % len(self.frames) # Loop animation
            current_midbottom = self.rect.midbottom # Store position anchor
            self.image = self.frames[self.current_frame]
            # Re-center rect if frame sizes change during animation (unlikely for simple items)
            self.rect = self.image.get_rect(midbottom=current_midbottom) # Re-anchor rect after getting new image

    def collect(self, player):
        """ Action when the player collects the chest. """
        # Only collect if properly initialized and not already collected
        if not self.is_collected and self._valid_init:
            print("Player collected chest!")
            # Ensure player has the heal_to_full method before calling it
            if hasattr(player, 'heal_to_full') and callable(player.heal_to_full):
                player.heal_to_full()
            else:
                print("Warning: Player object does not have 'heal_to_full' method.")
            self.is_collected = True
            self.kill() # Remove sprite from all groups it belongs to

########## START OF FILE: levels.py ##########

# levels.py
# -*- coding: utf-8 -*-
"""
levels.py
Returns sprite groups for platforms, ladders, hazards, spawns, level width,
and absolute min/max Y coordinates for the entire level.
"""
# version 1.0.0.9 (Added platform_type tags to all platforms)
import pygame
import random
from tiles import Platform, Ladder, Lava # Import tile classes
from constants import TILE_SIZE, GRAY, DARK_GREEN, ORANGE_RED, LAVA_PATCH_HEIGHT, BLACK
import constants as C # Already imported, but C alias is good practice

FENCE_WIDTH = 8
FENCE_HEIGHT = 15
FENCE_COLOR = GRAY

def _add_map_boundary_walls(platforms_group, map_total_width, all_content_sprites_list,
                            initial_screen_height_fallback, extra_sky_clearance=0):
    """
    Calculates content extents and adds TILE_SIZE thick boundary walls.
    map_total_width is the outer width including walls.
    extra_sky_clearance pushes the ceiling collision object higher.
    Returns min_y_overall, max_y_overall (absolute top/bottom of level including walls).
    """
    if not all_content_sprites_list:
        print("Warning: _add_map_boundary_walls called with empty content list. Using fallback extents.")
        min_y_content = 0 - TILE_SIZE * 5
        max_y_content = initial_screen_height_fallback
    else:
        all_rects = [s.rect for s in all_content_sprites_list if hasattr(s, 'rect')]
        if not all_rects:
            min_y_content = 0 - TILE_SIZE * 5
            max_y_content = initial_screen_height_fallback
        else:
            min_y_content = min(r.top for r in all_rects)
            max_y_content = max(r.bottom for r in all_rects)

    ceiling_object_top_y = min_y_content - TILE_SIZE - extra_sky_clearance
    level_min_y_abs = ceiling_object_top_y
    level_max_y_abs = max_y_content + TILE_SIZE
    boundary_box_height = level_max_y_abs - level_min_y_abs

    platforms_group.add(Platform(0, ceiling_object_top_y, map_total_width, TILE_SIZE, GRAY, platform_type="boundary"))
    platforms_group.add(Platform(0, max_y_content, map_total_width, TILE_SIZE, GRAY, platform_type="boundary"))
    platforms_group.add(Platform(0, level_min_y_abs, TILE_SIZE, boundary_box_height, GRAY, platform_type="boundary"))
    platforms_group.add(Platform(map_total_width - TILE_SIZE, level_min_y_abs, TILE_SIZE, boundary_box_height, GRAY, platform_type="boundary"))

    return level_min_y_abs, level_max_y_abs


def load_map_original(initial_width, initial_height):
    """ Creates the original level layout with boundary walls and colored ledges. """
    platforms = pygame.sprite.Group()
    ladders = pygame.sprite.Group()
    hazards = pygame.sprite.Group()
    enemy_spawns_data = []

    map_total_width = initial_width * 2.5
    player_spawn = (TILE_SIZE + 60, initial_height - TILE_SIZE - TILE_SIZE - 1)
    main_ground_y_ref = initial_height - TILE_SIZE
    main_ground_segment_height_ref = TILE_SIZE

    # Ground
    ground = Platform(TILE_SIZE, main_ground_y_ref, map_total_width - 2 * TILE_SIZE, main_ground_segment_height_ref, GRAY, platform_type="ground")
    platforms.add(ground)

    # Ledges
    platforms.add(Platform(TILE_SIZE + 160, initial_height - 150, 250, 20, DARK_GREEN, platform_type="ledge"))
    platforms.add(Platform(TILE_SIZE + 410, initial_height - 300, 180, 20, DARK_GREEN, platform_type="ledge"))
    platforms.add(Platform(min(map_total_width - TILE_SIZE - 200, TILE_SIZE + initial_width - 350), initial_height - 450, 200, 20, DARK_GREEN, platform_type="ledge"))
    platforms.add(Platform(min(map_total_width - TILE_SIZE - 150, TILE_SIZE + initial_width + 150), initial_height - 250, 150, 20, DARK_GREEN, platform_type="ledge"))
    platforms.add(Platform(TILE_SIZE + 860, initial_height - 550, 100, 20, DARK_GREEN, platform_type="ledge"))

    # Structural Wall
    wall_mid_x = TILE_SIZE + 760
    wall_mid_width = 30
    if wall_mid_x + wall_mid_width > map_total_width - TILE_SIZE:
        wall_mid_width = max(1, (map_total_width - TILE_SIZE) - wall_mid_x)
    platforms.add(Platform(wall_mid_x, initial_height - 400, wall_mid_width, 360, GRAY, platform_type="wall"))

    # Ladders
    ladder_width = 40
    ladder_height_main = 250
    ladders.add(Ladder(min(map_total_width - TILE_SIZE - ladder_width, TILE_SIZE + initial_width - 500),
                       main_ground_y_ref - ladder_height_main, ladder_width, ladder_height_main))
    ladders.add(Ladder(TILE_SIZE + 310, initial_height - 250, ladder_width, 150))

    all_content_sprites = list(platforms.sprites()) + list(ladders.sprites())
    level_min_y_abs, level_max_y_abs = _add_map_boundary_walls(platforms, map_total_width, all_content_sprites, initial_height, extra_sky_clearance=TILE_SIZE * 5)

    return platforms, ladders, hazards, enemy_spawns_data, player_spawn, \
           map_total_width, level_min_y_abs, level_max_y_abs, \
           main_ground_y_ref, main_ground_segment_height_ref

def load_map_lava(initial_width, initial_height):
    """ Creates a level with lava, boundary walls, and colored ledges. """
    platforms = pygame.sprite.Group()
    ladders = pygame.sprite.Group()
    hazards = pygame.sprite.Group()
    enemy_spawns_data = []
    map_total_width = initial_width * 2.8
    player_spawn_x = TILE_SIZE + 30
    player_spawn_y = initial_height - 120 - TILE_SIZE
    player_spawn = (player_spawn_x, player_spawn_y)
    main_ground_y_ref = initial_height - TILE_SIZE

    # Ledges
    platforms.add(Platform(TILE_SIZE, initial_height - 120, 150, 20, DARK_GREEN, platform_type="ledge"))
    platforms.add(Platform(TILE_SIZE + 260, initial_height - 180, 120, 20, DARK_GREEN, platform_type="ledge"))
    platforms.add(Platform(TILE_SIZE + 460, initial_height - 150, 100, 20, DARK_GREEN, platform_type="ledge"))
    platforms.add(Platform(TILE_SIZE + 660, initial_height - 200, 130, 20, DARK_GREEN, platform_type="ledge"))
    platforms.add(Platform(TILE_SIZE + 860, initial_height - 250, 100, 20, DARK_GREEN, platform_type="ledge"))
    platforms.add(Platform(TILE_SIZE + 1210, initial_height - 350, 150, 20, DARK_GREEN, platform_type="ledge"))
    platforms.add(Platform(TILE_SIZE + 1560, initial_height - 480, 200, 20, DARK_GREEN, platform_type="ledge"))

    # Structural Walls
    wall1_height = (main_ground_y_ref) - (initial_height - 400)
    platforms.add(Platform(TILE_SIZE + 1060, initial_height - 400, 30, wall1_height, GRAY, platform_type="wall"))
    wall2_height = (main_ground_y_ref) - (initial_height - 500)
    platforms.add(Platform(TILE_SIZE + 1410, initial_height - 500, 30, wall2_height, GRAY, platform_type="wall"))

    # Lava
    lava_y_surface = main_ground_y_ref
    hazards.add(Lava(TILE_SIZE, lava_y_surface, 1100 - TILE_SIZE, LAVA_PATCH_HEIGHT, ORANGE_RED))
    hazards.add(Lava(1130, lava_y_surface, 320, LAVA_PATCH_HEIGHT, ORANGE_RED))
    lava3_start_x = 1550
    lava3_width = (map_total_width - TILE_SIZE) - lava3_start_x
    if lava3_width > 0:
        hazards.add(Lava(lava3_start_x, lava_y_surface, lava3_width, LAVA_PATCH_HEIGHT, ORANGE_RED))

    all_content_sprites = list(platforms.sprites()) + list(hazards.sprites())
    level_min_y_abs, level_max_y_abs = _add_map_boundary_walls(platforms, map_total_width, all_content_sprites, initial_height, extra_sky_clearance=TILE_SIZE * 5)

    return platforms, ladders, hazards, enemy_spawns_data, player_spawn, \
           map_total_width, level_min_y_abs, level_max_y_abs, \
           main_ground_y_ref, 0

def load_map_cpu_extended(initial_width, initial_height):
    """
    Creates a larger level with CPU enemies, DEEP LAVA WELLS with fences,
    boundary walls, and colored ledges. Platform height adjusted.
    """
    platforms = pygame.sprite.Group()
    ladders = pygame.sprite.Group()
    hazards = pygame.sprite.Group()
    enemy_spawns_data = []
    map_total_width = initial_width * 3.5
    main_ground_y_ref = initial_height - TILE_SIZE
    main_ground_segment_height_ref = TILE_SIZE
    player_spawn = (TILE_SIZE * 2, main_ground_y_ref)
    gap_width_lava = TILE_SIZE * 4
    lava_collision_y_level = main_ground_y_ref + 1
    fence_y_pos = main_ground_y_ref - FENCE_HEIGHT

    # Ground Segments
    seg1_start_x = TILE_SIZE
    seg1_width = (initial_width * 0.7) - TILE_SIZE
    seg1_end_x = seg1_start_x + seg1_width
    platforms.add(Platform(seg1_start_x, main_ground_y_ref, seg1_width, main_ground_segment_height_ref, GRAY, platform_type="ground"))

    lava1_start_x = seg1_end_x
    lava1_width = gap_width_lava
    hazards.add(Lava(lava1_start_x, lava_collision_y_level, lava1_width, LAVA_PATCH_HEIGHT, ORANGE_RED))
    platforms.add(Platform(lava1_start_x - FENCE_WIDTH, fence_y_pos, FENCE_WIDTH, FENCE_HEIGHT, FENCE_COLOR, platform_type="fence"))
    platforms.add(Platform(lava1_start_x + lava1_width, fence_y_pos, FENCE_WIDTH, FENCE_HEIGHT, FENCE_COLOR, platform_type="fence"))

    seg2_start_x = lava1_start_x + lava1_width
    seg2_width = initial_width * 1.0
    seg2_end_x = seg2_start_x + seg2_width
    platforms.add(Platform(seg2_start_x, main_ground_y_ref, seg2_width, main_ground_segment_height_ref, GRAY, platform_type="ground"))

    lava2_start_x = seg2_end_x
    lava2_width = gap_width_lava * 0.8
    hazards.add(Lava(lava2_start_x, lava_collision_y_level, lava2_width, LAVA_PATCH_HEIGHT, ORANGE_RED))
    platforms.add(Platform(lava2_start_x - FENCE_WIDTH, fence_y_pos, FENCE_WIDTH, FENCE_HEIGHT, FENCE_COLOR, platform_type="fence"))
    platforms.add(Platform(lava2_start_x + lava2_width, fence_y_pos, FENCE_WIDTH, FENCE_HEIGHT, FENCE_COLOR, platform_type="fence"))

    seg3_start_x = lava2_start_x + lava2_width
    seg3_width = (map_total_width - TILE_SIZE) - seg3_start_x
    if seg3_width > 0:
        platforms.add(Platform(seg3_start_x, main_ground_y_ref, seg3_width, main_ground_segment_height_ref, GRAY, platform_type="ground"))

    # Floating Platforms (Ledges)
    plat1_x = TILE_SIZE + (initial_width * 0.3 - TILE_SIZE)
    plat1_x = max(seg1_start_x + TILE_SIZE, min(plat1_x, seg1_end_x - TILE_SIZE*7))
    platforms.add(Platform(plat1_x, main_ground_y_ref - TILE_SIZE * 1.8, TILE_SIZE * 6, TILE_SIZE * 0.5, DARK_GREEN, platform_type="ledge"))
    platforms.add(Platform(seg2_start_x + TILE_SIZE * 2, main_ground_y_ref - TILE_SIZE * 3, TILE_SIZE * 8, TILE_SIZE * 0.5, DARK_GREEN, platform_type="ledge"))
    platforms.add(Platform(seg3_start_x + TILE_SIZE * 4, main_ground_y_ref - TILE_SIZE * 5.5, TILE_SIZE * 7, TILE_SIZE * 0.5, DARK_GREEN, platform_type="ledge"))

    # Enemy Spawns
    spawn_y_on_ground = main_ground_y_ref - 1
    enemy1_x_pos = seg2_start_x + seg2_width * 0.5
    patrol_rect_enemy1 = pygame.Rect(
        seg2_start_x + TILE_SIZE, main_ground_y_ref - TILE_SIZE * 2,
        seg2_width - TILE_SIZE * 2, TILE_SIZE * 2
    )
    enemy_spawns_data.append({'pos': (enemy1_x_pos, spawn_y_on_ground), 'patrol': patrol_rect_enemy1})

    enemy2_platform_ref_x = seg2_start_x + TILE_SIZE * 2
    enemy2_platform = next((p for p in platforms if p.rect.left == enemy2_platform_ref_x and p.rect.width == TILE_SIZE * 8 and p.platform_type == "ledge"), None)
    if enemy2_platform:
        enemy2_x_pos = enemy2_platform.rect.centerx
        enemy2_y_pos = enemy2_platform.rect.top - 1
        enemy_spawns_data.append({'pos': (enemy2_x_pos, enemy2_y_pos), 'patrol': None})

    enemy3_x_pos = seg3_start_x + seg3_width * 0.3
    enemy_spawns_data.append({'pos': (enemy3_x_pos, spawn_y_on_ground), 'patrol': None})

    all_content_sprites = list(platforms.sprites()) + list(hazards.sprites())
    sky_clearance = TILE_SIZE * 10
    level_min_y_abs, level_max_y_abs = _add_map_boundary_walls(platforms, map_total_width, all_content_sprites, initial_height, extra_sky_clearance=sky_clearance)

    return platforms, ladders, hazards, enemy_spawns_data, player_spawn, \
           map_total_width, level_min_y_abs, level_max_y_abs, \
           main_ground_y_ref, main_ground_segment_height_ref

load_map_cpu = load_map_cpu_extended

# --- Test block for levels.py (if run directly) ---
if __name__ == '__main__':
    pygame.init()
    screen_width_test = 1000
    screen_height_test = 700
    test_screen = pygame.display.set_mode((screen_width_test, screen_height_test), pygame.RESIZABLE)

    test_platforms, test_ladders, test_hazards, test_enemy_spawns, test_player_spawn, \
    test_level_width, test_level_min_y, test_level_max_y, \
    test_main_ground_y, test_main_ground_h = \
        load_map_cpu_extended(screen_width_test, screen_height_test)
    pygame.display.set_caption("Level.py - Map Test (load_map_cpu_extended)")

    all_test_sprites = pygame.sprite.Group()
    all_test_sprites.add(test_platforms.sprites(), test_ladders.sprites(), test_hazards.sprites())

    if test_enemy_spawns:
        for spawn_info in test_enemy_spawns:
            spawn_pos = spawn_info['pos']
            enemy_placeholder = pygame.sprite.Sprite()
            enemy_placeholder.image = pygame.Surface((TILE_SIZE*0.5, TILE_SIZE*0.8))
            enemy_placeholder.image.fill(ORANGE_RED)
            enemy_placeholder.rect = enemy_placeholder.image.get_rect(midbottom=spawn_pos)
            all_test_sprites.add(enemy_placeholder)
            if spawn_info.get('patrol'):
                patrol_rect_vis = spawn_info['patrol'].copy()
                patrol_placeholder = pygame.sprite.Sprite()
                patrol_placeholder.image = pygame.Surface((patrol_rect_vis.width, patrol_rect_vis.height), pygame.SRCALPHA)
                patrol_placeholder.image.fill((255,0,255,50))
                pygame.draw.rect(patrol_placeholder.image, (255,0,255, 150), patrol_placeholder.image.get_rect(), 1)
                patrol_placeholder.rect = patrol_rect_vis
                all_test_sprites.add(patrol_placeholder)

    class TestDummyPlayer(pygame.sprite.Sprite):
        def __init__(self, x, y):
            super().__init__()
            self.image = pygame.Surface((TILE_SIZE * 0.75, TILE_SIZE))
            self.image.fill(DARK_GREEN)
            self.rect = self.image.get_rect(midbottom=(x,y))
            self.vel = pygame.math.Vector2(0,0)
            self.on_ground_flag = False
            self.gravity = C.PLAYER_GRAVITY
            self.jump_strength = C.PLAYER_JUMP_STRENGTH

        def update(self, platform_group_for_collision):
            self.vel.y += self.gravity
            if self.vel.y > C.TERMINAL_VELOCITY_Y: self.vel.y = C.TERMINAL_VELOCITY_Y
            pressed_keys = pygame.key.get_pressed()
            if pressed_keys[pygame.K_LEFT]: self.vel.x = -5
            elif pressed_keys[pygame.K_RIGHT]: self.vel.x = 5
            else: self.vel.x = 0
            if pressed_keys[pygame.K_UP] and self.on_ground_flag:
                self.vel.y = self.jump_strength
                self.on_ground_flag = False
            self.rect.x += self.vel.x
            self.test_collision_resolution('x', platform_group_for_collision)
            self.rect.y += self.vel.y
            self.on_ground_flag = False
            self.test_collision_resolution('y', platform_group_for_collision)

        def test_collision_resolution(self, direction, platform_group_to_collide_with):
            for plat in pygame.sprite.spritecollide(self, platform_group_to_collide_with, False):
                if plat.image.get_alpha() == 0 : continue
                if direction == 'x':
                    if self.vel.x > 0: self.rect.right = plat.rect.left
                    if self.vel.x < 0: self.rect.left = plat.rect.right
                    self.vel.x = 0
                if direction == 'y':
                    if self.vel.y > 0:
                        self.rect.bottom = plat.rect.top
                        self.on_ground_flag = True
                        self.vel.y = 0
                    if self.vel.y < 0:
                        self.rect.top = plat.rect.bottom
                        self.vel.y = 0

    dummy_test_player = TestDummyPlayer(test_player_spawn[0], test_player_spawn[1])
    all_test_sprites.add(dummy_test_player)
    camera_x_offset = 0
    camera_y_offset = 0
    test_game_running = True
    test_clock = pygame.time.Clock()
    effective_level_height_for_test = test_level_max_y - test_level_min_y

    while test_game_running:
        current_screen_width, current_screen_height = test_screen.get_size()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                test_game_running = False
            if event.type == pygame.VIDEORESIZE:
                 test_screen = pygame.display.set_mode((event.w, event.h), pygame.RESIZABLE)
        dummy_test_player.update(test_platforms)
        camera_x_offset = -dummy_test_player.rect.centerx + current_screen_width // 2
        camera_y_offset = -dummy_test_player.rect.centery + current_screen_height // 2
        camera_x_offset = min(0, camera_x_offset)
        if test_level_width > current_screen_width:
            camera_x_offset = max(-(test_level_width - current_screen_width), camera_x_offset)
        else:
            camera_x_offset = 0
        if effective_level_height_for_test <= current_screen_height:
            camera_y_offset = -(test_level_min_y + effective_level_height_for_test / 2 - current_screen_height / 2)
        else:
            camera_y_offset = min(-test_level_min_y, camera_y_offset)
            camera_y_offset = max(-(test_level_max_y - current_screen_height), camera_y_offset)
        test_screen.fill(BLACK)
        for sprite_to_draw in all_test_sprites:
            test_screen.blit(sprite_to_draw.image,
                             (sprite_to_draw.rect.x + camera_x_offset,
                              sprite_to_draw.rect.y + camera_y_offset))
        pygame.display.flip()
        test_clock.tick(60)
    pygame.quit()

########## START OF FILE: logger.py ##########

# logger.py
# version 1.0.0.3 (Added throttling for log_player_physics)
import logging
import os
import time # Added for robust timestamping

# --- GLOBAL LOGGING ENABLE/DISABLE SWITCH ---
LOGGING_ENABLED = False
# --- ---

# --- CONFIGURATION FOR DETAILED PHYSICS LOGS ---
ENABLE_DETAILED_PHYSICS_LOGS = True # This switch works with LOGGING_ENABLED
PHYSICS_LOG_INTERVAL_SEC = 1.0  # Log physics details at most once per this interval (per player)
_last_physics_log_time_by_player = {} # Stores last log timestamp for each player
# --- ---


LOG_FILENAME = "platformer_debug.log"
LOG_FILE_PATH = os.path.join(os.path.dirname(os.path.abspath(__file__)), LOG_FILENAME)

_platformer_logger_instance = logging.getLogger("PlatformerLogger")

if LOGGING_ENABLED:
    _platformer_logger_instance.setLevel(logging.DEBUG)

    if os.path.exists(LOG_FILE_PATH):
        try:
            os.remove(LOG_FILE_PATH)
        except OSError as e:
            import sys
            sys.stderr.write(f"Warning: Could not delete old log file {LOG_FILE_PATH}: {e}\n")

    for handler in list(_platformer_logger_instance.handlers):
        _platformer_logger_instance.removeHandler(handler)
        handler.close()

    try:
        _file_handler = logging.FileHandler(LOG_FILE_PATH, mode='w')
        _formatter = logging.Formatter("[%(asctime)s.%(msecs)03d] %(levelname)-7s %(name)s: %(message)s", datefmt="%Y-%m-%d %H:%M:%S")
        # Changed formatter to include levelname and logger name for better context
        # _formatter = logging.Formatter("[%(asctime)s.%(msecs)03d] %(message)s", datefmt="%Y-%m-%d %H:%M:%S")
        _file_handler.setFormatter(_formatter)
        _platformer_logger_instance.addHandler(_file_handler)
        _platformer_logger_instance.propagate = False

        # Optional console handler for seeing logs directly
        # _console_handler = logging.StreamHandler()
        # _console_handler.setFormatter(_formatter) # Use the same formatter
        # _console_handler.setLevel(logging.DEBUG) # Set level for console output
        # _platformer_logger_instance.addHandler(_console_handler)

        _platformer_logger_instance.info(f"Logger initialized. Logging enabled. Output to: {LOG_FILE_PATH}")

    except Exception as e:
        import sys
        sys.stderr.write(f"CRITICAL ERROR: Failed to initialize file logger at {LOG_FILE_PATH}: {e}\n")
        sys.stderr.write(f"CRITICAL ERROR: PlatformerLogger will not write to file, despite LOGGING_ENABLED=True.\n")
        for handler in list(_platformer_logger_instance.handlers):
            _platformer_logger_instance.removeHandler(handler)
            handler.close()
        _platformer_logger_instance.addHandler(logging.NullHandler())
        _platformer_logger_instance.propagate = False
else:
    for handler in list(_platformer_logger_instance.handlers):
        _platformer_logger_instance.removeHandler(handler)
        handler.close()
    _platformer_logger_instance.addHandler(logging.NullHandler())
    _platformer_logger_instance.setLevel(logging.CRITICAL + 1) # Effectively disable
    _platformer_logger_instance.propagate = False
    # print("INFO: PlatformerLogger is disabled by configuration.")


def log_player_physics(player, message_tag, extra_info=""):
    """Helper to log player physics details if detailed logging is enabled, with throttling."""
    if not LOGGING_ENABLED or not ENABLE_DETAILED_PHYSICS_LOGS:
        return

    try:
        # Determine a unique identifier for the player for throttling
        # Ensure player_id is a string or a consistently hashable type.
        # Using a prefix "player_" to avoid potential collisions if player_id could be an int like 0 or 1.
        player_throttle_id = f"player_{str(getattr(player, 'player_id', 'unknown'))}"
        current_time_sec = time.time()

        # --- Throttling Logic ---
        last_log_time = _last_physics_log_time_by_player.get(player_throttle_id, 0.0)
        if current_time_sec - last_log_time < PHYSICS_LOG_INTERVAL_SEC:
            return  # Throttled, do not log for this player yet

        # If not throttled, update the last log time for this player *before* formatting
        # to reduce chance of multiple logs if formatting is slow (unlikely but good practice).
        _last_physics_log_time_by_player[player_throttle_id] = current_time_sec
        # --- End Throttling Logic ---

        # Formatting logic (existing code)
        player_id_str_msg = str(getattr(player, 'player_id', 'P?')) # For the message content
        pos_x = getattr(player, 'pos', type('obj', (object,), {'x': float('nan')})).x
        pos_y = getattr(player, 'pos', type('obj', (object,), {'y': float('nan')})).y
        vel_x = getattr(player, 'vel', type('obj', (object,), {'x': float('nan')})).x
        vel_y = getattr(player, 'vel', type('obj', (object,), {'y': float('nan')})).y
        player_rect_str = str(getattr(player, 'rect', 'N/A'))
        player_on_ground = getattr(player, 'on_ground', 'N/A')
        player_state = getattr(player, 'state', 'N/A')
        player_acc_x = getattr(player, 'acc', type('obj', (object,), {'x': float('nan')})).x
        player_acc_y = getattr(player, 'acc', type('obj', (object,), {'y': float('nan')})).y
        player_wall_touch = getattr(player, 'touching_wall', 'N/A')

        log_msg_parts = [
            f"P{player_id_str_msg} PHYS: {message_tag: <18} | "
            f"Pos:({pos_x:6.2f},{pos_y:6.2f}) "
            f"Vel:({vel_x:5.2f},{vel_y:5.2f}) "
        ]

        if message_tag == "UPDATE_START":
             log_msg_parts.append(
                f"Acc:({player_acc_x:4.2f},{player_acc_y:4.2f}) "
                f"Rect:{player_rect_str} OnGround:{player_on_ground} State:{player_state}"
             )
        elif "PLAT_COLL_CHECK" in message_tag:
            player_r_str, plat_r_str, plat_t = "N/A", "N/A", "N/A"
            if isinstance(extra_info, tuple) and len(extra_info) == 3:
                player_r_str, plat_r_str, plat_t = str(extra_info[0]), str(extra_info[1]), str(extra_info[2])
            log_msg_parts.append(
                f"PlayerRect:{player_r_str} | PlatRect:{plat_r_str} | PlatType:{plat_t}"
            )
        elif "PLAT_COLL_RESOLVED" in message_tag:
            snap_r_str, orig_r_str, n_pos_str, n_vel_axis_val_str, n_og_str, axis_char = "N/A", "N/A", "N/A", "N/A", "N/A", "?"
            if isinstance(extra_info, tuple) and len(extra_info) == 6:
                snap_r_str, orig_r_str = str(extra_info[0]), str(extra_info[1])
                n_pos_x, n_pos_y = extra_info[2]
                n_pos_str = f"({n_pos_x:.2f},{n_pos_y:.2f})"
                n_vel_axis_val_str = f"{extra_info[3]:.2f}"
                n_og_str = str(extra_info[4])
                axis_char = str(extra_info[5])
            log_msg_parts.append(
                f"SnappedRect:{snap_r_str} (from {orig_r_str}) | "
                f"NewPos:{n_pos_str} | Vel.{axis_char}:{n_vel_axis_val_str} OnGround:{n_og_str}"
            )
        elif "CHAR_COLL_CHECK" in message_tag:
            player_r_str, other_r_str, other_id_str = "N/A", "N/A", "N/A"
            if isinstance(extra_info, tuple) and len(extra_info) == 3:
                player_r_str, other_r_str, other_id_str = str(extra_info[0]), str(extra_info[1]), str(extra_info[2])
            log_msg_parts.append(
                f"PlayerRect:{player_r_str} | OtherRect:{other_r_str} | OtherID:{other_id_str}"
            )
        elif "CHAR_COLL_RESOLVED" in message_tag:
            snap_r_str, orig_r_str, n_pos_str, n_vel_axis_val_str, axis_char = "N/A", "N/A", "N/A", "N/A", "?"
            if isinstance(extra_info, tuple) and len(extra_info) == 5:
                snap_r_str, orig_r_str = str(extra_info[0]), str(extra_info[1])
                n_pos_x, n_pos_y = extra_info[2]
                n_pos_str = f"({n_pos_x:.2f},{n_pos_y:.2f})"
                n_vel_axis_val_str = f"{extra_info[3]:.2f}"
                axis_char = str(extra_info[4])
            log_msg_parts.append(
                f"SnappedRect:{snap_r_str} (from {orig_r_str}) | "
                f"NewPos:{n_pos_str} | Vel.{axis_char}:{n_vel_axis_val_str}"
            )
        elif "PLAT_COLL_DONE" in message_tag:
            axis_char = "x" if "X_" in message_tag else "y"
            pos_axis_val = pos_x if axis_char == 'x' else pos_y
            vel_axis_val = vel_x if axis_char == 'x' else vel_y
            rect_midbottom_str = str(player.rect.midbottom) if hasattr(player,'rect') and hasattr(player.rect, 'midbottom') else 'N/A'
            if axis_char == "x": log_msg_parts.append(f"Pos.{axis_char}:{pos_axis_val:6.2f} | Rect.midbottom:{rect_midbottom_str} | Vel.{axis_char}:{vel_axis_val:5.2f} WallTouch:{player_wall_touch}")
            else: log_msg_parts.append(f"Pos.{axis_char}:{pos_axis_val:6.2f} | Rect.midbottom:{rect_midbottom_str} | Vel.{axis_char}:{vel_axis_val:5.2f} OnGround:{player_on_ground}")
        elif "FINAL_POS_SYNC" in message_tag: log_msg_parts.append(f"Pos:({pos_x:6.2f},{pos_y:6.2f}) | Rect.midbottom: {player_rect_str}") # player_rect_str is already player.rect
        elif "UPDATE_END" in message_tag: log_msg_parts.append(f"Pos:({pos_x:6.2f},{pos_y:6.2f}) Vel:({vel_x:5.2f},{vel_y:5.2f}) OnGround:{player_on_ground} State:{player_state}")
        
        if isinstance(extra_info, str) and extra_info and not any(kw in message_tag for kw in ["PLAT_COLL_CHECK", "PLAT_COLL_RESOLVED", "CHAR_COLL_CHECK", "CHAR_COLL_RESOLVED", "PLAT_COLL_DONE", "FINAL_POS_SYNC", "UPDATE_END", "UPDATE_START"]):
            log_msg_parts.append(f" {extra_info}")
            
        _platformer_logger_instance.debug("".join(log_msg_parts))
    except Exception as e:
        # Get player_id again for error message, or use a default if it fails early
        err_player_id = 'unknown_player'
        try:
            err_player_id = f"P{str(getattr(player, 'player_id', '?'))}"
        except: #pylint: disable=bare-except
            pass # Keep err_player_id as 'unknown_player'
        _platformer_logger_instance.error(f"Error in log_player_physics for {err_player_id} tag '{message_tag}': {e}", exc_info=False) # exc_info=False to prevent huge tracebacks for simple formatting errors. Set to True if needed.

logger = _platformer_logger_instance

# Expose logging functions directly
def debug(message, *args, **kwargs):
    if LOGGING_ENABLED:
        _platformer_logger_instance.debug(message, *args, **kwargs)

def info(message, *args, **kwargs):
    if LOGGING_ENABLED:
        _platformer_logger_instance.info(message, *args, **kwargs)

def warning(message, *args, **kwargs):
    if LOGGING_ENABLED:
        _platformer_logger_instance.warning(message, *args, **kwargs)

def error(message, *args, **kwargs):
    if LOGGING_ENABLED:
        _platformer_logger_instance.error(message, *args, **kwargs)

def critical(message, *args, **kwargs):
    if LOGGING_ENABLED:
        _platformer_logger_instance.critical(message, *args, **kwargs)

if __name__ == "__main__":
    if LOGGING_ENABLED:
        info("This is an info message from logger.py direct run.")
        debug("This is a debug message from logger.py direct run.")
        
        # Mock player for testing log_player_physics
        class MockPlayer:
            def __init__(self, player_id):
                self.player_id = player_id
                self.pos = type('obj', (object,), {'x': 10.0, 'y': 20.0})
                self.vel = type('obj', (object,), {'x': 1.0, 'y': -1.0})
                self.rect = type('obj', (object,), {'midbottom': (15,30)}) # Mocking rect enough for one case
                self.on_ground = True
                self.state = "idle"
                self.acc = type('obj', (object,), {'x': 0.0, 'y': 0.0})
                self.touching_wall = 0

        player1 = MockPlayer(1)
        player2 = MockPlayer("Alpha")

        print(f"Testing throttled physics logs (interval: {PHYSICS_LOG_INTERVAL_SEC}s). Output may be sparse.")
        for i in range(5): # Try to log 5 times in quick succession
            log_player_physics(player1, "UPDATE_START", f"Loop {i}")
            log_player_physics(player2, "UPDATE_START", f"Loop {i}")
            if i < 4: # Don't sleep on the last iteration
                time.sleep(0.3) # Sleep less than interval to test throttling

        time.sleep(PHYSICS_LOG_INTERVAL_SEC + 0.1) # Sleep longer than interval
        log_player_physics(player1, "UPDATE_END", "After long sleep")
        log_player_physics(player2, "UPDATE_END", "After long sleep")

        print(f"Test logs (if enabled) written to {LOG_FILE_PATH}")
    else:
        print("Logging is disabled. No log file generated from this direct run.")

########## START OF FILE: main.py ##########

# main.py
# -*- coding: utf-8 -*-
## version 1.0.0.8 (Added Editor Launch Support)
import sys
import os
import pygame
import traceback 
from typing import Dict, Optional, Any

# --- Logger Setup ---
try:
    import logger 
    logger.info("MAIN: Application starting.") 
except ImportError:
    print("FATAL MAIN: logger.py not found. Exiting.")
    sys.exit(1)
except Exception as e:
    print(f"FATAL MAIN: Error importing logger: {e}")
    sys.exit(1)

# --- Pyperclip Check ---
PYPERCLIP_AVAILABLE_MAIN = False
try:
    import pyperclip
    PYPERCLIP_AVAILABLE_MAIN = True
    logger.info("MAIN: Pyperclip library found and imported successfully.")
except ImportError:
    logger.warning("MAIN: Pyperclip library not found (pip install pyperclip). Paste in UI may be limited.")

# --- Platformer Game Module Imports ---
try:
    import constants as C 
    from camera import Camera
    from items import Chest
    from game_setup import initialize_game_elements 
    from server_logic import ServerState, run_server_mode
    from client_logic import ClientState, run_client_mode
    from couch_play_logic import run_couch_play_mode
    import game_ui 

    logger.info("MAIN: Platformer modules imported successfully.")
except ImportError as e:
    logger.critical(f"FATAL MAIN: Failed to import a required platformer module: {e}")
    traceback.print_exc()
    sys.exit(1)
except Exception as e:
    logger.critical(f"FATAL MAIN: An unexpected error occurred during platformer module imports: {e}")
    traceback.print_exc()
    sys.exit(1)

# --- Editor Module Import (Attempt) ---
EDITOR_AVAILABLE = False
editor_module = None
try:
    # Assuming 'editor' is a subfolder in your project root (where main.py is)
    # and it contains an 'editor.py' file.
    from editor import editor as editor_module_imported 
    editor_module = editor_module_imported # Assign to the variable we'll use
    EDITOR_AVAILABLE = True
    logger.info("MAIN: Level Editor module found and imported successfully.")
except ImportError:
    logger.warning("MAIN: Level Editor module ('editor/editor.py') not found or failed to import. Editor functionality will be disabled.")
    logger.warning(f"MAIN: Import error details: {traceback.format_exc(limit=1)}")
except Exception as e:
    logger.error(f"MAIN: An unexpected error occurred during editor module import: {e}")
    traceback.print_exc()


# --- Pygame Initialization ---
os.environ['SDL_VIDEO_WINDOW_POS'] = '0,0' 
pygame.init() 
pygame.font.init() 

class AppStatus:
    def __init__(self):
        self.app_running = True

def ensure_maps_directory_exists():
    """Ensures the MAPS_DIR exists, creating it if necessary."""
    maps_dir = C.MAPS_DIR
    if not os.path.exists(maps_dir):
        try:
            os.makedirs(maps_dir)
            logger.info(f"MAIN: Created maps directory at '{maps_dir}'")
        except OSError as e:
            logger.error(f"MAIN Error: Could not create maps directory '{maps_dir}': {e}")
            return False
    return True


# --- Display Setup ---
try:
    display_info = pygame.display.Info()
    monitor_width = display_info.current_w
    monitor_height = display_info.current_h
    initial_width = max(800, min(1600, monitor_width * 3 // 4))
    initial_height = max(600, min(900, monitor_height * 3 // 4))
    WIDTH_MAIN, HEIGHT_MAIN = initial_width, initial_height 
    screen_flags = pygame.RESIZABLE | pygame.DOUBLEBUF
    screen = pygame.display.set_mode((WIDTH_MAIN, HEIGHT_MAIN), screen_flags)
    pygame.display.set_caption("Platformer Adventure LAN")
    logger.info(f"MAIN: Initial window dimensions: {WIDTH_MAIN}x{HEIGHT_MAIN}")
except Exception as e:
    logger.critical(f"FATAL MAIN: Error setting up Pygame display: {e}")
    pygame.quit()
    sys.exit(1)

# --- Pygame Scrap Initialization ---
SCRAP_INITIALIZED_MAIN = False
try:
    if pygame.display.get_init(): 
        pygame.scrap.init() 
        SCRAP_INITIALIZED_MAIN = pygame.scrap.get_init()
        if SCRAP_INITIALIZED_MAIN: logger.info("MAIN: pygame.scrap clipboard module initialized successfully.")
        else: logger.warning("MAIN Warning: pygame.scrap.init() called but pygame.scrap.get_init() returned False.")
    else: logger.warning("MAIN Warning: Display not initialized before pygame.scrap.init() attempt.")
except AttributeError: logger.warning("MAIN Warning: pygame.scrap module not found or available on this system.")
except pygame.error as e: logger.warning(f"MAIN Warning: pygame.scrap module could not be initialized: {e}")
except Exception as e: logger.warning(f"MAIN Warning: An unexpected error occurred during pygame.scrap init: {e}")


_TILE_SIZE_DEFAULT = 40 
_LIGHT_BLUE_DEFAULT = (173, 216, 230)
game_elements: Dict[str, Any] = {
    "player1": None, "player2": None, "camera": None, "current_chest": None, "enemy_list": [],
    "platform_sprites": pygame.sprite.Group(), "ladder_sprites": pygame.sprite.Group(),
    "hazard_sprites": pygame.sprite.Group(), "enemy_sprites": pygame.sprite.Group(),
    "collectible_sprites": pygame.sprite.Group(), "projectile_sprites": pygame.sprite.Group(),
    "all_sprites": pygame.sprite.Group(), "level_pixel_width": WIDTH_MAIN, 
    "level_min_y_absolute": 0, "level_max_y_absolute": HEIGHT_MAIN,
    "ground_level_y": HEIGHT_MAIN - getattr(C, 'TILE_SIZE', _TILE_SIZE_DEFAULT),
    "ground_platform_height": getattr(C, 'TILE_SIZE', _TILE_SIZE_DEFAULT),
    "player1_spawn_pos": (100, HEIGHT_MAIN - (getattr(C, 'TILE_SIZE', _TILE_SIZE_DEFAULT) * 2)),
    "player2_spawn_pos": (150, HEIGHT_MAIN - (getattr(C, 'TILE_SIZE', _TILE_SIZE_DEFAULT) * 2)),
    "enemy_spawns_data_cache": [], "level_background_color": getattr(C, 'LIGHT_BLUE', _LIGHT_BLUE_DEFAULT),
    "loaded_map_name": None 
}

if __name__ == "__main__":
    logger.info("MAIN: Starting __main__ execution block.")
    main_clock = pygame.time.Clock()
    app_status = AppStatus()

    if not ensure_maps_directory_exists(): 
        logger.critical("MAIN: Failed to ensure maps directory exists. Game may not function correctly for map loading/downloading or editor.")
        # app_status.app_running = False # Decide if this is fatal

    fonts: Dict[str, Optional[pygame.font.Font]] = {"small": None, "medium": None, "large": None, "debug": None}
    try:
        fonts["small"] = pygame.font.Font(None, 28)
        fonts["medium"] = pygame.font.Font(None, 36)
        fonts["large"] = pygame.font.Font(None, 72)
        fonts["debug"] = pygame.font.Font(None, 20)
        if any(f is None for f in fonts.values()):
            raise pygame.error("One or more default fonts failed to load after init.")
        logger.info("MAIN: Fonts loaded successfully.")
    except pygame.error as e:
        logger.critical(f"FATAL MAIN: Font loading error: {e}. Ensure Pygame font module is working.")
        app_status.app_running = False 
    except Exception as e:
        logger.critical(f"FATAL MAIN: Unexpected error during font loading: {e}")
        app_status.app_running = False

    while app_status.app_running:
        current_screen_width, current_screen_height = screen.get_size()
        pygame.display.set_caption("Platformer Adventure - Main Menu")
        
        logger.info("\nMAIN: Showing main menu...") 
        menu_choice = game_ui.show_main_menu(screen, main_clock, fonts, app_status)
        logger.info(f"MAIN: Main menu choice: '{menu_choice}'")
        
        if not app_status.app_running or menu_choice == "quit":
            app_status.app_running = False; break 

        # --- Handle Editor Choice ---
        if menu_choice == "editor":
            if EDITOR_AVAILABLE and editor_module and hasattr(editor_module, 'run_editor_loop'):
                logger.info("MAIN: Launching Level Editor...")
                try:
                    # Call the editor's main function. Adjust if its signature is different.
                    # It's good practice for the editor to manage its own Pygame event loop.
                    # The app_status object is passed so the editor can signal a quit.
                    # C.MAPS_DIR is passed for the editor to know where to save/load maps.
                    editor_module.run_editor_loop(screen, main_clock, fonts, app_status, C.MAPS_DIR)
                    logger.info("MAIN: Returned from Level Editor.")
                except Exception as e:
                    logger.error(f"MAIN: Error running Level Editor: {e}")
                    traceback.print_exc()
                    # Display an error message on screen
                    screen.fill(getattr(C, 'BLACK', (0,0,0)))
                    if fonts.get("medium"):
                        err_surf = fonts["medium"].render("Error launching editor. Check logs.", True, getattr(C, 'RED', (255,0,0)))
                        screen.blit(err_surf, err_surf.get_rect(center=(current_screen_width//2, current_screen_height//2)))
                    pygame.display.flip()
                    pygame.time.wait(3000)
                # After editor closes (or fails), return to the main menu
                pygame.display.set_caption("Platformer Adventure - Main Menu") # Reset caption
                # Ensure Pygame key repeat is reset if the editor changed it
                pygame.key.set_repeat(0, 0) 
                continue # Go back to show_main_menu
            else:
                logger.warning("MAIN: Editor button clicked, but editor module is not available.")
                screen.fill(getattr(C, 'BLACK', (0,0,0)))
                if fonts.get("medium"):
                    msg_surf = fonts["medium"].render("Editor not available. See logs.", True, getattr(C, 'YELLOW', (255,255,0)))
                    screen.blit(msg_surf, msg_surf.get_rect(center=(current_screen_width//2, current_screen_height//2)))
                pygame.display.flip()
                pygame.time.wait(2500)
                continue # Go back to show_main_menu


        # --- Game Mode Logic (Host, Join, Couch Play) ---
        map_to_load_for_game: Optional[str] = None 
        if menu_choice in ["couch_play", "host"]:
            logger.info(f"MAIN: Mode '{menu_choice}' requires map selection. Opening map dialog...")
            map_to_load_for_game = game_ui.select_map_dialog(screen, main_clock, fonts, app_status)
            if not app_status.app_running: logger.info("MAIN: App quit during map selection."); break 
            if map_to_load_for_game is None:
                logger.info("MAIN: Map selection cancelled/no maps. Returning to main menu."); continue 
            logger.info(f"MAIN: Map selected for '{menu_choice}': '{map_to_load_for_game}'")
        
        initial_map_name_for_setup = map_to_load_for_game if menu_choice in ["host", "couch_play"] else None

        logger.info(f"MAIN: Initializing game elements for mode '{menu_choice}' with map '{initial_map_name_for_setup if initial_map_name_for_setup else 'To be determined by server (for client)'}'...")
        
        # Ensure game elements are reset or cleared before initializing for a new game mode
        # This can be done within initialize_game_elements or here by re-creating sprite groups etc.
        # For now, assuming initialize_game_elements handles this.
        
        initialized_elements = initialize_game_elements( 
            current_screen_width, current_screen_height, 
            for_game_mode=menu_choice,
            existing_sprites_groups={ 
                "all_sprites": pygame.sprite.Group(), # Fresh groups for new game instance
                "projectile_sprites": pygame.sprite.Group(),
                "player1": None, "player2": None,
                "current_chest": None
            },
            map_module_name=initial_map_name_for_setup 
        )

        if initialized_elements is None:
            logger.error(f"MAIN Error: Failed to initialize game elements for mode '{menu_choice}' (Map: '{initial_map_name_for_setup}'). Returning to menu.")
            screen.fill(getattr(C, 'BLACK', (0,0,0))) 
            if fonts.get("medium"):
                err_msg_surf = fonts["medium"].render(f"Error starting {menu_choice} mode.", True, getattr(C, 'RED', (255,0,0)))
                screen.blit(err_msg_surf, err_msg_surf.get_rect(center=(current_screen_width//2, current_screen_height//2)))
            pygame.display.flip(); pygame.time.wait(3000); continue

        game_elements.update(initialized_elements) # Update main game_elements dict
        
        if game_elements.get("camera"):
            cam_instance = game_elements["camera"]
            if hasattr(cam_instance, "set_screen_dimensions"):
                 cam_instance.set_screen_dimensions(current_screen_width, current_screen_height)
            else: 
                 cam_instance.screen_width, cam_instance.screen_height = current_screen_width, current_screen_height
                 if hasattr(cam_instance, 'camera_rect'):
                    cam_instance.camera_rect.width, cam_instance.camera_rect.height = current_screen_width, current_screen_height
            logger.info(f"MAIN: Camera screen dimensions updated to {current_screen_width}x{current_screen_height}")

        logger.info(f"MAIN: Launching game mode: '{menu_choice}'")
        if menu_choice == "host":
            server_state = ServerState()
            server_state.app_running = app_status.app_running 
            server_state.current_map_name = game_elements.get("loaded_map_name") 
            run_server_mode(screen, main_clock, fonts, game_elements, server_state)
            app_status.app_running = server_state.app_running
        elif menu_choice == "join_lan":
            client_state = ClientState(); client_state.app_running = app_status.app_running
            run_client_mode(screen, main_clock, fonts, game_elements, client_state, target_ip_port_str=None) 
            app_status.app_running = client_state.app_running
        elif menu_choice == "join_ip":
            logger.info("MAIN: Requesting IP input for 'join_ip' mode...")
            target_ip_input = game_ui.get_server_ip_input_dialog(screen, main_clock, fonts, app_status, default_input_text="127.0.0.1:5555")
            logger.info(f"MAIN: IP input dialog returned: '{target_ip_input}'")
            if target_ip_input and app_status.app_running: 
                client_state = ClientState(); client_state.app_running = app_status.app_running
                run_client_mode(screen, main_clock, fonts, game_elements, client_state, target_ip_port_str=target_ip_input) 
                app_status.app_running = client_state.app_running
            elif not app_status.app_running: logger.info("MAIN: IP input cancelled or app quit during dialog.")
            else: logger.info("MAIN: No IP entered. Returning to main menu.")
        elif menu_choice == "couch_play":
            run_couch_play_mode(screen, main_clock, fonts, game_elements, app_status) 
        
        logger.info(f"MAIN: Returned from game mode '{menu_choice}'. App running: {app_status.app_running}")
        # Reset key repeat after game modes, as some might enable it (e.g., text input)
        pygame.key.set_repeat(0, 0)

    logger.info("MAIN: Exiting application loop gracefully.")
    pygame.quit()
    if SCRAP_INITIALIZED_MAIN and pygame.scrap.get_init(): # Check again before quitting scrap
        try: 
            pygame.scrap.quit()
            logger.info("MAIN: pygame.scrap quit successfully.")
        except Exception as e: 
            logger.warning(f"MAIN Warning: Error during pygame.scrap.quit(): {e}")
    logger.info("MAIN: Application terminated.")
    sys.exit(0)

########## START OF FILE: maps\1.py ##########

# Level: 1
# Generated by Platformer Level Editor
import pygame
from tiles import Platform, Ladder, Lava 
import constants as C

LEVEL_SPECIFIC_BACKGROUND_COLOR = (75, 0, 130)

def load_map_1(initial_screen_width, initial_screen_height):
    """
    Loads the '1' level.
    """
    print(f"Loading map: load_map_1...")
    platforms = pygame.sprite.Group()
    ladders = pygame.sprite.Group() 
    hazards = pygame.sprite.Group()
    enemy_spawns_data = []
    collectible_spawns_data = []

    player1_spawn = (89, 757)

    # --- Placed Objects ---
    platforms.add(Platform(0, 0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 40, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 40, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 80, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 120, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 160, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 200, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 240, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 280, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 320, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 160, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 120, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 80, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 200, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 240, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 280, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 320, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 360, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 360, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 400, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 440, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 480, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 400, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 440, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 520, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 560, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 600, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 480, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 520, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 640, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 680, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 600, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 560, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 640, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 680, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 720, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 720, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 760, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 760, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(80, 760, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(120, 760, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(160, 760, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(200, 760, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(240, 760, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(280, 760, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(320, 760, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(360, 760, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(400, 760, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(440, 760, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(480, 760, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1000, 760, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1040, 760, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1080, 760, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1120, 760, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1160, 760, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1160, 720, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1160, 680, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1160, 640, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1160, 600, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1160, 560, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1160, 520, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1160, 480, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1160, 440, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1160, 400, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1160, 360, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1160, 320, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1160, 280, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1160, 240, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1160, 200, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1160, 160, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1160, 120, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1160, 80, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1120, 720, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1120, 680, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1120, 640, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1120, 600, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1120, 560, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1120, 520, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1120, 440, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1120, 480, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1120, 400, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1120, 360, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1120, 320, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1120, 280, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1120, 240, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1120, 200, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1120, 160, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1120, 120, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1120, 80, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1120, 40, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1120, 0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1160, 0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1160, 40, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(320, 480, 40, 10, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(360, 480, 40, 10, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(400, 480, 40, 10, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(440, 480, 40, 10, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(480, 480, 40, 10, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(520, 480, 40, 10, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(200, 360, 40, 10, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(240, 360, 40, 10, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(640, 600, 40, 10, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(680, 600, 40, 10, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(720, 600, 40, 10, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(760, 600, 40, 10, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(800, 600, 40, 10, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(840, 600, 40, 10, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(760, 400, 40, 10, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(800, 400, 40, 10, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(840, 400, 40, 10, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(880, 400, 40, 10, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(920, 400, 40, 10, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(440, 240, 40, 10, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(480, 240, 40, 10, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(520, 240, 40, 10, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(560, 240, 40, 10, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(600, 240, 40, 10, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(240, 320, 40, 10, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(360, 440, 40, 10, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(560, 480, 40, 10, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(600, 480, 40, 10, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(640, 480, 40, 10, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(680, 480, 40, 10, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(720, 480, 40, 10, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(720, 440, 40, 10, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(720, 400, 40, 10, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(920, 360, 40, 10, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(720, 360, 40, 10, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(480, 720, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1000, 720, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(80, 620.0, 40, 20, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(120, 620.0, 40, 20, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(160, 620.0, 40, 20, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(200, 620.0, 40, 20, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(240, 620.0, 40, 20, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(280, 620.0, 40, 20, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(80, 540.0, 40, 20, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(80, 420.0, 40, 20, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(1080.0, 620, 40, 20, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(1080.0, 500, 40, 20, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(920.0, 500, 40, 20, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(880.0, 500, 40, 20, (0,100,0), platform_type='ledge'))
    # No ladders placed.
    hazards.add(Lava(520, 760, 40, 40, (255,69,0)))
    hazards.add(Lava(560, 760, 40, 40, (255,69,0)))
    hazards.add(Lava(600, 760, 40, 40, (255,69,0)))
    hazards.add(Lava(640, 760, 40, 40, (255,69,0)))
    hazards.add(Lava(680, 760, 40, 40, (255,69,0)))
    hazards.add(Lava(720, 760, 40, 40, (255,69,0)))
    hazards.add(Lava(760, 760, 40, 40, (255,69,0)))
    hazards.add(Lava(800, 760, 40, 40, (255,69,0)))
    hazards.add(Lava(840, 760, 40, 40, (255,69,0)))
    hazards.add(Lava(880, 760, 40, 40, (255,69,0)))
    hazards.add(Lava(920, 760, 40, 40, (255,69,0)))
    hazards.add(Lava(960, 760, 40, 40, (255,69,0)))
    enemy_spawns_data.append({'pos': (769, 397), 'patrol': None, 'enemy_color_id': 'cyan'})
    enemy_spawns_data.append({'pos': (409, 477), 'patrol': None, 'enemy_color_id': 'pink'})
    enemy_spawns_data.append({'pos': (689, 597), 'patrol': None, 'enemy_color_id': 'red'})
    collectible_spawns_data.append({'type': 'chest', 'pos': (466, 239)})

    # --- Level Dimensions for Game Camera & Boundaries ---
    map_total_width_pixels = 1360
    level_min_y_absolute = -80
    level_max_y_absolute = 880
    main_ground_y_reference = 800
    main_ground_height_reference = 40

    _boundary_thickness = C.TILE_SIZE * 2
    _boundary_wall_height = level_max_y_absolute - level_min_y_absolute + (2 * _boundary_thickness)
    _boundary_color = getattr(C, 'DARK_GRAY', (50,50,50)) 

    platforms.add(Platform(0, level_min_y_absolute - _boundary_thickness, map_total_width_pixels, _boundary_thickness, _boundary_color, platform_type="boundary_wall_top"))
    platforms.add(Platform(0, level_max_y_absolute, map_total_width_pixels, _boundary_thickness, _boundary_color, platform_type="boundary_wall_bottom"))
    platforms.add(Platform(-_boundary_thickness, level_min_y_absolute - _boundary_thickness, _boundary_thickness, _boundary_wall_height, _boundary_color, platform_type="boundary_wall_left"))
    platforms.add(Platform(map_total_width_pixels, level_min_y_absolute - _boundary_thickness, _boundary_thickness, _boundary_wall_height, _boundary_color, platform_type="boundary_wall_right"))

    print(f"Map 'load_map_1' loaded with: {len(platforms)} platforms, {len(ladders)} ladders, {len(hazards)} hazards.")
    return (platforms, ladders, hazards, enemy_spawns_data, collectible_spawns_data,
            player1_spawn,
            map_total_width_pixels, level_min_y_absolute, level_max_y_absolute,
            main_ground_y_reference, main_ground_height_reference,
            LEVEL_SPECIFIC_BACKGROUND_COLOR)


########## START OF FILE: maps\2.py ##########

# Level: 2
# Generated by Platformer Level Editor
import pygame
from tiles import Platform, Ladder, Lava 
import constants as C

LEVEL_SPECIFIC_BACKGROUND_COLOR = (173, 216, 230)

def load_map_2(initial_screen_width, initial_screen_height):
    """
    Loads the '2' level.
    """
    print(f"Loading map: load_map_2...")
    platforms = pygame.sprite.Group()
    ladders = pygame.sprite.Group() 
    hazards = pygame.sprite.Group()
    enemy_spawns_data = []
    collectible_spawns_data = []

    player1_spawn = (89.0, 1917.0)

    # --- Placed Objects ---
    platforms.add(Platform(0, 0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 40, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 80, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 120, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 160, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 200, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 240, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 280, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 320, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 360, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 400, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 360, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 320, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 280, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 240, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(80, 0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 40, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(80, 40, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 80, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(80, 80, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 120, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(80, 120, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 160, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(80, 160, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 200, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(80, 200, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(80, 240, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(80, 280, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(80, 320, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(80, 360, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 400, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(80, 400, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 440, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(80, 440, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 480, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(80, 480, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 520, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(80, 520, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 560, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(80, 560, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 520, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 560, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 480, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 440, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 600, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 600, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 640, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 640, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 680, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 680, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 720.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 720.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 760.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 760.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 800.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 800.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 840.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 840.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(80, 800.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(80, 840.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 880.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(80, 880.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 920.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(80, 920.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 960.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(80, 960.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 880.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 920.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 960.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 1000.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 1000.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(80, 1000.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 1040.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(80, 1040.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 1080.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(80, 1080.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 1120.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(80, 1120.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 1080.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 1120.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 1040.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 1160.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 1160.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 1200.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 1200.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 1240.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 1240.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 1280.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(80, 1280.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 1320.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(80, 1320.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 1280.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 1320.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 1360.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 1360.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 1400.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 1400.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 1440.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 1440.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 1480.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 1480.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 1520.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 1520.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 1560.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 1560.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 1600.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 1600.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 1640.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 1640.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 1680.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 1680.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 1720.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 1720.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 1760.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 1760.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 1800.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 1800.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 1840.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 1840.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 1880.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 1880.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 1920.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 1920.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 1960.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 1960.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(80, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(120, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(80, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(120, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(160, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(160, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(200, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(200, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(240, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(240, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(280, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(280, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(320, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(320, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(360, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(360, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(160, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(200, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(120, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(80, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(240, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(280, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(320, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(400, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(400, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(440, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(440, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(480, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(480, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(520, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(520, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(560, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(560, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(600, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(600, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(640, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(640, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(680, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(680, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(680, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(720, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(720, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(760, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(760, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(800, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(800, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(840, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(840, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(880, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(920, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(880, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(920, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(960, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1000, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1040, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(960.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1000.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(960.0, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1000.0, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1040.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1040.0, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1080.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1120.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1080.0, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1120.0, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1080.0, 1920.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1120.0, 1920.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1160.0, 1920.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1160.0, 1960.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1200.0, 1920.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1200.0, 1960.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1240.0, 1920.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1240.0, 1960.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1280.0, 1920.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1280.0, 1960.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1320.0, 1920.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1360.0, 1920.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1320.0, 1960.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1360.0, 1960.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1280.0, 2000.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1320.0, 2000.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1400.0, 1960.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1440.0, 1960.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1400.0, 2000.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1440.0, 2000.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1480.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1520.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1480.0, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1520.0, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1560.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1560.0, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1600.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1600.0, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1640.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1640.0, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1680.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1680.0, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1720.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1720.0, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1680.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1720.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1640.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1520.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1560.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1400.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1440.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1480.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1600.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1760.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1760.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1840.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1880.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1840.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1880.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2000.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2040.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2000.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2040.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2080.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2080.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1960.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1960.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1920.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1920.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1760.0, 1880, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1800.0, 1880, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1800.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1800.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2120.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2160.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2120.0, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2160.0, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2080.0, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2160.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2200.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2200.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2280.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2320.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2280.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2320.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2360.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2360.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2240.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2240.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2120.0, 1880, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2160.0, 1880, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2120.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2200.0, 1880, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2400.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2400.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2440.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2440.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2480.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2520.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2480.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2520.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2560.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2600.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2560.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2600.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2680.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2720.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2680.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2720.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2760.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2760.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2800.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2840.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2800.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2840.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2800.0, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2840.0, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2640.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2600.0, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2640.0, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2520.0, 1880, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2560.0, 1880, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2600.0, 1880, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2640.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2760.0, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2880.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2920.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2880.0, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2920.0, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2960.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(2960.0, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3000.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3040.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3000.0, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3040.0, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3040.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3080.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3080.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3120.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3120.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3160.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3160.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3200.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3200.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3240.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3240.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3280.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3280.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3320.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3320.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3360.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3400.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3360.0, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3400.0, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3400.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3440.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3440.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3480.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3440.0, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3480.0, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3520.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3520.0, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3560.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3560.0, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3600.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3600.0, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3600.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3640.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3640.0, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3680.0, 1920.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3680.0, 1960.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3560.0, 1880.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3600.0, 1880.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3560.0, 1920.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3720.0, 1920.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3720.0, 1960.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3760.0, 1920.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3760.0, 1960.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3800.0, 1880.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3840.0, 1880.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3800.0, 1920.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3840.0, 1920.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3840.0, 1840.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3880.0, 1840.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3880.0, 1880.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3920.0, 1840.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3920.0, 1880.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3880, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3920, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3880, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3920, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3840, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3800, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3760, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3800, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(4000, 1960, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(4000, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3920.0, 2000, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(4000.0, 1920, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960, 1880.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(4000, 1880.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960, 1840.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(4000, 1840.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960, 1800.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(4000, 1800.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960, 1760.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(4000, 1760.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960, 1720.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(4000, 1720.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960, 1680.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(4000, 1680.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960, 1640.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(4000, 1640.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960, 1600.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(4000, 1600.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3920, 1600.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3920, 1640.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3920, 1560.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960, 1560.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3920, 1520.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960, 1520.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3920, 1480.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960, 1480.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3920, 1440.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960, 1440.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3920, 1400.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960, 1400.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3920, 1360.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960, 1360.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3920, 1320.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960, 1320.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3920.0, 1280.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960.0, 1280.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3920.0, 1240.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960.0, 1240.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3920.0, 1200.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960.0, 1200.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3920.0, 1160.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960.0, 1160.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3920.0, 1120.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960.0, 1120.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3920.0, 1080.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960.0, 1080.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3920.0, 1000.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960.0, 1000.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3920.0, 1040.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960.0, 1040.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3920.0, 960.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960.0, 960.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3920.0, 800.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960.0, 800.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3920.0, 840.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960.0, 840.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3920.0, 880.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960.0, 880.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3920.0, 920.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960.0, 920.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3920.0, 760.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960.0, 760.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3920.0, 720.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960.0, 720.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3920.0, 520.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960.0, 520.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3920.0, 560.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960.0, 560.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3920.0, 600.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960.0, 600.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3920.0, 640.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960.0, 640.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3920.0, 680.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960.0, 680.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3920.0, 480, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960.0, 480, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3920.0, 440, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960.0, 440, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3920.0, 400, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960.0, 400, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3920.0, 360, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960.0, 360, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3920.0, 320, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960.0, 320, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3920.0, 280, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960.0, 280, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3920.0, 240, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960.0, 240, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3920.0, 200, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960.0, 200, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3920.0, 160, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960.0, 160, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3920.0, 120, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960.0, 120, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3920.0, 80, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960.0, 80, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3920.0, 40, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960.0, 40, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3920.0, 0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(3960.0, 0, 40, 40, (128,128,128), platform_type='wall'))
    # No ladders placed.
    hazards.add(Lava(920, 1880, 40, 40, (255,69,0)))
    hazards.add(Lava(960, 1880, 40, 40, (255,69,0)))
    hazards.add(Lava(1000, 1880, 40, 40, (255,69,0)))
    hazards.add(Lava(1040.0, 1880.0, 40, 40, (255,69,0)))
    hazards.add(Lava(1080.0, 1880.0, 40, 40, (255,69,0)))
    hazards.add(Lava(1120.0, 1880.0, 40, 40, (255,69,0)))
    enemy_spawns_data.append({'pos': (329, 1917), 'patrol': None, 'enemy_color_id': 'yellow'})
    enemy_spawns_data.append({'pos': (369, 1957), 'patrol': None, 'enemy_color_id': 'red'})
    enemy_spawns_data.append({'pos': (409, 1957), 'patrol': None, 'enemy_color_id': 'purple'})
    enemy_spawns_data.append({'pos': (449, 1957), 'patrol': None, 'enemy_color_id': 'pink'})
    enemy_spawns_data.append({'pos': (489, 1957.0), 'patrol': None, 'enemy_color_id': 'green'})
    enemy_spawns_data.append({'pos': (529.0, 1957), 'patrol': None, 'enemy_color_id': 'cyan'})
    collectible_spawns_data.append({'type': 'chest', 'pos': (1306.0, 1919)})

    # --- Level Dimensions for Game Camera & Boundaries ---
    map_total_width_pixels = 4200
    level_min_y_absolute = -80
    level_max_y_absolute = 2120
    main_ground_y_reference = 2040
    main_ground_height_reference = 40

    _boundary_thickness = C.TILE_SIZE * 2
    _boundary_wall_height = level_max_y_absolute - level_min_y_absolute + (2 * _boundary_thickness)
    _boundary_color = getattr(C, 'DARK_GRAY', (50,50,50)) 

    platforms.add(Platform(0, level_min_y_absolute - _boundary_thickness, map_total_width_pixels, _boundary_thickness, _boundary_color, platform_type="boundary_wall_top"))
    platforms.add(Platform(0, level_max_y_absolute, map_total_width_pixels, _boundary_thickness, _boundary_color, platform_type="boundary_wall_bottom"))
    platforms.add(Platform(-_boundary_thickness, level_min_y_absolute - _boundary_thickness, _boundary_thickness, _boundary_wall_height, _boundary_color, platform_type="boundary_wall_left"))
    platforms.add(Platform(map_total_width_pixels, level_min_y_absolute - _boundary_thickness, _boundary_thickness, _boundary_wall_height, _boundary_color, platform_type="boundary_wall_right"))

    print(f"Map 'load_map_2' loaded with: {len(platforms)} platforms, {len(ladders)} ladders, {len(hazards)} hazards.")
    return (platforms, ladders, hazards, enemy_spawns_data, collectible_spawns_data,
            player1_spawn,
            map_total_width_pixels, level_min_y_absolute, level_max_y_absolute,
            main_ground_y_reference, main_ground_height_reference,
            LEVEL_SPECIFIC_BACKGROUND_COLOR)


########## START OF FILE: maps\ok.py ##########

# Level: yes
# Generated by Platformer Level Editor
import pygame
from tiles import Platform, Ladder, Lava 
import constants as C

LEVEL_SPECIFIC_BACKGROUND_COLOR = (173, 216, 230)

def load_map_yes(initial_screen_width, initial_screen_height):
    """
    Loads the 'yes' level.
    """
    print(f"Loading map: load_map_yes...")
    platforms = pygame.sprite.Group()
    ladders = pygame.sprite.Group() 
    hazards = pygame.sprite.Group()
    enemy_spawns_data = []
    collectible_spawns_data = []

    player1_spawn = (620, 440) # Default P1 Spawn

    # --- Placed Objects ---
    # No platforms placed.
    # No ladders placed.
    # No hazards placed.
    # No enemy spawns defined.
    # No collectible spawns defined.

    # --- Level Dimensions for Game Camera & Boundaries ---
    map_total_width_pixels = 1360
    level_min_y_absolute = -80
    level_max_y_absolute = 880
    main_ground_y_reference = 800
    main_ground_height_reference = 40

    _boundary_thickness = C.TILE_SIZE * 2
    _boundary_wall_height = level_max_y_absolute - level_min_y_absolute + (2 * _boundary_thickness)
    _boundary_color = getattr(C, 'DARK_GRAY', (50,50,50)) 

    platforms.add(Platform(0, level_min_y_absolute - _boundary_thickness, map_total_width_pixels, _boundary_thickness, _boundary_color, platform_type="boundary_wall_top"))
    platforms.add(Platform(0, level_max_y_absolute, map_total_width_pixels, _boundary_thickness, _boundary_color, platform_type="boundary_wall_bottom"))
    platforms.add(Platform(-_boundary_thickness, level_min_y_absolute - _boundary_thickness, _boundary_thickness, _boundary_wall_height, _boundary_color, platform_type="boundary_wall_left"))
    platforms.add(Platform(map_total_width_pixels, level_min_y_absolute - _boundary_thickness, _boundary_thickness, _boundary_wall_height, _boundary_color, platform_type="boundary_wall_right"))

    print(f"Map 'load_map_yes' loaded with: {len(platforms)} platforms, {len(ladders)} ladders, {len(hazards)} hazards.")
    return (platforms, ladders, hazards, enemy_spawns_data, collectible_spawns_data,
            player1_spawn,
            map_total_width_pixels, level_min_y_absolute, level_max_y_absolute,
            main_ground_y_reference, main_ground_height_reference,
            LEVEL_SPECIFIC_BACKGROUND_COLOR)


########## START OF FILE: maps\yes.py ##########

# Level: yes
# Generated by Platformer Level Editor
import pygame
from tiles import Platform, Ladder, Lava 
import constants as C

LEVEL_SPECIFIC_BACKGROUND_COLOR = (173, 216, 230)

def load_map_yes(initial_screen_width, initial_screen_height):
    """
    Loads the 'yes' level.
    """
    print(f"Loading map: load_map_yes...")
    platforms = pygame.sprite.Group()
    ladders = pygame.sprite.Group() 
    hazards = pygame.sprite.Group()
    enemy_spawns_data = []
    collectible_spawns_data = []

    player1_spawn = (89, 757.0)

    # --- Placed Objects ---
    platforms.add(Platform(0, 0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 40, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 40, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 80, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 80, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 120, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 120, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 160, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 160, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 200, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 200, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 240, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 240, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 280, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 280, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 320, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 320, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 360, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 360, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 400, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 400, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 440, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 440, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 480, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 480, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 520, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 520, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 560, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 560, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 600, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 600, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 640, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 640, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 680, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 680, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(0, 720, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40, 720, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40.0, 760, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(80.0, 760, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(40.0, 800, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(80.0, 800, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(120.0, 760, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(120.0, 800, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(160.0, 760.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(160.0, 800.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(200.0, 760.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(200.0, 800.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(240.0, 760.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(240.0, 800.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(280.0, 760.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(280.0, 800.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(320.0, 760.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(320.0, 800.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(360.0, 760.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(360.0, 800.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(400.0, 760.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(400.0, 800.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(440.0, 760.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(440.0, 800.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(480, 760.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(480, 800.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(520, 760.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(520, 800.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(560, 760.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(560, 800.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(600, 760.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(600, 800.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(640, 760.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(640, 800.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(680, 760.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(680, 800.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(720, 760.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(720, 800.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(760, 760.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(760, 800.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(800, 760.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(840, 760.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(800, 800.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(840, 800.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(880, 760.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(920, 760.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(880, 800.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(920, 800.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(960, 760.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(960, 800.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1000, 760.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1000, 800.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1040, 760.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1040, 800.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1080, 760.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1080, 800.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1120, 760.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1120, 800.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1160, 760.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1160, 800.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1200, 760.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1200, 800.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1160, 720.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1200, 720.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1160, 680.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1200, 680.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1160, 640.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1200, 640.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1160, 600.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1200, 600.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1160, 560.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1200, 560.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1160, 520.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1200, 520.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1160, 480.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1200, 480.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1160, 440.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1200, 440.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1160, 400.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1200, 400.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1160, 360.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1200, 360.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1160, 320.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1200, 320.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1160, 280.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1200, 280.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1160, 240.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1200, 240.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1160, 200.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1200, 200.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1160, 160.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1200, 160.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1160, 120.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1200, 120.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1160, 80.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1200, 80.0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1120.0, 0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1160.0, 0, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1120.0, 40, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1160.0, 40, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1120.0, 80, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1120.0, 120, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1120, 240, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1120, 280, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1120, 320, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1120, 360, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1120, 400, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1120, 440, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1120, 480, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1120, 520, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1120, 560, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1120, 600, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1120, 640, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1120, 680, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1120, 720, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1080.0, 120, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1080.0, 160, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1120.0, 160, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(1120.0, 200, 40, 40, (128,128,128), platform_type='wall'))
    platforms.add(Platform(460, 720, 20, 40, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(300.0, 680, 20, 40, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(380.0, 640, 20, 40, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(260.0, 600.0, 20, 40, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(220.0, 560.0, 20, 40, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(180.0, 520.0, 20, 40, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(500.0, 640.0, 20, 40, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(580.0, 640.0, 20, 40, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(660.0, 640.0, 20, 40, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(700.0, 640.0, 20, 40, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(780.0, 640.0, 20, 40, (0,100,0), platform_type='ledge'))
    platforms.add(Platform(820.0, 640.0, 20, 40, (0,100,0), platform_type='ledge'))
    # No ladders placed.
    hazards.add(Lava(480.0, 720, 40, 40, (255,69,0)))
    hazards.add(Lava(520.0, 720, 40, 40, (255,69,0)))
    hazards.add(Lava(560.0, 720, 40, 40, (255,69,0)))
    hazards.add(Lava(600.0, 720, 40, 40, (255,69,0)))
    hazards.add(Lava(640.0, 720, 40, 40, (255,69,0)))
    hazards.add(Lava(680.0, 720, 40, 40, (255,69,0)))
    hazards.add(Lava(720.0, 720, 40, 40, (255,69,0)))
    hazards.add(Lava(760.0, 720, 40, 40, (255,69,0)))
    hazards.add(Lava(800.0, 720, 40, 40, (255,69,0)))
    hazards.add(Lava(840.0, 720, 40, 40, (255,69,0)))
    enemy_spawns_data.append({'pos': (1009, 757.0), 'patrol': None, 'enemy_color_id': 'cyan'})
    enemy_spawns_data.append({'pos': (889.0, 757.0), 'patrol': None, 'enemy_color_id': 'green'})
    collectible_spawns_data.append({'type': 'chest', 'pos': (946.0, 759)})

    # --- Level Dimensions for Game Camera & Boundaries ---
    map_total_width_pixels = 1400
    level_min_y_absolute = -80
    level_max_y_absolute = 920
    main_ground_y_reference = 840
    main_ground_height_reference = 40

    _boundary_thickness = C.TILE_SIZE * 2
    _boundary_wall_height = level_max_y_absolute - level_min_y_absolute + (2 * _boundary_thickness)
    _boundary_color = getattr(C, 'DARK_GRAY', (50,50,50)) 

    platforms.add(Platform(0, level_min_y_absolute - _boundary_thickness, map_total_width_pixels, _boundary_thickness, _boundary_color, platform_type="boundary_wall_top"))
    platforms.add(Platform(0, level_max_y_absolute, map_total_width_pixels, _boundary_thickness, _boundary_color, platform_type="boundary_wall_bottom"))
    platforms.add(Platform(-_boundary_thickness, level_min_y_absolute - _boundary_thickness, _boundary_thickness, _boundary_wall_height, _boundary_color, platform_type="boundary_wall_left"))
    platforms.add(Platform(map_total_width_pixels, level_min_y_absolute - _boundary_thickness, _boundary_thickness, _boundary_wall_height, _boundary_color, platform_type="boundary_wall_right"))

    print(f"Map 'load_map_yes' loaded with: {len(platforms)} platforms, {len(ladders)} ladders, {len(hazards)} hazards.")
    return (platforms, ladders, hazards, enemy_spawns_data, collectible_spawns_data,
            player1_spawn,
            map_total_width_pixels, level_min_y_absolute, level_max_y_absolute,
            main_ground_y_reference, main_ground_height_reference,
            LEVEL_SPECIFIC_BACKGROUND_COLOR)


########## START OF FILE: network_comms.py ##########

# network_comms.py
# -*- coding: utf-8 -*-
# version 1.0000000.1
"""
Networking utilities for data encoding/decoding and IP retrieval.
"""
import socket
import json

def get_local_ip():
    """Gets the local IP address of the machine."""
    best_ip = '127.0.0.1'
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80)) # Connect to a known external server (doesn't send data)
        best_ip = s.getsockname()[0]
        s.close()
    except Exception:
        try:
            best_ip = socket.gethostbyname(socket.gethostname())
        except Exception:
            best_ip = '127.0.0.1' # Fallback
    return best_ip

def encode_data(data):
    """Encodes Python dictionary to JSON bytes with a newline delimiter."""
    try:
        return json.dumps(data).encode('utf-8') + b'\n'
    except TypeError as e:
        print(f"Encoding Error: {e} Data: {str(data)[:100]}")
        return None
    except Exception as e:
        print(f"Unexpected Encoding Error: {e}")
        return None

def decode_data_stream(byte_buffer):
    """
    Decodes a stream of newline-delimited JSON byte data.
    Returns a list of decoded objects and the remaining unparsed buffer.
    """
    decoded_objects = []
    remaining_buffer = byte_buffer
    while b'\n' in remaining_buffer:
        message, remaining_buffer = remaining_buffer.split(b'\n', 1)
        if not message:  # Skip empty messages (e.g. if multiple newlines)
            continue
        try:
            decoded_objects.append(json.loads(message.decode('utf-8')))
        except json.JSONDecodeError as e:
            # print(f"JSON Decode Error: {e}. Malformed message: {message[:100]}") # Optional: log malformed
            continue # Skip malformed JSON
        except Exception as e:
            # print(f"Unexpected Decode Error: {e}. Message: {message[:100]}") # Optional: log other errors
            continue
    return decoded_objects, remaining_buffer

########## START OF FILE: player.py ##########

# player.py
# -*- coding: utf-8 -*-
"""
## version 1.0.0.3 (Standardized pos/rect sync to midbottom, refined wall collision re-check)
Defines the Player class, handling core attributes.
Delegates state, animation, physics, collisions, input, combat, and network handling
to respective handler modules.
"""
import pygame
import os
import sys
import math

from utils import PrintLimiter
import constants as C
from assets import load_all_player_animations

# Import NEW handler functions
from player_state_handler import set_player_state
from player_animation_handler import update_player_animation
from player_movement_physics import update_player_core_logic
from player_collision_handler import (
    check_player_platform_collisions,
    check_player_ladder_collisions,
    check_player_character_collisions,
    check_player_hazard_collisions
)

# Import EXISTING handler functions
from player_input_handler import process_player_input_logic
from player_combat_handler import (fire_player_fireball, check_player_attack_collisions, 
                                   player_take_damage, player_self_inflict_damage, player_heal_to_full)
from player_network_handler import (get_player_network_data, set_player_network_data, 
                                    handle_player_network_input, get_player_input_state_for_network)


class Player(pygame.sprite.Sprite):
    print_limiter = PrintLimiter(default_limit=5, default_period=3.0)

    def __init__(self, start_x, start_y, player_id=1):
        super().__init__()
        self.player_id = player_id
        self._valid_init = True
        
        asset_folder = 'characters/player1' if self.player_id == 1 else 'characters/player2'
        if self.player_id not in [1, 2]:
            if Player.print_limiter.can_print(f"player_init_unrecognized_id_{self.player_id}"):
                print(f"Player Info ({self.player_id}): Unrecognized ID. Defaulting to player1 assets.")
        
        self.animations = load_all_player_animations(relative_asset_folder=asset_folder)
        if self.animations is None:
            print(f"CRITICAL Player Init Error ({self.player_id}): Failed to load critical animations. Player invalid.")
            self.image = pygame.Surface((30, 40)).convert_alpha(); self.image.fill(C.RED)
            self.rect = self.image.get_rect(midbottom=(start_x, start_y))
            self.pos = pygame.math.Vector2(self.rect.midbottom) # Store midbottom
            self.is_dead = True; self._valid_init = False; return

        try: self.standard_height = self.animations['idle'][0].get_height()
        except (KeyError, IndexError, TypeError): self.standard_height = 60

        self._last_facing_right = True
        self._last_state_for_debug = "init"
        self.state = 'idle'
        self.current_frame = 0
        self.last_anim_update = pygame.time.get_ticks()

        idle_frames = self.animations.get('idle')
        if idle_frames and len(idle_frames) > 0: self.image = idle_frames[0]
        else:
            self.image = pygame.Surface((30,40)); self.image.fill(C.RED)
            self.rect = self.image.get_rect(midbottom=(start_x, start_y)) # Set rect before pos
            self.pos = pygame.math.Vector2(self.rect.midbottom)      # Store midbottom
            self._valid_init = False; return
            
        self.rect = self.image.get_rect(midbottom=(start_x, start_y))
        self.pos = pygame.math.Vector2(self.rect.midbottom) # Store midbottom as float Vector2
        
        self.vel = pygame.math.Vector2(0, 0)
        self.acc = pygame.math.Vector2(0, C.PLAYER_GRAVITY)
        self.facing_right = True
        self.on_ground = False
        self.on_ladder = False
        self.can_grab_ladder = False
        self.touching_wall = 0
        self.can_wall_jump = False
        self.wall_climb_timer = 0

        self.is_crouching = False
        self.is_dashing = False; self.dash_timer = 0; self.dash_duration = getattr(C, 'PLAYER_DASH_DURATION', 150)
        self.is_rolling = False; self.roll_timer = 0; self.roll_duration = getattr(C, 'PLAYER_ROLL_DURATION', 300)
        self.is_sliding = False; self.slide_timer = 0; self.slide_duration = getattr(C, 'PLAYER_SLIDE_DURATION', 400)
        
        self.is_attacking = False; self.attack_timer = 0; self.attack_duration = 300
        self.attack_type = 0
        self.can_combo = False; self.combo_window = getattr(C, 'PLAYER_COMBO_WINDOW', 150)
        self.wall_climb_duration = getattr(C, 'PLAYER_WALL_CLIMB_DURATION', 500)
        self.is_taking_hit = False; self.hit_timer = 0
        self.hit_duration = getattr(C, 'PLAYER_HIT_STUN_DURATION', 300)
        self.hit_cooldown = getattr(C, 'PLAYER_HIT_COOLDOWN', 600)
        self.is_dead = False
        self.death_animation_finished = False
        self.state_timer = 0

        self.max_health = C.PLAYER_MAX_HEALTH
        self.current_health = self.max_health
        self.attack_hitbox = pygame.Rect(0, 0, 45, 30)

        self.is_trying_to_move_left = False
        self.is_trying_to_move_right = False
        self.is_holding_climb_ability_key = False
        self.is_holding_crouch_ability_key = False

        self.fireball_cooldown_timer = 0
        self.fireball_last_input_dir = pygame.math.Vector2(1.0, 0.0)
        self.projectile_sprites_group = None
        self.all_sprites_group = None
        
        self.fireball_key = None 
        if self.player_id == 1: self.fireball_key = getattr(C, 'P1_FIREBALL_KEY', pygame.K_1)
        elif self.player_id == 2: self.fireball_key = getattr(C, 'P2_FIREBALL_KEY', pygame.K_0)

    def set_projectile_group_references(self, projectile_group: pygame.sprite.Group, 
                                        all_sprites_group: pygame.sprite.Group):
        self.projectile_sprites_group = projectile_group
        self.all_sprites_group = all_sprites_group

    def set_state(self, new_state: str):
        set_player_state(self, new_state)

    def animate(self):
        update_player_animation(self)

    def handle_input(self, keys_pressed_state, pygame_event_list):
        default_key_config = {
            'left': pygame.K_a, 'right': pygame.K_d, 'up': pygame.K_w, 'down': pygame.K_s,
            'attack1': pygame.K_v, 'attack2': pygame.K_b, 'dash': pygame.K_LSHIFT,
            'roll': pygame.K_LCTRL, 'interact': pygame.K_e
        }
        process_player_input_logic(self, keys_pressed_state, pygame_event_list, default_key_config)

    def handle_mapped_input(self, keys_pressed_state, pygame_event_list, key_map_dict):
        process_player_input_logic(self, keys_pressed_state, pygame_event_list, key_map_dict)

    def fire_fireball(self):
        fire_player_fireball(self)

    def check_attack_collisions(self, list_of_targets):
        check_player_attack_collisions(self, list_of_targets)

    def take_damage(self, damage_amount_taken):
        player_take_damage(self, damage_amount_taken)

    def self_inflict_damage(self, damage_amount_to_self):
        player_self_inflict_damage(self, damage_amount_to_self)

    def heal_to_full(self):
        player_heal_to_full(self)
        
    def get_network_data(self):
        return get_player_network_data(self)

    def set_network_data(self, received_network_data):
        set_player_network_data(self, received_network_data)

    def handle_network_input(self, network_input_data_dict):
        handle_player_network_input(self, network_input_data_dict)

    def get_input_state_for_network(self, keys_state, events, key_map):
        return get_player_input_state_for_network(self, keys_state, events, key_map)

    def check_platform_collisions(self, direction: str, platforms_group: pygame.sprite.Group):
        check_player_platform_collisions(self, direction, platforms_group)

    def check_ladder_collisions(self, ladders_group: pygame.sprite.Group):
        check_player_ladder_collisions(self, ladders_group)

    def check_character_collisions(self, direction: str, characters_list: list):
        return check_player_character_collisions(self, direction, characters_list)
        
    def check_hazard_collisions(self, hazards_group: pygame.sprite.Group):
        check_player_hazard_collisions(self, hazards_group)

    def update(self, dt_sec, platforms_group, ladders_group, hazards_group, 
               other_players_sprite_list, enemies_sprite_list):
        update_player_core_logic(self, dt_sec, platforms_group, ladders_group, hazards_group,
                                 other_players_sprite_list, enemies_sprite_list)

    def reset_state(self, spawn_position_tuple: tuple):
        if not self._valid_init: 
            asset_folder = 'characters/player1' if self.player_id == 1 else 'characters/player2'
            self.animations = load_all_player_animations(relative_asset_folder=asset_folder)
            if self.animations is not None:
                self._valid_init = True
                idle_frames = self.animations.get('idle')
                if idle_frames and len(idle_frames) > 0: self.image = idle_frames[0]
                else: self.image = pygame.Surface((30,40)); self.image.fill(C.RED)
                # Update rect and pos based on new image for potentially invalid player
                self.rect = self.image.get_rect(midbottom=spawn_position_tuple)
                self.pos = pygame.math.Vector2(self.rect.midbottom)
            else: return
        
        self.pos = pygame.math.Vector2(spawn_position_tuple) # spawn_position_tuple is already (midbottom_x, midbottom_y)
        self.rect.midbottom = (round(self.pos.x), round(self.pos.y))
        self.vel = pygame.math.Vector2(0, 0)
        self.acc = pygame.math.Vector2(0, C.PLAYER_GRAVITY if hasattr(C, 'PLAYER_GRAVITY') else 0.7)
        
        self.current_health = self.max_health
        self.is_dead = False; self.death_animation_finished = False
        self.is_taking_hit = False; self.is_attacking = False; self.attack_type = 0
        self.is_dashing = False; self.is_rolling = False; self.is_sliding = False
        self.on_ladder = False; self.touching_wall = 0; self.facing_right = True
        
        self.hit_timer = 0; self.dash_timer = 0; self.roll_timer = 0; self.slide_timer = 0
        self.attack_timer = 0; self.wall_climb_timer = 0; self.fireball_cooldown_timer = 0
        self.fireball_last_input_dir = pygame.math.Vector2(1.0, 0.0)

        if hasattr(self.image, 'set_alpha') and hasattr(self.image, 'get_alpha') and \
           self.image.get_alpha() is not None and self.image.get_alpha() < 255:
            self.image.set_alpha(255)
        
        set_player_state(self, 'idle')

########## START OF FILE: player_animation_handler.py ##########

# player_animation_handler.py
# -*- coding: utf-8 -*-
"""
## version 1.0.0.3 (Implemented correct rect anchoring for height changes)
Handles player animation selection and frame updates.
Correctly anchors the player's rect when height changes (e.g., crouching).
"""
import pygame
import constants as C

def determine_animation_key(player):
    """Helper function to determine the correct animation key based on player state."""
    animation_key = player.state # Default to current logical state
    player_is_intending_to_move_lr = player.is_trying_to_move_left or player.is_trying_to_move_right

    if player.is_dead:
        is_still_nm = abs(player.vel.x) < 0.5 and abs(player.vel.y) < 1.0
        key_variant = 'death_nm' if is_still_nm else 'death'
        if key_variant in player.animations and player.animations[key_variant]:
            animation_key = key_variant
        elif 'death' in player.animations and player.animations['death']:
            animation_key = 'death'
        # If 'death' itself is missing, it will be caught by the final fallback
    elif player.is_attacking:
        base_key = ''
        if player.attack_type == 1: base_key = 'attack'
        elif player.attack_type == 2: base_key = 'attack2'
        elif player.attack_type == 3: base_key = 'attack_combo'
        elif player.attack_type == 4: base_key = 'crouch_attack'

        if base_key == 'crouch_attack': # Crouch attack typically has only one variant
            animation_key = base_key
        elif base_key: # For standing/moving attacks, check for _nm (non-moving) variant
            nm_variant = f"{base_key}_nm"
            moving_variant = base_key
            # Prioritize moving variant if intending to move and it exists
            if player_is_intending_to_move_lr and moving_variant in player.animations and player.animations[moving_variant]:
                animation_key = moving_variant
            # Else, use non-moving variant if it exists
            elif nm_variant in player.animations and player.animations[nm_variant]:
                animation_key = nm_variant
            # Fallback to moving variant if _nm is missing but moving exists
            elif moving_variant in player.animations and player.animations[moving_variant]:
                animation_key = moving_variant
            # If all fail, it's caught by the final fallback
    elif player.state == 'wall_climb':
        is_actively_climbing = player.is_holding_climb_ability_key and \
                               abs(player.vel.y - C.PLAYER_WALL_CLIMB_SPEED) < 0.01 # More precise check
        key_variant = 'wall_climb' if is_actively_climbing else 'wall_climb_nm'
        if key_variant in player.animations and player.animations[key_variant]:
            animation_key = key_variant
        elif 'wall_climb' in player.animations and player.animations['wall_climb']: # Fallback
            animation_key = 'wall_climb'
    elif player.state == 'hit':
        animation_key = 'hit'
    elif not player.on_ground and not player.on_ladder and player.touching_wall == 0 and \
         player.state not in ['jump', 'jump_fall_trans'] and player.vel.y > getattr(C, 'MIN_Y_VEL_FOR_FALL_ANIM', 1.0):
        animation_key = 'fall'
    elif player.on_ladder:
        animation_key = 'ladder_climb' if abs(player.vel.y) > 0.1 else 'ladder_idle'
    elif player.is_dashing: animation_key = 'dash'
    elif player.is_rolling: animation_key = 'roll'
    elif player.is_sliding: animation_key = 'slide' # Assumes 'slide' is the looping part
    elif player.state == 'slide_trans_start': animation_key = 'slide_trans_start'
    elif player.state == 'slide_trans_end': animation_key = 'slide_trans_end'
    elif player.state == 'crouch_trans': animation_key = 'crouch_trans'
    # Add stand_up_trans if you have it for visual transition from crouch to idle/run
    # elif player.state == 'stand_up_trans': animation_key = 'stand_up_trans'
    elif player.state == 'turn': animation_key = 'turn'
    elif player.state == 'jump': animation_key = 'jump'
    elif player.state == 'jump_fall_trans': animation_key = 'jump_fall_trans'
    elif player.state == 'wall_slide': animation_key = 'wall_slide'
    elif player.state == 'wall_hang': animation_key = 'wall_hang'
    elif player.on_ground:
        if player.is_crouching: # Current state could be 'crouch' or 'crouch_walk'
            key_variant = 'crouch_walk' if player_is_intending_to_move_lr else 'crouch'
            if key_variant in player.animations and player.animations[key_variant]:
                animation_key = key_variant
            elif 'crouch' in player.animations and player.animations['crouch']: # Fallback if specific (e.g. crouch_walk) missing
                animation_key = 'crouch'
        elif player_is_intending_to_move_lr:
            animation_key = 'run'
        else:
            animation_key = 'idle'
    else: # Default if in air and no other more specific air state matched
        if player.state not in ['jump','jump_fall_trans','fall', 'wall_slide', 'wall_hang', 'wall_climb', 'wall_climb_nm', 'hit', 'dash', 'roll']:
             # If current state isn't an expected air state, might default to idle (looks weird) or fall
             animation_key = 'fall' if 'fall' in player.animations else 'idle'


    # Final validation of the determined key and its animation frames
    if animation_key not in player.animations or not player.animations[animation_key]:
        if player.print_limiter.can_print(f"anim_key_final_fallback_{player.player_id}_{animation_key}_{player.state}"):
            print(f"ANIM_HANDLER Warning (P{player.player_id}): Anim key '{animation_key}' (derived from state '{player.state}') invalid. Fallback to 'idle'.")
        return 'idle' # Return the key to be used
    return animation_key


def advance_frame_and_handle_state_transitions(player, current_animation_frames_list, current_time_ms, current_animation_key):
    """Advances animation frame and handles state transitions for non-looping animations."""
    ms_per_frame = C.ANIM_FRAME_DURATION
    if player.is_attacking and player.attack_type == 2 and hasattr(C, 'PLAYER_ATTACK2_FRAME_DURATION_MULTIPLIER'):
        ms_per_frame = int(C.ANIM_FRAME_DURATION * C.PLAYER_ATTACK2_FRAME_DURATION_MULTIPLIER)

    if not (player.is_dead and player.death_animation_finished):
        if current_time_ms - player.last_anim_update > ms_per_frame:
            player.last_anim_update = current_time_ms
            player.current_frame += 1

            if player.current_frame >= len(current_animation_frames_list):
                if player.is_dead: # Death animation finished
                    player.current_frame = len(current_animation_frames_list) - 1
                    player.death_animation_finished = True
                    # The image for the final death frame will be set outside this advancement logic
                    return # Stop further processing for dead, finished animation

                # Check if current animation key (derived from player.state) is non-looping
                non_looping_animation_keys = [
                    'attack','attack_nm','attack2','attack2_nm','attack_combo','attack_combo_nm',
                    'crouch_attack','dash','roll','slide','hit','turn','jump',
                    'jump_fall_trans','crouch_trans','slide_trans_start','slide_trans_end'
                    # Add 'stand_up_trans' if you implement it
                ]
                # Use current_animation_key which is the one actually playing
                if current_animation_key in non_looping_animation_keys:
                    next_logical_state = None
                    player_is_intending_to_move = player.is_trying_to_move_left or player.is_trying_to_move_right

                    # Determine next state based on the animation that just finished
                    if current_animation_key == 'jump':
                        next_logical_state = 'jump_fall_trans' if 'jump_fall_trans' in player.animations and player.animations['jump_fall_trans'] else 'fall'
                    elif current_animation_key == 'jump_fall_trans':
                        next_logical_state = 'fall'
                    elif current_animation_key == 'hit':
                        player.is_taking_hit = False # Hit stun ends
                        next_logical_state = 'fall' if not player.on_ground and not player.on_ladder else 'idle'
                    elif current_animation_key == 'turn':
                        next_logical_state = 'run' if player_is_intending_to_move else 'idle'
                    elif 'attack' in current_animation_key: # Covers all attack types
                        player.is_attacking = False; player.attack_type = 0
                        if player.on_ladder: pass # Stay on ladder, will revert to ladder_idle/climb
                        elif player.is_crouching: next_logical_state = 'crouch' # Stay crouched
                        elif not player.on_ground: next_logical_state = 'fall'
                        elif player_is_intending_to_move: next_logical_state = 'run'
                        else: next_logical_state = 'idle'
                    elif current_animation_key == 'crouch_trans':
                        # Finished transitioning into crouch. player.is_crouching should be True.
                        # The actual state will be 'crouch' or 'crouch_walk' handled by input_handler/core_logic.
                        # So, if still is_crouching, go to 'crouch', otherwise 'idle' (if uncrouch key pressed during trans).
                        next_logical_state = 'crouch' if player.is_crouching else 'idle'
                    # elif current_animation_key == 'stand_up_trans': # If you add this
                        # player.is_crouching = False # Ensure flag is false
                        # next_logical_state = 'idle' # Or run if moving
                    elif current_animation_key == 'slide_trans_start':
                        next_logical_state = 'slide' # Transition to looping slide
                    elif current_animation_key == 'slide' or current_animation_key == 'slide_trans_end':
                        player.is_sliding = False
                        # After slide, player might be crouching or standing depending on input
                        next_logical_state = 'crouch' if player.is_crouching else 'idle'
                    else: # For 'dash', 'roll'
                        if current_animation_key == 'dash': player.is_dashing = False
                        if current_animation_key == 'roll': player.is_rolling = False

                        if player.on_ladder: pass
                        elif player.is_crouching: next_logical_state = 'crouch'
                        elif not player.on_ground: next_logical_state = 'fall'
                        elif player_is_intending_to_move: next_logical_state = 'run'
                        else: next_logical_state = 'idle'

                    if next_logical_state:
                        # Import locally to break potential circular import issues at module load time,
                        # and to avoid calling set_state if this function itself was called from set_state
                        # without an intervening game loop tick.
                        # This can be tricky. Ideally, player.update() manages these transitions.
                        from player_state_handler import set_player_state
                        # Check if the current logical state (player.state) has already changed
                        # (e.g. by input during this animation). If so, don't override with this purely anim-driven one.
                        # This logic might need to be in Player.update() for better control flow.
                        # For now, we assume if a non-looping anim finishes, it dictates the next state.
                        if player.state == current_animation_key: # Only set if state hasn't already been changed by something else
                            set_player_state(player, next_logical_state)
                            # Since set_player_state calls update_player_animation again,
                            # we must return here to prevent current instance from continuing.
                            return
                        else: # State was already changed by other logic, reset frame for current (new) state
                            player.current_frame = 0
                    else: # Animation is non-looping but no specific next state, so loop it (or go to idle)
                        player.current_frame = 0
                else: # Looping animation
                    player.current_frame = 0

    # Ensure current_frame is valid after advancement logic.
    # This can happen if a state change occurred and the new animation has fewer frames.
    if player.current_frame >= len(current_animation_frames_list):
        player.current_frame = 0


def update_player_animation(player):
    """
    Updates the player's current image based on its state, frame, and facing direction.
    Correctly anchors the player's rect when height changes.
    """
    if not player._valid_init or not hasattr(player, 'animations') or not player.animations:
        return
    # Allow death animation to play even if player.alive() is False
    if not player.alive() and not (player.is_dead and not player.death_animation_finished):
        return

    current_time_ms = pygame.time.get_ticks()
    # 1. Determine the correct animation key to use based on current player state
    animation_key = determine_animation_key(player)
    current_animation_frames = player.animations.get(animation_key)

    if not current_animation_frames:
        if player.print_limiter.can_print(f"anim_frames_missing_final_{player.player_id}_{animation_key}"):
            print(f"CRITICAL ANIM_HANDLER (P{player.player_id}): Frames for FINAL key '{animation_key}' (State: {player.state}) are missing! Using fallback RED.")
        if hasattr(player, 'image') and player.image: player.image.fill(C.RED)
        return

    # 2. Advance the animation frame and handle transitions for non-looping animations
    advance_frame_and_handle_state_transitions(player, current_animation_frames, current_time_ms, animation_key)

    # Re-fetch animation_key and frames if state changed during advance_frame_and_handle_state_transitions
    # This happens if a non-looping animation finished and set_player_state was called.
    if player.state != animation_key: # Check if logical state diverged from playing animation key
        new_animation_key_after_transition = determine_animation_key(player)
        new_current_animation_frames = player.animations.get(new_animation_key_after_transition)
        if new_current_animation_frames:
            animation_key = new_animation_key_after_transition
            current_animation_frames = new_current_animation_frames
            # player.current_frame should have been reset to 0 by set_player_state
        else: # Should not happen if set_player_state has fallbacks
            if player.print_limiter.can_print(f"anim_frames_missing_post_trans_{player.player_id}_{new_animation_key_after_transition}"):
                print(f"CRITICAL ANIM_HANDLER (P{player.player_id}): Frames for key '{new_animation_key_after_transition}' (post-transition) missing!")
            if hasattr(player, 'image') and player.image: player.image.fill(C.RED)
            return

    # Ensure current_frame is valid for the (potentially new) current_animation_frames
    if player.current_frame < 0 or player.current_frame >= len(current_animation_frames):
        player.current_frame = 0 # Safeguard


    # 3. Get the image for the current frame
    image_for_this_frame = current_animation_frames[player.current_frame]

    # 4. Flip if necessary
    if not player.facing_right:
        image_for_this_frame = pygame.transform.flip(image_for_this_frame, True, False)

    # --- CRITICAL SECTION: Update image and rect, with correct anchoring ---
    # Only proceed if the visual representation needs to change
    if player.image is not image_for_this_frame or player._last_facing_right != player.facing_right:
        old_rect_height = player.rect.height
        old_rect_midbottom = player.rect.midbottom # Player class uses midbottom for pos

        player.image = image_for_this_frame
        # Get new rect based on the new image, initially at (0,0) or image's internal rect pos
        player.rect = player.image.get_rect()

        new_rect_height = player.rect.height
        height_changed = (old_rect_height != new_rect_height)

        # Anchor the new rect
        if player.on_ground and height_changed:
            # If on ground and height changes (crouch/stand), keep FEET (bottom) planted.
            # Horizontal position is maintained via midbottom's X.
            player.rect.bottom = old_rect_midbottom[1] # Keep original Y of feet
            player.rect.centerx = old_rect_midbottom[0] # Keep original X of midbottom
            if player.print_limiter.can_print(f"anim_anchor_ground_{player.player_id}_{animation_key}"):
                print(f"DEBUG ANIM (P{player.player_id}): Ground anchor. Key:{animation_key}. OldH:{old_rect_height}, NewH:{new_rect_height}. OldB:{old_rect_midbottom[1]}, NewB:{player.rect.bottom}")

        else:
            # If in air, or on ground but no height change (e.g., idle to run, or just flipping)
            # maintain midbottom position.
            player.rect.midbottom = old_rect_midbottom
            if height_changed and player.print_limiter.can_print(f"anim_anchor_air_{player.player_id}_{animation_key}"):
                 print(f"DEBUG ANIM (P{player.player_id}): Air/NoHeightChange anchor. Key:{animation_key}. OldH:{old_rect_height}, NewH:{new_rect_height}")


        # Sync player.pos to the newly anchored player.rect.midbottom
        # This is crucial because player.pos is the source of truth for physics before collisions.
        player.pos = pygame.math.Vector2(player.rect.midbottom)

        player._last_facing_right = player.facing_right

########## START OF FILE: player_collision_handler.py ##########

# player_collision_handler.py
# -*- coding: utf-8 -*-
"""
Handles all player-related collision detection and resolution.
Logs detailed physics information if enabled.
"""
import pygame
import constants as C
from tiles import Lava
from enemy import Enemy

# Import the shared logging flag and helper function from logger.py
from logger import ENABLE_DETAILED_PHYSICS_LOGS, log_player_physics

def check_player_platform_collisions(player, direction: str, platforms_group: pygame.sprite.Group):
    """
    Handles collisions between the player and solid platforms.
    Resolves collisions by adjusting player position and velocity.
    Updates `player.on_ground` and `player.touching_wall` flags.

    Args:
        player (Player): The player instance.
        direction (str): The axis of movement being checked ('x' or 'y').
        platforms_group (pygame.sprite.Group): Group of platform sprites.
    """
    if not player._valid_init: return

    # This rect represents the player's position *after* movement on the current axis
    # but *before* any collision resolution (snapping) within this function.
    # It's assumed player.rect has been updated based on player.vel before this function is called.
    rect_after_current_axis_move = player.rect.copy()
    collided_with_wall_on_side = 0  # Used for X-axis: -1 for left wall, 1 for right wall

    colliding_platforms = pygame.sprite.spritecollide(player, platforms_group, False)

    for platform_sprite in colliding_platforms:
        # For logging, capture the player's rect state *before* this specific platform collision is resolved.
        current_player_rect_for_log = player.rect.copy()

        log_player_physics(player, f"PLAT_COLL_CHECK DIR:{direction}",
                           (current_player_rect_for_log, platform_sprite.rect, platform_sprite.platform_type))

        if direction == 'x':
            # --- X-Axis Collision Resolution ---
            if player.vel.x > 0:  # Moving right
                # Check if the player *just* crossed the left edge of the platform
                if player.rect.right > platform_sprite.rect.left and \
                   rect_after_current_axis_move.left < platform_sprite.rect.left:
                    player.rect.right = platform_sprite.rect.left
                    player.vel.x = 0
                    if not player.on_ground and not player.on_ladder:
                        # Check for significant vertical overlap to confirm it's a wall
                        if player.rect.bottom > platform_sprite.rect.top + getattr(C, 'MIN_WALL_OVERLAP_PX', 5) and \
                           player.rect.top < platform_sprite.rect.bottom - getattr(C, 'MIN_WALL_OVERLAP_PX', 5):
                            collided_with_wall_on_side = 1
                    # Update precise position: X from center, Y from bottom (feet)
                    player.pos.x = player.rect.centerx
                    player.pos.y = player.rect.bottom
                    log_player_physics(player, f"PLAT_COLL_RESOLVED_X_R",
                                       (player.rect.copy(), current_player_rect_for_log,
                                        (player.pos.x, player.pos.y), player.vel.x, player.on_ground, 'x'))

            elif player.vel.x < 0:  # Moving left
                # Check if the player *just* crossed the right edge of the platform
                if player.rect.left < platform_sprite.rect.right and \
                   rect_after_current_axis_move.right > platform_sprite.rect.right:
                    player.rect.left = platform_sprite.rect.right
                    player.vel.x = 0
                    if not player.on_ground and not player.on_ladder:
                        if player.rect.bottom > platform_sprite.rect.top + getattr(C, 'MIN_WALL_OVERLAP_PX', 5) and \
                           player.rect.top < platform_sprite.rect.bottom - getattr(C, 'MIN_WALL_OVERLAP_PX', 5):
                            collided_with_wall_on_side = -1
                    player.pos.x = player.rect.centerx
                    player.pos.y = player.rect.bottom
                    log_player_physics(player, f"PLAT_COLL_RESOLVED_X_L",
                                       (player.rect.copy(), current_player_rect_for_log,
                                        (player.pos.x, player.pos.y), player.vel.x, player.on_ground, 'x'))

        elif direction == 'y':
            # --- Y-Axis Collision Resolution ---
            if player.vel.y >= 0:  # Moving down or stationary (after gravity)
                # Condition: Player's bottom is at/below platform top, AND player's top was previously above platform top.
                if player.rect.bottom >= platform_sprite.rect.top and \
                   rect_after_current_axis_move.bottom > platform_sprite.rect.top and \
                   rect_after_current_axis_move.top < platform_sprite.rect.top + 1: # +1 for int/float tolerance

                    min_overlap_ratio = getattr(C, 'MIN_PLATFORM_OVERLAP_RATIO_FOR_LANDING', 0.15)
                    min_horizontal_overlap = player.rect.width * min_overlap_ratio
                    actual_overlap_width = min(player.rect.right, platform_sprite.rect.right) - \
                                           max(player.rect.left, platform_sprite.rect.left)

                    if actual_overlap_width >= min_horizontal_overlap:
                        player.rect.bottom = platform_sprite.rect.top # Snap to platform

                        # Actions on fresh landing (was in air, moving down)
                        if not player.on_ground and player.vel.y > 0:
                            player.can_wall_jump = False
                            player.wall_climb_timer = 0 # Reset wall climb state
                            if not player.is_sliding and not (hasattr(player, 'state') and player.state.startswith('slide_trans')):
                                landing_friction = getattr(C, 'LANDING_FRICTION_MULTIPLIER', 0.8)
                                player.vel.x *= landing_friction

                        player.on_ground = True
                        player.vel.y = 0
                        player.pos.x = player.rect.centerx
                        player.pos.y = player.rect.bottom # Anchor Y to feet
                        log_player_physics(player, f"PLAT_COLL_Y_LAND",
                                           (player.rect.copy(), current_player_rect_for_log,
                                            (player.pos.x, player.pos.y), player.vel.y, player.on_ground, 'y_land'))

            elif player.vel.y < 0:  # Moving up
                # Condition: Player's top is at/above platform bottom, AND player's bottom was previously below platform bottom.
                if player.rect.top <= platform_sprite.rect.bottom and \
                   rect_after_current_axis_move.top < platform_sprite.rect.bottom and \
                   rect_after_current_axis_move.bottom > platform_sprite.rect.bottom -1: # -1 for tolerance

                    min_overlap_ratio = getattr(C, 'MIN_PLATFORM_OVERLAP_RATIO_FOR_CEILING', 0.15)
                    min_horizontal_overlap = player.rect.width * min_overlap_ratio
                    actual_overlap_width = min(player.rect.right, platform_sprite.rect.right) - \
                                           max(player.rect.left, platform_sprite.rect.left)

                    if actual_overlap_width >= min_horizontal_overlap:
                        if player.on_ladder: player.on_ladder = False # Knock off ladder
                        player.rect.top = platform_sprite.rect.bottom # Snap to ceiling
                        player.vel.y = 0  # Stop upward movement
                        player.pos.x = player.rect.centerx
                        player.pos.y = player.rect.bottom # Anchor Y to feet
                        log_player_physics(player, f"PLAT_COLL_Y_CEIL_NORMAL",
                                           (player.rect.copy(), current_player_rect_for_log,
                                            (player.pos.x, player.pos.y), player.vel.y, player.on_ground, 'y_ceil_norm'))

    # Update player's touching_wall status based on X-axis collisions resolved in this call
    # This is done *after* iterating through all platforms for the current axis.
    if direction == 'x':
        if collided_with_wall_on_side != 0 and not player.on_ground and not player.on_ladder:
            player.touching_wall = collided_with_wall_on_side
            # Allow wall jump unless actively climbing up the wall
            player.can_wall_jump = not (hasattr(player, 'state') and player.state == 'wall_climb' and player.is_holding_climb_ability_key)
        # else:
            # Consider if/how touching_wall should be cleared if no X collision occurs.
            # Often, touching_wall is reset at the start of the player's broader update cycle.
            # If not, player.touching_wall might "stick" if they move away from a wall.
            # For now, this function only SETS touching_wall, doesn't clear it if no x-collision.


# --- The rest of your functions remain unchanged ---
def check_player_ladder_collisions(player, ladders_group: pygame.sprite.Group):
    if not player._valid_init: return
    ladder_check_rect = player.rect.inflate(-player.rect.width * 0.6, -player.rect.height * 0.1)
    player.can_grab_ladder = False
    for ladder_sprite in pygame.sprite.spritecollide(player, ladders_group, False,
                           collided=lambda p_sprite, l_sprite: ladder_check_rect.colliderect(l_sprite.rect)):
        if abs(player.rect.centerx - ladder_sprite.rect.centerx) < ladder_sprite.rect.width * 0.7 and \
           ladder_sprite.rect.top < player.rect.centery < ladder_sprite.rect.bottom :
              player.can_grab_ladder = True; break


def check_player_character_collisions(player, direction: str, characters_list: list):
    if not player._valid_init or player.is_dead or not player.alive(): return False
    collision_occurred_this_axis = False

    # rect_after_axis_move_before_char_snapping = player.rect.copy() # Not strictly used by current logic below

    for other_char in characters_list:
        if other_char is player: continue

        if not (other_char and hasattr(other_char, '_valid_init') and \
                other_char._valid_init and hasattr(other_char, 'is_dead') and \
                not other_char.is_dead and other_char.alive()):
            continue

        if player.rect.colliderect(other_char.rect):
            current_player_rect_for_log = player.rect.copy()
            log_player_physics(player, f"CHAR_COLL_CHECK DIR:{direction}",
                               (current_player_rect_for_log, other_char.rect,
                                getattr(other_char, 'player_id', getattr(other_char, 'enemy_id', 'UnknownChar'))))

            collision_occurred_this_axis = True

            is_enemy_stompable = isinstance(other_char, Enemy) and \
                                     not other_char.is_dead and \
                                     not getattr(other_char, 'is_stomp_dying', False)

            if is_enemy_stompable and direction == 'y' and player.vel.y > 0.5: # Ensure downward velocity for stomp
                # More robust stomp check: player's feet were above enemy's head, now at/below
                # rect_after_current_axis_move is needed if you check against player's previous position
                # For simplicity, using current player.pos.y - player.vel.y as a rough estimate of previous bottom
                # A more accurate previous_rect_bottom would be better if available from player's main update
                previous_player_bottom_y_estimate = player.pos.y - player.vel.y # Assuming pos.y is rect.bottom
                # A small grace for enemy head height for stomp
                stomp_head_grace = getattr(C, 'PLAYER_STOMP_LAND_ON_ENEMY_GRACE_PX', 5)
                enemy_stomp_target_top = other_char.rect.top + stomp_head_grace

                player_landed_on_enemy_head = (
                    previous_player_bottom_y_estimate <= enemy_stomp_target_top and # Was above
                    player.rect.bottom >= other_char.rect.top and # Is now at or below (but not too far below)
                    player.rect.bottom <= other_char.rect.top + (other_char.rect.height * 0.40) # Don't stomp if already passed through
                )
                if player_landed_on_enemy_head:
                    if hasattr(other_char, 'stomp_kill') and callable(other_char.stomp_kill):
                        other_char.stomp_kill() # Enemy handles its death
                        player.vel.y = C.PLAYER_STOMP_BOUNCE_STRENGTH # Player bounces
                        player.on_ground = False # Player is now in the air
                        if hasattr(player, 'set_state'): player.set_state('jump')
                        player.rect.bottom = other_char.rect.top -1 # Place player just above enemy
                        player.pos.x = player.rect.centerx # Sync pos
                        player.pos.y = player.rect.bottom
                    log_player_physics(player, f"CHAR_COLL_STOMP",
                                       (player.rect.copy(), current_player_rect_for_log,
                                        (player.pos.x, player.pos.y), player.vel.y, 'y_stomp'))
                    return True # Stomp collision handled, often no further char collision needed this frame for Y

            # --- Standard Pushback Collision Resolution (if not a stomp) ---
            player_state_str = str(getattr(player, 'state', '')).lower()
            is_attacking_self = getattr(player, 'is_attacking', False) or \
                                ('attack' in player_state_str)

            if direction == 'x':
                if is_attacking_self:
                    # Player is attacking: Snap position, stop own X-velocity.
                    if player.vel.x > 0 or (player.vel.x == 0 and player.rect.centerx < other_char.rect.centerx):
                        player.rect.right = other_char.rect.left
                    elif player.vel.x < 0 or (player.vel.x == 0 and player.rect.centerx >= other_char.rect.centerx):
                        player.rect.left = other_char.rect.right
                    player.vel.x = 0
                    player.pos.x = player.rect.centerx; player.pos.y = player.rect.bottom
                    log_player_physics(player, f"CHAR_COLL_ATTACK_X_STOP",
                                       (player.rect.copy(), current_player_rect_for_log,
                                        (player.pos.x, player.pos.y), player.vel.x, 'x_attack_stop'))
                else:
                    # Standard pushback if player is NOT attacking
                    bounce_vel = getattr(C, 'CHARACTER_BOUNCE_VELOCITY', 2.5)
                    push_dir_self = 0
                    if player.rect.centerx < other_char.rect.centerx:
                        player.rect.right = other_char.rect.left
                        push_dir_self = -1
                    else:
                        player.rect.left = other_char.rect.right
                        push_dir_self = 1
                    player.vel.x = push_dir_self * bounce_vel

                    other_char_state_str = str(getattr(other_char, 'state', '')).lower()
                    is_attacking_other = getattr(other_char, 'is_attacking', False) or \
                                         ('attack' in other_char_state_str)

                    if hasattr(other_char, 'vel') and not is_attacking_other:
                        other_char.vel.x = -push_dir_self * bounce_vel
                    if hasattr(other_char, 'pos') and hasattr(other_char, 'rect') and not is_attacking_other:
                        # Nudge other char slightly further if possible
                        other_char.pos.x += (-push_dir_self * 1.0) # Reduced nudge to prevent overcorrection
                        other_char.rect.centerx = round(other_char.pos.x) # Assuming other_char.pos.x is its center
                        other_char.rect.bottom = round(other_char.pos.y)   # Assuming other_char.pos.y is its bottom
                        # Re-sync other_char.pos if its rect was directly manipulated
                        if hasattr(other_char, 'pos'): # Re-check because we modified rect
                            other_char.pos.x = other_char.rect.centerx
                            other_char.pos.y = other_char.rect.bottom


                    player.pos.x = player.rect.centerx; player.pos.y = player.rect.bottom
                    log_player_physics(player, f"CHAR_COLL_X_PUSHBACK",
                                       (player.rect.copy(), current_player_rect_for_log,
                                        (player.pos.x, player.pos.y), player.vel.x, 'x_push'))

            elif direction == 'y': # Non-stomp vertical character collisions
                # This logic is simple; more robust might involve predicting pass-through
                if player.vel.y > 0 and player.rect.bottom > other_char.rect.top and \
                   player.rect.centery < other_char.rect.centery: # Player is landing on top
                    player.rect.bottom = other_char.rect.top
                    player.on_ground = True # Potentially landing on another character
                    player.vel.y = 0
                elif player.vel.y < 0 and player.rect.top < other_char.rect.bottom and \
                     player.rect.centery > other_char.rect.centery: # Player is hitting from below
                    player.rect.top = other_char.rect.bottom
                    player.vel.y = 0
                player.pos.x = player.rect.centerx; player.pos.y = player.rect.bottom
                log_player_physics(player, f"CHAR_COLL_Y_STOP",
                                   (player.rect.copy(), current_player_rect_for_log,
                                    (player.pos.x, player.pos.y), player.vel.y, 'y_char_stop'))
    return collision_occurred_this_axis


def check_player_hazard_collisions(player, hazards_group: pygame.sprite.Group):
    current_time_ms = pygame.time.get_ticks()
    if not player._valid_init or player.is_dead or not player.alive() or \
       (player.is_taking_hit and current_time_ms - player.hit_timer < player.hit_cooldown):
        return

    damaged_this_frame = False
    # Use a slightly inflated rect for hazard collision to make it a bit more forgiving or sensitive
    # hazard_check_rect = player.rect.inflate(2, 2)
    # collided_hazards = pygame.sprite.spritecollide(player, hazards_group, False, pygame.sprite.collide_rect_ratio(0.8)) # Example
    collided_hazards = pygame.sprite.spritecollide(player, hazards_group, False)


    for hazard in collided_hazards:
        if isinstance(hazard, Lava): # Example for Lava, expand for other hazard types
            # More precise check for lava: feet significantly in lava
            player_feet_in_lava = player.rect.bottom > hazard.rect.top + (player.rect.height * 0.2) # e.g. 20% of player height in lava
            min_horizontal_hazard_overlap = player.rect.width * 0.20 # Need some horizontal overlap
            actual_overlap_width = min(player.rect.right, hazard.rect.right) - max(player.rect.left, hazard.rect.left)

            if player_feet_in_lava and actual_overlap_width >= min_horizontal_hazard_overlap:
                if not damaged_this_frame:
                    log_player_physics(player, f"HAZARD_COLL_LAVA", (player.rect.copy(), hazard.rect))
                    if hasattr(player, 'take_damage'): player.take_damage(C.LAVA_DAMAGE)
                    damaged_this_frame = True

                    if not player.is_dead: # Knockback from lava
                         player.vel.y = C.PLAYER_JUMP_STRENGTH * 0.75 # Bounce up
                         # Determine knockback direction based on player's center vs hazard's center
                         if player.rect.centerx < hazard.rect.centerx:
                             player.vel.x = -getattr(C, 'PLAYER_RUN_SPEED_LIMIT', 7) * 0.6
                         else:
                             player.vel.x = getattr(C, 'PLAYER_RUN_SPEED_LIMIT', 7) * 0.6
                         player.on_ground = False
                         player.on_ladder = False
                         if hasattr(player, 'set_state'): player.set_state('hit' if 'hit' in player.animations else 'jump') # Or a specific 'hit_lava' state
                    break # Processed one hazard damage this frame
        # Add elif for other hazard types here if needed

        if damaged_this_frame: break

########## START OF FILE: player_combat_handler.py ##########

# player_combat_handler.py
# -*- coding: utf-8 -*-
"""
version 1.0.0.2 (Added debug prints for fireball firing)
Handles player combat: attacks, damage dealing/taking, healing, and projectile firing.
Functions here will typically take a 'player' instance as their first argument.
"""
import pygame
import constants as C
from projectiles import Fireball # Needed for instantiating Fireball

def fire_player_fireball(player):
    """
    Handles the logic for the player instance firing a fireball.
    Checks cooldowns, determines spawn position and direction, and adds
    the fireball to appropriate sprite groups.

    Args:
        player (Player): The player instance attempting to fire.
    """
    # ADD THIS DEBUG PRINT:
    print(f"DEBUG PCH (P{player.player_id}): Attempting fire_player_fireball. Valid: {player._valid_init}, Dead: {player.is_dead}, Alive: {player.alive() if hasattr(player, 'alive') else 'N/A'}, ProjGrp: {player.projectile_sprites_group is not None}, AllGrp: {player.all_sprites_group is not None}")

    # Basic validation: Player must be valid, alive, and have sprite group references
    if not player._valid_init or player.is_dead or not player.alive():
        print(f"DEBUG PCH (P{player.player_id}): Fireball RETURN early - player not valid/alive.") # ADDED
        return
    if player.projectile_sprites_group is None or player.all_sprites_group is None:
        print(f"DEBUG PCH (P{player.player_id}): Fireball RETURN early - sprite groups not set.") # MODIFIED/ADDED
        if player.print_limiter.can_print(f"player_{player.player_id}_fireball_no_group_ref_handler"):
            # Use a unique key for PrintLimiter to avoid message collision
            print(f"Player {player.player_id} (CombatHandler): Cannot fire fireball, projectile/all_sprites group not set.")
        return

    current_time_ms = pygame.time.get_ticks()
    # ADD THIS DEBUG PRINT:
    print(f"DEBUG PCH (P{player.player_id}): Fireball Cooldown Check. Current: {current_time_ms}, LastFire: {player.fireball_cooldown_timer}, CooldownVal: {C.FIREBALL_COOLDOWN}, Diff: {current_time_ms - player.fireball_cooldown_timer}")
    
    # Check if fireball is off cooldown
    if current_time_ms - player.fireball_cooldown_timer >= C.FIREBALL_COOLDOWN:
        player.fireball_cooldown_timer = current_time_ms # Reset cooldown timer

        # Determine fireball spawn position relative to player
        spawn_x = player.rect.centerx
        spawn_y = player.rect.centery 
        
        # Use the player's last stored aim direction for the fireball
        current_aim_direction = player.fireball_last_input_dir.copy()
        # Ensure the aim direction has a non-zero length (fallback to facing direction)
        if current_aim_direction.length_squared() == 0: 
            current_aim_direction.x = 1.0 if player.facing_right else -1.0
            current_aim_direction.y = 0.0
        
        offset_distance = (player.rect.width / 2) + (C.FIREBALL_DIMENSIONS[0] / 2) - 35 
        
        if abs(current_aim_direction.y) > 0.8 * abs(current_aim_direction.x): 
            offset_distance = (player.rect.height / 2) + (C.FIREBALL_DIMENSIONS[1] / 2) - 35
        
        if current_aim_direction.length_squared() > 0: 
            offset_vector = current_aim_direction.normalize() * offset_distance
            spawn_x += offset_vector.x
            spawn_y += offset_vector.y

        new_fireball = Fireball(spawn_x, spawn_y, current_aim_direction, player)
        player.projectile_sprites_group.add(new_fireball)
        player.all_sprites_group.add(new_fireball)
        
        # ADD THIS AT THE END OF SUCCESSFUL FIRING
        print(f"DEBUG PCH (P{player.player_id}): Fireball CREATED AND ADDED to groups. Groups now: Proj Count={len(player.projectile_sprites_group.sprites())}, All Count={len(player.all_sprites_group.sprites())}")
        
        if player.print_limiter.can_print(f"player_{player.player_id}_fire_fireball_msg_combat_handler"):
            print(f"Player {player.player_id} (CombatHandler) fires fireball. Aim Dir: {current_aim_direction}, Spawn Pos: ({spawn_x:.1f}, {spawn_y:.1f})")
    else: # Fireball is on cooldown
        # ADD THIS PRINT
        print(f"DEBUG PCH (P{player.player_id}): Fireball ON COOLDOWN.")
        if player.print_limiter.can_print(f"player_{player.player_id}_fireball_cooldown_combat_handler"):
            print(f"Player {player.player_id} (CombatHandler): Fireball on cooldown.")


def check_player_attack_collisions(player, targets_list):
    """
    Checks for collisions between the player's active attack hitbox and a list of targets.
    Applies damage to targets if a hit is registered.

    Args:
        player (Player): The attacking player instance.
        targets_list (list): A list of potential target Sprites (e.g., enemies, other players).
    """
    # Player must be valid, actively attacking, and alive to deal damage
    if not player._valid_init or not player.is_attacking or player.is_dead or not player.alive():
        return

    # --- Position the player's attack hitbox based on facing direction and state ---
    if player.facing_right:
        player.attack_hitbox.midleft = player.rect.midright # Hitbox to the right
    else:
        player.attack_hitbox.midright = player.rect.midleft # Hitbox to the left
    
    vertical_offset_for_crouch_attack = -10 if player.is_crouching and player.attack_type == 4 else 0
    player.attack_hitbox.centery = player.rect.centery + vertical_offset_for_crouch_attack
    
    current_time_ms = pygame.time.get_ticks()
    for target_sprite in targets_list:
        if target_sprite is player: continue 

        if not (target_sprite and hasattr(target_sprite, '_valid_init') and target_sprite._valid_init and \
                hasattr(target_sprite, 'is_dead') and not target_sprite.is_dead and target_sprite.alive()):
            continue

        target_is_currently_invincible = False
        if hasattr(target_sprite, 'is_taking_hit') and hasattr(target_sprite, 'hit_timer') and \
           hasattr(target_sprite, 'hit_cooldown'):
            if target_sprite.is_taking_hit and \
               (current_time_ms - target_sprite.hit_timer < target_sprite.hit_cooldown):
                target_is_currently_invincible = True
        
        if target_is_currently_invincible:
            continue 

        if player.attack_hitbox.colliderect(target_sprite.rect):
            if hasattr(target_sprite, 'take_damage') and callable(target_sprite.take_damage):
                damage_to_inflict = 0
                if player.attack_type == 1: damage_to_inflict = C.PLAYER_ATTACK1_DAMAGE
                elif player.attack_type == 2: damage_to_inflict = C.PLAYER_ATTACK2_DAMAGE
                elif player.attack_type == 3: damage_to_inflict = C.PLAYER_COMBO_ATTACK_DAMAGE
                elif player.attack_type == 4: damage_to_inflict = C.PLAYER_CROUCH_ATTACK_DAMAGE
                
                if damage_to_inflict > 0:
                    target_sprite.take_damage(damage_to_inflict) 


def player_take_damage(player, damage_amount):
    """
    Handles the player instance taking a specified amount of damage.
    Updates health, and potentially triggers 'hit' or 'death' states.

    Args:
        player (Player): The player instance receiving damage.
        damage_amount (int): The amount of damage to inflict.
    """
    current_time_ms = pygame.time.get_ticks()
    
    if not player._valid_init or player.is_dead or not player.alive() or \
       (player.is_taking_hit and current_time_ms - player.hit_timer < player.hit_cooldown): 
        return

    player.current_health -= damage_amount
    player.current_health = max(0, player.current_health) 

    if player.current_health <= 0: 
        if not player.is_dead: 
            player.set_state('death') 
    else: 
        if not (player.state == 'hit' and current_time_ms - player.state_timer < player.hit_duration):
             player.set_state('hit') 

def player_self_inflict_damage(player, damage_amount):
    """
    Allows the player instance to inflict damage on themselves.
    Typically used for debugging or special abilities.

    Args:
        player (Player): The player instance.
        damage_amount (int): The amount of damage for self-infliction.
    """
    if not player._valid_init or player.is_dead or not player.alive(): return 
    player_take_damage(player, damage_amount) 

def player_heal_to_full(player):
    """
    Heals the player instance to their maximum health.
    Can also cancel 'hit' stun state.

    Args:
        player (Player): The player instance to be healed.
    """
    if not player._valid_init: return
    if player.is_dead and player.current_health <=0 : return 
    
    player.current_health = player.max_health
    
    if player.is_taking_hit: player.is_taking_hit = False 
    if player.state == 'hit': player.set_state('idle')

########## START OF FILE: player_input_handler.py ##########

# player_input_handler.py
# -*- coding: utf-8 -*-
"""
version 1.0.0.5 (Disabled fireball while crouching)
Handles processing of player input and translating it to actions.
Functions here will typically take a 'player' instance as their first argument.
"""
import pygame
import constants as C

def process_player_input_logic(player, keys_pressed, pygame_events, key_config_map):
    """
    Core logic for processing raw Pygame input (held keys and events)
    into player actions and state changes.
    Modifies the 'player' instance directly based on the input and key configuration.

    Args:
        player (Player): The player instance to be controlled.
        keys_pressed (pygame.key.ScancodeWrapper): Snapshot of currently held keys
                                                   (from pygame.key.get_pressed()).
        pygame_events (list): List of Pygame events for the current frame
                              (from pygame.event.get()).
        key_config_map (dict): A dictionary mapping action strings
                               (e.g., 'left', 'attack1') to Pygame key constants
                               (e.g., pygame.K_a, pygame.K_v).
    """
    if not player._valid_init: return # Do nothing if player initialization failed

    current_time_ms = pygame.time.get_ticks() # For managing state timers and cooldowns

    is_input_blocked = player.is_dead or \
                       (player.is_taking_hit and current_time_ms - player.hit_timer < player.hit_duration)

    if is_input_blocked:
        player.acc.x = 0
        return

    player.is_trying_to_move_left = keys_pressed[key_config_map['left']]
    player.is_trying_to_move_right = keys_pressed[key_config_map['right']]
    player.is_holding_climb_ability_key = keys_pressed[key_config_map['up']]
    player.is_holding_crouch_ability_key = keys_pressed[key_config_map['down']] # Still used for ladder down & fireball aim

    fireball_aim_x_input = 0.0
    fireball_aim_y_input = 0.0
    if keys_pressed[key_config_map['left']]: fireball_aim_x_input = -1.0
    elif keys_pressed[key_config_map['right']]: fireball_aim_x_input = 1.0

    if keys_pressed[key_config_map['up']]: fireball_aim_y_input = -1.0
    elif player.is_holding_crouch_ability_key: fireball_aim_y_input = 1.0

    if fireball_aim_x_input != 0.0 or fireball_aim_y_input != 0.0:
        player.fireball_last_input_dir.x = fireball_aim_x_input
        player.fireball_last_input_dir.y = fireball_aim_y_input
    elif player.fireball_last_input_dir.length_squared() == 0:
        player.fireball_last_input_dir.x = 1.0 if player.facing_right else -1.0
        player.fireball_last_input_dir.y = 0.0

    player.acc.x = 0
    player_intends_horizontal_move = False

    can_player_control_horizontal_movement = not (
        player.is_dashing or player.is_rolling or player.is_sliding or player.on_ladder or
        (player.is_attacking and player.state in ['attack_nm','attack2_nm','attack_combo_nm','crouch_attack']) or
        player.state in ['turn','hit','death','death_nm','wall_climb','wall_climb_nm','wall_hang']
    )

    if can_player_control_horizontal_movement:
        if player.is_trying_to_move_left and not player.is_trying_to_move_right:
            player.acc.x = -C.PLAYER_ACCEL
            player_intends_horizontal_move = True
            if player.facing_right and player.on_ground and not player.is_crouching and \
               not player.is_attacking and player.state in ['idle','run']:
                player.set_state('turn')
            player.facing_right = False
        elif player.is_trying_to_move_right and not player.is_trying_to_move_left:
            player.acc.x = C.PLAYER_ACCEL
            player_intends_horizontal_move = True
            if not player.facing_right and player.on_ground and not player.is_crouching and \
               not player.is_attacking and player.state in ['idle','run']:
                player.set_state('turn')
            player.facing_right = True

    if player.on_ladder:
         player.vel.y = 0
         if player.is_holding_climb_ability_key:
             player.vel.y = -C.PLAYER_LADDER_CLIMB_SPEED
         elif player.is_holding_crouch_ability_key: # Uses HOLD for ladder
             player.vel.y = C.PLAYER_LADDER_CLIMB_SPEED

    for event in pygame_events:
        if event.type == pygame.KEYDOWN:
            if event.key == key_config_map['up']:
                  can_perform_jump_action = not player.is_attacking and \
                                            not player.is_rolling and not player.is_sliding and \
                                            not player.is_dashing and \
                                            player.state not in ['turn','hit','death','death_nm']
                  if can_perform_jump_action:
                      if player.on_ground:
                          if player.is_crouching:
                              player.is_crouching = False
                          player.vel.y = C.PLAYER_JUMP_STRENGTH
                          player.set_state('jump')
                          player.on_ground = False
                      elif player.on_ladder:
                          player.is_crouching = False
                          player.vel.y = C.PLAYER_JUMP_STRENGTH * 0.8
                          player.vel.x = C.PLAYER_RUN_SPEED_LIMIT * 0.5 * (1 if player.facing_right else -1)
                          player.on_ladder = False
                          player.set_state('jump')
                      elif player.can_wall_jump and player.touching_wall != 0:
                          player.is_crouching = False
                          player.vel.y = C.PLAYER_JUMP_STRENGTH
                          player.vel.x = C.PLAYER_RUN_SPEED_LIMIT * 1.5 * (-player.touching_wall)
                          player.facing_right = not player.facing_right
                          player.set_state('jump')
                          player.can_wall_jump = False; player.touching_wall = 0; player.wall_climb_timer = 0

            if event.key == key_config_map['attack1']:
                  can_perform_attack_action = not player.is_attacking and not player.is_dashing and \
                                              not player.is_rolling and not player.is_sliding and \
                                              not player.on_ladder and player.state not in ['turn','hit']
                  if can_perform_attack_action:
                       player.attack_type = 1
                       is_moving_for_attack_anim = (player.acc.x !=0 or abs(player.vel.x) > 1.0)
                       attack_animation_key = 'attack' if is_moving_for_attack_anim and \
                                              'attack' in player.animations and player.animations['attack'] \
                                              else 'attack_nm'
                       if player.is_crouching:
                           player.attack_type = 4
                           attack_animation_key = 'crouch_attack'
                       player.set_state(attack_animation_key)

            if event.key == key_config_map['attack2']:
                  can_perform_attack2_action = not player.is_dashing and not player.is_rolling and \
                                               not player.is_sliding and not player.on_ladder and \
                                               player.state not in ['turn','hit']
                  if can_perform_attack2_action:
                       is_moving_for_attack2_anim = (player.acc.x != 0 or abs(player.vel.x) > 1.0)
                       time_since_attack1_ended = current_time_ms - (player.attack_timer + player.attack_duration)
                       is_in_combo_window_for_attack3 = (player.attack_type == 1 and not player.is_attacking and
                                                         time_since_attack1_ended < player.combo_window)
                       selected_attack2_anim_key = ''
                       if is_in_combo_window_for_attack3 and \
                          'attack_combo' in player.animations and player.animations['attack_combo']:
                           player.attack_type = 3
                           selected_attack2_anim_key = 'attack_combo' if is_moving_for_attack2_anim else 'attack_combo_nm'
                       elif player.is_crouching and 'crouch_attack' in player.animations and \
                            player.animations['crouch_attack'] and not player.is_attacking :
                           player.attack_type = 4; selected_attack2_anim_key = 'crouch_attack'
                       elif not player.is_attacking and 'attack2' in player.animations and player.animations['attack2']:
                           player.attack_type = 2
                           selected_attack2_anim_key = 'attack2' if is_moving_for_attack2_anim else 'attack2_nm'
                       elif not player.is_attacking and player.attack_type == 0 and \
                            'attack' in player.animations and player.animations['attack']:
                           player.attack_type = 1
                           selected_attack2_anim_key = 'attack' if is_moving_for_attack2_anim else 'attack_nm'
                       if selected_attack2_anim_key : player.set_state(selected_attack2_anim_key)

            if event.key == key_config_map['dash']:
                  if player.on_ground and not player.is_dashing and not player.is_rolling and \
                     not player.is_attacking and not player.is_crouching and not player.on_ladder and \
                     player.state not in ['turn','hit']:
                      player.set_state('dash')

            if event.key == key_config_map['roll']:
                  if player.on_ground and not player.is_rolling and not player.is_dashing and \
                     not player.is_attacking and not player.is_crouching and not player.on_ladder and \
                     player.state not in ['turn','hit']:
                      player.set_state('roll')

            if event.key == key_config_map['down']:
                can_initiate_slide_action = player.on_ground and player.state == 'run' and \
                                            abs(player.vel.x) > C.PLAYER_RUN_SPEED_LIMIT * 0.6 and \
                                            not player.is_sliding and not player.is_crouching and \
                                            not player.is_attacking and not player.is_rolling and \
                                            not player.is_dashing and not player.on_ladder and \
                                            player.state not in ['turn','hit']
                if can_initiate_slide_action:
                    slide_start_anim_key = 'slide_trans_start' if 'slide_trans_start' in player.animations and \
                                             player.animations['slide_trans_start'] else 'slide'
                    if slide_start_anim_key in player.animations and player.animations[slide_start_anim_key]:
                        player.set_state(slide_start_anim_key)
                        player.is_crouching = False
                else:
                    can_player_toggle_crouch = player.on_ground and not player.on_ladder and \
                                               not player.is_sliding and \
                                               not (player.is_dashing or player.is_rolling or player.is_attacking or \
                                                    player.state in ['turn','hit','death','death_nm'])
                    if can_player_toggle_crouch:
                        if not player.is_crouching:
                            player.is_crouching = True
                            player.is_sliding = False
                            if 'crouch_trans' in player.animations and player.animations['crouch_trans'] and \
                               player.state not in ['crouch','crouch_walk','crouch_trans']:
                                player.set_state('crouch_trans')
                            elif player.state not in ['crouch', 'crouch_walk', 'crouch_trans']:
                                player.set_state('crouch')
                        else:
                            player.is_crouching = False
                            if 'stand_up_trans' in player.animations and player.animations['stand_up_trans'] and \
                               player.state not in ['idle','run','stand_up_trans']:
                                player.set_state('stand_up_trans')

            if event.key == key_config_map['interact']:
                  if player.can_grab_ladder and not player.on_ladder:
                      player.is_crouching = False
                      player.on_ladder = True; player.vel.y=0; player.vel.x=0; player.on_ground=False
                      player.touching_wall=0; player.can_wall_jump=False; player.wall_climb_timer=0
                      player.set_state('ladder_idle')
                  elif player.on_ladder:
                      player.on_ladder = False
                      player.set_state('fall' if not player.on_ground else 'idle')

            # --- MODIFIED FIREBALL LOGIC ---
            if player.fireball_key and event.key == player.fireball_key:
                 if not player.is_crouching: # <-- ADDED THIS CHECK
                     print(f"DEBUG PIH (P{player.player_id}): Matched fireball key press ({event.key}) and not crouching. Calling player.fire_fireball().")
                     if hasattr(player, 'fire_fireball'):
                         player.fire_fireball()
                 else:
                     print(f"DEBUG PIH (P{player.player_id}): Matched fireball key press ({event.key}) BUT player is crouching. Fireball blocked.")
            # --- END OF MODIFIED FIREBALL LOGIC ---


    is_in_manual_override_or_transition_state = player.is_attacking or player.is_dashing or \
                                                player.is_rolling or player.is_sliding or \
                                                player.is_taking_hit or \
                                                player.state in [
                                                    'jump','turn','death','death_nm','hit','jump_fall_trans',
                                                    'crouch_trans', 'stand_up_trans',
                                                    'slide_trans_start','slide_trans_end',
                                                    'wall_climb','wall_climb_nm','wall_hang','wall_slide',
                                                    'ladder_idle','ladder_climb'
                                                ]

    if not is_in_manual_override_or_transition_state:
        if player.on_ladder:
            if abs(player.vel.y) > 0.1 :
                player.set_state('ladder_climb' if 'ladder_climb' in player.animations and \
                                 player.animations['ladder_climb'] else 'idle')
            else:
                player.set_state('ladder_idle' if 'ladder_idle' in player.animations and \
                                 player.animations['ladder_idle'] else 'idle')
        elif player.on_ground:
             if player.is_crouching:
                 target_crouch_state_key = 'crouch_walk' if player_intends_horizontal_move and \
                                             'crouch_walk' in player.animations and player.animations['crouch_walk'] \
                                             else 'crouch'
                 if player.state not in ['crouch', 'crouch_walk'] or player.state != target_crouch_state_key:
                    player.set_state(target_crouch_state_key if target_crouch_state_key in player.animations and \
                                     player.animations[target_crouch_state_key] else 'crouch')
             elif player_intends_horizontal_move:
                 player.set_state('run' if 'run' in player.animations and player.animations['run'] else 'idle')
             else:
                 player.set_state('idle')
        else:
             if player.touching_wall != 0:
                 current_wall_time_ms = pygame.time.get_ticks()
                 is_wall_climb_duration_expired = (player.wall_climb_duration > 0 and player.wall_climb_timer > 0 and
                                                   current_wall_time_ms - player.wall_climb_timer > player.wall_climb_duration)
                 if player.vel.y > C.PLAYER_WALL_SLIDE_SPEED * 0.5 or is_wall_climb_duration_expired:
                     player.set_state('wall_slide'); player.can_wall_jump = True
                 elif player.is_holding_climb_ability_key and abs(player.vel.x) < 1.0 and \
                      not is_wall_climb_duration_expired and 'wall_climb' in player.animations and player.animations['wall_climb']:
                     player.set_state('wall_climb'); player.can_wall_jump = False
                 else:
                     player.set_state('wall_slide'); player.can_wall_jump = True
             elif player.vel.y > 1.0 and player.state not in ['jump','jump_fall_trans']:
                  player.set_state('fall' if 'fall' in player.animations and player.animations['fall'] else 'idle')
             elif player.state not in ['jump','jump_fall_trans','fall']:
                  player.set_state('idle')

########## START OF FILE: player_movement_physics.py ##########

# player_movement_physics.py
# -*- coding: utf-8 -*-
import pygame
import constants as C
from player_collision_handler import ( 
    check_player_platform_collisions,
    check_player_ladder_collisions,
    check_player_character_collisions,
    check_player_hazard_collisions
)
from player_animation_handler import update_player_animation
from player_state_handler import set_player_state 

# Import the shared logging flag and helper function from logger.py
from logger import info, debug, warning, error, critical, ENABLE_DETAILED_PHYSICS_LOGS, log_player_physics 


def manage_player_state_timers_and_cooldowns(player):
    current_time_ms = pygame.time.get_ticks()
    if player.is_dashing and current_time_ms - player.dash_timer > player.dash_duration:
        player.is_dashing = False
        set_player_state(player, 'idle' if player.on_ground else 'fall')
    if player.is_rolling and current_time_ms - player.roll_timer > player.roll_duration:
        player.is_rolling = False
        set_player_state(player, 'idle' if player.on_ground else 'fall')
    if player.is_sliding and current_time_ms - player.slide_timer > player.slide_duration:
        if player.state == 'slide':
            player.is_sliding = False
            slide_end_anim_key = 'slide_trans_end' if 'slide_trans_end' in player.animations else None
            if slide_end_anim_key: set_player_state(player, slide_end_anim_key)
            else: set_player_state(player, 'crouch' if player.is_holding_crouch_ability_key else 'idle')
    if player.is_taking_hit and current_time_ms - player.hit_timer > player.hit_cooldown:
        if player.state == 'hit': player.is_taking_hit = False
        else: player.is_taking_hit = False

def apply_player_movement_and_physics(player):
    should_apply_gravity = not (
        player.on_ladder or player.state == 'wall_hang' or
        (player.state == 'wall_climb' and player.vel.y <= C.PLAYER_WALL_CLIMB_SPEED + 0.1) or
        player.is_dashing
    )
    if should_apply_gravity: player.vel.y += player.acc.y

    should_apply_horizontal_physics = not (
        player.is_dashing or player.is_rolling or player.on_ladder or
        (player.state == 'wall_climb' and player.vel.y <= C.PLAYER_WALL_CLIMB_SPEED + 0.1)
    )
    if should_apply_horizontal_physics:
        player.vel.x += player.acc.x
        friction_coeff = 0
        if player.on_ground and player.acc.x == 0 and not player.is_sliding and player.state != 'slide': friction_coeff = C.PLAYER_FRICTION
        elif not player.on_ground and not player.is_attacking and player.state not in ['wall_slide','wall_hang','wall_climb','wall_climb_nm']: friction_coeff = C.PLAYER_FRICTION * 0.2
        elif player.is_sliding or player.state == 'slide': friction_coeff = C.PLAYER_FRICTION * 0.7
        if friction_coeff != 0:
             friction_force = player.vel.x * friction_coeff
             if abs(player.vel.x) > 0.1: player.vel.x += friction_force
             else: player.vel.x = 0
             if abs(player.vel.x) < 0.5 and (player.is_sliding or player.state == 'slide'):
                 player.is_sliding = False
                 slide_end_key = 'slide_trans_end' if 'slide_trans_end' in player.animations and player.animations['slide_trans_end'] else None
                 if slide_end_key: set_player_state(player, slide_end_key)
                 else:
                     player.is_crouching = player.is_holding_crouch_ability_key
                     set_player_state(player, 'crouch' if player.is_crouching else 'idle')
        current_h_speed_limit = C.PLAYER_RUN_SPEED_LIMIT
        if player.is_crouching and player.state == 'crouch_walk': current_h_speed_limit *= 0.6
        if not player.is_dashing and not player.is_rolling and not player.is_sliding and player.state != 'slide':
            player.vel.x = max(-current_h_speed_limit, min(current_h_speed_limit, player.vel.x))
    if player.vel.y > 0 and not player.on_ladder:
        player.vel.y = min(player.vel.y, getattr(C, 'TERMINAL_VELOCITY_Y', 18))

def update_player_core_logic(player, dt_sec, platforms_group, ladders_group, hazards_group,
                             other_players_list, enemies_list):
    if not player._valid_init: return
    log_player_physics(player, "UPDATE_START")

    if player.is_dead:
        if player.alive() and hasattr(player, 'animate'):
            if not player.death_animation_finished:
                if not player.on_ground:
                    player.vel.y += player.acc.y
                    player.vel.y = min(player.vel.y, getattr(C, 'TERMINAL_VELOCITY_Y', 18))
                    player.pos.y += player.vel.y
                    player.rect.midbottom = (round(player.pos.x), round(player.pos.y))
                    player.on_ground = False
                    for platform_sprite in pygame.sprite.spritecollide(player, platforms_group, False):
                        if player.vel.y > 0 and player.rect.bottom > platform_sprite.rect.top and \
                           (player.pos.y - player.vel.y) <= platform_sprite.rect.top + 1:
                            player.rect.bottom = platform_sprite.rect.top
                            player.on_ground = True; player.vel.y = 0; player.acc.y = 0
                            player.pos = pygame.math.Vector2(player.rect.midbottom); break
            update_player_animation(player)
        log_player_physics(player, "UPDATE_END", "Player is dead")
        debug("------------------------------") # Use the imported debug
        return

    manage_player_state_timers_and_cooldowns(player)
    check_player_ladder_collisions(player, ladders_group)
    if player.on_ladder and not player.can_grab_ladder:
        player.on_ladder = False
        set_player_state(player, 'fall' if not player.on_ground else 'idle')
    apply_player_movement_and_physics(player)

    player.touching_wall = 0
    player.on_ground = False

    # --- HORIZONTAL MOVEMENT & COLLISION ---
    player.pos.x += player.vel.x
    player.rect.midbottom = (round(player.pos.x), round(player.pos.y)) 
    log_player_physics(player, "X_MOVE_APPLIED")
    
    check_player_platform_collisions(player, 'x', platforms_group) 
    log_player_physics(player, "X_PLAT_COLL_DONE")

    all_other_char_sprites = [p for p in other_players_list if p and p._valid_init and p.alive() and p is not player] + \
                             [e for e in enemies_list if e and e._valid_init and e.alive()]
    collided_horizontally_char = check_player_character_collisions(player, 'x', all_other_char_sprites) 

    if collided_horizontally_char:
        log_player_physics(player, "X_CHAR_COLL_POST")
        player.rect.midbottom = (round(player.pos.x), round(player.pos.y)) 
        check_player_platform_collisions(player, 'x', platforms_group) 
        log_player_physics(player, "X_PLAT_RECHECK")

    # --- VERTICAL MOVEMENT & COLLISION ---
    player.pos.y += player.vel.y
    player.rect.midbottom = (round(player.pos.x), round(player.pos.y))
    log_player_physics(player, "Y_MOVE_APPLIED")
    
    check_player_platform_collisions(player, 'y', platforms_group)
    log_player_physics(player, "Y_PLAT_COLL_DONE")

    collided_vertically_char = False
    if not collided_horizontally_char:
        collided_vertically_char = check_player_character_collisions(player, 'y', all_other_char_sprites)
        if collided_vertically_char:
            log_player_physics(player, "Y_CHAR_COLL_POST")
            player.rect.midbottom = (round(player.pos.x), round(player.pos.y))
            check_player_platform_collisions(player, 'y', platforms_group)
            log_player_physics(player, "Y_PLAT_RECHECK")
    
    player.pos = pygame.math.Vector2(player.rect.midbottom) 
    log_player_physics(player, "FINAL_POS_SYNC")
    
    check_player_hazard_collisions(player, hazards_group)

    if player.alive() and not player.is_dead and player.is_attacking:
        targets_for_player_attack = [p for p in other_players_list if p and p._valid_init and p.alive() and p is not player] + \
                                    [e for e in enemies_list if e and e._valid_init and e.alive()]
        player.check_attack_collisions(targets_for_player_attack)

    update_player_animation(player)
    log_player_physics(player, "UPDATE_END")
    debug("------------------------------")

########## START OF FILE: player_network_handler.py ##########

########## START OF FILE: player_network_handler.py ##########

# player_network_handler.py
# -*- coding: utf-8 -*-
"""
version 1.0000000.1
Handles network-related data serialization, deserialization, and input processing
for the Player class in a networked environment.
Functions here will typically take a 'player' instance as their first argument.
"""
import pygame
import constants as C # For potential network-related constants if any

def get_player_network_data(player):
    """
    Gathers essential player data into a dictionary for network transmission.

    Args:
        player (Player): The player instance whose data is being serialized.

    Returns:
        dict: A dictionary containing the player's network-relevant state.
    """
    # Ensure all serialized values are basic Python types (int, float, bool, str, list, dict)
    # Pygame Vector2 needs to be converted to a tuple of floats.
    data = {
        'player_id': player.player_id, 
        '_valid_init': player._valid_init, # Important for client to know if player is valid
        
        'pos': (player.pos.x, player.pos.y), 
        'vel': (player.vel.x, player.vel.y), 
        'facing_right': player.facing_right, 
        
        'state': player.state, # Current logical state string
        'current_frame': player.current_frame, 
        'last_anim_update': player.last_anim_update, # Timestamp for animation sync
        
        'current_health': player.current_health, 
        'is_dead': player.is_dead,
        'death_animation_finished': player.death_animation_finished,
        
        'is_attacking': player.is_attacking, 
        'attack_type': player.attack_type,
        # Add other relevant boolean flags if needed for precise state replication
        'is_crouching': player.is_crouching,
        'is_dashing': player.is_dashing,
        'is_rolling': player.is_rolling,
        'is_sliding': player.is_sliding,
        'on_ladder': player.on_ladder,
        'is_taking_hit': player.is_taking_hit, # To sync hit stun visuals/invincibility
        
        # Fireball aim direction is crucial for remote players to see where fireballs might go
        'fireball_aim_x': player.fireball_last_input_dir.x, 
        'fireball_aim_y': player.fireball_last_input_dir.y
    }
    # print(f"DEBUG PNH (get_player_network_data) for P{player.player_id}: pos={data['pos']}, valid={data['_valid_init']}, alive (instance): {player.alive() if hasattr(player, 'alive') else 'N/A'}") # DEBUG
    return data

def set_player_network_data(player, network_data): 
    """
    Applies received network data to update the local player instance's state.
    This is typically used on clients to reflect the server's authoritative state,
    or on the server to update a remote player's placeholder.

    Args:
        player (Player): The player instance to be updated.
        network_data (dict): The dictionary of player state received over the network.
    """
    if network_data is None:
        # print(f"DEBUG PNH (set_player_network_data) for P{player.player_id}: Received None network_data. No update.") # DEBUG
        return

    # print(f"DEBUG PNH (set_player_network_data) for P{player.player_id}: Applying network data. Current valid: {player._valid_init}, alive: {player.alive() if hasattr(player, 'alive') else 'N/A'}. Net valid: {network_data.get('_valid_init')}, Net pos: {network_data.get('pos')}") # DEBUG
    
    player_id_from_data = network_data.get('player_id', 'Unknown') # For logging

    # Critical: Update _valid_init first.
    new_valid_init = network_data.get('_valid_init', player._valid_init)
    if player._valid_init != new_valid_init:
        # print(f"DEBUG PNH (set_player_network_data) for P{player_id_from_data}: _valid_init changed from {player._valid_init} to {new_valid_init}") # DEBUG
        player._valid_init = new_valid_init
    
    if not player._valid_init:
        if player.alive(): 
            # print(f"DEBUG PNH (set_player_network_data) for P{player_id_from_data}: Player became invalid, killing sprite.") # DEBUG
            player.kill()  
        return 

    pos_data = network_data.get('pos')
    if pos_data: 
        # print(f"DEBUG PNH (set_player_network_data) for P{player_id_from_data}: Old Pos: {player.pos}, New Net Pos: {pos_data}") # DEBUG
        player.pos.x, player.pos.y = pos_data
    
    vel_data = network_data.get('vel')
    if vel_data: player.vel.x, player.vel.y = vel_data
    
    player.facing_right = network_data.get('facing_right', player.facing_right)
    
    player.current_health = network_data.get('current_health', player.current_health)
    new_is_dead_from_net = network_data.get('is_dead', player.is_dead)
    player.death_animation_finished = network_data.get('death_animation_finished', player.death_animation_finished)

    if new_is_dead_from_net and not player.is_dead: 
        # print(f"DEBUG PNH (set_player_network_data) for P{player_id_from_data}: Transitioning to DEAD from network.") # DEBUG
        player.is_dead = True
        player.current_health = 0 
        player.set_state('death') 
    elif not new_is_dead_from_net and player.is_dead: 
        # print(f"DEBUG PNH (set_player_network_data) for P{player_id_from_data}: Transitioning to ALIVE from network (was dead).") # DEBUG
        player.is_dead = False
        player.death_animation_finished = False 
        if player.state in ['death', 'death_nm']: 
            player.set_state('idle') 
    else: 
        player.is_dead = new_is_dead_from_net 

    player.is_attacking = network_data.get('is_attacking', player.is_attacking)
    player.attack_type = network_data.get('attack_type', player.attack_type)
    player.is_crouching = network_data.get('is_crouching', player.is_crouching)
    player.is_dashing = network_data.get('is_dashing', player.is_dashing)
    player.is_rolling = network_data.get('is_rolling', player.is_rolling)
    player.is_sliding = network_data.get('is_sliding', player.is_sliding)
    player.on_ladder = network_data.get('on_ladder', player.on_ladder)
    
    new_is_taking_hit_from_net = network_data.get('is_taking_hit', player.is_taking_hit)
    if new_is_taking_hit_from_net and not player.is_taking_hit: 
        player.is_taking_hit = True
        player.hit_timer = pygame.time.get_ticks() 
        if player.state != 'hit' and not player.is_dead : player.set_state('hit') 
    elif not new_is_taking_hit_from_net and player.is_taking_hit: 
        player.is_taking_hit = False
        if player.state == 'hit' and not player.is_dead : player.set_state('idle') 

    new_logical_state_from_net = network_data.get('state', player.state)
    if player.state != new_logical_state_from_net and \
       not (player.is_dead and new_logical_state_from_net in ['death', 'death_nm']):
         # print(f"DEBUG PNH (set_player_network_data) for P{player_id_from_data}: Setting state from '{player.state}' to '{new_logical_state_from_net}'") # DEBUG
         player.set_state(new_logical_state_from_net)
    else: 
        player.current_frame = network_data.get('current_frame', player.current_frame)
        player.last_anim_update = network_data.get('last_anim_update', player.last_anim_update)
    
    fb_aim_x_net = network_data.get('fireball_aim_x')
    fb_aim_y_net = network_data.get('fireball_aim_y')
    if fb_aim_x_net is not None and fb_aim_y_net is not None:
        player.fireball_last_input_dir.x = float(fb_aim_x_net)
        player.fireball_last_input_dir.y = float(fb_aim_y_net)
    
    player.rect.midbottom = (round(player.pos.x), round(player.pos.y))
    # print(f"DEBUG PNH (set_player_network_data) for P{player_id_from_data}: Updated rect.midbottom to {player.rect.midbottom}") # DEBUG
    
    if player._valid_init and player.alive(): 
        # print(f"DEBUG PNH (set_player_network_data) for P{player_id_from_data}: Player valid and alive, calling animate().") # DEBUG
        player.animate()
    # else: # DEBUG
        # print(f"DEBUG PNH (set_player_network_data) for P{player_id_from_data}: Player NOT valid or NOT alive. Valid: {player._valid_init}, Alive: {player.alive() if hasattr(player, 'alive') else 'N/A'}. Skipping animate.") # DEBUG


def handle_player_network_input(player, received_input_data_dict): 
    """
    Processes input data received over the network for this player instance.
    This is used by the server to update a remote player's actions based on
    what their client sent. It's a simplified version of local input processing.

    Args:
        player (Player): The player instance whose actions are being driven by network input.
        received_input_data_dict (dict): The input state dictionary from the client.
    """
    # print(f"DEBUG PNH (handle_player_network_input) for P{player.player_id}: Processing input: {received_input_data_dict}") # DEBUG
    if not player._valid_init or player.is_dead or not player.alive():
        # print(f"DEBUG PNH (handle_player_network_input) for P{player.player_id}: Input ignored, player not valid/alive. Valid: {player._valid_init}, Dead: {player.is_dead}, Alive: {player.alive() if hasattr(player,'alive') else 'N/A'}") # DEBUG
        return

    player.acc.x = 0 
    
    intends_move_left_net = received_input_data_dict.get('left_held', False)
    intends_move_right_net = received_input_data_dict.get('right_held', False)
    
    net_fireball_aim_x = received_input_data_dict.get('fireball_aim_x')
    net_fireball_aim_y = received_input_data_dict.get('fireball_aim_y')
    if net_fireball_aim_x is not None and net_fireball_aim_y is not None:
        if float(net_fireball_aim_x) != 0.0 or float(net_fireball_aim_y) != 0.0:
            player.fireball_last_input_dir.x = float(net_fireball_aim_x)
            player.fireball_last_input_dir.y = float(net_fireball_aim_y)
    
    can_control_horizontal_via_net = not (
        player.is_dashing or player.is_rolling or player.is_sliding or player.on_ladder or
        (player.is_attacking and player.state in ['attack_nm','attack2_nm','attack_combo_nm','crouch_attack']) or
        player.state in ['turn','hit','death','death_nm','wall_climb','wall_climb_nm','wall_hang']
    )
    
    new_facing_direction_net = player.facing_right 
    if can_control_horizontal_via_net:
        if intends_move_left_net and not intends_move_right_net:
            player.acc.x = -C.PLAYER_ACCEL
            new_facing_direction_net = False
        elif intends_move_right_net and not intends_move_left_net:
            player.acc.x = C.PLAYER_ACCEL
            new_facing_direction_net = True
            
    if player.on_ground and player.state in ['idle', 'run'] and not player.is_attacking and \
       player.facing_right != new_facing_direction_net:
        player.facing_right = new_facing_direction_net
        player.set_state('turn') 
    else: 
        player.facing_right = new_facing_direction_net
    
    can_perform_action_net = not player.is_attacking and not player.is_dashing and \
                             not player.is_rolling and not player.is_sliding and \
                             not player.on_ladder and player.state not in ['turn','hit']
    
    if received_input_data_dict.get('attack1_pressed_event', False) and can_perform_action_net:
        player.attack_type = 4 if player.is_crouching else 1 
        attack_anim_key_net = 'crouch_attack' if player.is_crouching else \
                              ('attack' if (intends_move_left_net or intends_move_right_net) else 'attack_nm')
        player.set_state(attack_anim_key_net)
    
    if received_input_data_dict.get('attack2_pressed_event', False) and can_perform_action_net:
        player.attack_type = 4 if player.is_crouching else 2 
        attack2_anim_key_net = 'crouch_attack' if player.is_crouching else \
                               ('attack2' if (intends_move_left_net or intends_move_right_net) else 'attack2_nm')
        player.set_state(attack2_anim_key_net)

    if received_input_data_dict.get('fireball_pressed_event', False) and can_perform_action_net:
        if hasattr(player, 'fire_fireball'): 
             player.fire_fireball() 

    if received_input_data_dict.get('jump_intent', False) and can_perform_action_net and not player.is_crouching:
         if player.on_ground: 
             player.vel.y = C.PLAYER_JUMP_STRENGTH
             player.set_state('jump')
             player.on_ground = False 

    if received_input_data_dict.get('dash_pressed_event', False) and player.on_ground and \
       can_perform_action_net and not player.is_crouching:
        player.set_state('dash')
    
    if received_input_data_dict.get('roll_pressed_event', False) and player.on_ground and \
       can_perform_action_net and not player.is_crouching:
        player.set_state('roll')
    
    # Set player's intention flags based on network input for server-side update logic
    player.is_holding_crouch_ability_key = received_input_data_dict.get('down_held', False)
    player.is_holding_climb_ability_key = received_input_data_dict.get('up_held', False)
    # print(f"DEBUG PNH (handle_player_network_input) for P{player.player_id}: Accel.x set to {player.acc.x}, FacingRight: {player.facing_right}") # DEBUG


def get_player_input_state_for_network(player, current_pygame_keys, current_pygame_events, key_map):
    """
    Gathers the local player's current input state into a dictionary format
    suitable for sending over the network.

    Args:
        player (Player): The local player instance (used for player_id and fireball_key config).
        current_pygame_keys: The result of pygame.key.get_pressed().
        current_pygame_events: The list from pygame.event.get().
        key_map (dict): The key mapping for this player's controls.

    Returns:
        dict: A dictionary representing the player's input state.
    """
    input_state_dict = {
        'left_held': bool(current_pygame_keys[key_map['left']]),
        'right_held': bool(current_pygame_keys[key_map['right']]),
        'up_held': bool(current_pygame_keys[key_map['up']]),
        'down_held': bool(current_pygame_keys[key_map['down']]),
        
        'attack1_pressed_event': False, 
        'attack2_pressed_event': False,
        'dash_pressed_event': False, 
        'roll_pressed_event': False,
        'interact_pressed_event': False, 
        'jump_intent': False, 
        'fireball_pressed_event': False,
        
        'fireball_aim_x': player.fireball_last_input_dir.x, 
        'fireball_aim_y': player.fireball_last_input_dir.y
    }
    
    for event in current_pygame_events:
        if event.type == pygame.KEYDOWN:
            if event.key == key_map.get('attack1'): input_state_dict["attack1_pressed_event"] = True
            if event.key == key_map.get('attack2'): input_state_dict["attack2_pressed_event"] = True
            if event.key == key_map.get('dash'): input_state_dict["dash_pressed_event"] = True
            if event.key == key_map.get('roll'): input_state_dict["roll_pressed_event"] = True
            if event.key == key_map.get('interact'): input_state_dict["interact_pressed_event"] = True
            if event.key == key_map.get('up'): input_state_dict["jump_intent"] = True 
            
            if player.fireball_key and event.key == player.fireball_key:
                input_state_dict['fireball_pressed_event'] = True
                
    # print(f"DEBUG PNH (get_player_input_state_for_network) for P{player.player_id}: Generated input state: {input_state_dict}") # DEBUG
    return input_state_dict

########## END OF FILE: player_network_handler.py ##########

########## START OF FILE: player_state_handler.py ##########

# player_state_handler.py
# -*- coding: utf-8 -*-
"""
## version 1.0.0.2 (Clarified interaction with animation handler)
Handles player state transitions and state-specific initializations.
"""
import pygame
import constants as C
from utils import PrintLimiter # Assuming PrintLimiter is accessible

def set_player_state(player, new_state: str):
    """
    Sets the player's logical state, handling transitions and
    state-specific initializations. Calls update_player_animation to refresh visuals.
    Operates on the 'player' instance.
    """
    if not player._valid_init: return

    original_new_state_request = new_state

    # Ensure the requested state has animations, or fallback
    animation_frames_for_new_state = player.animations.get(new_state)
    if not animation_frames_for_new_state:
        fallback_state_key = 'fall' if not player.on_ground else 'idle'
        if fallback_state_key in player.animations and player.animations[fallback_state_key]:
            new_state = fallback_state_key
            if player.print_limiter.can_print(f"player_set_state_fallback_{player.player_id}_{original_new_state_request}"):
                print(f"Player Warning (P{player.player_id}): State '{original_new_state_request}' anim missing. Fallback to '{new_state}'.")
        else: # Critical fallback if even idle/fall are missing
            first_available_anim_key = next((key for key, anim in player.animations.items() if anim), None)
            if not first_available_anim_key:
                if player.print_limiter.can_print(f"player_set_state_no_anims_{player.player_id}"):
                    print(f"CRITICAL Player Error (P{player.player_id}): No animations loaded. Requested: '{original_new_state_request}'. Player invalid.")
                player._valid_init = False; return # Cannot proceed
            new_state = first_available_anim_key
            if player.print_limiter.can_print(f"player_set_state_critical_fallback_{player.player_id}_{original_new_state_request}"):
                print(f"Player CRITICAL Warning (P{player.player_id}): State '{original_new_state_request}' and preferred fallbacks missing. Using first available: '{new_state}'.")

    # Determine if state can actually change
    can_change_state_now = (player.state != new_state or new_state in getattr(player, 'allow_state_reset_list', ['death'])) and \
                           not (player.is_dead and player.death_animation_finished and new_state != 'death')


    if can_change_state_now:
        # Debug info
        if player.state != new_state and player.print_limiter.can_print(f"state_change_{player.player_id}_{player.state}_{new_state}"):
             print(f"DEBUG P_STATE_H (P{player.player_id}): State changing from '{player.state}' to '{new_state}' (request was '{original_new_state_request}')")
        player._last_state_for_debug = new_state # For external debug viewing

        # Reset general boolean flags based on new state
        if 'attack' not in new_state and player.is_attacking: player.is_attacking = False; player.attack_type = 0
        if new_state != 'hit': player.is_taking_hit = False
        if new_state != 'dash': player.is_dashing = False
        if new_state != 'roll': player.is_rolling = False
        if new_state not in ['slide', 'slide_trans_start', 'slide_trans_end']: player.is_sliding = False
        # Note: player.is_crouching is managed by input_handler based on toggle,
        # this function just sets the visual state (e.g. 'crouch', 'crouch_trans')

        # Set the new state and reset animation/state timers
        player.state = new_state
        player.current_frame = 0 # Always reset frame for new state
        player.last_anim_update = pygame.time.get_ticks()
        player.state_timer = pygame.time.get_ticks() # Timer for how long player is in this state

        # State-specific initializations (velocities, timers, specific flags)
        if new_state == 'dash':
            player.is_dashing = True
            player.dash_timer = player.state_timer # Store start time of dash
            player.vel.x = C.PLAYER_DASH_SPEED * (1 if player.facing_right else -1)
            player.vel.y = 0 # Dash is horizontal
        elif new_state == 'roll':
            player.is_rolling = True
            player.roll_timer = player.state_timer
            # Give a speed boost if rolling from standstill or slow
            if abs(player.vel.x) < C.PLAYER_ROLL_SPEED * 0.7:
                player.vel.x = C.PLAYER_ROLL_SPEED * (1 if player.facing_right else -1)
            else: # Maintain some existing momentum if already fast
                player.vel.x = player.vel.x * 0.8 + (C.PLAYER_ROLL_SPEED * 0.2 * (1 if player.facing_right else -1))
            player.vel.x = max(-C.PLAYER_ROLL_SPEED, min(C.PLAYER_ROLL_SPEED, player.vel.x))
        elif new_state == 'slide' or new_state == 'slide_trans_start':
            player.is_sliding = True
            player.slide_timer = player.state_timer
            if abs(player.vel.x) < C.PLAYER_RUN_SPEED_LIMIT * 0.5: # Ensure some speed for slide
                 player.vel.x = C.PLAYER_RUN_SPEED_LIMIT * 0.6 * (1 if player.facing_right else -1)
        elif 'attack' in new_state: # Covers 'attack', 'attack_nm', 'crouch_attack', etc.
            player.is_attacking = True
            player.attack_timer = player.state_timer
            # Calculate attack duration based on animation frames
            animation_for_this_attack = player.animations.get(new_state, [])
            num_attack_frames = len(animation_for_this_attack)
            base_ms_per_frame = C.ANIM_FRAME_DURATION
            if player.attack_type == 2 and hasattr(C, 'PLAYER_ATTACK2_FRAME_DURATION_MULTIPLIER'):
                ms_per_frame = int(base_ms_per_frame * C.PLAYER_ATTACK2_FRAME_DURATION_MULTIPLIER)
            else:
                ms_per_frame = base_ms_per_frame
            player.attack_duration = num_attack_frames * ms_per_frame if num_attack_frames > 0 else getattr(C, 'CHARACTER_ATTACK_STATE_DURATION', 300)

            if new_state.endswith('_nm') or new_state == 'crouch_attack': # Non-moving attacks
                player.vel.x = 0 # Stop horizontal movement for stationary attacks
        elif new_state == 'hit':
            player.is_taking_hit = True
            player.hit_timer = player.state_timer
            # Simple knockback example
            if not player.on_ground and player.vel.y > -abs(C.PLAYER_JUMP_STRENGTH * 0.5): # If in air and not already moving up fast
                player.vel.x *= -0.3 # Reverse and reduce horizontal
                player.vel.y = C.PLAYER_JUMP_STRENGTH * 0.4 # Small pop-up
            player.is_attacking = False; player.attack_type = 0 # Cancel attacks
        elif new_state == 'death' or new_state == 'death_nm':
            player.is_dead = True
            player.vel.x = 0
            if player.vel.y < -1: player.vel.y = 1 # Don't fly up on death
            player.acc.x = 0
            if not player.on_ground: player.acc.y = C.PLAYER_GRAVITY # Fall if in air
            else: player.vel.y = 0; player.acc.y = 0 # Stay on ground
            player.death_animation_finished = False
        elif new_state == 'wall_climb':
            player.wall_climb_timer = player.state_timer # For climb duration limit
            player.vel.y = C.PLAYER_WALL_CLIMB_SPEED # Move up wall
            player.vel.x = 0 # Stop horizontal movement against wall
        elif new_state == 'wall_slide' or new_state == 'wall_hang':
            player.wall_climb_timer = 0 # Reset climb duration timer

        # Update animation immediately to reflect the new state's first frame
        # This call will handle correct rect anchoring.
        from player_animation_handler import update_player_animation # Local import is good practice here
        update_player_animation(player)

    elif not player.is_dead: # If state didn't change, but for debug
         player._last_state_for_debug = player.state

########## START OF FILE: projectiles.py ##########

# projectiles.py
# -*- coding: utf-8 -*-
"""
Defines projectile classes like Fireball.
"""
# version 1.0.1 (fixed length_sq typo in init)
import pygame
import os # For path joining
import constants as C
from assets import load_gif_frames, resource_path

class Fireball(pygame.sprite.Sprite):
    def __init__(self, x, y, direction_vector, owner_player):
        super().__init__()
        self.owner_player = owner_player
        self.damage = C.FIREBALL_DAMAGE
        self.speed = C.FIREBALL_SPEED

        full_gif_path = resource_path(C.FIREBALL_SPRITE_PATH)
        self.frames = load_gif_frames(full_gif_path)
        
        if not self.frames or \
           (len(self.frames) == 1 and self.frames[0].get_size() == (30,40) and self.frames[0].get_at((0,0)) == C.RED): 
            print(f"Warning: Fireball GIF '{full_gif_path}' failed to load or is default placeholder. Using fallback.")
            self.image = pygame.Surface(C.FIREBALL_DIMENSIONS, pygame.SRCALPHA).convert_alpha()
            self.image.fill((0,0,0,0)) 
            pygame.draw.circle(self.image, (255, 120, 0, 200), (C.FIREBALL_DIMENSIONS[0]//2, C.FIREBALL_DIMENSIONS[1]//2), C.FIREBALL_DIMENSIONS[0]//3)
            pygame.draw.circle(self.image, C.RED, (C.FIREBALL_DIMENSIONS[0]//2, C.FIREBALL_DIMENSIONS[1]//2), C.FIREBALL_DIMENSIONS[0]//4)
            self.frames = [self.image]
        
        self.current_frame_index = 0
        self.image = self.frames[self.current_frame_index]
        self.rect = self.image.get_rect(center=(x, y))
        self.pos = pygame.math.Vector2(self.rect.center)

        # <<< CORRECTED HERE >>>
        if direction_vector.length_squared() > 0: # Was length_sq()
            self.vel = direction_vector.normalize() * self.speed
        else: 
            self.vel = pygame.math.Vector2(1 if owner_player.facing_right else -1, 0) * self.speed
        
        self.spawn_time = pygame.time.get_ticks()
        self.last_anim_update = self.spawn_time
        self.projectile_id = f"fb_{getattr(owner_player, 'player_id', 'unknown')}_{self.spawn_time}"

    def animate(self):
        now = pygame.time.get_ticks()
        anim_duration = C.ANIM_FRAME_DURATION / 1.5 
        if now - self.last_anim_update > anim_duration:
            self.last_anim_update = now
            self.current_frame_index = (self.current_frame_index + 1) % len(self.frames)
            old_center = self.rect.center
            self.image = self.frames[self.current_frame_index]
            if self.vel.x < 0: 
                 self.image = pygame.transform.flip(self.frames[self.current_frame_index], True, False)
            else:
                 self.image = self.frames[self.current_frame_index]
            self.rect = self.image.get_rect(center=old_center)

    def update(self, dt_sec, platforms, characters_to_hit_group): 
        self.pos += self.vel 
        self.rect.center = round(self.pos.x), round(self.pos.y)
        self.animate()

        if pygame.time.get_ticks() - self.spawn_time > C.FIREBALL_LIFESPAN:
            self.kill()
            return

        if pygame.sprite.spritecollideany(self, platforms):
            self.kill()
            return

        hit_characters = pygame.sprite.spritecollide(self, characters_to_hit_group, False)
        for char in hit_characters:
            if char is self.owner_player and (pygame.time.get_ticks() - self.spawn_time < 100): 
                continue
            if char is self.owner_player and not getattr(C, "ALLOW_SELF_FIREBALL_DAMAGE", False): 
                continue

            if hasattr(char, 'take_damage') and callable(char.take_damage):
                can_damage_target = True
                if hasattr(char, 'is_taking_hit') and hasattr(char, 'hit_timer') and hasattr(char, 'hit_cooldown'):
                    now = pygame.time.get_ticks()
                    if char.is_taking_hit and (now - char.hit_timer < char.hit_cooldown):
                        can_damage_target = False
                
                if can_damage_target:
                    char.take_damage(self.damage)
                    self.kill()
                    return 
        
    def get_network_data(self):
        return {
            'id': self.projectile_id,
            'pos': (self.pos.x, self.pos.y),
            'vel': (self.vel.x, self.vel.y), 
            'owner_id': self.owner_player.player_id if self.owner_player else None,
            'frame': self.current_frame_index,
            'spawn_time': self.spawn_time,
            'image_flipped': self.vel.x < 0 
        }

    def set_network_data(self, data):
        self.pos.x, self.pos.y = data['pos']
        if 'vel' in data:
             self.vel.x, self.vel.y = data['vel']
        self.rect.center = round(self.pos.x), round(self.pos.y)
        self.current_frame_index = data.get('frame', self.current_frame_index)
        old_center = self.rect.center
        base_image = self.frames[self.current_frame_index]
        if data.get('image_flipped', False):
            self.image = pygame.transform.flip(base_image, True, False)
        else:
            self.image = base_image
        self.rect = self.image.get_rect(center=old_center)

########## START OF FILE: server_logic.py ##########

# server_logic.py
# -*- coding: utf-8 -*-
"""
version 1.0.0.2 (Changed reset key from R to Q)
Handles server-side game logic, connection management, and broadcasting.
"""
import pygame
import socket
import threading
import time
import traceback
from typing import Optional
import os # For file operations
import constants as C
from network_comms import get_local_ip, encode_data, decode_data_stream
from game_state_manager import get_network_game_state, reset_game_state
from enemy import Enemy # For print_limiter access if needed, or just for type hinting
import game_ui
from game_ui import draw_platformer_scene_on_surface, draw_download_dialog # Added draw_download_dialog

# Shared lock for client connection and input buffer
client_lock = threading.Lock()

class ServerState:
    """
    A simple class to hold server-specific shared state used by the server's
    main loop and its threads. This helps in managing shared resources and
    the running state of the server components.
    """
    def __init__(self):
        self.client_connection = None  # Holds the active client socket object
        self.client_address = None     # Holds the (IP, port) of the active client
        self.client_input_buffer = {}  # Stores the last processed input from the client
        self.app_running = True        # Global flag: True if the application is running
        
        # Network socket objects
        self.server_tcp_socket = None  # TCP socket for listening to client connections
        self.server_udp_socket = None  # UDP socket for broadcasting server presence
        
        # Thread objects
        self.broadcast_thread = None       # Thread for LAN broadcasting
        self.client_handler_thread = None  # Thread for handling communication with the connected client
        
        # Configuration (can be loaded from constants.py or passed)
        self.service_name = getattr(C, "SERVICE_NAME", "platformer_adventure_lan_v1")
        self.discovery_port_udp = getattr(C, "DISCOVERY_PORT_UDP", 5556)
        self.server_port_tcp = getattr(C, "SERVER_PORT_TCP", 5555)
        self.buffer_size = getattr(C, "BUFFER_SIZE", 8192)
        self.broadcast_interval_s = getattr(C, "BROADCAST_INTERVAL_S", 1.0)

        # Map synchronization state
        self.current_map_name: Optional[str] = None
        self.client_map_status: str = "unknown" # "unknown", "present", "missing", "downloading_requested", "downloading_ack", "error"
        self.client_download_progress: float = 0.0
        self.game_start_signaled_to_client: bool = False # To ensure start_game_now is sent once


def broadcast_presence_thread(server_state_obj: ServerState):
    """
    Thread function to periodically broadcast the server's presence on the LAN.
    Uses UDP to send a discovery message.
    """
    current_lan_ip = get_local_ip() 
    broadcast_message_dict = {
        "service": server_state_obj.service_name,
        "tcp_ip": current_lan_ip,
        "tcp_port": server_state_obj.server_port_tcp
    }
    broadcast_message_bytes = encode_data(broadcast_message_dict)

    if not broadcast_message_bytes:
        print("Server Error: Could not encode broadcast message for presence.")
        return

    try:
        server_state_obj.server_udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
        server_state_obj.server_udp_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        server_state_obj.server_udp_socket.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
        server_state_obj.server_udp_socket.settimeout(0.5) 
    except socket.error as e:
        print(f"Server Error: Failed to create UDP broadcast socket: {e}")
        server_state_obj.server_udp_socket = None
        return
    
    broadcast_address = ('<broadcast>', server_state_obj.discovery_port_udp)
    print(f"DEBUG Server (broadcast_presence_thread): Broadcasting presence: {broadcast_message_dict} to {broadcast_address} (LAN IP: {current_lan_ip})") 

    while server_state_obj.app_running:
        try:
            server_state_obj.server_udp_socket.sendto(broadcast_message_bytes, broadcast_address)
        except socket.error as sock_err:
            pass 
        except Exception as e:
            print(f"Server Warning: Unexpected error during broadcast send: {e}")
        
        for _ in range(int(server_state_obj.broadcast_interval_s * 10)): 
            if not server_state_obj.app_running: break
            time.sleep(0.1)
            
    if server_state_obj.server_udp_socket:
        server_state_obj.server_udp_socket.close()
        server_state_obj.server_udp_socket = None
    print("DEBUG Server (broadcast_presence_thread): Broadcast thread stopped.") 


def handle_client_connection_thread(conn: socket.socket, addr, server_state_obj: ServerState):
    """
    Thread function to handle receiving data from a single connected client.
    Updates the server_state_obj.client_input_buffer with the latest client input.
    Also handles map file requests from the client.
    """
    print(f"DEBUG Server (handle_client_connection_thread): Client connected from {addr}. Handler thread started.") 
    conn.settimeout(1.0) 
    partial_data_from_client = b"" 

    # Send initial map info
    if server_state_obj.current_map_name:
        try:
            conn.sendall(encode_data({"command": "set_map", "name": server_state_obj.current_map_name}))
            print(f"DEBUG Server Handler ({addr}): Sent initial map info: {server_state_obj.current_map_name}")
        except socket.error as e:
            print(f"DEBUG Server Handler ({addr}): Error sending initial map info: {e}. Client may have disconnected early.")
            # No need to break here immediately, the main loop's recv will catch the disconnect.
    else:
        print(f"DEBUG Server Handler ({addr}): CRITICAL - server_state_obj.current_map_name is None. Cannot send initial map info.")
        # This is a server-side logic error if current_map_name isn't set before client connects.

    while server_state_obj.app_running:
        with client_lock: 
            if server_state_obj.client_connection is not conn:
                print(f"DEBUG Server Handler ({addr}): Stale connection. Exiting thread.") 
                break 
        try:
            chunk = conn.recv(server_state_obj.buffer_size)
            if not chunk: 
                print(f"DEBUG Server Handler ({addr}): Client disconnected (received empty data).") 
                break
            
            partial_data_from_client += chunk
            decoded_inputs, partial_data_from_client = decode_data_stream(partial_data_from_client)

            for msg in decoded_inputs:
                command = msg.get("command")
                if command == "report_map_status":
                    map_name = msg.get("name")
                    status = msg.get("status")
                    print(f"DEBUG Server Handler ({addr}): Client map status for '{map_name}': {status}")
                    with client_lock:
                        server_state_obj.client_map_status = status
                        if status == "present":
                             server_state_obj.client_download_progress = 100.0
                             # Server can now signal game start if P1 is also ready (implicitly P1 is always ready as host)
                             if not server_state_obj.game_start_signaled_to_client:
                                conn.sendall(encode_data({"command": "start_game_now"}))
                                server_state_obj.game_start_signaled_to_client = True
                                print(f"DEBUG Server Handler ({addr}): Client has map. Sent start_game_now.")

                elif command == "request_map_file":
                    map_name_req = msg.get("name")
                    print(f"DEBUG Server Handler ({addr}): Client requested map file: '{map_name_req}'")
                    map_file_path = os.path.join(C.MAPS_DIR, map_name_req + ".py")
                    if os.path.exists(map_file_path):
                        with open(map_file_path, "r", encoding="utf-8") as f: # Read as text
                            map_content_str = f.read()
                        
                        conn.sendall(encode_data({"command": "map_file_info", "name": map_name_req, "size": len(map_content_str.encode('utf-8'))}))
                        
                        # Send in chunks as JSON strings
                        offset = 0
                        map_content_bytes = map_content_str.encode('utf-8')
                        while offset < len(map_content_bytes):
                            chunk = map_content_bytes[offset : offset + C.MAP_DOWNLOAD_CHUNK_SIZE]
                            # Send chunk as a string within the JSON payload
                            conn.sendall(encode_data({"command": "map_data_chunk", "data": chunk.decode('utf-8', 'replace'), "seq": offset})) # 'seq' can be offset
                            offset += len(chunk)
                        
                        conn.sendall(encode_data({"command": "map_transfer_end", "name": map_name_req}))
                        print(f"DEBUG Server Handler ({addr}): Sent map file '{map_name_req}' to client.")
                    else:
                        print(f"Server Error: Client requested map '{map_name_req}' but it was not found on server at '{map_file_path}'.")
                        # Optionally send an error message to client
                        conn.sendall(encode_data({"command": "map_file_error", "name": map_name_req, "reason": "not_found"}))


                elif command == "report_download_progress":
                    progress = msg.get("progress", 0)
                    # print(f"DEBUG Server Handler ({addr}): Client download progress: {progress:.1f}%") # Can be noisy
                    with client_lock:
                        server_state_obj.client_download_progress = progress

                elif "input" in msg: # Regular game input
                    with client_lock:
                        if server_state_obj.client_connection is conn: 
                            server_state_obj.client_input_buffer = msg["input"]
                # else: # Other commands if any
                #     print(f"DEBUG Server Handler ({addr}): Received unhandled command: {command}")


        except socket.timeout:
            continue 
        except socket.error as e:
            if server_state_obj.app_running:
                print(f"DEBUG Server Handler ({addr}): Socket error: {e}. Assuming disconnect.") 
            break 
        except Exception as e:
            if server_state_obj.app_running:
                print(f"DEBUG Server Handler ({addr}): Unexpected error: {e}") 
                traceback.print_exc()
            break

    with client_lock:
        if server_state_obj.client_connection is conn: 
            print(f"DEBUG Server Handler ({addr}): Closing active connection from handler.") 
            server_state_obj.client_connection = None 
            server_state_obj.client_input_buffer = {"disconnect": True} 
            server_state_obj.client_map_status = "disconnected" # Update status
    try:
        conn.shutdown(socket.SHUT_RDWR) 
    except: pass 
    try:
        conn.close() 
    except: pass
    print(f"DEBUG Server: Client handler for {addr} finished.") 


def run_server_mode(screen: pygame.Surface, clock: pygame.time.Clock, 
                    fonts: dict, game_elements_ref: dict, server_state_obj: ServerState):
    """
    Main function to run the game in server mode.
    Manages client connections, game loop, and state synchronization.
    """
    print("DEBUG Server: Entering run_server_mode.") 
    pygame.display.set_caption("Platformer - HOST (P1: WASD+VB | Self-Harm: H | Heal: G | Reset: Q)") 
    
    server_state_obj.app_running = True 
    current_width, current_height = screen.get_size()

    # current_map_name should be set by main.py before calling this.
    # If it's None here, there's a logic flow issue in main.
    if server_state_obj.current_map_name is None:
        print("CRITICAL SERVER: server_state_obj.current_map_name is None at start of run_server_mode. This should be set by main.py.")
        # Fallback or error handling needed, e.g., return or set a default.
        # For now, we'll assume it's set.

    if server_state_obj.broadcast_thread and server_state_obj.broadcast_thread.is_alive():
        print("DEBUG Server: Broadcast thread already running.") 
    else:
        print("DEBUG Server: Starting broadcast thread.") 
        server_state_obj.broadcast_thread = threading.Thread(
            target=broadcast_presence_thread, args=(server_state_obj,), daemon=True
        )
        server_state_obj.broadcast_thread.start()

    if server_state_obj.server_tcp_socket: 
        print("DEBUG Server: Closing existing TCP socket before creating new one.") 
        try: server_state_obj.server_tcp_socket.close()
        except: pass
    
    server_state_obj.server_tcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_state_obj.server_tcp_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    try:
        server_state_obj.server_tcp_socket.bind((C.SERVER_IP_BIND, server_state_obj.server_port_tcp))
        server_state_obj.server_tcp_socket.listen(1) 
        server_state_obj.server_tcp_socket.settimeout(1.0) 
        print(f"DEBUG Server: Listening on {C.SERVER_IP_BIND}:{server_state_obj.server_port_tcp}") 
    except socket.error as e:
        print(f"FATAL SERVER ERROR: Failed to bind/listen TCP socket: {e}")
        return 

    print("DEBUG Server: Waiting for Player 2 to connect...") 
    temp_client_conn_obj = None 
    server_state_obj.client_map_status = "unknown" # Reset for new client
    server_state_obj.client_download_progress = 0.0
    server_state_obj.game_start_signaled_to_client = False


    # --- Wait for Client Connection and Map Sync Phase ---
    client_sync_wait_active = True
    while client_sync_wait_active and server_state_obj.app_running:
        current_width, current_height = screen.get_size()
        for event in pygame.event.get():
            if event.type == pygame.QUIT: server_state_obj.app_running = False; client_sync_wait_active = False; break
            if event.type == pygame.VIDEORESIZE: # Basic resize handling
                if not screen.get_flags() & pygame.FULLSCREEN:
                    current_width, current_height = max(320,event.w), max(240,event.h)
                    screen = pygame.display.set_mode((current_width, current_height), pygame.RESIZABLE|pygame.DOUBLEBUF)
                    # Camera update if needed by host view
            if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
                server_state_obj.app_running = False; client_sync_wait_active = False; break
        if not server_state_obj.app_running: break

        # Accept new connection if none active
        if server_state_obj.client_connection is None:
            try:
                temp_client_conn_obj, temp_client_addr_tuple = server_state_obj.server_tcp_socket.accept()
                with client_lock:
                    server_state_obj.client_connection = temp_client_conn_obj
                    server_state_obj.client_address = temp_client_addr_tuple
                    server_state_obj.client_input_buffer = {}
                    server_state_obj.client_map_status = "waiting_client_report" # New status after connect
                    server_state_obj.game_start_signaled_to_client = False
                print(f"DEBUG Server: Accepted connection from {temp_client_addr_tuple}")

                # Start client handler thread
                if server_state_obj.client_handler_thread and server_state_obj.client_handler_thread.is_alive():
                    server_state_obj.client_handler_thread.join(timeout=0.1) # Try to clean up old one
                server_state_obj.client_handler_thread = threading.Thread(
                    target=handle_client_connection_thread, 
                    args=(server_state_obj.client_connection, server_state_obj.client_address, server_state_obj), 
                    daemon=True
                )
                server_state_obj.client_handler_thread.start()
            except socket.timeout: pass # No connection attempt, continue
            except Exception as e_accept: print(f"Server: Error accepting client: {e_accept}")
        
        # UI Update
        dialog_title = "Server Hosting"
        dialog_message = "Waiting for Player 2 to connect..."
        dialog_progress = -1 # Waiting state

        with client_lock: # Access shared state safely
            if server_state_obj.client_connection:
                if server_state_obj.client_map_status == "waiting_client_report":
                    dialog_message = f"Player 2 ({server_state_obj.client_address[0]}) connected. Waiting for map status..."
                elif server_state_obj.client_map_status == "missing":
                     dialog_message = f"Player 2 is missing map '{server_state_obj.current_map_name}'. Sending..."
                     dialog_progress = server_state_obj.client_download_progress
                elif server_state_obj.client_map_status == "downloading_ack": # Client acknowledged download start
                     dialog_message = f"Player 2 downloading '{server_state_obj.current_map_name}'..."
                     dialog_progress = server_state_obj.client_download_progress
                elif server_state_obj.client_map_status == "present":
                    dialog_message = f"Player 2 has map '{server_state_obj.current_map_name}'. Ready."
                    dialog_progress = 100.0
                    client_sync_wait_active = False # Exit this loop, proceed to game
                elif server_state_obj.client_map_status == "disconnected":
                    dialog_message = "Player 2 disconnected. Waiting for new connection..."
                    server_state_obj.client_connection = None # Allow re-accepting
        
        # Draw the waiting/syncing UI
        game_ui.draw_download_dialog(screen, fonts, dialog_title, dialog_message, dialog_progress)
        clock.tick(10) # Lower FPS while waiting

    if not server_state_obj.app_running or server_state_obj.client_connection is None or server_state_obj.client_map_status != "present":
        print(f"DEBUG Server: Exiting wait loop (app_running: {server_state_obj.app_running}, client_conn: {server_state_obj.client_connection is not None}, map_status: {server_state_obj.client_map_status}).") 
        # Ensure broadcast thread stops if server mode exits here
        server_state_obj.app_running = False # Signal threads to stop
        if server_state_obj.broadcast_thread and server_state_obj.broadcast_thread.is_alive():
            server_state_obj.broadcast_thread.join(timeout=0.5)
        if server_state_obj.client_handler_thread and server_state_obj.client_handler_thread.is_alive():
            server_state_obj.client_handler_thread.join(timeout=0.5)
        if server_state_obj.server_tcp_socket: server_state_obj.server_tcp_socket.close(); server_state_obj.server_tcp_socket = None
        return 


    # --- Main Game Loop (starts after client is connected and map is synced) ---
    print(f"DEBUG Server: Client {server_state_obj.client_address} connected and map synced. Starting game...") 
    
    p1 = game_elements_ref.get("player1") 
    p2 = game_elements_ref.get("player2") 
    if p1: print(f"DEBUG Server: P1 instance from game_elements: {p1}, Valid: {p1._valid_init if p1 else 'N/A'}") 
    if p2: print(f"DEBUG Server: P2 instance from game_elements: {p2}, Valid: {p2._valid_init if p2 else 'N/A'}") 

    p1_key_map_config = { 
        'left': pygame.K_a, 'right': pygame.K_d, 'up': pygame.K_w, 'down': pygame.K_s,
        'attack1': pygame.K_v, 'attack2': pygame.K_b, 'dash': pygame.K_LSHIFT,
        'roll': pygame.K_LCTRL, 'interact': pygame.K_e
    }
    
    server_game_active = True
    while server_game_active and server_state_obj.app_running:
        dt_sec = clock.tick(C.FPS) / 1000.0 
        now_ticks_server = pygame.time.get_ticks() 
        
        pygame_events = pygame.event.get()
        keys_pressed_p1 = pygame.key.get_pressed()

        is_p1_game_over_for_reset = False
        if p1 and p1._valid_init:
            if p1.is_dead and (not p1.alive() or (hasattr(p1, 'death_animation_finished') and p1.death_animation_finished)):
                is_p1_game_over_for_reset = True
        else: 
            is_p1_game_over_for_reset = True

        host_requested_reset = False
        for event in pygame_events:
            if event.type == pygame.QUIT: server_game_active = False; server_state_obj.app_running = False; break
            if event.type == pygame.VIDEORESIZE:
                if not screen.get_flags() & pygame.FULLSCREEN:
                    current_width, current_height = max(320,event.w), max(240,event.h)
                    screen = pygame.display.set_mode((current_width,current_height), pygame.RESIZABLE|pygame.DOUBLEBUF)
                    if game_elements_ref.get("camera"):
                        game_elements_ref["camera"].screen_width = current_width
                        game_elements_ref["camera"].screen_height = current_height
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE: server_game_active = False 
                if event.key == pygame.K_q: host_requested_reset = True
                if p1 and p1._valid_init: 
                    if event.key == pygame.K_h and hasattr(p1, 'self_inflict_damage'): p1.self_inflict_damage(C.PLAYER_SELF_DAMAGE)
                    if event.key == pygame.K_g and hasattr(p1, 'heal_to_full'): p1.heal_to_full()
        
        if not server_state_obj.app_running or not server_game_active: break

        if p1 and p1._valid_init and not p1.is_dead:
            if hasattr(p1, 'handle_mapped_input'):
                p1.handle_mapped_input(keys_pressed_p1, pygame_events, p1_key_map_config)

        p2_network_input, client_disconnected_signal, p2_requested_reset = None, False, False
        with client_lock: 
            if server_state_obj.client_input_buffer:
                buffered_input = server_state_obj.client_input_buffer.copy() # Make a copy
                server_state_obj.client_input_buffer.clear() # Clear after copying
                
                if buffered_input.get("disconnect"): client_disconnected_signal = True
                elif buffered_input.get("action_reset", False): p2_requested_reset = True
                
                if p2 and p2._valid_init: # Process self-harm/heal directly on server
                    if buffered_input.get("action_self_harm", False) and hasattr(p2, 'self_inflict_damage'):
                        p2.self_inflict_damage(C.PLAYER_SELF_DAMAGE)
                    elif buffered_input.get("action_heal", False) and hasattr(p2, 'heal_to_full'):
                        p2.heal_to_full()
                
                # Pass other inputs to p2.handle_network_input
                p2_network_input = buffered_input

        if client_disconnected_signal:
            print("DEBUG Server: Client disconnected signal received in main loop.") 
            server_game_active = False 
            # Reset client related server state for next potential connection
            with client_lock:
                server_state_obj.client_connection = None
                server_state_obj.client_map_status = "unknown"
                server_state_obj.client_download_progress = 0.0
            break 

        if p2 and p2._valid_init and p2_network_input and hasattr(p2, 'handle_network_input'):
            p2.handle_network_input(p2_network_input) 

        if host_requested_reset or (p2_requested_reset and is_p1_game_over_for_reset):
            print("DEBUG Server: Game state reset triggered.") 
            game_elements_ref["current_chest"] = reset_game_state(game_elements_ref)

        if p1 and p1._valid_init:
            other_players_for_p1_update = [char for char in [p2] if char and char._valid_init and char.alive() and char is not p1]
            p1.update(dt_sec, game_elements_ref["platform_sprites"], game_elements_ref["ladder_sprites"], 
                      game_elements_ref["hazard_sprites"], other_players_for_p1_update, game_elements_ref["enemy_list"])

        if p2 and p2._valid_init:
            other_players_for_p2_update = [char for char in [p1] if char and char._valid_init and char.alive() and char is not p2]
            p2.update(dt_sec, game_elements_ref["platform_sprites"], game_elements_ref["ladder_sprites"], 
                      game_elements_ref["hazard_sprites"], other_players_for_p2_update, game_elements_ref["enemy_list"])

        active_players_for_enemy_ai = [char for char in [p1, p2] if char and char._valid_init and not char.is_dead and char.alive()]
        for enemy in list(game_elements_ref.get("enemy_list", [])): 
            if enemy._valid_init:
                enemy.update(dt_sec, active_players_for_enemy_ai, game_elements_ref["platform_sprites"], game_elements_ref["hazard_sprites"])
                if enemy.is_dead and hasattr(enemy, 'death_animation_finished') and \
                   enemy.death_animation_finished and enemy.alive():
                    if hasattr(Enemy, 'print_limiter') and Enemy.print_limiter.can_print(f"server_killing_enemy_{enemy.enemy_id}"):
                         print(f"Server: Auto-killing enemy {enemy.enemy_id} as death anim finished.")
                    enemy.kill() 
            
        hittable_characters_server_group = pygame.sprite.Group()
        if p1 and p1.alive() and p1._valid_init: hittable_characters_server_group.add(p1)
        if p2 and p2.alive() and p2._valid_init: hittable_characters_server_group.add(p2)
        for enemy_inst_proj in game_elements_ref.get("enemy_list", []):
            if enemy_inst_proj and enemy_inst_proj.alive() and enemy_inst_proj._valid_init:
                hittable_characters_server_group.add(enemy_inst_proj)
        game_elements_ref.get("projectile_sprites", pygame.sprite.Group()).update(dt_sec, game_elements_ref["platform_sprites"], hittable_characters_server_group)
        
        game_elements_ref.get("collectible_sprites", pygame.sprite.Group()).update(dt_sec)
        server_current_chest = game_elements_ref.get("current_chest")
        if server_current_chest and server_current_chest.alive(): 
            player_who_collected_chest = None
            if p1 and p1._valid_init and not p1.is_dead and p1.alive() and pygame.sprite.collide_rect(p1, server_current_chest):
                player_who_collected_chest = p1
            elif p2 and p2._valid_init and not p2.is_dead and p2.alive() and pygame.sprite.collide_rect(p2, server_current_chest):
                player_who_collected_chest = p2
            
            if player_who_collected_chest:
                server_current_chest.collect(player_who_collected_chest) 
                game_elements_ref["current_chest"] = None 
        
        server_camera = game_elements_ref.get("camera")
        if server_camera:
            camera_focus_target = None
            if p1 and p1.alive() and p1._valid_init and not p1.is_dead: camera_focus_target = p1
            elif p2 and p2.alive() and p2._valid_init and not p2.is_dead: camera_focus_target = p2
            
            if camera_focus_target: server_camera.update(camera_focus_target)
            else: server_camera.static_update() 

        if server_state_obj.client_connection: 
            network_state_to_send = get_network_game_state(game_elements_ref)
            encoded_game_state = encode_data(network_state_to_send)
            if encoded_game_state:
                try:
                    server_state_obj.client_connection.sendall(encoded_game_state)
                except socket.error as e:
                    print(f"DEBUG Server: Send failed to client: {e}. Client likely disconnected.") 
                    server_game_active = False 
                    with client_lock: server_state_obj.client_connection = None 
                    break 
        
        try:
            # Pass download status for UI display
            dl_status_msg, dl_progress = None, None
            with client_lock:
                if server_state_obj.client_map_status in ["missing", "downloading_ack"]:
                    dl_status_msg = f"P2 Downloading Map: {server_state_obj.current_map_name}"
                    dl_progress = server_state_obj.client_download_progress
            draw_platformer_scene_on_surface(screen, game_elements_ref, fonts, now_ticks_server,
                                             download_status_message=dl_status_msg,
                                             download_progress_percent=dl_progress)
        except Exception as e:
            print(f"Server draw error: {e}"); traceback.print_exc()
            server_game_active = False; break
        pygame.display.flip()

    print("DEBUG Server: Exiting active game loop.") 
    
    connection_to_close_at_server_exit = None
    with client_lock:
        if server_state_obj.client_connection:
            connection_to_close_at_server_exit = server_state_obj.client_connection
            server_state_obj.client_connection = None 
    if connection_to_close_at_server_exit:
        print("DEBUG Server: Mode exit cleanup - closing client connection.") 
        try:
            connection_to_close_at_server_exit.shutdown(socket.SHUT_RDWR)
            connection_to_close_at_server_exit.close()
        except: pass 

    if server_state_obj.server_tcp_socket:
        print("DEBUG Server: Closing main TCP listening socket.") 
        server_state_obj.server_tcp_socket.close()
        server_state_obj.server_tcp_socket = None
    
    print("DEBUG Server: Server mode finished and returned to caller.") 

########## START OF FILE: tiles.py ##########

# tiles.py
# -*- coding: utf-8 -*-
"""
Defines classes for static and interactive tiles in the game world.
"""
# version 1.0.0.1 (Added platform_type to Platform class)
import pygame
# Import all necessary constants, including DARK_GREEN if not already present
from constants import GRAY, BLUE, ORANGE_RED, DARK_GREEN 

class Platform(pygame.sprite.Sprite):
    """ 
    Standard solid platform.
    Can be tagged with a platform_type (e.g., "ground", "ledge", "wall").
    """
    def __init__(self, x, y, width, height, color=GRAY, platform_type="generic"):
        super().__init__()
        
        # Ensure valid dimensions for the surface
        surf_width = max(1, int(width))
        surf_height = max(1, int(height))
        
        self.image = pygame.Surface((surf_width, surf_height))
        self.image.fill(color)
        self.rect = self.image.get_rect(topleft=(x, y))
        
        self.color = color # Store the color, can be useful for debugging or logic
        self.platform_type = platform_type # Store the type of platform

        if width <= 0 or height <= 0:
            print(f"Warning: Platform created with non-positive dimensions: w={width}, h={height} at ({x},{y}). Using 1x1.")
            # Surface already created with max(1,...) dimensions, rect is based on original x,y


class Ladder(pygame.sprite.Sprite):
    """ Climbable ladder area. """
    def __init__(self, x, y, width, height):
        super().__init__()
        # Ensure valid dimensions
        width = max(1, int(width))
        height = max(1, int(height))
        self.image = pygame.Surface((width, height)).convert_alpha()
        self.image.fill((0, 0, 0, 0)) # Fully transparent background
        self.image.set_alpha(100) # Make semi-transparent visually

        # Draw visual cues (rungs, rails)
        rung_color = (40, 40, 180, 200) # Slightly transparent dark blue
        num_rungs = int(height / 15)
        if num_rungs > 0: # Avoid division by zero if height is too small
            rung_spacing = height / num_rungs
            for i in range(1, num_rungs + 1): # Iterate to include a rung near the top
                rung_y = i * rung_spacing
                # Ensure rung_y is within bounds before drawing
                if rung_y < height -1 : # -1 to keep it within the surface
                    pygame.draw.line(self.image, rung_color, (0, rung_y), (width, rung_y), 2)
        
        # Draw side rails (ensure lines are within surface bounds)
        # Use min/max to prevent drawing outside the surface if width is very small
        rail_thickness = 3
        left_rail_x = min(rail_thickness -1, width -1) # If width=1, rail is at x=0
        right_rail_x = max(0, width - rail_thickness)   # If width=1, rail is at x=0
        
        pygame.draw.line(self.image, rung_color, (left_rail_x, 0), (left_rail_x, height), rail_thickness)
        if width > rail_thickness * 2: # Only draw second rail if there's space
             pygame.draw.line(self.image, rung_color, (right_rail_x, 0), (right_rail_x, height), rail_thickness)

        self.rect = self.image.get_rect(topleft=(x, y))

class Lava(pygame.sprite.Sprite):
    """ Dangerous lava tile that damages characters. """
    def __init__(self, x, y, width, height, color=ORANGE_RED):
        super().__init__()
        # Ensure valid dimensions
        width = max(1, int(width))
        height = max(1, int(height))
        self.image = pygame.Surface((width, height))
        self.image.fill(color)
        self.rect = self.image.get_rect(topleft=(x, y))
        # Optional: Add visual effect like simple noise/flicker
        # import random
        # for _ in range(int(width*height*0.05)): # Add some darker spots
        #      px = random.randint(0, width-1)
        #      py = random.randint(0, height-1)
        #      dark_color_r = max(0, color[0]-random.randint(30,70))
        #      dark_color_g = max(0, color[1]-random.randint(10,40))
        #      dark_color_b = max(0, color[2]-random.randint(0,20))
        #      self.image.set_at((px, py), (dark_color_r, dark_color_g, dark_color_b))

########## START OF FILE: utils.py ##########

# utils.py
# -*- coding: utf-8 -*-
"""
Shared utility classes and functions.
version 1.0000000.1
"""
import time

class PrintLimiter:
    def __init__(self, default_limit=5, default_period=2.0):
        self.counts = {}
        self.timestamps = {}
        self.default_limit = default_limit
        self.default_period = default_period
        self.globally_suppressed = {} # Tracks if the "suppressing further prints" message was shown

    def can_print(self, message_key, limit=None, period=None):
        limit = limit if limit is not None else self.default_limit
        period = period if period is not None else self.default_period
        current_time = time.time()
        
        if message_key not in self.timestamps:
            self.timestamps[message_key] = current_time
            self.counts[message_key] = 0
            self.globally_suppressed[message_key] = False

        if current_time - self.timestamps[message_key] > period:
            self.timestamps[message_key] = current_time
            self.counts[message_key] = 0
            self.globally_suppressed[message_key] = False # Reset suppression message flag

        if self.counts[message_key] < limit:
            self.counts[message_key] += 1
            return True
        elif not self.globally_suppressed[message_key]: # Only print suppression message once per period
            # print(f"[PrintLimiter] Suppressing further prints for '{message_key}' for {period:.1f}s (limit: {limit})") # Keep this commented for less console noise
            self.globally_suppressed[message_key] = True
            return False
        return False