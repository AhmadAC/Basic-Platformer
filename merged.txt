

========== START OF FILE: assets.py ==========

# -*- coding: utf-8 -*-
"""
Handles loading game assets, primarily animations.
Uses a helper function `resource_path` to work correctly
both locally and when packaged by PyInstaller (--onedir).
"""
import pygame
import os
import sys
from PIL import Image
import numpy as np # Pillow might use this

# Import constants (specifically colors for placeholders)
try:
    from constants import RED, BLACK, BLUE
except ImportError:
    # Provide fallback colors if constants cannot be imported (e.g., during spec generation)
    print("Warning: Failed to import constants. Using fallback colors.")
    RED = (255, 0, 0)
    BLACK = (0, 0, 0)
    BLUE = (0, 0, 255)

# --- Helper Function for PyInstaller Compatibility ---
def resource_path(relative_path):
    """ Get absolute path to resource, works for dev and for PyInstaller """
    try:
        # PyInstaller creates a temp folder and stores path in _MEIPASS
        # For --onedir, _MEIPASS usually points to the executable's directory
        base_path = sys._MEIPASS
        # print(f"Running from PyInstaller bundle: _MEIPASS={base_path}") # Debug print
    except AttributeError:
        # _MEIPASS attribute not found, running in normal Python environment
        # Assume assets are relative to the main script or project root.
        # Using os.path.abspath(".") assumes you run your script from the project root.
        # If assets.py is not in the root, adjust accordingly, e.g.:
        # base_path = os.path.abspath(os.path.join(os.path.dirname(__file__), "..")) # If assets.py is in a 'src' subdir
        base_path = os.path.abspath(".")
        # print(f"Running locally: base_path={base_path}") # Debug print

    full_path = os.path.join(base_path, relative_path)
    # print(f"Resolved path for '{relative_path}': {full_path}") # Debug print
    return full_path
# ----------------------------------------------------

# Asset Loading (Modified to use resource_path implicitly via load_all_player_animations)
def load_gif_frames(full_path_filename):
    """Loads frames from a GIF file using Pillow and converts them to Pygame Surfaces.
       Expects the *full, resolved path* to the file."""
    frames = []
    try:
        # Use Pillow to open the GIF using the provided full path
        pil_gif = Image.open(full_path_filename)
        frame_num = 0
        while True:
            try:
                # Seek to the next frame
                pil_gif.seek(frame_num)
                current_pil_frame = pil_gif.copy()
                rgba_frame = current_pil_frame.convert('RGBA') # Ensure RGBA for transparency
                frame_data = rgba_frame.tobytes()
                frame_size = rgba_frame.size
                frame_mode = rgba_frame.mode # Should be RGBA now

                # Create Pygame surface from RGBA data
                surface = pygame.image.frombuffer(frame_data, frame_size, "RGBA")
                surface = surface.convert_alpha() # Ensure optimal format for Pygame

                frames.append(surface)
                frame_num += 1

            except EOFError:
                # Reached the end of the GIF frames
                break
            except Exception as e:
                print(f"Error processing frame {frame_num} in {full_path_filename}: {e}")
                frame_num += 1 # Try next frame even if one fails

        if not frames:
             print(f"Error: No frames loaded from {full_path_filename}. Creating placeholder.")
             placeholder = pygame.Surface((30, 40)).convert_alpha()
             placeholder.fill(RED)
             pygame.draw.rect(placeholder, BLACK, placeholder.get_rect(), 1)
             return [placeholder]
        return frames

    except FileNotFoundError:
        print(f"Error: GIF file not found at resolved path: {full_path_filename}")
        placeholder = pygame.Surface((30, 40)).convert_alpha()
        placeholder.fill(RED)
        pygame.draw.rect(placeholder, BLACK, placeholder.get_rect(), 1)
        return [placeholder]
    except Exception as e:
        print(f"Error loading GIF {full_path_filename} with Pillow: {e}")
        placeholder = pygame.Surface((30, 40)).convert_alpha()
        placeholder.fill(RED)
        pygame.draw.rect(placeholder, BLACK, placeholder.get_rect(), 2)
        return [placeholder]

# --- Modified function to use resource_path ---
def load_all_player_animations(relative_asset_folder='characters/player1'):
    """Loads all animations for the player/enemy using the defined map.
       Uses resource_path to find the assets correctly."""
    animations = {}
    # Define the animation mapping (can be reused by Enemy if needed)
    anim_files_map = {
        'attack': '__Attack.gif', 'attack2': '__Attack2.gif', 'attack_combo': '__AttackCombo2hit.gif',
        'attack_nm': '__AttackNoMovement.gif', 'attack2_nm': '__Attack2NoMovement.gif',
        'attack_combo_nm': '__AttackComboNoMovement.gif', 'crouch': '__Crouch.gif',
        'crouch_trans': '__CrouchTransition.gif', 'crouch_walk': '__CrouchWalk.gif',
        'crouch_attack': '__CrouchAttack.gif', 'dash': '__Dash.gif', 'death': '__Death.gif',
        'death_nm': '__DeathNoMovement.gif', 'fall': '__Fall.gif', 'hit': '__Hit.gif',
        'idle': '__Idle.gif', 'jump': '__Jump.gif', 'jump_fall_trans': '__JumpFallInbetween.gif',
        'roll': '__Roll.gif', 'run': '__Run.gif', 'slide': '__SlideAll.gif',
        'slide_trans_start': '__SlideTransitionStart.gif', 'slide_trans_end': '__SlideTransitionEnd.gif',
        'turn': '__TurnAround.gif', 'wall_climb': '__WallClimb.gif',
        'wall_climb_nm': '__WallClimbNoMovement.gif', 'wall_hang': '__WallHang.gif',
        'wall_slide': '__WallSlide.gif',
        # Add 'ladder_idle' and 'ladder_climb' if you have those GIFs (currently not used)
    }

    print(f"Attempting to load animations from relative folder: '{relative_asset_folder}'")
    missing_files_details = [] # Store tuples of (name, expected_relative_path, resolved_path)

    # Determine the base path once
    try:
        base_path = sys._MEIPASS
    except AttributeError:
        base_path = os.path.abspath(".") # Or adjust as needed for your local structure

    print(f"Using base path for assets: {base_path}")

    for name, filename in anim_files_map.items():
         # Construct the relative path first (for reporting)
         relative_path_to_file = os.path.join(relative_asset_folder, filename)
         # Use resource_path to get the full, absolute path
         full_path = resource_path(relative_path_to_file)

         # Check existence using the *full* path
         if not os.path.exists(full_path):
             missing_files_details.append((name, relative_path_to_file, full_path))
             animations[name] = [] # Mark as missing
             continue # Skip loading if file doesn't exist

         # Load using the full path
         loaded_frames = load_gif_frames(full_path)
         animations[name] = loaded_frames

         if not animations[name]: # load_gif_frames returns placeholder on failure
             print(f"Warning: Failed to load frames for state '{name}' from existing file '{full_path}'. Placeholder used.")
             # Placeholder already created by load_gif_frames if loading failed after finding file
         #else:
             # print(f"Successfully loaded {len(animations[name])} frames for '{name}' from '{full_path}'") # Verbose success

    if missing_files_details:
        print("\n--- Missing Animation Files ---")
        for name, rel_path, res_path in missing_files_details:
            print(f"- State '{name}': Expected relative path: '{rel_path}', Resolved path checked: '{res_path}'")
        print(f"(Base path used: {base_path})")
        print("-----------------------------\n")
        print("Ensure these files exist relative to your script/executable OR")
        print("Ensure PyInstaller's '--add-data' or spec file 'datas' includes the asset folder correctly.")

    # Critical check for idle animation (using the placeholder if it failed)
    if 'idle' not in animations or not animations['idle'] or animations['idle'][0].get_size() == (30, 40): # Check if it's a placeholder
        is_missing = 'idle' not in animations or not animations['idle']
        is_placeholder = not is_missing and animations['idle'][0].get_size() == (30, 40) # Basic placeholder check

        if is_missing:
            print("CRITICAL ERROR: Idle animation state not found in map or file missing entirely.")
        elif is_placeholder:
             print(f"CRITICAL ERROR: Idle animation failed to load from '{resource_path(os.path.join(relative_asset_folder, anim_files_map['idle']))}'. Using placeholder.")

        # Create a minimal dummy animation to prevent crashes during init elsewhere ONLY if it's truly absent
        if is_missing:
            placeholder = pygame.Surface((30, 40)).convert_alpha(); placeholder.fill(RED)
            animations['idle'] = [placeholder] # Ensure 'idle' key exists
        # The calling function should still check for this failure state
        # Returning None might be too drastic if only idle failed but others loaded
        # Let's return the animations dict but signal the caller to check idle specifically.
        # Or, make it return None to force a halt. Let's return None for safety.
        print("Returning None due to critical idle animation failure.")
        return None # Indicate critical failure

    # Provide placeholders for any *other* missing/failed animations AFTER checking idle
    for name in anim_files_map:
        if name == 'idle': continue # Already handled

        if name not in animations or not animations[name] or animations[name][0].get_size() == (30, 40):
            if name not in animations or not animations[name]:
                 print(f"Warning: Animation state '{name}' was missing. Providing placeholder.")
            else: # It exists but must be a placeholder from load_gif_frames
                 print(f"Warning: Animation state '{name}' failed during loading. Using placeholder.")

            # Create a different placeholder for non-idle missing animations
            placeholder = pygame.Surface((30, 40)).convert_alpha(); placeholder.fill(BLUE)
            pygame.draw.line(placeholder, RED, (0,0), (30,40), 2); pygame.draw.line(placeholder, RED, (0,40), (30,0), 2)
            animations[name] = [placeholder] # Ensure the key exists with the placeholder

    print(f"Finished loading animations. {len(animations)} animation states processed.")
    return animations
# ------------------------------------------

# Example Usage (if you run this file directly for testing)
if __name__ == "__main__":
    print("Running asset loader directly for testing...")
    pygame.init() # Pygame needed for surface creation

    # --- Determine where the script thinks the 'characters' folder should be ---
    # This assumes your project structure is like:
    # project_root/
    #   assets.py
    #   constants.py
    #   main.py (or similar)
    #   characters/
    #     player1/
    #       __Idle.gif
    #       ...
    # If assets.py is in a subdirectory, adjust the relative path passed.
    test_asset_folder = 'characters/player1'
    print(f"\nTesting load_all_player_animations with relative folder: '{test_asset_folder}'")
    loaded_animations = load_all_player_animations(test_asset_folder)

    if loaded_animations:
        print(f"\nSuccessfully loaded animation data.")
        # print("Loaded states:", list(loaded_animations.keys()))
        # Example: Check frames for 'idle'
        if 'idle' in loaded_animations and loaded_animations['idle']:
            print(f"Idle animation loaded with {len(loaded_animations['idle'])} frames.")
            # Check if it's a placeholder
            if loaded_animations['idle'][0].get_width() == 30 and loaded_animations['idle'][0].get_height() == 40:
                 if loaded_animations['idle'][0].get_at((0,0)) == RED:
                     print("WARNING: Idle animation appears to be a RED placeholder!")
                 elif loaded_animations['idle'][0].get_at((0,0)) == BLUE:
                     print("WARNING: Idle animation appears to be a BLUE placeholder!")

        else:
            print("Idle animation missing or empty in returned dictionary.")
    else:
        print("\nAnimation loading failed (returned None), likely due to critical idle animation issue.")

    pygame.quit()

========== START OF FILE: camera.py ==========

# -*- coding: utf-8 -*-
"""
camera.py
Defines the Camera class for managing the game's viewport.
"""
import pygame

class Camera:
    def __init__(self, level_width, level_height, screen_width, screen_height):
        """
        Initializes the camera.

        Args:
            level_width (int): The total width of the game level.
            level_height (int): The total height of the game level.
            screen_width (int): The width of the game screen/window.
            screen_height (int): The height of the game screen/window.
        """
        self.camera_rect = pygame.Rect(0, 0, screen_width, screen_height)
        self.level_width = level_width
        self.level_height = level_height
        self.screen_width = screen_width
        self.screen_height = screen_height

    def apply(self, target):
        """
        Applies the camera offset to a target sprite or rect.

        Args:
            target (pygame.sprite.Sprite or pygame.Rect): The sprite or rect to offset.

        Returns:
            pygame.Rect: A new Rect representing the target's position on the screen.
        """
        if isinstance(target, pygame.sprite.Sprite):
            return target.rect.move(self.camera_rect.topleft)
        elif isinstance(target, pygame.Rect):
            return target.move(self.camera_rect.topleft)
        else:
            # Handle other types if necessary, or raise an error
            raise TypeError("Camera.apply() target must be a Sprite or Rect.")


    def update(self, target_sprite):
        """
        Updates the camera's position to follow the target_sprite.

        Args:
            target_sprite (pygame.sprite.Sprite): The sprite the camera should follow.
                                                 Expected to have a 'rect' attribute.
        """
        if not target_sprite or not hasattr(target_sprite, 'rect'):
            # print("Warning: Camera update called with invalid target_sprite.")
            self.static_update() # Keep camera still if no valid target
            return

        # Calculate the desired camera position to center the target
        # The camera's topleft x should be such that when added to the target's x,
        # the target appears in the center of the screen.
        # So, target_x + camera_offset_x = screen_center_x
        # camera_offset_x = screen_center_x - target_x
        # The camera_rect.x stores a NEGATIVE offset.
        x = -target_sprite.rect.centerx + int(self.screen_width / 2)
        y = -target_sprite.rect.centery + int(self.screen_height / 2)

        # Clamp scrolling to level boundaries
        # Prevent camera from showing areas outside the level
        x = min(0, x)  # Don't scroll beyond the left edge of the level
        y = min(0, y)  # Don't scroll beyond the top edge of the level

        # Don't scroll beyond the right edge of the level
        # If camera_rect.width (screen_width) is greater than level_width, this ensures x stays at 0
        x = max(-(self.level_width - self.screen_width), x)
        # Don't scroll beyond the bottom edge of the level
        # If camera_rect.height (screen_height) is greater than level_height, this ensures y stays at 0
        y = max(-(self.level_height - self.screen_height), y)


        self.camera_rect.x = x
        self.camera_rect.y = y

    def static_update(self):
        """
        Called when there's no target to follow.
        The camera remains in its current position.
        (Currently does nothing, but can be expanded if needed)
        """
        pass # Camera position doesn't change

    def get_pos(self):
        """ Returns the camera's current topleft offset (usually negative or zero values). """
        return (self.camera_rect.x, self.camera_rect.y)

    def set_pos(self, x, y):
        """ Manually sets the camera's topleft offset. """
        self.camera_rect.x = x
        self.camera_rect.y = y

========== START OF FILE: constants.py ==========

# -*- coding: utf-8 -*-
"""
Stores constant values used throughout the game.
"""

# --- Gameplay / Physics ---
FPS = 60
PLAYER_ACCEL = 0.5
PLAYER_FRICTION = -0.15  # Negative value!
PLAYER_GRAVITY = 0.7
PLAYER_JUMP_STRENGTH = -15
PLAYER_RUN_SPEED_LIMIT = 7
PLAYER_DASH_SPEED = 15
PLAYER_ROLL_SPEED = 9
PLAYER_WALL_SLIDE_SPEED = 2
PLAYER_WALL_CLIMB_SPEED = -4
PLAYER_LADDER_CLIMB_SPEED = 3
PLAYER_MAX_HEALTH = 100
PLAYER_ATTACK_DAMAGE = 15
CHARACTER_BOUNCE_VELOCITY = 2.5 # Pixels per frame push back on collision

# --- Enemy Constants ---
ENEMY_MAX_HEALTH = 80
ENEMY_RUN_SPEED_LIMIT = 5 # Give enemy its own speed limit
ENEMY_ACCEL = 0.4         # Give enemy its own acceleration
ENEMY_FRICTION = -0.12    # Give enemy its own friction
ENEMY_DETECTION_RANGE = 350
ENEMY_ATTACK_RANGE = 60
ENEMY_ATTACK_DAMAGE = 10
ENEMY_ATTACK_COOLDOWN = 1500
ENEMY_PATROL_DIST = 150 # How far to move before turning in patrol

# --- Colors ---
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
RED = (255, 0, 0)
DARK_RED = (139, 0, 0)
GREEN = (0, 255, 0)
DARK_GREEN = (0, 100, 0)
BLUE = (0, 0, 255)
GRAY = (128, 128, 128)
DARK_GRAY = (50, 50, 50)
LIGHT_BLUE = (173, 216, 230)
ORANGE_RED = (255, 69, 0) # For Lava

# --- Animation ---
ANIM_FRAME_DURATION = 80 # ms per frame

# --- UI ---
HEALTH_BAR_WIDTH = 50
HEALTH_BAR_HEIGHT = 8

# --- Map ---
TILE_SIZE = 40 # Example, if you use a grid later
LAVA_PATCH_HEIGHT = 20 # How tall lava patches/wells rects are for collision (can be diff from visual depth)

# --- Other ---
# -*- coding: utf-8 -*-
"""
Stores constant values used throughout the game.
"""

# --- Gameplay / Physics ---
FPS = 60
PLAYER_ACCEL = 0.5
PLAYER_FRICTION = -0.15  # Negative value!
PLAYER_GRAVITY = 0.7
PLAYER_JUMP_STRENGTH = -15
PLAYER_RUN_SPEED_LIMIT = 7
PLAYER_DASH_SPEED = 15
PLAYER_ROLL_SPEED = 9
PLAYER_WALL_SLIDE_SPEED = 2
PLAYER_WALL_CLIMB_SPEED = -4
PLAYER_LADDER_CLIMB_SPEED = 3
PLAYER_MAX_HEALTH = 100
PLAYER_ATTACK_DAMAGE = 15
CHARACTER_BOUNCE_VELOCITY = 2.5 # Pixels per frame push back on collision

# --- Enemy Constants ---
ENEMY_MAX_HEALTH = 80
ENEMY_RUN_SPEED_LIMIT = 5 # Give enemy its own speed limit
ENEMY_ACCEL = 0.4         # Give enemy its own acceleration
ENEMY_FRICTION = -0.12    # Give enemy its own friction
ENEMY_DETECTION_RANGE = 350
ENEMY_ATTACK_RANGE = 60
ENEMY_ATTACK_DAMAGE = 10
ENEMY_ATTACK_COOLDOWN = 1500
ENEMY_PATROL_DIST = 150 # How far to move before turning in patrol

# --- Colors ---
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
RED = (255, 0, 0)
DARK_RED = (139, 0, 0)
GREEN = (0, 255, 0)
DARK_GREEN = (0, 100, 0)
BLUE = (0, 0, 255)
GRAY = (128, 128, 128)
DARK_GRAY = (50, 50, 50)
LIGHT_BLUE = (173, 216, 230)
ORANGE_RED = (255, 69, 0) # For Lava

# --- Animation ---
ANIM_FRAME_DURATION = 80 # ms per frame

# --- UI ---
HEALTH_BAR_WIDTH = 50
HEALTH_BAR_HEIGHT = 8

# --- Map ---
TILE_SIZE = 40 # Example, if you use a grid later
LAVA_PATCH_HEIGHT = 20 # How tall lava patches/wells rects are for collision (can be diff from visual depth)

LAVA_DAMAGE = 50

========== START OF FILE: enemy.py ==========

# -*- coding: utf-8 -*-
"""
enemy.py
Defines the Enemy class (CPU player clone).
Handles AI-driven movement, animations mirroring player, states, and interactions.
Each instance randomly selects a color variant for its animations.
"""
import pygame
import random
import math
import os # Needed for path joining

# Import necessary components
import constants as C # Use constants with C. prefix
from assets import load_all_player_animations # Reuse player animation loader
from tiles import Lava # Import Lava for type checking in hazard collision

class Enemy(pygame.sprite.Sprite):
    def __init__(self, start_x, start_y, patrol_area=None, enemy_id=None): # Added enemy_id
        super().__init__()
        self.spawn_pos = pygame.math.Vector2(start_x, start_y)
        self.patrol_area = patrol_area
        self.enemy_id = enemy_id 
        self.target_player_object = None # Stores the current AI target player object

        character_base_folder = 'characters'
        available_colors = ['cyan', 'green', 'pink', 'purple', 'red', 'yellow']
        if not available_colors:
             print("ERROR: No enemy colors defined in Enemy.__init__!")
             available_colors = ['player1'] 
             character_base_folder = '.' 

        chosen_color = random.choice(available_colors)
        self.color_name = chosen_color 
        chosen_folder_path = os.path.join(character_base_folder, chosen_color)

        print(f"Initializing Enemy instance with color: {chosen_color} (Path: {chosen_folder_path}) (ID: {self.enemy_id})")

        self.animations = load_all_player_animations(relative_asset_folder=chosen_folder_path) # Corrected typo
        if self.animations is None: 
            print(f"CRITICAL Enemy Init Error: Failed loading animations from {chosen_folder_path} for enemy {self.enemy_id}. Check path and idle animation.")
            self.image = pygame.Surface((30, 40)).convert_alpha(); self.image.fill(C.BLUE)
            self.rect = self.image.get_rect(midbottom=(start_x, start_y))
            self._valid_init = False
            self.is_dead = True 
            return 
        else:
             self._valid_init = True

        self._last_facing = True; self._last_state_for_debug = "init"
        self.state = 'idle'; self.current_frame = 0; self.last_anim_update = pygame.time.get_ticks()
        initial_anim = self.animations.get('idle')
        if not initial_anim: 
             print(f"Warning: Idle animation missing for {chosen_color} enemy, using first available.")
             first_key = next(iter(self.animations), None)
             initial_anim = self.animations.get(first_key) if first_key else None
        self.image = initial_anim[0] if initial_anim else pygame.Surface((30, 40)).convert_alpha() 
        if not initial_anim: self.image.fill(C.BLUE) 

        self.rect = self.image.get_rect(midbottom=(start_x, start_y))
        self.pos = pygame.math.Vector2(start_x, start_y); self.vel = pygame.math.Vector2(0, 0)
        self.acc = pygame.math.Vector2(0, C.PLAYER_GRAVITY)
        self.facing_right = random.choice([True, False]); self.on_ground = False
        self.on_ladder = False; self.can_grab_ladder = False; self.touching_wall = 0
        self.is_crouching = False; self.is_dashing = False; self.is_rolling = False
        self.is_sliding = False; self.can_wall_jump = False; self.wall_climb_timer = 0
        self.is_attacking = False; self.attack_timer = 0; self.attack_duration = 300
        self.attack_type = 0; self.attack_cooldown_timer = 0
        self.is_taking_hit = False; self.hit_timer = 0; self.hit_duration = 300 
        self.hit_cooldown = 500 
        self.is_dead = False; self.state_timer = 0
        self.max_health = C.ENEMY_MAX_HEALTH; self.current_health = self.max_health
        self.ai_state = 'patrolling'; self.patrol_target_x = start_x
        self.set_new_patrol_target()
        self.attack_hitbox = pygame.Rect(0, 0, 50, 35)
        try: self.standard_height = self.animations['idle'][0].get_height()
        except (KeyError, IndexError, TypeError): 
            print(f"Warning Enemy ({self.color_name}): Could not get idle anim height, using default.")
            self.standard_height = 60

    def set_new_patrol_target(self):
        if self.patrol_area and isinstance(self.patrol_area, pygame.Rect):
             min_x = self.patrol_area.left + self.rect.width / 2
             max_x = self.patrol_area.right - self.rect.width / 2
             if min_x < max_x: 
                 self.patrol_target_x = random.uniform(min_x, max_x)
             else: 
                 self.patrol_target_x = self.patrol_area.centerx
        else:
            direction = 1 if random.random() > 0.5 else -1
            self.patrol_target_x = self.pos.x + direction * C.ENEMY_PATROL_DIST

    def set_state(self, new_state):
        if not self._valid_init: return
        anim_state = new_state
        valid_anim_states = ['idle', 'run', 'attack', 'attack_nm', 'hit', 'death', 'death_nm', 'fall']
        if new_state not in valid_anim_states:
            if new_state in ['chasing', 'patrolling']: anim_state = 'run' if abs(self.vel.x) > 0.1 else 'idle'
            elif 'attack' in new_state: anim_state = new_state 
            else: anim_state = 'idle' 

        if anim_state not in self.animations or not self.animations[anim_state]:
             print(f"Warning Enemy ({self.color_name}): Animation for state '{anim_state}' missing/empty. Falling back to idle.")
             anim_state = 'idle'
             if 'idle' not in self.animations or not self.animations['idle']:
                 print(f"CRITICAL ERROR Enemy ({self.color_name}): Cannot find valid idle animation.")
                 return 

        if self.state != new_state and not self.is_dead:
            self._last_state_for_debug = new_state
            if 'attack' not in new_state: self.is_attacking = False; self.attack_type = 0
            if new_state != 'hit': self.is_taking_hit = False 

            self.state = new_state 
            self.current_frame = 0; self.last_anim_update = pygame.time.get_ticks(); self.state_timer = pygame.time.get_ticks()

            if 'attack' in new_state:
                self.is_attacking = True; self.attack_type = 1; self.attack_timer = self.state_timer
                anim = self.animations.get(anim_state) 
                self.attack_duration = len(anim) * C.ANIM_FRAME_DURATION if anim else 400
                self.vel.x = 0 
            elif new_state == 'hit':
                 self.is_taking_hit = True; self.hit_timer = self.state_timer
                 self.vel.x *= -0.5; self.vel.y = C.PLAYER_JUMP_STRENGTH * 0.3
                 self.is_attacking = False 
            elif new_state == 'death': 
                 self.is_dead = True; self.vel.x = 0; self.vel.y = 0
                 self.acc = pygame.math.Vector2(0, 0); self.current_health = 0
            self.animate() 
        elif not self.is_dead:
             self._last_state_for_debug = self.state 

    def animate(self):
        if not self._valid_init or not hasattr(self, 'animations') or not self.animations: return
        now = pygame.time.get_ticks()

        state_key = self.state
        if self.state == 'patrolling' or self.state == 'chasing':
             state_key = 'run' if abs(self.vel.x) > 0.5 else 'idle'
        elif self.is_attacking: state_key = 'attack_nm' if 'attack_nm' in self.animations and self.animations['attack_nm'] else 'attack' 
        elif self.is_taking_hit: state_key = 'hit' 
        elif self.is_dead: state_key = 'death_nm' if abs(self.vel.x) < 0.5 and 'death_nm' in self.animations and self.animations['death_nm'] else 'death'
        elif not self.on_ground: state_key = 'fall' if 'fall' in self.animations and self.animations['fall'] else 'idle' 
        else: state_key = 'idle' 

        if state_key not in self.animations or not self.animations[state_key]: state_key = 'idle'
        animation = self.animations.get(state_key) 
        if not animation:
             if hasattr(self, 'image') and self.image: self.image.fill(C.BLUE)
             return 

        if now - self.last_anim_update > C.ANIM_FRAME_DURATION:
            self.last_anim_update = now
            self.current_frame = (self.current_frame + 1)
            if self.current_frame >= len(animation):
                if self.state == 'hit': 
                    self.set_state('idle')
                    return
                elif self.is_dead: self.current_frame = len(animation) - 1 
                else: self.current_frame = 0 
            if self.current_frame >= len(animation): self.current_frame = 0

        if not animation or self.current_frame < 0 or self.current_frame >= len(animation):
            self.current_frame = 0 
            if not animation: 
                 if hasattr(self, 'image') and self.image: self.image.fill(C.BLUE)
                 return

        new_image = animation[self.current_frame]
        current_facing_is_right = self.facing_right
        if not current_facing_is_right: new_image = pygame.transform.flip(new_image, True, False)
        if self.image is not new_image or self._last_facing != current_facing_is_right:
            old_midbottom = self.rect.midbottom
            self.image = new_image
            self.rect = self.image.get_rect(midbottom=old_midbottom) 
            self._last_facing = current_facing_is_right

    def ai_update(self, players_list): # MODIFIED: Parameter is now a list
        now = pygame.time.get_ticks()
        
        # Prevent AI if dead or in hit stun cooldown
        if not self._valid_init or self.is_dead or (self.is_taking_hit and now - self.hit_timer < self.hit_cooldown):
            self.acc.x = 0
            self.target_player_object = None # Clear target
            return

        # Find the closest, living player
        closest_player_obj = None
        min_dist_sq = float('inf') # Use squared distance to avoid sqrt initially

        if not players_list: # Handle empty players_list (e.g., if both players disconnect or die simultaneously)
            self.target_player_object = None
        else:
            for p_obj in players_list:
                if p_obj and hasattr(p_obj, 'is_dead') and not p_obj.is_dead and hasattr(p_obj, 'pos'):
                    # Calculate squared distance first
                    dist_x = p_obj.pos.x - self.pos.x
                    dist_y = p_obj.pos.y - self.pos.y
                    current_dist_sq = dist_x**2 + dist_y**2
                    if current_dist_sq < min_dist_sq:
                        min_dist_sq = current_dist_sq
                        closest_player_obj = p_obj
        
        self.target_player_object = closest_player_obj # Update the AI's current target

        # If no valid target, default to patrolling
        if not self.target_player_object:
            self.ai_state = 'patrolling'
            if self.state != 'patrolling': self.set_state('patrolling')
            if abs(self.pos.x - self.patrol_target_x) < 10: self.set_new_patrol_target()
            target_facing_right_patrol = (self.patrol_target_x > self.pos.x)
            self.acc.x = C.ENEMY_ACCEL * 0.7 * (1 if target_facing_right_patrol else -1)
            if not self.is_attacking and self.facing_right != target_facing_right_patrol:
                self.facing_right = target_facing_right_patrol
            return

        # Use the chosen target_player_object for AI logic
        player = self.target_player_object 
        dist_to_player = math.sqrt(min_dist_sq) # Now calculate actual distance if needed

        y_diff = abs(player.rect.centery - self.rect.centery)
        line_of_sight = y_diff < self.rect.height * 2.0 
        player_in_range = dist_to_player < C.ENEMY_ATTACK_RANGE and line_of_sight # player.is_dead already checked
        player_detected = dist_to_player < C.ENEMY_DETECTION_RANGE and line_of_sight # player.is_dead already checked
        can_attack_now = now - self.attack_cooldown_timer > C.ENEMY_ATTACK_COOLDOWN

        if self.is_attacking and now - self.attack_timer > self.attack_duration:
             self.is_attacking = False; self.attack_type = 0
             self.attack_cooldown_timer = now
             self.set_state('idle') 
             return 

        if self.is_attacking:
            self.acc.x = 0; return

        target_acc_x = 0; target_facing_right = self.facing_right

        if player_in_range and can_attack_now:
            self.ai_state = 'attacking' 
            target_facing_right = (player.pos.x > self.pos.x) 
            self.facing_right = target_facing_right 
            self.set_state('attack_nm' if 'attack_nm' in self.animations else 'attack') 
            return 
        elif player_detected:
            self.ai_state = 'chasing'
            target_facing_right = (player.pos.x > self.pos.x)
            target_acc_x = C.ENEMY_ACCEL * (1 if target_facing_right else -1)
            if self.state != 'chasing': self.set_state('chasing') 
        else: 
            self.ai_state = 'patrolling'
            if self.state != 'patrolling': self.set_state('patrolling')
            if abs(self.pos.x - self.patrol_target_x) < 10: self.set_new_patrol_target()
            target_facing_right = (self.patrol_target_x > self.pos.x)
            target_acc_x = C.ENEMY_ACCEL * 0.7 * (1 if target_facing_right else -1)

        self.acc.x = target_acc_x
        if not self.is_attacking and self.facing_right != target_facing_right:
             self.facing_right = target_facing_right

    # MODIFIED: 'player' parameter renamed to 'players_list'
    def update(self, dt, players_list, platforms, hazards):
        if not self._valid_init or self.is_dead:
            if self.is_dead: self.animate() 
            return

        now = pygame.time.get_ticks()
        if self.is_taking_hit and now - self.hit_timer > self.hit_cooldown:
            self.is_taking_hit = False

        self.ai_update(players_list) # Pass the list of players

        if not self.is_dead: self.vel.y += C.PLAYER_GRAVITY 
        self.vel.x += self.acc.x 
        current_friction = 0
        if self.on_ground and self.acc.x == 0: current_friction = C.ENEMY_FRICTION
        if current_friction != 0:
             friction_force = self.vel.x * current_friction
             if abs(self.vel.x) > 0.1: self.vel.x += friction_force
             else: self.vel.x = 0 
        self.vel.x = max(-C.ENEMY_RUN_SPEED_LIMIT, min(C.ENEMY_RUN_SPEED_LIMIT, self.vel.x))
        self.vel.y = min(self.vel.y, 18)

        self.on_ground = False 

        self.pos.x += self.vel.x
        self.rect.centerx = round(self.pos.x)
        self.check_platform_collisions('x', platforms)
        collided_x_player = self.check_character_collision('x', players_list) # Pass list

        self.pos.y += self.vel.y
        self.rect.bottom = round(self.pos.y)
        self.check_platform_collisions('y', platforms)
        if not collided_x_player:
            self.check_character_collision('y', players_list) # Pass list

        self.pos.x = self.rect.centerx; self.pos.y = self.rect.bottom

        self.check_attack_collisions(players_list) # Pass list
        self.check_hazard_collisions(hazards)

        self.animate() 

    def check_platform_collisions(self, direction, platforms):
        """ Resolves collisions with solid platforms. Bounces horizontally if specified in original code. """
        collided_sprites = pygame.sprite.spritecollide(self, platforms, False)
        for plat in collided_sprites:
            if direction == 'x':
                original_vel_x = self.vel.x
                if original_vel_x > 0: 
                    self.rect.right = plat.rect.left
                elif original_vel_x < 0: 
                    self.rect.left = plat.rect.right
                
                # Check if your original code had bouncing for enemies or just stopping
                # self.vel.x *= -1 # If bouncing
                # self.facing_right = not self.facing_right # If bouncing
                self.vel.x = 0 # If stopping (as per the code you provided before this error)

                self.pos.x = self.rect.centerx
                if self.ai_state == 'patrolling':
                    self.set_new_patrol_target()
            elif direction == 'y':
                if self.vel.y > 0: 
                    previous_bottom = self.pos.y - self.vel.y
                    if previous_bottom <= plat.rect.top + 1: 
                         self.rect.bottom = plat.rect.top
                         self.on_ground = True
                         self.vel.y = 0
                         self.pos.y = self.rect.bottom
                elif self.vel.y < 0: 
                    previous_top = (self.pos.y - self.rect.height) - self.vel.y
                    if previous_top >= plat.rect.bottom - 1: 
                         self.rect.top = plat.rect.bottom
                         self.vel.y = 0
                         self.pos.y = self.rect.bottom 


    # MODIFIED: 'player' parameter renamed to 'players_list'
    def check_character_collision(self, direction, players_list):
        if not self._valid_init or self.is_dead: return False
        
        any_collision_this_frame = False
        for player_obj in players_list:
            if not player_obj or (hasattr(player_obj, 'is_dead') and player_obj.is_dead):
                continue

            if self.rect.colliderect(player_obj.rect):
                any_collision_this_frame = True
                if direction == 'x':
                    push_dir = 0 
                    if self.rect.centerx < player_obj.rect.centerx: 
                        self.rect.right = player_obj.rect.left
                        push_dir = -1 
                    else: 
                        self.rect.left = player_obj.rect.right
                        push_dir = 1 

                    self.vel.x = push_dir * C.CHARACTER_BOUNCE_VELOCITY
                    if hasattr(player_obj, 'vel'):
                        player_obj.vel.x = -push_dir * C.CHARACTER_BOUNCE_VELOCITY
                        player_obj.rect.x += -push_dir * 2 
                    self.pos.x = self.rect.centerx 
                elif direction == 'y':
                     if self.vel.y > 0 and self.rect.bottom > player_obj.rect.top: 
                        self.rect.bottom = player_obj.rect.top
                        self.on_ground = True 
                        self.vel.y = 0
                     elif self.vel.y < 0 and self.rect.top < player_obj.rect.bottom: 
                        self.rect.top = player_obj.rect.bottom
                        self.vel.y = 0
                     self.pos.y = self.rect.bottom 
                # If a collision happened with one player, we might break or continue
                # For now, let it check all players, but bounce logic might be tricky for multiple simultaneous
        return any_collision_this_frame


    def check_hazard_collisions(self, hazards):
        now = pygame.time.get_ticks()
        if not self._valid_init or self.is_dead or (self.is_taking_hit and now - self.hit_timer < self.hit_cooldown):
             return

        collided_hazards = pygame.sprite.spritecollide(self, hazards, False)
        damaged_this_frame = False
        for hazard in collided_hazards:
            check_point = (self.rect.centerx, self.rect.bottom - 1)
            if isinstance(hazard, Lava) and hazard.rect.collidepoint(check_point) and not damaged_this_frame:
                self.take_damage(C.LAVA_DAMAGE)
                damaged_this_frame = True
                if not self.is_dead:
                     self.vel.y = C.PLAYER_JUMP_STRENGTH * 0.3 
                     push_dir = 1 if self.rect.centerx < hazard.rect.centerx else -1
                     self.vel.x = -push_dir * 4 
                     self.on_ground = False 
                break 

    # MODIFIED: 'player' parameter renamed to 'players_list'
    def check_attack_collisions(self, players_list):
        if not self._valid_init or not self.is_attacking or self.is_dead: return

        if self.facing_right: self.attack_hitbox.midleft = self.rect.midright
        else: self.attack_hitbox.midright = self.rect.midleft
        self.attack_hitbox.centery = self.rect.centery

        now = pygame.time.get_ticks()
        for player_obj in players_list:
            if not player_obj or (hasattr(player_obj, 'is_dead') and player_obj.is_dead):
                continue
            
            # Check if player_obj is invincible
            if hasattr(player_obj, 'is_taking_hit') and player_obj.is_taking_hit and \
               hasattr(player_obj, 'hit_timer') and hasattr(player_obj, 'hit_cooldown') and \
               now - player_obj.hit_timer < player_obj.hit_cooldown:
                continue 

            if self.attack_hitbox.colliderect(player_obj.rect):
                if hasattr(player_obj, 'take_damage') and callable(player_obj.take_damage):
                    player_obj.take_damage(C.ENEMY_ATTACK_DAMAGE)
                    # Potentially break if an attack only hits one target per swing


    def take_damage(self, amount):
        now = pygame.time.get_ticks()
        if not self._valid_init or self.is_dead or (self.is_taking_hit and now - self.hit_timer < self.hit_cooldown):
            return

        self.current_health -= amount
        self.current_health = max(0, self.current_health)

        if self.current_health <= 0:
            if not self.is_dead: self.set_state('death')
        else:
             if not (self.is_taking_hit and now - self.hit_timer < self.hit_duration):
                self.set_state('hit') 

    def reset(self):
        if not self._valid_init: return
        self.pos = self.spawn_pos.copy()
        self.vel = pygame.math.Vector2(0, 0)
        self.acc = pygame.math.Vector2(0, C.PLAYER_GRAVITY) 
        self.current_health = self.max_health
        self.is_dead = False; self.is_taking_hit = False; self.is_attacking = False
        self.attack_type = 0; self.attack_cooldown_timer = 0
        self.facing_right = random.choice([True, False])
        self.on_ground = False 
        self.rect.midbottom = (round(self.pos.x), round(self.pos.y))
        self.set_state('idle') 
        self.ai_state = 'patrolling' 
        self.target_player_object = None # Reset target
        self.set_new_patrol_target() 

========== START OF FILE: items.py ==========

# items.py
# -*- coding: utf-8 -*-
"""
Defines collectible items like Chests.
Uses resource_path helper for PyInstaller compatibility.
"""
import pygame
import os
import sys # Needed for resource_path logic (imported via assets)
import random

# Import necessary components
import constants as C
# Import BOTH the loader AND the path helper from assets.py
from assets import load_gif_frames, resource_path

class Chest(pygame.sprite.Sprite):
    """
    A chest that restores player health when collected.
    """
    def __init__(self, x, y):
        super().__init__()

        # --- Define the relative path to the asset ---
        # This path is relative to the project root (or wherever resource_path resolves from)
        relative_chest_path = os.path.join('characters', 'items', 'chest.gif')

        # --- Use resource_path to get the correct full path ---
        # resource_path figures out if we're running bundled or locally
        full_chest_path = resource_path(relative_chest_path)
        print(f"Attempting to load chest GIF from resolved path: {full_chest_path}") # Debug print resolved path

        # --- Load frames using the full path ---
        self.frames = load_gif_frames(full_chest_path)

        # --- Error Handling and Placeholder ---
        # Check if loading failed OR if load_gif_frames returned its standard red placeholder
        # (assuming the standard placeholder size is 30x40 from assets.py)
        is_placeholder = False
        if self.frames and len(self.frames) == 1:
             placeholder_check_surf = self.frames[0]
             # Basic check based on size and maybe color (adjust size if your placeholder is different)
             if placeholder_check_surf.get_size() == (30, 40) and placeholder_check_surf.get_at((0,0)) == C.RED:
                 is_placeholder = True

        if not self.frames or is_placeholder:
            # Provide a specific fallback surface for the chest if loading fails OR returns default placeholder
            if not self.frames:
                print(f"Error: Failed to load chest from '{full_chest_path}'. Using placeholder.")
            else: # It returned a placeholder
                print(f"Warning: Chest loaded as a default placeholder from '{full_chest_path}'. Check file/path.")

            self.image = pygame.Surface((30, 30)).convert_alpha()
            self.image.fill(C.YELLOW) # Use a distinct placeholder color for chest issues
            pygame.draw.rect(self.image, C.BLACK, self.image.get_rect(), 1)
            pygame.draw.line(self.image, C.BLACK, (0, 0), (30, 30), 1) # Add cross to placeholder
            pygame.draw.line(self.image, C.BLACK, (0, 30), (30, 0), 1)
            self.frames = [self.image] # Make frames list contain the specific chest placeholder
            self._valid_init = False # Indicate potential issue, though it might still draw
        else:
            # Successfully loaded actual frames
            self.image = self.frames[0] # Use the first frame
            self._valid_init = True
            print(f"Successfully loaded {len(self.frames)} frame(s) for chest.")

        self.rect = self.image.get_rect(midbottom=(x, y))
        self.pos = pygame.math.Vector2(x, y) # Store position if needed later

        # Animation state
        self.current_frame = 0
        self.last_anim_update = pygame.time.get_ticks()
        self.is_collected = False # Flag to prevent multiple collections

    def update(self, dt):
        """ Handles animation if the GIF has multiple frames. dt is not used here yet. """
        # Don't animate if initialization potentially failed or only 1 frame (placeholder/static)
        if not self._valid_init or len(self.frames) <= 1:
            return

        now = pygame.time.get_ticks()
        # Adjust ANIM_FRAME_DURATION if chest animation speed should differ
        anim_speed_multiplier = 2 # Example: make chest animation slower than player/enemy
        if now - self.last_anim_update > C.ANIM_FRAME_DURATION * anim_speed_multiplier:
            self.last_anim_update = now
            self.current_frame = (self.current_frame + 1) % len(self.frames) # Loop animation
            current_midbottom = self.rect.midbottom # Store position anchor
            self.image = self.frames[self.current_frame]
            # Re-center rect if frame sizes change during animation (unlikely for simple items)
            self.rect = self.image.get_rect(midbottom=current_midbottom) # Re-anchor rect after getting new image

    def collect(self, player):
        """ Action when the player collects the chest. """
        # Only collect if properly initialized and not already collected
        if not self.is_collected and self._valid_init:
            print("Player collected chest!")
            # Ensure player has the heal_to_full method before calling it
            if hasattr(player, 'heal_to_full') and callable(player.heal_to_full):
                player.heal_to_full()
            else:
                print("Warning: Player object does not have 'heal_to_full' method.")
            self.is_collected = True
            self.kill() # Remove sprite from all groups it belongs to

========== START OF FILE: levels.py ==========

# -*- coding: utf-8 -*-
"""
levels.py
Returns sprite groups for platforms, ladders, hazards, spawns, level width, ground Y, and ground height.
"""
import pygame
import random
from tiles import Platform, Ladder, Lava # Import tile classes
from constants import TILE_SIZE, GRAY, DARK_GREEN, ORANGE_RED, LAVA_PATCH_HEIGHT

# Constants for fences (can be adjusted)
FENCE_WIDTH = 8
FENCE_HEIGHT = 15 # Short enough to jump over easily
FENCE_COLOR = GRAY # Match ground or use a distinct color like DARK_GRAY


def load_map_original(initial_width, initial_height):
    """ Creates the original level layout. """
    platforms = pygame.sprite.Group()
    ladders = pygame.sprite.Group()
    hazards = pygame.sprite.Group()
    enemy_spawns_data = [] # List of dictionaries {'pos': (x,y), 'patrol': rect or None}
    player_spawn = (100, initial_height - 41)
    ground_width = initial_width * 2.5
    ground_y = initial_height - 40
    ground_height = 40
    ground = Platform(0, ground_y, ground_width, ground_height, GRAY)
    platforms.add(ground)

    # Platforms
    platforms.add(Platform(200, initial_height - 150, 250, 20, GRAY))
    platforms.add(Platform(450, initial_height - 300, 180, 20, GRAY))
    platforms.add(Platform(initial_width - 350, initial_height - 450, 200, 20, GRAY))
    platforms.add(Platform(initial_width + 150, initial_height - 250, 150, 20, GRAY))
    platforms.add(Platform(900, initial_height - 550, 100, 20, GRAY))

    # Walls
    wall_left = Platform(-20, -initial_height, 20, initial_height * 2 + ground_height, GRAY) # Extend up/down
    wall_right_level_end = Platform(ground_width, -initial_height, 20, initial_height * 2 + ground_height, GRAY) # Extend up/down
    wall_mid = Platform(800, initial_height - 400, 30, 360, GRAY)
    platforms.add(wall_left, wall_right_level_end, wall_mid)

    # Ladders
    ladder_width = 40; ladder_height = 250; ladder_x = initial_width - 500; ladder_y = ground_y - ladder_height
    ladders.add(Ladder(ladder_x, ladder_y, ladder_width, ladder_height))
    ladders.add(Ladder(350, initial_height - 250, ladder_width, 150))

    return platforms, ladders, hazards, enemy_spawns_data, player_spawn, ground_width, ground_y, ground_height

def load_map_lava(initial_width, initial_height):
    """ Creates a level with lava rivers/pools. """
    platforms = pygame.sprite.Group()
    ladders = pygame.sprite.Group()
    hazards = pygame.sprite.Group()
    enemy_spawns_data = []
    player_spawn = (80, initial_height - 150)
    level_width = initial_width * 2.8
    ground_level_y_ref = initial_height - 40 # Reference Y where lava sits
    ground_platform_height = 0 # No single ground platform

    # Platforms
    platforms.add(Platform(50, initial_height - 120, 150, 20, DARK_GREEN))
    platforms.add(Platform(300, initial_height - 180, 120, 20, DARK_GREEN))
    platforms.add(Platform(500, initial_height - 150, 100, 20, DARK_GREEN))
    platforms.add(Platform(700, initial_height - 200, 130, 20, DARK_GREEN))
    platforms.add(Platform(900, initial_height - 250, 100, 20, DARK_GREEN))
    platforms.add(Platform(1100, initial_height - 400, 30, 400, GRAY)) # Wall climb
    platforms.add(Platform(1250, initial_height - 350, 150, 20, DARK_GREEN))
    platforms.add(Platform(1450, initial_height - 500, 30, 500, GRAY)) # Wall climb
    platforms.add(Platform(1600, initial_height - 480, 200, 20, DARK_GREEN)) # Final

    # Lava Pools
    lava_y = ground_level_y_ref
    lava_height = 60 # Make visually deeper
    hazards.add(Lava(0, lava_y, 1100, lava_height, ORANGE_RED))
    hazards.add(Lava(1130, lava_y, 320, lava_height, ORANGE_RED))
    hazards.add(Lava(1550, lava_y, level_width - 1550, lava_height, ORANGE_RED))

    # Boundary walls
    platforms.add(Platform(-20, -initial_height, 20, initial_height * 2 + lava_height, GRAY))
    platforms.add(Platform(level_width, -initial_height, 20, initial_height * 2 + lava_height, GRAY))

    # TODO: Add fences for load_map_lava if desired, similar to load_map_cpu_extended below

    return platforms, ladders, hazards, enemy_spawns_data, player_spawn, level_width, ground_level_y_ref, ground_platform_height


def load_map_cpu_extended(initial_width, initial_height):
    """ Creates a larger level with CPU enemy and DEEP LAVA WELLS with fences. """
    platforms = pygame.sprite.Group()
    ladders = pygame.sprite.Group()
    hazards = pygame.sprite.Group()
    enemy_spawns_data = []
    player_spawn = (100, initial_height - 41 - FENCE_HEIGHT) # Adjust spawn height for fence

    level_width = initial_width * 4.0 # Make the level much wider

    # Ground Definition
    ground_y = initial_height - 40
    ground_height = 40
    # lava_well_visual_depth = 200 # How far down the lava extends visually in the gap (unused for now)
    lava_collision_height = LAVA_PATCH_HEIGHT # Use constant for collision rect height

    # --- Create Ground Segments with Gaps ---
    gap_width = 120 # Width of the lava gaps
    # Define segments by their start and end X coordinates
    segment_defs = [
        (0, 500),               # Segment 1: Start=0, End=500
        (500 + gap_width, 1100), # Segment 2: Start=620, End=1100
        (1100 + gap_width, 1700),# Segment 3: Start=1220, End=1700
        (1700 + gap_width, 2300),# Segment 4: Start=1820, End=2300
        (2300 + gap_width, level_width) # Final Segment: Start=2420, End=level_width
    ]

    # Create platform sprites for ground segments
    for start_x, end_x in segment_defs:
        width = end_x - start_x
        if width > 0: # Ensure non-zero width
            platforms.add(Platform(start_x, ground_y, width, ground_height, GRAY))

    # --- Create Lava Wells AND FENCES in the Gaps ---
    for i in range(len(segment_defs) - 1):
        lava_start_x = segment_defs[i][1] # End X of the previous segment
        lava_end_x = segment_defs[i+1][0] # Start X of the next segment
        lava_width = lava_end_x - lava_start_x # Calculate the gap width

        if lava_width > 0:
            # Create the damaging lava rect (thin, at the top of the well)
            # Place its top slightly below ground surface for feet collision
            lava_collision_y = ground_y + 1
            hazards.add(Lava(lava_start_x, lava_collision_y, lava_width, lava_collision_height, ORANGE_RED))

            # --- Add Little Fences ---
            fence_y = ground_y - FENCE_HEIGHT # Place top of fence FENCE_HEIGHT pixels above ground Y

            # Fence before the gap (at the end of the previous ground segment)
            # Its right edge is at lava_start_x, so its left edge (x) is lava_start_x - FENCE_WIDTH
            platforms.add(Platform(lava_start_x - FENCE_WIDTH, fence_y, FENCE_WIDTH, FENCE_HEIGHT, FENCE_COLOR))

            # Fence after the gap (at the start of the next ground segment)
            # Its left edge is at lava_end_x
            platforms.add(Platform(lava_end_x, fence_y, FENCE_WIDTH, FENCE_HEIGHT, FENCE_COLOR))

            # Optional: Add a visual-only lava sprite below for the deep well effect
            # visual_lava = Platform(lava_start_x, lava_collision_y + lava_collision_height, lava_width, lava_well_visual_depth - lava_collision_height, ORANGE_RED)
            # Needs separate handling for drawing if not in 'platforms' or 'hazards'

    # --- Platforms above ground ---
    platforms.add(Platform(300, initial_height - 160, 200, 20, DARK_GREEN))
    platforms.add(Platform(700, initial_height - 280, 150, 20, DARK_GREEN))
    platforms.add(Platform(1400, initial_height - 180, 250, 20, DARK_GREEN)) # Over a gap
    platforms.add(Platform(2000, initial_height - 160, 150, 20, DARK_GREEN))
    platforms.add(Platform(level_width - 400, initial_height- 240, 180, 20, DARK_GREEN)) # Near end

    # --- Boundary Walls ---
    # Make walls very tall to prevent jumping over, start high above ground too
    wall_height = initial_height * 3 + ground_height
    wall_y = -initial_height * 2
    platforms.add(Platform(-20, wall_y, 20, wall_height, GRAY)) # Tall Left wall
    platforms.add(Platform(level_width, wall_y, 20, wall_height, GRAY)) # Tall Right wall

    # --- Enemy Spawns ---
    # Adjust spawn Y for fences if spawning near an edge
    spawn_y_on_ground = ground_y - 1 # Standard Y just above ground
    spawn_y_on_ground_fenced = ground_y - FENCE_HEIGHT - 1 # Y just above fence height

    # Spawn near middle on ground segment 2 (needs to clear fence if near edge)
    enemy_spawns_data.append({'pos': (segment_defs[1][0] + 100, spawn_y_on_ground_fenced), 'patrol': None})
    # Spawn on platform over gap (no fence here)
    enemy_spawns_data.append({'pos': (1450, initial_height - 181), 'patrol': None})
    # Spawn patrolling near end on ground segment (needs to clear fence if near edge)
    patrol_rect = pygame.Rect(segment_defs[-1][0] + 50, ground_y - 100, 350, 100) # Area for patrol target selection
    enemy_spawns_data.append({'pos': (segment_defs[-1][0] + 100, spawn_y_on_ground_fenced), 'patrol': patrol_rect})

    # Adjust player spawn Y slightly just in case it's near a fence edge initially
    # (The previous adjustment at the top should handle the general case)
    # player_spawn = (player_spawn[0], ground_y - FENCE_HEIGHT - 1) # Ensure player starts above fence level

    return platforms, ladders, hazards, enemy_spawns_data, player_spawn, level_width, ground_y, ground_height

# Alias for easy switching in main.py
load_map_cpu = load_map_cpu_extended

# Example usage (if you were to run this file directly for testing)
if __name__ == '__main__':
    pygame.init()
    screen_width = 800
    screen_height = 600
    screen = pygame.display.set_mode((screen_width, screen_height))
    pygame.display.set_caption("Level Test")

    # Test the map with fences
    platforms, ladders, hazards, enemy_spawns, player_spawn_pos, level_w, ground_y_pos, ground_h_val = load_map_cpu_extended(screen_width, screen_height)

    all_sprites = pygame.sprite.Group()
    all_sprites.add(platforms, ladders, hazards) # Add all created sprites

    # Basic game loop for visualization
    running = True
    camera_x = 0
    clock = pygame.time.Clock()

    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            if event.type == pygame.KEYDOWN:
                 if event.key == pygame.K_LEFT:
                     camera_x += 20
                 if event.key == pygame.K_RIGHT:
                     camera_x -= 20


        # Clear screen
        screen.fill((135, 206, 235)) # Light blue background

        # Draw everything (shifted by camera)
        for sprite in all_sprites:
            screen.blit(sprite.image, (sprite.rect.x + camera_x, sprite.rect.y))

        # Draw player spawn position marker
        pygame.draw.circle(screen, (0, 255, 0), (player_spawn_pos[0] + camera_x, player_spawn_pos[1]), 5)

        # Draw enemy spawn position markers
        for spawn_data in enemy_spawns:
            pygame.draw.circle(screen, (255, 0, 0), (spawn_data['pos'][0] + camera_x, spawn_data['pos'][1]), 5)
            if spawn_data['patrol']:
                 patrol_vis_rect = spawn_data['patrol'].move(camera_x, 0)
                 pygame.draw.rect(screen, (255, 255, 0), patrol_vis_rect, 1)


        pygame.display.flip()
        clock.tick(60)

    pygame.quit()

========== START OF FILE: main.py ==========

# merged_main.py
# Run this code
# -*- coding: utf-8 -*-
import pygame
import sys
import os
import math # Keep math
import random
import socket
import threading
import time
import json
import traceback

# --- Pyperclip Check ---
PYPERCLIP_AVAILABLE = False
try:
    import pyperclip
    PYPERCLIP_AVAILABLE = True
    print("Pyperclip library found and imported successfully.")
except ImportError:
    print("Warning: Pyperclip library not found (pip install pyperclip).")

# --- Platformer Imports ---
try:
    import constants as C
    from player import Player # Player class should have self_inflict_damage, reset_state, etc.
    from enemy import Enemy
    from tiles import Platform, Ladder, Lava # Ensure Platform is imported if used in fallback
    from camera import Camera
    try:
        from items import Chest
    except ImportError:
        print("Warning: items.py or Chest class not found. Chests will not be available.")
        Chest = None
    import levels as LevelLoader
    import ui
    print("Platformer modules imported successfully.")
except ImportError as e:
    print(f"FATAL: Failed to import platformer module: {e}")
    print("Ensure player.py, enemy.py, tiles.py, levels.py, ui.py, camera.py, constants.py are present.")
    sys.exit(1)
except Exception as e:
    print(f"FATAL: Error during platformer module import: {e}")
    sys.exit(1)

# --- Pygame Init ---
pygame.init()
pygame.font.init()

# --- Pygame Scrap Init ---
SCRAP_INITIALIZED = False
try:
    pygame.scrap.init()
    SCRAP_INITIALIZED = pygame.scrap.get_init()
    if SCRAP_INITIALIZED: print("Clipboard (pygame.scrap) module initialized successfully.")
    else: print("Warning: pygame.scrap module initialized but status check failed.")
except pygame.error as e: print(f"Warning: pygame.scrap module could not be initialized: {e}")
except AttributeError: print(f"Warning: pygame.scrap module not found or available on this system.")
except Exception as e: print(f"Warning: An unexpected error occurred during pygame.scrap init: {e}")

# --- Constants & Globals ---
SERVER_IP_BIND = '0.0.0.0'
SERVER_PORT_TCP = 5555
DISCOVERY_PORT_UDP = 5556
BUFFER_SIZE = 4096
BROADCAST_INTERVAL_S = 1.0
CLIENT_SEARCH_TIMEOUT_S = 5.0
SERVICE_NAME = "platformer_adventure_lan_v1"

try:
    display_info = pygame.display.Info()
    monitor_width = display_info.current_w; monitor_height = display_info.current_h
    initial_width = max(800, min(1600, monitor_width * 3 // 4))
    initial_height = max(600, min(900, monitor_height * 3 // 4))
    WIDTH = initial_width; HEIGHT = initial_height
    flags = pygame.RESIZABLE | pygame.DOUBLEBUF
    screen = pygame.display.set_mode((WIDTH, HEIGHT), flags)
    print(f"Initial window: {WIDTH}x{HEIGHT}")
except Exception as e: print(f"Error setting up display: {e}"); pygame.quit(); sys.exit()

clock = None
font_small, font_medium, font_large, debug_font = None, None, None, None
app_running = True

server_tcp_socket, server_udp_socket, client_connection, client_address = None, None, None, None
client_input_buffer = {}; client_state_buffer = b""; client_lock = threading.Lock()
broadcast_thread, client_handler_thread = None, None
client_tcp_socket = None; server_state_buffer = b""

player1, player2, camera, current_chest = None, None, None, None
platform_sprites, ladder_sprites, hazard_sprites, enemy_sprites, collectible_sprites, all_sprites = \
    pygame.sprite.Group(), pygame.sprite.Group(), pygame.sprite.Group(), \
    pygame.sprite.Group(), pygame.sprite.Group(), pygame.sprite.Group()
enemy_list = []
level_pixel_width, level_pixel_height = WIDTH, HEIGHT
ground_level_y, ground_platform_height = HEIGHT - 40, 40
player1_spawn_pos, player2_spawn_pos = (100, HEIGHT - 80), (150, HEIGHT - 80)
enemy_spawns_data = [] # Initialize as empty list globally, populated by level loader

# --- Helper Functions (Network - kept as is) ---
def get_local_ip():
    best_ip = '127.0.0.1'
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM); s.connect(("8.8.8.8", 80))
        best_ip = s.getsockname()[0]; s.close()
    except Exception:
        try: best_ip = socket.gethostbyname(socket.gethostname())
        except Exception: best_ip = '127.0.0.1'
    print(f"Detected local IP: {best_ip}")
    return best_ip

def encode_data(data):
    try: return json.dumps(data).encode('utf-8') + b'\n'
    except TypeError as e: print(f"Encoding Error: {e} Data: {str(data)[:100]}"); return None
    except Exception as e: print(f"Unexpected Encoding Error: {e}"); return None

def decode_data_stream(byte_buffer):
    decoded_objects, remaining_buffer = [], byte_buffer
    while b'\n' in remaining_buffer:
        message, remaining_buffer = remaining_buffer.split(b'\n', 1)
        if not message: continue
        try: decoded_objects.append(json.loads(message.decode('utf-8')))
        except Exception: continue
    return decoded_objects, remaining_buffer

# --- Platformer Specific Helper Functions ---
def initialize_platformer_elements(for_game_mode="unknown"):
    global platform_sprites, ladder_sprites, hazard_sprites, enemy_spawns_data, \
           player1_spawn_pos, player2_spawn_pos, level_pixel_width, level_pixel_height, ground_level_y, \
           ground_platform_height, all_sprites, enemy_sprites, \
           collectible_sprites, player1, player2, enemy_list, \
           current_chest, WIDTH, HEIGHT, camera

    print(f"Initializing platformer elements for mode: {for_game_mode}...")
    if player1: player1.kill(); player1 = None
    if player2: player2.kill(); player2 = None
    if current_chest: current_chest.kill(); current_chest = None
    all_sprites.empty(); platform_sprites.empty(); ladder_sprites.empty(); hazard_sprites.empty()
    enemy_sprites.empty(); collectible_sprites.empty(); enemy_list.clear()

    print("Loading level data via LevelLoader...")
    try:
        platform_data_group, ladder_data_group, hazard_data_group, enemy_spawns_data_list, \
        p1_spawn_tuple, lvl_width_pixels, ground_y_coord, ground_h_pixels = \
            LevelLoader.load_map_cpu_extended(WIDTH, HEIGHT) # Using one of your defined maps
        
        enemy_spawns_data = enemy_spawns_data_list # Store the loaded spawn data globally
        
        platform_sprites.add(platform_data_group); ladder_sprites.add(ladder_data_group)
        hazard_sprites.add(hazard_data_group); player1_spawn_pos = p1_spawn_tuple
        player2_spawn_pos = (p1_spawn_tuple[0] + 60, p1_spawn_tuple[1])
        level_pixel_width = lvl_width_pixels; level_pixel_height = HEIGHT # Assuming full screen height for level
        ground_level_y = ground_y_coord; ground_platform_height = ground_h_pixels
        print("Level geometry loaded.")
    except Exception as e: print(f"CRITICAL ERROR loading level: {e}"); traceback.print_exc(); return False

    all_sprites.add(platform_sprites, ladder_sprites, hazard_sprites)

    if for_game_mode in ["host", "couch_play", "single_player"]:
        print("Initializing player 1..."); player1 = Player(player1_spawn_pos[0], player1_spawn_pos[1], player_id=1)
        if not player1._valid_init: print("CRITICAL: P1 init failed."); return False
        all_sprites.add(player1); print("P1 initialized.")
    if for_game_mode == "couch_play":
        print("Initializing player 2 (couch)..."); player2 = Player(player2_spawn_pos[0], player2_spawn_pos[1], player_id=2)
        if not player2._valid_init: print("CRITICAL: P2 (couch) init failed."); return False
        all_sprites.add(player2); print("P2 (couch) initialized.")
    elif for_game_mode == "host":
        print("Initializing player 2 (remote placeholder)..."); player2 = Player(player2_spawn_pos[0], player2_spawn_pos[1], player_id=2)
        if not player2._valid_init: print("CRITICAL: P2 (remote) init failed."); return False
        all_sprites.add(player2); print("P2 (remote) initialized.")
    elif for_game_mode == "client":
        print("Initializing player 1 (remote placeholder)..."); player1 = Player(player1_spawn_pos[0], player1_spawn_pos[1], player_id=1)
        if not player1._valid_init: print("CRITICAL: P1 (remote) init failed."); return False
        all_sprites.add(player1); print("P1 (remote) initialized.")
        print("Initializing player 2 (local client)..."); player2 = Player(player2_spawn_pos[0], player2_spawn_pos[1], player_id=2)
        if not player2._valid_init: print("CRITICAL: P2 (local client) init failed."); return False
        all_sprites.add(player2); print("P2 (local client) initialized.")

    enemy_list.clear(); print(f"Spawning {len(enemy_spawns_data)} enemies...") # Use global enemy_spawns_data
    for i, spawn_data in enumerate(enemy_spawns_data): # Use global enemy_spawns_data
        try:
            enemy = Enemy(spawn_data['pos'][0], spawn_data['pos'][1], spawn_data.get('patrol'), enemy_id=i)
            if enemy._valid_init: all_sprites.add(enemy); enemy_sprites.add(enemy); enemy_list.append(enemy)
            else: print(f"Error: Enemy {i} init failed.")
        except Exception as e: print(f"Error spawning enemy {i}: {e}")
    print(f"Enemies spawned: {len(enemy_list)}")

    current_chest = spawn_chest_platformer() # Assigns to global current_chest
    if current_chest: all_sprites.add(current_chest); collectible_sprites.add(current_chest)
    
    return True

def spawn_chest_platformer():
    global platform_sprites, collectible_sprites, all_sprites, ground_level_y, Chest, current_chest
    if Chest is None: print("Chest class not available."); return None
    if current_chest and current_chest.alive(): current_chest.kill()
    try:
        valid_plats = [p for p in platform_sprites if p.rect.top < ground_level_y - 50 and p.rect.width > 50]
        if not valid_plats: valid_plats = list(platform_sprites)
        if not valid_plats: print("No platforms to spawn chest on."); return None
        chosen_platform = random.choice(valid_plats)
        cx = random.randint(chosen_platform.rect.left + 20, chosen_platform.rect.right - 20)
        cy = chosen_platform.rect.top
        new_chest = Chest(cx, cy)
        if hasattr(new_chest, '_valid_init') and new_chest._valid_init:
            print(f"Chest object created at ({int(new_chest.rect.centerx)}, {int(new_chest.rect.bottom)}).")
            return new_chest
    except Exception as e: print(f"Error creating new chest object: {e}")
    return None

def reset_platformer_game_state():
    global player1, player2, enemy_list, current_chest, player1_spawn_pos, player2_spawn_pos, all_sprites, collectible_sprites
    print("\n--- Resetting Platformer Game State ---")
    if player1 and hasattr(player1, 'reset_state'): player1.reset_state(player1_spawn_pos); print("P1 Reset")
    if player2 and hasattr(player2, 'reset_state'): player2.reset_state(player2_spawn_pos); print("P2 Reset")
    for enemy in enemy_list:
        if hasattr(enemy, 'reset'): enemy.reset()
    print(f"{len(enemy_list)} enemies reset.")
    
    current_chest = spawn_chest_platformer()
    if current_chest:
        all_sprites.add(current_chest)
        collectible_sprites.add(current_chest)
        print("Chest respawned.")
    else:
        print("Failed to respawn chest or Chest class not available.")
    print("--- Game State Reset Finished ---\n")

def get_platformer_network_state():
    global player1, player2, enemy_list, current_chest
    state = {'p1': None, 'p2': None, 'enemies': {}, 'chest': None, 'game_over': False}
    if player1 and hasattr(player1, 'get_network_data'): state['p1'] = player1.get_network_data()
    if player2 and hasattr(player2, 'get_network_data'): state['p2'] = player2.get_network_data()
    for enemy in enemy_list:
        if hasattr(enemy, 'enemy_id') and hasattr(enemy, 'get_network_data') and enemy.alive():
            state['enemies'][str(enemy.enemy_id)] = enemy.get_network_data()
    if current_chest and current_chest.alive() and hasattr(current_chest, 'rect'):
        state['chest'] = {'pos': (current_chest.rect.centerx, current_chest.rect.centery),
                          'is_collected': getattr(current_chest, 'is_collected', False)}
    p1_dead = not (player1 and hasattr(player1, 'is_dead') and not player1.is_dead)
    state['game_over'] = p1_dead # Simplified: server game over if host P1 is dead
    return state

def set_platformer_network_state(network_state):
    global player1, player2, enemy_list, current_chest, all_sprites, enemy_sprites, collectible_sprites, Chest
    if player1 and 'p1' in network_state and network_state['p1'] and hasattr(player1, 'set_network_data'):
        player1.set_network_data(network_state['p1'])
    if player2 and 'p2' in network_state and network_state['p2'] and hasattr(player2, 'set_network_data'):
        player2.set_network_data(network_state['p2'])

    if 'enemies' in network_state:
        received_enemy_ids = set(network_state['enemies'].keys())
        current_enemy_map = {str(enemy.enemy_id): enemy for enemy in enemy_list if hasattr(enemy, 'enemy_id')}
        for enemy_id_str, enemy_data in network_state['enemies'].items():
            if enemy_id_str in current_enemy_map:
                enemy = current_enemy_map[enemy_id_str]
                if hasattr(enemy, 'set_network_data'): enemy.set_network_data(enemy_data)
        for local_id_str, local_enemy in current_enemy_map.items():
            if local_id_str not in received_enemy_ids and local_enemy.alive(): local_enemy.kill()

    if 'chest' in network_state:
        chest_data = network_state['chest']
        if chest_data and Chest is not None:
            chest_pos = chest_data.get('pos'); chest_is_collected = chest_data.get('is_collected', False)
            if chest_is_collected:
                if current_chest and current_chest.alive(): current_chest.kill(); current_chest = None
            elif chest_pos:
                if not current_chest or not current_chest.alive():
                    if current_chest: current_chest.kill()
                    try:
                        new_chest = Chest(chest_pos[0], chest_pos[1])
                        if hasattr(new_chest, '_valid_init') and new_chest._valid_init:
                             new_chest.rect.center = chest_pos
                             all_sprites.add(new_chest); collectible_sprites.add(new_chest)
                             current_chest = new_chest
                        else: current_chest = None
                    except Exception as e: print(f"Error creating chest from net: {e}"); current_chest = None
                elif current_chest:
                    current_chest.rect.center = chest_pos
                    if hasattr(current_chest, 'is_collected'): current_chest.is_collected = False
        elif current_chest and current_chest.alive(): current_chest.kill(); current_chest = None
    # game_over_from_server = network_state.get('game_over', False)

def draw_platformer_scene(target_screen, current_time_ticks):
    global all_sprites, camera, player1, player2, screen, debug_font, WIDTH, HEIGHT, enemy_sprites
    target_screen.fill(getattr(C, 'LIGHT_BLUE', (135, 206, 235)))
    if camera:
        for entity in all_sprites:
            if hasattr(entity, 'image') and hasattr(entity, 'rect'):
                 target_screen.blit(entity.image, camera.apply(entity.rect))
        for enemy in enemy_sprites:
            if hasattr(enemy, 'current_health') and hasattr(enemy, 'max_health') and not enemy.is_dead:
                enemy_screen_rect = camera.apply(enemy.rect)
                bar_w = getattr(C, 'HEALTH_BAR_WIDTH', 50); bar_h = getattr(C, 'HEALTH_BAR_HEIGHT', 8)
                bar_x = enemy_screen_rect.centerx - bar_w / 2
                bar_y = enemy_screen_rect.top - bar_h - getattr(C, 'HEALTH_BAR_OFFSET_ABOVE', 5)
                if hasattr(ui, 'draw_health_bar'):
                    ui.draw_health_bar(target_screen, bar_x, bar_y, bar_w, bar_h, enemy.current_health, enemy.max_health)
    else: all_sprites.draw(target_screen)
    if hasattr(ui, 'draw_player_hud'):
        if player1 and hasattr(player1, '_valid_init') and player1._valid_init:
            ui.draw_player_hud(target_screen, 10, 10, player1, 1)
        if player2 and hasattr(player2, '_valid_init') and player2._valid_init:
            p2_hud_x = WIDTH - (getattr(C, 'HEALTH_BAR_WIDTH', 50) * 2) - 120
            ui.draw_player_hud(target_screen, p2_hud_x, 10, player2, 2)
    if debug_font and clock :
        try:
            fps_text = f"FPS: {clock.get_fps():.1f}"; debug_texts = [fps_text]
            if camera: debug_texts.append(f"Cam:({int(camera.camera_rect.x)}, {int(camera.camera_rect.y)})")
            y_offset = 5
            for text_line in debug_texts:
                text_surface = debug_font.render(text_line, True, getattr(C,'BLACK',(0,0,0)))
                bg_surface = pygame.Surface((text_surface.get_width()+4, text_surface.get_height()+2), pygame.SRCALPHA)
                bg_surface.fill((200,200,200,180)); bg_surface.blit(text_surface, (2,1))
                target_screen.blit(bg_surface, (WIDTH - bg_surface.get_width() - 5, y_offset)); y_offset += bg_surface.get_height() + 2
        except Exception as e: print(f"Error drawing debug/FPS: {e}")

def update_camera_platformer(target_focus=None, target2_focus=None):
    global camera
    if not camera: return
    actual_target = None
    if target_focus and hasattr(target_focus, '_valid_init') and target_focus._valid_init and hasattr(target_focus, 'is_dead') and not target_focus.is_dead:
        actual_target = target_focus
    elif target2_focus and hasattr(target2_focus, '_valid_init') and target2_focus._valid_init and hasattr(target2_focus, 'is_dead') and not target2_focus.is_dead:
        actual_target = target2_focus
    if actual_target: camera.update(actual_target)
    else: camera.static_update()

# --- Server Functions ---
def broadcast_presence(server_lan_ip):
    global app_running, server_udp_socket, SERVICE_NAME, SERVER_PORT_TCP, DISCOVERY_PORT_UDP, BROADCAST_INTERVAL_S
    print(f"Starting presence broadcast on UDP port {DISCOVERY_PORT_UDP}")
    broadcast_message_dict = {"service": SERVICE_NAME, "tcp_ip": server_lan_ip, "tcp_port": SERVER_PORT_TCP}
    broadcast_message_bytes = encode_data(broadcast_message_dict) 
    if not broadcast_message_bytes: print("Error: Could not encode broadcast message."); return
    try:
        server_udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
        server_udp_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        server_udp_socket.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1); server_udp_socket.settimeout(0.5)
    except socket.error as e: print(f"Error creating UDP broadcast socket: {e}"); server_udp_socket = None; return
    broadcast_address = ('<broadcast>', DISCOVERY_PORT_UDP)
    print(f"Broadcasting service '{SERVICE_NAME}' for {server_lan_ip}:{SERVER_PORT_TCP}...")
    while app_running:
        try: server_udp_socket.sendto(broadcast_message_bytes[:-1], broadcast_address)
        except socket.error: pass
        except Exception as e: print(f"Unexpected error during broadcast send: {e}")
        time.sleep(BROADCAST_INTERVAL_S)
    print("Stopping presence broadcast.")
    if server_udp_socket: server_udp_socket.close(); server_udp_socket = None

def handle_client_connection(conn, addr):
    global client_input_buffer, app_running, client_lock, client_connection, BUFFER_SIZE
    print(f"Client connected via TCP: {addr}"); conn.settimeout(1.0) 
    partial_data_from_client = b""
    while app_running:
        with client_lock:
            if client_connection is not conn: print(f"Handler for {addr}: Conn inactive. Exit."); break
        try:
            chunk = conn.recv(BUFFER_SIZE)
            if not chunk: print(f"Client {addr} disconnected (empty data)."); break
            partial_data_from_client += chunk
            decoded_inputs, partial_data_from_client = decode_data_stream(partial_data_from_client)
            if decoded_inputs:
                last_input_data = decoded_inputs[-1]
                if "input" in last_input_data:
                    with client_lock:
                        if client_connection is conn: client_input_buffer = last_input_data["input"]
        except socket.timeout: continue
        except socket.error as e:
            if app_running: print(f"Socket error with client {addr}: {e}. Assuming disconnect."); break
        except Exception as e:
             if app_running: print(f"Unexpected error handling client {addr}: {e}"); traceback.print_exc(); break
    print(f"Stopping client handler for {addr}.")
    with client_lock:
        if client_connection is conn: client_connection = None; client_input_buffer = {"disconnect": True}
    try: conn.shutdown(socket.SHUT_RDWR)
    except: pass
    try: conn.close()
    except: pass

def run_server_mode():
    global app_running, screen, clock, font_small, font_large, debug_font, camera
    global client_connection, client_address, client_input_buffer, player1, player2
    global server_tcp_socket, broadcast_thread, client_handler_thread, client_lock
    global WIDTH, HEIGHT, level_pixel_width, level_pixel_height
    global current_chest # Global for assignment

    if not initialize_platformer_elements(for_game_mode="host"): return
    camera = Camera(level_pixel_width, level_pixel_height, WIDTH, HEIGHT)
    pygame.display.set_caption("Platformer - HOST (P1: WASD+VB | Self-Harm: H | Reset: R)")
    server_lan_ip = get_local_ip(); print(f"Server LAN IP: {server_lan_ip}")
    p1_key_map = {
        'left': pygame.K_a, 'right': pygame.K_d, 'up': pygame.K_w, 'down': pygame.K_s,
        'attack1': pygame.K_v, 'attack2': pygame.K_b, 'dash': pygame.K_LSHIFT,
        'roll': pygame.K_LCTRL, 'interact': pygame.K_e}
    broadcast_thread = threading.Thread(target=broadcast_presence, args=(server_lan_ip,), daemon=True); broadcast_thread.start()
    server_tcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM); server_tcp_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    try:
        server_tcp_socket.bind((SERVER_IP_BIND, SERVER_PORT_TCP)); server_tcp_socket.listen(1)
        server_tcp_socket.settimeout(1.0); print(f"Server TCP listening on {SERVER_IP_BIND}:{SERVER_PORT_TCP}")
    except socket.error as e: print(f"FATAL: Failed to bind TCP socket: {e}"); app_running = False; return

    print("Waiting for Player 2 to connect..."); temp_client_conn = None
    while temp_client_conn is None and app_running:
        try:
            events = pygame.event.get();
            for event in events:
                if event.type == pygame.QUIT: app_running = False; break
                if event.type == pygame.VIDEORESIZE:
                     if not screen.get_flags() & pygame.FULLSCREEN:
                        try:
                            WIDTH=max(320,event.w); HEIGHT=max(240,event.h)
                            screen=pygame.display.set_mode((WIDTH,HEIGHT), pygame.RESIZABLE|pygame.DOUBLEBUF)
                            if camera: camera.screen_width = WIDTH; camera.screen_height = HEIGHT
                        except pygame.error as e: print(f"Resize error: {e}")
                if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE: app_running = False; break
            if not app_running: break
            screen.fill(C.BLACK); wait_text = font_large.render("Waiting for P2...", True, C.WHITE)
            screen.blit(wait_text, wait_text.get_rect(center=(WIDTH//2, HEIGHT//2))); pygame.display.flip(); clock.tick(10)
            temp_client_conn, temp_client_addr = server_tcp_socket.accept()
            with client_lock:
                 if client_connection: client_connection.close()
                 client_connection = temp_client_conn; client_address = temp_client_addr; client_input_buffer = {}
        except socket.timeout: continue
        except Exception as e: print(f"Client wait error: {e}"); app_running = False; break
    if not app_running or client_connection is None: print("Exiting server (no client/closed)."); return

    print(f"Client connected: {client_address}. Starting game...")
    client_handler_thread = threading.Thread(target=handle_client_connection, args=(client_connection, client_address), daemon=True)
    client_handler_thread.start()
    server_running_game = True
    while server_running_game and app_running:
        dt_sec = clock.tick(C.FPS) / 1000.0; now_ticks = pygame.time.get_ticks()
        p1_events = pygame.event.get(); keys_p1 = pygame.key.get_pressed()
        
        # Server decides game_over based on P1's status (host) and potentially P2 from network state
        p1_is_effectively_dead = not (player1 and player1._valid_init and not player1.is_dead)
        # For P2, we'd check its state if it's actively playing (e.g. from last received network state)
        # For now, simple game_over if P1 (host) is dead.
        game_over_check = p1_is_effectively_dead
        reset_now = False

        for event in p1_events:
            if event.type == pygame.QUIT: server_running_game = False; app_running = False; break
            if event.type == pygame.VIDEORESIZE:
                if not screen.get_flags() & pygame.FULLSCREEN:
                    try:
                        WIDTH=max(320,event.w); HEIGHT=max(240,event.h)
                        screen=pygame.display.set_mode((WIDTH,HEIGHT), pygame.RESIZABLE|pygame.DOUBLEBUF)
                        if camera: camera.screen_width = WIDTH; camera.screen_height = HEIGHT
                    except pygame.error as e: print(f"Resize error: {e}")
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE: server_running_game = False # To menu
                if event.key == pygame.K_r and game_over_check : reset_now = True # Allow reset if game over
                if event.key == pygame.K_h and player1 and player1._valid_init and hasattr(player1, 'self_inflict_damage'):
                    player1.self_inflict_damage(getattr(C, 'PLAYER_SELF_DAMAGE', 10))
                # Heal Player 1 with 'G'
                if event.key == pygame.K_g and player1 and player1._valid_init and hasattr(player1, 'heal_to_full'):
                    player1.heal_to_full()


        if not app_running or not server_running_game: break
        if player1 and player1._valid_init and not player1.is_dead:
            player1.handle_mapped_input(keys_p1, p1_events, p1_key_map)

        remote_p2_input_copy, client_was_disconnected, reset_req_p2 = None, False, False
        with client_lock:
            if client_input_buffer:
                if client_input_buffer.get("disconnect"): client_was_disconnected = True
                elif client_input_buffer.get("action_reset", False): reset_req_p2 = True
                # Check for self-harm action from client if implemented in get_input_state
                # elif client_input_buffer.get("action_self_harm", False) and player2 and player2._valid_init:
                #     player2.self_inflict_damage(getattr(C, 'PLAYER_SELF_DAMAGE', 10))
                else: remote_p2_input_copy = client_input_buffer.copy()
                client_input_buffer = {} # Consume buffer
        if client_was_disconnected: print("Client disconnected."); server_running_game = False; app_running = False; break
        if player2 and player2._valid_init and remote_p2_input_copy and hasattr(player2, 'handle_network_input'):
            player2.handle_network_input(remote_p2_input_copy)

        if reset_now or (reset_req_p2 and game_over_check):
            reset_platformer_game_state() # Assigns to global current_chest
            if camera: camera.set_pos(0,0); game_over_check = False; reset_req_p2 = False; reset_now = False

        if not game_over_check:
            try:
                if player1 and player1._valid_init: player1.update(dt_sec, platform_sprites, ladder_sprites, hazard_sprites, enemy_sprites)
                if player2 and player2._valid_init: player2.update(dt_sec, platform_sprites, ladder_sprites, hazard_sprites, enemy_sprites)
                active_players = [p for p in [player1, player2] if p and p._valid_init and not p.is_dead]
                enemy_sprites.update(dt_sec, active_players, platform_sprites, hazard_sprites)
                collectible_sprites.update(dt_sec)
                if Chest and current_chest and current_chest.alive():
                    if player1 and player1._valid_init and not player1.is_dead and pygame.sprite.collide_rect(player1, current_chest):
                         current_chest.collect(player1); current_chest = None # Assigns to global
                    elif player2 and player2._valid_init and not player2.is_dead and current_chest and current_chest.alive() and pygame.sprite.collide_rect(player2, current_chest):
                         current_chest.collect(player2); current_chest = None # Assigns to global
            except Exception as e: print(f"Server update error: {e}"); traceback.print_exc(); server_running_game=False; break
        update_camera_platformer(player1, player2)
        if client_connection:
            net_state = get_platformer_network_state() # Reads global current_chest
            encoded_state = encode_data(net_state)
            if encoded_state:
                try: client_connection.sendall(encoded_state)
                except socket.error as e: print(f"Send failed: {e}"); server_running_game = False; app_running=False; break
        try: draw_platformer_scene(screen, now_ticks)
        except Exception as e: print(f"Server draw error: {e}"); traceback.print_exc(); server_running_game=False; break
        pygame.display.flip()
    print("Exiting server game loop."); app_running = False
    temp_conn = None
    with client_lock: temp_conn = client_connection; client_connection = None
    if temp_conn:
        try: temp_conn.shutdown(socket.SHUT_RDWR); temp_conn.close()
        except: pass
    if server_tcp_socket: server_tcp_socket.close(); server_tcp_socket = None
    if broadcast_thread and broadcast_thread.is_alive(): broadcast_thread.join(0.2)
    if client_handler_thread and client_handler_thread.is_alive(): client_handler_thread.join(0.2)
    print("Server mode finished.")

def run_client_mode(target_ip_port=None):
    global app_running, screen, clock, font_small, font_large, client_tcp_socket, server_state_buffer, camera
    global player1, player2, WIDTH, HEIGHT, level_pixel_width, level_pixel_height
    global current_chest # MODIFIED: Global for assignment by set_platformer_network_state

    if not initialize_platformer_elements(for_game_mode="client"): return
    camera = Camera(level_pixel_width, level_pixel_height, WIDTH, HEIGHT)
    server_ip_connect, server_port_connect = None, SERVER_PORT_TCP
    if target_ip_port:
        parts = target_ip_port.rsplit(':', 1); server_ip_connect = parts[0]
        if len(parts) > 1:
            try: server_port_connect = int(parts[1])
            except ValueError: print(f"Invalid port in '{target_ip_port}'.")
    else:
        server_ip_connect, found_port = find_server(screen, font_small, font_large)
        if found_port: server_port_connect = found_port
    if not server_ip_connect: print("Exiting client (no server)."); return
    if not app_running: print("Exiting client (app closed)."); return
    
    # Client (who is Player 2 in the game world) uses these keys locally for convenience.
    # The Player class's get_input_state method will map these to generic actions.
    p2_local_key_map_for_input_state = {
        'left': pygame.K_a, 'right': pygame.K_d, 'up': pygame.K_w, 'down': pygame.K_s,
        'attack1': pygame.K_v, 'attack2': pygame.K_b, 'dash': pygame.K_LSHIFT,
        'roll': pygame.K_LCTRL, 'interact': pygame.K_e,
        # 'self_harm': pygame.K_h # This key is for direct local action, not necessarily for get_input_state
    }

    client_tcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    connection_successful, error_message = False, "Unknown Connect Error"
    try:
        print(f"Connecting to {server_ip_connect}:{server_port_connect}..."); pygame.display.set_caption(f"Platformer - Connecting...")
        screen.fill(C.BLACK); conn_text = font_large.render(f"Connecting...", True, C.WHITE)
        screen.blit(conn_text, conn_text.get_rect(center=(WIDTH//2, HEIGHT//2))); pygame.display.flip()
        client_tcp_socket.settimeout(10.0); client_tcp_socket.connect((server_ip_connect, server_port_connect))
        client_tcp_socket.settimeout(0.05); print("TCP Connection successful!"); connection_successful = True
    except socket.error as e: error_message = f"Connection Error ({e.strerror})"
    except Exception as e: error_message = f"Unexpected Connection Error: {e}"
    if not connection_successful:
        screen.fill(C.BLACK); fail_text = font_large.render(f"Connection Failed", True, C.RED)
        screen.blit(fail_text, fail_text.get_rect(center=(WIDTH//2, HEIGHT//2 - 30))); pygame.display.flip(); time.sleep(3)
        if client_tcp_socket: client_tcp_socket.close(); client_tcp_socket = None
        return

    pygame.display.set_caption("Platformer - CLIENT (You are P2: WASD+VB | Self-Harm: H | Reset: Enter)")
    server_state_buffer = b""; last_received_server_state = None; client_running_game = True
    while client_running_game and app_running:
        dt_sec = clock.tick(C.FPS) / 1000.0; now_ticks = pygame.time.get_ticks()
        client_input_actions = {'action_reset': False, 'action_self_harm': False} # Send actions to server
        game_over_from_server = last_received_server_state.get('game_over', False) if last_received_server_state else False
        client_events = pygame.event.get(); keys_client = pygame.key.get_pressed()
        for event in client_events:
            if event.type == pygame.QUIT: client_running_game = False; app_running = False; break
            if event.type == pygame.VIDEORESIZE:
                if not screen.get_flags() & pygame.FULLSCREEN:
                    try:
                        WIDTH=max(320,event.w); HEIGHT=max(240,event.h)
                        screen=pygame.display.set_mode((WIDTH,HEIGHT), pygame.RESIZABLE|pygame.DOUBLEBUF)
                        if camera: camera.screen_width = WIDTH; camera.screen_height = HEIGHT
                    except pygame.error as e: print(f"Resize error: {e}")
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE: client_running_game = False
                if game_over_from_server and event.key == pygame.K_RETURN: client_input_actions['action_reset'] = True
                if event.key == pygame.K_h: # Client wants to self-harm (as P2)
                    client_input_actions['action_self_harm'] = True # Send this action to server
                # Client heal key (G), sends action to server for P2
                if event.key == pygame.K_g:
                    client_input_actions['action_heal'] = True


        if not app_running or not client_running_game: break
        p2_input_dict_to_send = {}
        if player2 and hasattr(player2, 'get_input_state'): # player2 is the client's local representation
             p2_input_dict_to_send = player2.get_input_state(keys_client, client_events, p2_local_key_map_for_input_state)
        p2_input_dict_to_send.update(client_input_actions) # Merge actions like reset, self-harm

        if client_tcp_socket:
            client_payload = {"input": p2_input_dict_to_send}
            encoded_payload = encode_data(client_payload)
            if encoded_payload:
                try: client_tcp_socket.sendall(encoded_payload)
                except socket.error as e: print(f"Client send failed: {e}"); client_running_game=False; app_running=False; break
        if client_tcp_socket:
            try:
                chunk = client_tcp_socket.recv(BUFFER_SIZE * 2)
                if not chunk: print("Server disconnected."); client_running_game=False; app_running=False; break
                server_state_buffer += chunk
                decoded_states, server_state_buffer = decode_data_stream(server_state_buffer)
                if decoded_states:
                    last_received_server_state = decoded_states[-1]
                    set_platformer_network_state(last_received_server_state) # Can assign to global current_chest
            except socket.error as e:
                if e.errno != 10035 and e.errno != 11: print(f"Client recv error: {e}"); client_running_game=False; app_running=False; break
            except Exception as e: print(f"Client data proc error: {e}"); traceback.print_exc(); client_running_game=False; break
        cam_target_client = None
        if last_received_server_state:
            p1_data = last_received_server_state.get('p1'); p2_data = last_received_server_state.get('p2')
            if p1_data and not p1_data.get('is_dead', True) and player1 and player1._valid_init: cam_target_client = player1
            elif p2_data and not p2_data.get('is_dead', True) and player2 and player2._valid_init: cam_target_client = player2
        if cam_target_client: camera.update(cam_target_client)
        else: camera.static_update()
        try: draw_platformer_scene(screen, now_ticks) # Reads global current_chest
        except Exception as e: print(f"Client draw error: {e}"); traceback.print_exc(); client_running_game=False; break
        pygame.display.flip()
    print("Exiting client game loop.")
    if client_tcp_socket:
        try: client_tcp_socket.shutdown(socket.SHUT_RDWR); client_tcp_socket.close()
        except: pass
        client_tcp_socket = None
    print("Client mode finished.")

def run_couch_play_mode():
    global app_running, screen, clock, font_small, font_large, debug_font, camera
    global player1, player2, WIDTH, HEIGHT, level_pixel_width, level_pixel_height
    global current_chest, platform_sprites, ladder_sprites, hazard_sprites, enemy_sprites, collectible_sprites, all_sprites, enemy_list
    # MODIFIED: Added global for current_chest

    print("Starting Couch Play mode...")
    pygame.display.set_caption("Platformer - Couch (P1:WASD+VB, P2:IJKL+OP | Swap:Q | Harm:H,N | Heal:G,M | Reset:R)")

    if not initialize_platformer_elements(for_game_mode="couch_play"): return
    camera = Camera(level_pixel_width, level_pixel_height, WIDTH, HEIGHT)

    p1_key_map = {
        'left': pygame.K_a, 'right': pygame.K_d, 'up': pygame.K_w, 'down': pygame.K_s,
        'attack1': pygame.K_v, 'attack2': pygame.K_b, 'dash': pygame.K_LSHIFT,
        'roll': pygame.K_LCTRL, 'interact': pygame.K_e }
    p2_key_map = {
        'left': pygame.K_j, 'right': pygame.K_l, 'up': pygame.K_i, 'down': pygame.K_k,
        'attack1': pygame.K_o, 'attack2': pygame.K_p, 'dash': pygame.K_SEMICOLON,
        'roll': pygame.K_QUOTE, 'interact': pygame.K_BACKSLASH }

    couch_running_game = True
    while couch_running_game and app_running:
        dt_sec = clock.tick(getattr(C, 'FPS', 60)) / 1000.0; now_ticks = pygame.time.get_ticks()
        events = pygame.event.get(); keys = pygame.key.get_pressed()
        reset_now_couch = False

        for event in events:
            if event.type == pygame.QUIT: couch_running_game = False; app_running = False; break
            if event.type == pygame.VIDEORESIZE:
                if not screen.get_flags() & pygame.FULLSCREEN:
                    try:
                        WIDTH=max(320,event.w); HEIGHT=max(240,event.h)
                        screen=pygame.display.set_mode((WIDTH,HEIGHT), pygame.RESIZABLE|pygame.DOUBLEBUF)
                        if camera: camera.screen_width = WIDTH; camera.screen_height = HEIGHT
                    except pygame.error as e: print(f"Resize error: {e}")
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE: couch_running_game = False; break # Exit to main menu
                if event.key == pygame.K_q: # Character Swap
                    if player1 and player1._valid_init and player2 and player2._valid_init:
                        player1, player2 = player2, player1; print("Players SWAPPED characters!")
                
                # Allow reset anytime for testing with 'R'
                if event.key == pygame.K_r: reset_now_couch = True
                
                # Player 1 Self-Harm & Heal
                if event.key == pygame.K_h and player1 and player1._valid_init and hasattr(player1, 'self_inflict_damage'):
                    player1.self_inflict_damage(getattr(C, 'PLAYER_SELF_DAMAGE', 10))
                if event.key == pygame.K_g and player1 and player1._valid_init and hasattr(player1, 'heal_to_full'):
                    player1.heal_to_full()
                
                # Player 2 Self-Harm & Heal
                if event.key == pygame.K_n and player2 and player2._valid_init and hasattr(player2, 'self_inflict_damage'):
                    player2.self_inflict_damage(getattr(C, 'PLAYER_SELF_DAMAGE', 10))
                if event.key == pygame.K_m and player2 and player2._valid_init and hasattr(player2, 'heal_to_full'):
                    player2.heal_to_full()

        if not app_running or not couch_running_game: break

        if player1 and player1._valid_init and not player1.is_dead:
            player1.handle_mapped_input(keys, events, p1_key_map)
        if player2 and player2._valid_init and not player2.is_dead:
            player2.handle_mapped_input(keys, events, p2_key_map)

        p1_dead_check_couch = not (player1 and player1._valid_init and not player1.is_dead)
        p2_dead_check_couch = not (player2 and player2._valid_init and not player2.is_dead)
        # For couch co-op, game might be "over" if both are dead, or if one is and it's a team game.
        # current_game_over_couch = p1_dead_check_couch and p2_dead_check_couch
        # Removing the game_over condition for reset to allow reset anytime in couch mode for testing.
        if reset_now_couch:
            reset_platformer_game_state() # Assigns to global current_chest
            if camera: camera.set_pos(0,0); reset_now_couch = False

        # Update logic (runs even if one player is dead, so the other can continue)
        try:
            if player1 and player1._valid_init: player1.update(dt_sec, platform_sprites, ladder_sprites, hazard_sprites, enemy_sprites)
            if player2 and player2._valid_init: player2.update(dt_sec, platform_sprites, ladder_sprites, hazard_sprites, enemy_sprites)
            active_players_couch = [p for p in [player1, player2] if p and p._valid_init and not p.is_dead]
            enemy_sprites.update(dt_sec, active_players_couch, platform_sprites, hazard_sprites)
            collectible_sprites.update(dt_sec)
            if Chest and current_chest and current_chest.alive():
                if player1 and player1._valid_init and not player1.is_dead and pygame.sprite.collide_rect(player1, current_chest):
                    current_chest.collect(player1); current_chest = None # Assigns to global
                elif player2 and player2._valid_init and not player2.is_dead and current_chest and current_chest.alive() and pygame.sprite.collide_rect(player2, current_chest):
                    current_chest.collect(player2); current_chest = None # Assigns to global
        except Exception as e: print(f"Couch update error: {e}"); traceback.print_exc(); couch_running_game=False; break
        
        update_camera_platformer(player1, player2)
        try: draw_platformer_scene(screen, now_ticks)
        except Exception as e: print(f"Couch draw error: {e}"); traceback.print_exc(); couch_running_game=False; break
        pygame.display.flip()
    print("Exiting Couch Play mode.")

def get_server_id_input(screen_surf, font_prompt, font_input, font_info, clock_obj):
    global app_running, SCRAP_INITIALIZED, PYPERCLIP_AVAILABLE, WIDTH, HEIGHT
    input_text = ""; input_active = True; cursor_visible = True; last_cursor_toggle = time.time()
    input_rect = pygame.Rect(WIDTH // 4, HEIGHT // 2 - 10, WIDTH // 2, 50)
    print("Prompting for Server IP Address (or IP:Port)...")
    pygame.key.set_repeat(500, 50); paste_info_msg = None; paste_msg_start_time = 0
    while input_active and app_running:
        current_time = time.time()
        if current_time - last_cursor_toggle > 0.5: cursor_visible = not cursor_visible; last_cursor_toggle = current_time
        events = pygame.event.get()
        for event in events:
            if event.type == pygame.QUIT: app_running = False; input_active = False
            if event.type == pygame.VIDEORESIZE:
                 if not screen.get_flags() & pygame.FULLSCREEN:
                     try:
                         WIDTH=max(320,event.w); HEIGHT=max(240,event.h)
                         screen_surf=pygame.display.set_mode((WIDTH,HEIGHT), pygame.RESIZABLE|pygame.DOUBLEBUF)
                         input_rect = pygame.Rect(WIDTH // 4, HEIGHT // 2 - 10, WIDTH // 2, 50)
                     except pygame.error as e: print(f"Resize error: {e}")
            if event.type == pygame.KEYDOWN:
                paste_info_msg = None
                if event.key == pygame.K_ESCAPE: input_active = False; input_text = None
                elif event.key == pygame.K_RETURN:
                    if input_text.strip(): input_active = False
                    else: input_text = ""
                elif event.key == pygame.K_BACKSPACE: input_text = input_text[:-1]
                elif event.key == pygame.K_v and (event.mod & pygame.KMOD_CTRL or event.mod & pygame.KMOD_META):
                    pasted_content, paste_method_used = None, "None"
                    if SCRAP_INITIALIZED:
                        try:
                            cb_data = pygame.scrap.get(pygame.SCRAP_TEXT)
                            if cb_data: pasted_content = cb_data.decode('utf-8', errors='ignore').replace('\x00', '').strip()
                            if pasted_content: paste_method_used = "pygame.scrap"
                        except: pass
                    if not pasted_content and PYPERCLIP_AVAILABLE:
                        try:
                            cb_data = pyperclip.paste()
                            if isinstance(cb_data, str): pasted_content = cb_data.replace('\x00', '').strip()
                            if pasted_content: paste_method_used = "pyperclip"
                        except: pass
                    if pasted_content: input_text += pasted_content; print(f"Pasted via {paste_method_used}.")
                    else: paste_info_msg = "Paste Failed/Empty"; paste_msg_start_time = current_time
                elif event.unicode.isalnum() or event.unicode in ['.', ':', '-']: input_text += event.unicode
        screen_surf.fill(C.BLACK)
        prompt_surf = font_prompt.render("Enter Host IP Address or IP:Port", True, C.WHITE)
        screen_surf.blit(prompt_surf, prompt_surf.get_rect(center=(WIDTH // 2, HEIGHT // 2 - 60)))
        info_surf = font_info.render("(Enter=Confirm, Esc=Cancel, Ctrl+V=Paste)", True, C.GREY)
        screen_surf.blit(info_surf, info_surf.get_rect(center=(WIDTH // 2, HEIGHT - 40)))
        pygame.draw.rect(screen_surf, C.GREY, input_rect, border_radius=5)
        pygame.draw.rect(screen_surf, C.WHITE, input_rect, 2, border_radius=5)
        text_surf = font_input.render(input_text, True, C.BLACK)
        text_rect_render = text_surf.get_rect(midleft=(input_rect.left + 10, input_rect.centery))
        clip_render_area = input_rect.inflate(-12, -12)
        if text_rect_render.right > clip_render_area.right : text_rect_render.right = clip_render_area.right
        screen_surf.set_clip(clip_render_area); screen_surf.blit(text_surf, text_rect_render); screen_surf.set_clip(None)
        if cursor_visible:
            cursor_x_pos = text_rect_render.right + 2
            if cursor_x_pos < clip_render_area.left + 2: cursor_x_pos = clip_render_area.left + 2
            if cursor_x_pos > clip_render_area.right -1: cursor_x_pos = clip_render_area.right -1
            pygame.draw.line(screen_surf, C.BLACK, (cursor_x_pos, input_rect.top + 5), (cursor_x_pos, input_rect.bottom - 5), 2)
        if paste_info_msg and current_time - paste_msg_start_time < 2.0:
            msg_s = font_info.render(paste_info_msg, True, C.RED); screen_surf.blit(msg_s, msg_s.get_rect(center=(WIDTH//2, input_rect.bottom+30)))
        elif paste_info_msg: paste_info_msg = None
        pygame.display.flip(); clock_obj.tick(30)
    pygame.key.set_repeat(0,0)
    return input_text.strip() if input_text is not None else None

def find_server(screen_surf, font_small_obj, font_large_obj):
    global app_running, clock, WIDTH, HEIGHT, SERVICE_NAME, DISCOVERY_PORT_UDP, CLIENT_SEARCH_TIMEOUT_S, BUFFER_SIZE
    print(f"Searching LAN for '{SERVICE_NAME}' on UDP port {DISCOVERY_PORT_UDP}...")
    pygame.display.set_caption("Platformer - Searching LAN...")
    search_text_surf = font_large_obj.render("Searching for server on LAN...", True, C.WHITE)
    listen_socket, found_server_ip, found_server_port = None, None, None
    try:
        listen_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
        listen_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        listen_socket.bind(('', DISCOVERY_PORT_UDP)); listen_socket.settimeout(0.5)
    except socket.error as e:
        print(f"Error binding UDP listen socket {DISCOVERY_PORT_UDP}: {e}")
        screen_surf.fill(C.BLACK); err1 = font_small_obj.render(f"Error: Cannot listen on UDP {DISCOVERY_PORT_UDP}.", True, C.RED)
        screen_surf.blit(err1, err1.get_rect(center=(WIDTH//2, HEIGHT // 2))); pygame.display.flip(); time.sleep(4)
        return None, None
    start_time, my_ip = time.time(), get_local_ip()
    while time.time() - start_time < CLIENT_SEARCH_TIMEOUT_S and app_running:
        for event in pygame.event.get():
             if event.type == pygame.QUIT: app_running = False; break
             if event.type == pygame.VIDEORESIZE:
                if not screen.get_flags() & pygame.FULLSCREEN:
                    try:
                        WIDTH=max(320,event.w); HEIGHT=max(240,event.h)
                        screen_surf=pygame.display.set_mode((WIDTH,HEIGHT), pygame.RESIZABLE|pygame.DOUBLEBUF)
                    except pygame.error as e: print(f"Resize error: {e}")
             if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE: print("Search cancelled."); app_running = False; break
        if not app_running: break
        screen_surf.fill(C.BLACK); screen_surf.blit(search_text_surf, search_text_surf.get_rect(center=(WIDTH//2, HEIGHT//2))); pygame.display.flip(); clock.tick(10)
        try:
            data, addr = listen_socket.recvfrom(BUFFER_SIZE)
            if addr[0] == my_ip: continue
            decoded_msgs, _ = decode_data_stream(data + b'\n')
            if not decoded_msgs: continue; message = decoded_msgs[0]
            if (message and message.get("service") == SERVICE_NAME and isinstance(message.get("tcp_ip"), str) and isinstance(message.get("tcp_port"), int)):
                ip, port = message["tcp_ip"], message["tcp_port"]
                print(f"Found server: {ip}:{port} from {addr[0]}"); found_server_ip, found_server_port = ip, port; break
        except socket.timeout: continue
        except Exception as e: print(f"Error processing UDP broadcast: {e}")
    if listen_socket: listen_socket.close()
    if not found_server_ip and app_running:
        print(f"No server found."); screen_surf.fill(C.BLACK); fail1 = font_large_obj.render("Server Not Found!", True, C.RED)
        screen_surf.blit(fail1, fail1.get_rect(center=(WIDTH//2, HEIGHT//2))); pygame.display.flip(); time.sleep(3)
    return found_server_ip, found_server_port

def show_main_menu():
    global screen, clock, font_small, font_medium, font_large, app_running, WIDTH, HEIGHT
    button_width, button_height, spacing = 350, 55, 20; title_button_gap = 60
    title_color = C.WHITE; btn_txt_color = C.WHITE; btn_color = C.BLUE; btn_hover = C.GREEN
    title_surf = font_large.render("Platformer Adventure LAN", True, title_color)
    buttons_data = {
        "host": {"text": "Host Game (Online)", "action": "host"}, "join_lan": {"text": "Join Game (LAN)", "action": "join_lan"},
        "join_internet": {"text": "Join Game (Internet)", "action": "join_internet"}, "couch_play": {"text": "Couch Play (Local)", "action": "couch_play"},
        "quit": {"text": "Quit Game", "action": "quit"} }
    def update_button_geometries():
        nonlocal title_rect, current_y_layout # Ensure these are correctly scoped if Python 2 vs 3
        title_rect = title_surf.get_rect(center=(WIDTH // 2, HEIGHT // 4))
        current_y_layout = title_rect.bottom + title_button_gap
        for props_dict in buttons_data.values():
            props_dict["rect"] = pygame.Rect(0,0,button_width,button_height)
            props_dict["rect"].centerx = WIDTH // 2; props_dict["rect"].top = current_y_layout
            props_dict["text_surf"] = font_medium.render(props_dict["text"], True, btn_txt_color)
            props_dict["text_rect"] = props_dict["text_surf"].get_rect(center=props_dict["rect"].center)
            current_y_layout += button_height + spacing
    title_rect = None; current_y_layout = 0 # Initialize before first call
    update_button_geometries()
    selected_option_menu = None
    while selected_option_menu is None and app_running:
        mouse_pos_menu = pygame.mouse.get_pos(); events_menu = pygame.event.get()
        for event_m in events_menu:
            if event_m.type == pygame.QUIT: app_running = False; selected_option_menu = "quit"
            if event_m.type == pygame.VIDEORESIZE:
                 if not screen.get_flags() & pygame.FULLSCREEN:
                     try:
                         WIDTH=max(320,event_m.w); HEIGHT=max(240,event_m.h)
                         screen=pygame.display.set_mode((WIDTH,HEIGHT), pygame.RESIZABLE|pygame.DOUBLEBUF); update_button_geometries()
                     except pygame.error as e: print(f"Menu resize error: {e}")
            if event_m.type == pygame.KEYDOWN and event_m.key == pygame.K_ESCAPE: app_running = False; selected_option_menu = "quit"
            if event_m.type == pygame.MOUSEBUTTONDOWN and event_m.button == 1:
                for props_m in buttons_data.values():
                    if props_m["rect"].collidepoint(mouse_pos_menu): selected_option_menu = props_m["action"]; break
        screen.fill(C.BLACK)
        if title_rect: screen.blit(title_surf, title_rect)
        for props_m in buttons_data.values():
            hover_m = props_m["rect"].collidepoint(mouse_pos_menu)
            pygame.draw.rect(screen, btn_hover if hover_m else btn_color, props_m["rect"], border_radius=8)
            screen.blit(props_m["text_surf"], props_m["text_rect"])
        pygame.display.flip(); clock.tick(30)
    return selected_option_menu

# --- Main Execution ---
if __name__ == "__main__":
    clock = pygame.time.Clock()
    try:
        font_small = pygame.font.Font(None, 28); font_medium = pygame.font.Font(None, 36)
        font_large = pygame.font.Font(None, 72); debug_font = pygame.font.Font(None, 20)
    except Exception as e: print(f"FATAL: Font loading error: {e}"); pygame.quit(); sys.exit(1)

    while app_running:
        pygame.display.set_caption("Platformer Adventure - Main Menu")
        menu_choice = show_main_menu()
        if menu_choice == "host": run_server_mode()
        elif menu_choice == "join_lan": run_client_mode()
        elif menu_choice == "join_internet":
            target_ip = get_server_id_input(screen, font_medium, font_medium, font_small, clock)
            if target_ip and app_running: run_client_mode(target_ip_port=target_ip)
        elif menu_choice == "couch_play": run_couch_play_mode()
        elif menu_choice == "quit": app_running = False
        else:
            if not app_running: print("Exiting from menu choice or event.")
    print("Exiting application gracefully.")
    pygame.quit()
    try:
        if SCRAP_INITIALIZED and pygame.scrap.get_init(): pygame.scrap.quit()
    except: pass
    sys.exit(0)

========== START OF FILE: player.py ==========

# player.py
# -*- coding: utf-8 -*-
"""
Defines the Player class, handling movement, animations, states, and interactions.
"""
import pygame
import os
import sys
import math

# Import necessary components from other modules
import constants as C # Use constants with C. prefix
from assets import load_all_player_animations # Import the animation loader
from tiles import Lava # Import Lava for type checking in hazard collision

class Player(pygame.sprite.Sprite):
    def __init__(self, start_x, start_y, player_id=1):
        super().__init__()
        self.player_id = player_id

        asset_folder = 'characters/player1'
        self.animations = load_all_player_animations(relative_asset_folder=asset_folder)

        if self.animations is None:
            print(f"Player {self.player_id} Init Error: Failed to load critical animations from {asset_folder}.")
            self.image = pygame.Surface((30, 40)).convert_alpha(); self.image.fill(C.RED)
            self.rect = self.image.get_rect(midbottom=(start_x, start_y))
            self.is_dead = True
            self._valid_init = False
            return
        else:
             self._valid_init = True
        try:
            self.standard_height = self.animations['idle'][0].get_height()
        except (KeyError, IndexError): # Handle if 'idle' or its frames are missing
            print(f"Warning Player {self.player_id}: Could not get player idle animation height, using default.")
            self.standard_height = 60 # Fallback
        except TypeError: # Handle if animations['idle'] is None or not a list
            print(f"Warning Player {self.player_id}: Idle animation data is invalid, using default height.")
            self.standard_height = 60 # Fallback

        self._last_facing = True
        self._last_state_for_debug = "init"
        self.state = 'idle'
        self.current_frame = 0
        self.last_anim_update = pygame.time.get_ticks()
        idle_anim = self.animations.get('idle')
        if idle_anim and len(idle_anim) > 0:
            self.image = idle_anim[0]
        else:
            self.image = pygame.Surface((30,40)); self.image.fill(C.RED) # Fallback image
            print(f"CRITICAL Player {self.player_id}: Missing or empty 'idle' animation during init.")
        self.rect = self.image.get_rect(midbottom=(start_x, start_y))
        self.pos = pygame.math.Vector2(start_x, start_y)
        self.vel = pygame.math.Vector2(0, 0)
        self.acc = pygame.math.Vector2(0, C.PLAYER_GRAVITY)
        self.facing_right = True
        self.on_ground = False
        self.on_ladder = False
        self.can_grab_ladder = False
        self.touching_wall = 0
        self.is_crouching = False
        self.is_dashing = False
        self.dash_timer = 0
        self.dash_duration = 150
        self.is_rolling = False
        self.roll_timer = 0
        self.roll_duration = 300
        self.is_sliding = False
        self.slide_timer = 0
        self.slide_duration = 400
        self.is_attacking = False
        self.attack_timer = 0
        self.attack_duration = 300
        self.attack_type = 0
        self.can_combo = False
        self.combo_window = 150
        self.wall_climb_timer = 0
        self.wall_climb_duration = 500
        self.can_wall_jump = False
        self.is_taking_hit = False
        self.hit_timer = 0
        self.hit_duration = 400
        self.hit_cooldown = 600
        self.is_dead = False
        self.state_timer = 0
        self.max_health = C.PLAYER_MAX_HEALTH
        self.current_health = self.max_health
        self.attack_hitbox = pygame.Rect(0, 0, 45, 30)
        self.is_trying_to_move_left = False
        self.is_trying_to_move_right = False
        self.is_holding_climb_ability_key = False
        self.is_holding_crouch_ability_key = False

    def set_state(self, new_state):
        if not self._valid_init: return
        if new_state in ['ladder_idle', 'ladder_climb'] and new_state not in self.animations:
             new_state = 'idle'
        if new_state not in self.animations:
             print(f"Warning Player {self.player_id}: Animation state '{new_state}' not found.")
             new_state = 'fall' if not self.on_ground else 'idle'
             if new_state not in self.animations:
                 print(f"CRITICAL ERROR Player {self.player_id}: Fallback state '{new_state}' also missing!")
                 available_keys = list(self.animations.keys())
                 if not available_keys : return
                 new_state = available_keys[0]
        if not self.animations.get(new_state): # Check if list is None or empty
            print(f"Warning Player {self.player_id}: Animation list for state '{new_state}' is empty or None.")
            # Try to find 'idle', if not, first available key, if none, then it's critical.
            new_state_candidate = 'idle' if new_state != 'idle' and 'idle' in self.animations and self.animations['idle'] else None
            if not new_state_candidate:
                available_keys = [k for k,v in self.animations.items() if v] # find first non-empty animation
                if available_keys: new_state_candidate = available_keys[0]

            if not new_state_candidate: # Still no valid animation
                print(f"CRITICAL ERROR Player {self.player_id}: Cannot find any valid animation for fallback. Animations dict: {self.animations.keys()}")
                if hasattr(self, 'image') and self.image: self.image.fill(C.RED) # Show error on player
                self._valid_init = False # Mark as invalid to stop further processing
                return
            new_state = new_state_candidate


        if self.state != new_state and not self.is_dead: # Only change if different and not dead
            self._last_state_for_debug = new_state
            if 'attack' not in new_state: self.is_attacking = False; self.attack_type = 0
            if new_state != 'dash': self.is_dashing = False
            if new_state != 'roll': self.is_rolling = False
            if new_state != 'slide' and 'slide_trans' not in new_state: self.is_sliding = False
            if new_state != 'hit': self.is_taking_hit = False # Reset unless entering hit state

            self.state = new_state
            self.current_frame = 0
            self.last_anim_update = pygame.time.get_ticks()
            self.state_timer = pygame.time.get_ticks()

            # State entry logic
            if new_state == 'dash':
                self.is_dashing = True; self.dash_timer = self.state_timer
                self.vel.x = C.PLAYER_DASH_SPEED * (1 if self.facing_right else -1); self.vel.y = 0
            elif new_state == 'roll':
                 self.is_rolling = True; self.roll_timer = self.state_timer
                 if abs(self.vel.x) < C.PLAYER_ROLL_SPEED / 2: self.vel.x = C.PLAYER_ROLL_SPEED * (1 if self.facing_right else -1)
                 elif abs(self.vel.x) < C.PLAYER_ROLL_SPEED: self.vel.x += (C.PLAYER_ROLL_SPEED / 3) * (1 if self.facing_right else -1)
                 self.vel.x = max(-C.PLAYER_ROLL_SPEED, min(C.PLAYER_ROLL_SPEED, self.vel.x))
            elif new_state == 'slide' or new_state == 'slide_trans_start':
                 self.is_sliding = True; self.slide_timer = self.state_timer
                 if abs(self.vel.x) < C.PLAYER_RUN_SPEED_LIMIT * 0.5: self.vel.x = C.PLAYER_RUN_SPEED_LIMIT * 0.6 * (1 if self.facing_right else -1)
            elif 'attack' in new_state:
                self.is_attacking = True; self.attack_timer = self.state_timer; anim = self.animations.get(new_state)
                self.attack_duration = len(anim) * C.ANIM_FRAME_DURATION if anim else 300
                if new_state in ['attack_nm', 'attack2_nm', 'attack_combo_nm', 'crouch_attack']: self.vel.x = 0
            elif new_state == 'hit':
                 self.is_taking_hit = True; self.hit_timer = self.state_timer
                 self.vel.x *= -0.3; self.vel.y = C.PLAYER_JUMP_STRENGTH * 0.4; self.is_attacking = False
            elif new_state == 'death' or new_state == 'death_nm':
                 self.is_dead = True; self.vel.x = 0; self.vel.y = 0
                 self.acc = pygame.math.Vector2(0, 0); self.current_health = 0
            elif new_state == 'wall_climb':
                 self.wall_climb_timer = self.state_timer; self.vel.y = C.PLAYER_WALL_CLIMB_SPEED
            elif new_state == 'wall_slide' or new_state == 'wall_hang': self.wall_climb_timer = 0
            self.animate() # Update visual immediately
        elif not self.is_dead: self._last_state_for_debug = self.state # Keep track even if state is same

    def animate(self):
        if not self._valid_init or not hasattr(self, 'animations') or not self.animations: return
        now = pygame.time.get_ticks(); state_key = self.state
        moving_intended = abs(self.acc.x) > C.PLAYER_ACCEL * 0.1
        if self.is_attacking:
            if self.attack_type == 1: state_key = 'attack' if moving_intended else 'attack_nm'
            elif self.attack_type == 2: state_key = 'attack2' if moving_intended else 'attack2_nm'
            elif self.attack_type == 3: state_key = 'attack_combo' if moving_intended else 'attack_combo_nm'
            elif self.attack_type == 4: state_key = 'crouch_attack'
            if state_key not in self.animations or not self.animations[state_key]:
                 base_state = state_key.replace('_nm', '')
                 state_key = base_state if base_state in self.animations and self.animations[base_state] else 'idle'
        elif self.state == 'wall_climb':
             is_actively_climbing = self.is_holding_climb_ability_key and abs(self.vel.y - C.PLAYER_WALL_CLIMB_SPEED) < 0.1
             state_key = 'wall_climb' if is_actively_climbing else 'wall_climb_nm'
             if state_key not in self.animations or not self.animations[state_key]: state_key = 'wall_climb'
        elif self.state == 'death':
             state_key = 'death_nm' if abs(self.vel.x) < 0.5 and abs(self.vel.y) < 1.0 else 'death'
             if state_key not in self.animations or not self.animations[state_key]: state_key = 'death'
        elif self.state == 'hit': state_key = 'hit'
        elif not self.on_ground and not self.on_ladder and self.touching_wall == 0 and self.state not in ['jump', 'jump_fall_trans'] and self.vel.y > 1:
             state_key = 'fall'
        if state_key not in self.animations or not self.animations[state_key]: state_key = 'idle'
        animation = self.animations.get(state_key)
        if not animation :
            if hasattr(self, 'image') and self.image: self.image.fill(C.RED)
            print(f"Player {self.player_id}: Animation list for '{state_key}' empty in animate.")
            return
        if now - self.last_anim_update > C.ANIM_FRAME_DURATION:
            self.last_anim_update = now; self.current_frame = (self.current_frame + 1)
            if self.current_frame >= len(animation):
                non_looping = ['attack','attack_nm','attack2','attack2_nm','attack_combo','attack_combo_nm',
                               'crouch_attack','dash','roll','slide','hit','turn','jump',
                               'jump_fall_trans','crouch_trans','slide_trans_start','slide_trans_end']
                if self.state in non_looping:
                     next_s = None; current_s = self.state
                     is_input_moving = self.is_trying_to_move_left or self.is_trying_to_move_right
                     if current_s == 'jump': next_s = 'jump_fall_trans' if 'jump_fall_trans' in self.animations else 'fall'
                     elif current_s == 'jump_fall_trans': next_s = 'fall'
                     elif current_s == 'hit': next_s = 'fall' if not self.on_ground and not self.on_ladder else 'idle'
                     elif current_s == 'turn': next_s = 'run' if is_input_moving else 'idle'
                     elif 'attack' in current_s:
                          self.is_attacking = False; self.attack_type = 0
                          if self.on_ladder: pass
                          elif self.is_crouching: next_s = 'crouch'
                          elif not self.on_ground: next_s = 'fall'
                          elif is_input_moving : next_s = 'run'
                          else: next_s = 'idle'
                     elif current_s == 'crouch_trans':
                         self.is_crouching = self.is_holding_crouch_ability_key
                         next_s = 'crouch' if self.is_crouching else 'idle'
                     elif current_s == 'slide_trans_start': next_s = 'slide'
                     elif current_s in ['slide_trans_end', 'slide']:
                         self.is_sliding = False; self.is_crouching = self.is_holding_crouch_ability_key
                         next_s = 'crouch' if self.is_crouching else 'idle'
                     else:
                          if current_s == 'dash': self.is_dashing = False
                          if current_s == 'roll': self.is_rolling = False
                          if self.on_ladder: pass
                          elif self.is_crouching: next_s = 'crouch'
                          elif not self.on_ground: next_s = 'fall'
                          elif is_input_moving : next_s = 'run'
                          else: next_s = 'idle'
                     if next_s: self.set_state(next_s); return
                     else: self.current_frame = 0
                elif self.is_dead: self.current_frame = len(animation) - 1
                else: self.current_frame = 0
            if self.current_frame >= len(animation): self.current_frame = 0
        if not animation or self.current_frame < 0 or self.current_frame >= len(animation):
            self.current_frame = 0
            if not animation:
                if hasattr(self, 'image') and self.image: self.image.fill(C.RED); return
        new_image = animation[self.current_frame]
        if not self.facing_right: new_image = pygame.transform.flip(new_image, True, False)
        if self.image is not new_image or self._last_facing != self.facing_right:
            old_midbottom = self.rect.midbottom; self.image = new_image
            self.rect = self.image.get_rect(midbottom=old_midbottom); self._last_facing = self.facing_right

    def _process_input_logic(self, keys, events, key_config):
        now = pygame.time.get_ticks()
        if not self._valid_init or self.is_dead or (self.is_taking_hit and now - self.hit_timer < self.hit_duration):
            self.acc.x = 0; return
        self.is_trying_to_move_left = keys[key_config['left']]
        self.is_trying_to_move_right = keys[key_config['right']]
        self.is_holding_climb_ability_key = keys[key_config['up']]
        self.is_holding_crouch_ability_key = keys[key_config['down']]
        self.acc.x = 0; is_trying_to_move_lr_thistick = False
        can_control_horizontal = not (self.is_dashing or self.is_rolling or self.is_sliding or self.on_ladder or \
                                     (self.is_attacking and self.state in ['attack_nm','attack2_nm','attack_combo_nm','crouch_attack']) or \
                                      self.state in ['turn','hit','death','death_nm','wall_climb','wall_climb_nm','wall_hang'])
        if can_control_horizontal:
            if self.is_trying_to_move_left and not self.is_trying_to_move_right:
                self.acc.x = -C.PLAYER_ACCEL; is_trying_to_move_lr_thistick = True
                if self.facing_right and self.on_ground and not self.is_crouching and not self.is_attacking and self.state in ['idle','run']: self.set_state('turn')
                self.facing_right = False
            elif self.is_trying_to_move_right and not self.is_trying_to_move_left:
                self.acc.x = C.PLAYER_ACCEL; is_trying_to_move_lr_thistick = True
                if not self.facing_right and self.on_ground and not self.is_crouching and not self.is_attacking and self.state in ['idle','run']: self.set_state('turn')
                self.facing_right = True
        can_initiate_crouch = self.on_ground and not self.on_ladder and not (self.is_dashing or self.is_rolling or self.is_sliding or self.is_attacking or self.state in ['turn','hit','death'])
        if self.is_holding_crouch_ability_key and can_initiate_crouch:
            if not self.is_crouching:
                 self.is_crouching = True; self.is_sliding = False
                 if 'crouch_trans' in self.animations and self.animations['crouch_trans'] and self.state not in ['crouch','crouch_walk','crouch_trans']: self.set_state('crouch_trans')
        elif not self.is_holding_crouch_ability_key and self.is_crouching: self.is_crouching = False
        if self.on_ladder:
             self.vel.y = 0
             if self.is_holding_climb_ability_key: self.vel.y = -C.PLAYER_LADDER_CLIMB_SPEED
             elif self.is_holding_crouch_ability_key: self.vel.y = C.PLAYER_LADDER_CLIMB_SPEED
        for event in events:
            if event.type == pygame.KEYDOWN:
                 if event.key == key_config['up']:
                      can_jump = not self.is_crouching and not self.is_attacking and not self.is_rolling and not self.is_sliding and not self.is_dashing and self.state not in ['turn','hit']
                      if self.on_ground and can_jump: self.vel.y = C.PLAYER_JUMP_STRENGTH; self.set_state('jump'); self.on_ground = False
                      elif self.on_ladder: self.vel.y = C.PLAYER_JUMP_STRENGTH * 0.8; self.vel.x = C.PLAYER_RUN_SPEED_LIMIT * 0.5 * (1 if self.facing_right else -1); self.on_ladder = False; self.set_state('jump')
                      elif self.can_wall_jump and self.touching_wall != 0: self.vel.y = C.PLAYER_JUMP_STRENGTH; self.vel.x = C.PLAYER_RUN_SPEED_LIMIT * 1.5 * (-self.touching_wall); self.facing_right = not self.facing_right; self.set_state('jump'); self.can_wall_jump = False; self.touching_wall = 0; self.wall_climb_timer = 0
                 if event.key == key_config['attack1']:
                      can_attack = not self.is_attacking and not self.is_dashing and not self.is_rolling and not self.is_sliding and not self.on_ladder and self.state not in ['turn','hit']
                      if can_attack:
                           moving = (self.acc.x !=0)
                           if self.is_crouching: self.attack_type = 4; self.set_state('crouch_attack')
                           else: self.attack_type = 1; self.set_state('attack' if moving and 'attack' in self.animations else 'attack_nm')
                 if event.key == key_config['attack2']:
                      can_attack = not self.is_attacking and not self.is_dashing and not self.is_rolling and not self.is_sliding and not self.on_ladder and self.state not in ['turn','hit']
                      if can_attack:
                           time_since_attack = now - self.state_timer; moving = (self.acc.x != 0)
                           combo = (self.state in ['attack','attack_nm'] and self.attack_type == 1 and time_since_attack < self.attack_duration + self.combo_window)
                           if combo and 'attack_combo' in self.animations: self.attack_type = 3; self.set_state('attack_combo' if moving and 'attack_combo' in self.animations else 'attack_combo_nm')
                           elif self.is_crouching: self.attack_type = 4; self.set_state('crouch_attack')
                           elif 'attack2' in self.animations: self.attack_type = 2; self.set_state('attack2' if moving and 'attack2' in self.animations else 'attack2_nm')
                           elif self.attack_type == 0: self.attack_type = 1; self.set_state('attack' if moving and 'attack' in self.animations else 'attack_nm')
                 if event.key == key_config['dash']:
                      if self.on_ground and not self.is_dashing and not self.is_rolling and not self.is_attacking and not self.is_crouching and not self.on_ladder and self.state not in ['turn','hit']: self.set_state('dash')
                 if event.key == key_config['roll']:
                      if self.on_ground and not self.is_rolling and not self.is_dashing and not self.is_attacking and not self.is_crouching and not self.on_ladder and self.state not in ['turn','hit']: self.set_state('roll')
                 if event.key == key_config['down']:
                      can_slide = self.on_ground and self.state == 'run' and abs(self.vel.x) > C.PLAYER_RUN_SPEED_LIMIT * 0.6 and not self.is_sliding and not self.is_crouching and not self.is_attacking and not self.is_rolling and not self.is_dashing and not self.on_ladder and self.state not in ['turn','hit']
                      if can_slide:
                           start_s = 'slide_trans_start' if 'slide_trans_start' in self.animations and self.animations['slide_trans_start'] else 'slide'
                           if start_s in self.animations: self.set_state(start_s)
                 if event.key == key_config['interact']:
                      if self.can_grab_ladder and not self.on_ladder: self.on_ladder = True; self.vel.y=0; self.vel.x=0; self.on_ground=False; self.touching_wall=0; self.can_wall_jump=False; self.wall_climb_timer=0; self.set_state('ladder_idle')
                      elif self.on_ladder: self.on_ladder = False; self.set_state('fall' if not self.on_ground else 'idle')
        is_manual_state = self.is_attacking or self.is_dashing or self.is_rolling or self.is_sliding or self.is_taking_hit or self.state in ['jump','turn','death','death_nm','hit','jump_fall_trans','crouch_trans','slide_trans_start','slide_trans_end','wall_climb','wall_climb_nm','wall_hang','wall_slide','ladder_idle','ladder_climb']
        if not is_manual_state:
            if self.on_ladder:
                if abs(self.vel.y) > 0.1 : self.set_state('ladder_climb')
                else: self.set_state('ladder_idle')
            elif self.on_ground:
                 if self.is_crouching:
                     target_s = 'crouch_walk' if is_trying_to_move_lr_thistick and 'crouch_walk' in self.animations else 'crouch'
                     self.set_state(target_s if target_s in self.animations else 'idle')
                 elif is_trying_to_move_lr_thistick: self.set_state('run' if 'run' in self.animations else 'idle')
                 else: self.set_state('idle')
            else: # In Air
                 if self.touching_wall != 0:
                     now_w = pygame.time.get_ticks()
                     climb_exp = (self.wall_climb_duration > 0 and self.wall_climb_timer > 0 and now_w - self.wall_climb_timer > self.wall_climb_duration)
                     if self.vel.y > C.PLAYER_WALL_SLIDE_SPEED * 0.5 or climb_exp: self.set_state('wall_slide'); self.can_wall_jump = True
                     elif self.is_holding_climb_ability_key and abs(self.vel.x) < 1.0 and not climb_exp and 'wall_climb' in self.animations: self.set_state('wall_climb'); self.can_wall_jump = False
                     else:
                         hang_s = 'wall_hang' if ('wall_hang' in self.animations and self.animations['wall_hang']) else 'wall_slide'
                         self.set_state(hang_s)
                         if self.state == hang_s: self.vel.y = C.PLAYER_WALL_SLIDE_SPEED * 0.1
                         self.can_wall_jump = True
                 elif self.vel.y > 1.0 and self.state not in ['jump','jump_fall_trans']:
                      self.set_state('fall' if 'fall' in self.animations else 'idle')
                 elif self.state not in ['jump','jump_fall_trans','fall']: self.set_state('idle')

    def handle_input(self, keys, events):
        key_config = {'left':pygame.K_a,'right':pygame.K_d,'up':pygame.K_w,'down':pygame.K_s,
                      'attack1':pygame.K_v,'attack2':pygame.K_b,'dash':pygame.K_LSHIFT, # Changed J,K to V,B for P1 default
                      'roll':pygame.K_LCTRL,'interact':pygame.K_e}
        self._process_input_logic(keys, events, key_config)

    def handle_mapped_input(self, keys, events, key_map):
        self._process_input_logic(keys, events, key_map)

    def update(self, dt, platforms, ladders, hazards, enemies):
        if not self._valid_init or self.is_dead:
            if self.is_dead: self.animate(); return
        now = pygame.time.get_ticks()
        if self.is_taking_hit and now - self.hit_timer > self.hit_cooldown: self.is_taking_hit = False
        self.check_ladder_collisions(ladders)
        if self.on_ladder and not self.can_grab_ladder: self.on_ladder = False; self.set_state('fall' if not self.on_ground else 'idle')
        apply_grav = not (self.on_ladder or self.state == 'wall_hang' or (self.state == 'wall_climb' and self.vel.y <= C.PLAYER_WALL_CLIMB_SPEED + 0.1))
        if apply_grav: self.vel.y += C.PLAYER_GRAVITY
        apply_horiz_phys = not (self.is_dashing or self.is_rolling or self.on_ladder or (self.state == 'wall_climb' and self.vel.y <= C.PLAYER_WALL_CLIMB_SPEED + 0.1))
        if apply_horiz_phys:
            self.vel.x += self.acc.x; current_fric = 0
            if self.on_ground and self.acc.x == 0 and not self.is_sliding and self.state != 'slide': current_fric = C.PLAYER_FRICTION
            elif not self.on_ground and not self.is_attacking and self.state not in ['wall_slide','wall_hang','wall_climb','wall_climb_nm']: current_fric = C.PLAYER_FRICTION * 0.2
            elif self.is_sliding or self.state == 'slide': current_fric = C.PLAYER_FRICTION * 0.7
            if current_fric != 0:
                 fric_force = self.vel.x * current_fric
                 if abs(self.vel.x) > 0.1: self.vel.x += fric_force
                 else: self.vel.x = 0
                 if abs(self.vel.x) < 0.5 and (self.is_sliding or self.state == 'slide'):
                     self.is_sliding = False
                     end_s = 'slide_trans_end' if 'slide_trans_end' in self.animations and self.animations['slide_trans_end'] else None
                     if end_s: self.set_state(end_s)
                     else: self.is_crouching = self.is_holding_crouch_ability_key; self.set_state('crouch' if self.is_crouching else 'idle')
            limit = C.PLAYER_RUN_SPEED_LIMIT * 0.6 if self.is_crouching and self.state == 'crouch_walk' else C.PLAYER_RUN_SPEED_LIMIT
            if not self.is_dashing and not self.is_rolling and not self.is_sliding and self.state != 'slide':
                self.vel.x = max(-limit, min(limit, self.vel.x))
        if self.vel.y > 0 and not self.on_ladder: self.vel.y = min(self.vel.y, 18)
        self.touching_wall = 0; self.on_ground = False
        self.pos.x += self.vel.x; self.rect.centerx = round(self.pos.x)
        self.check_platform_collisions('x', platforms)
        collided_x_enemy = self.check_character_collisions('x', enemies)
        self.pos.y += self.vel.y; self.rect.bottom = round(self.pos.y)
        self.check_platform_collisions('y', platforms)
        if not collided_x_enemy: self.check_character_collisions('y', enemies)
        self.pos.x = self.rect.centerx; self.pos.y = self.rect.bottom
        self.check_hazard_collisions(hazards); self.check_attack_collisions(enemies); self.animate()

    def check_platform_collisions(self, direction, platforms):
        collided_wall_side = 0
        for plat in pygame.sprite.spritecollide(self, platforms, False):
            if direction == 'x':
                if self.vel.x > 0: self.rect.right = plat.rect.left; collided_wall_side = 1 if not self.on_ground and not self.on_ladder and self.rect.bottom > plat.rect.top + 5 else 0
                elif self.vel.x < 0: self.rect.left = plat.rect.right; collided_wall_side = -1 if not self.on_ground and not self.on_ladder and self.rect.bottom > plat.rect.top + 5 else 0
                self.vel.x = 0; self.pos.x = self.rect.centerx
            elif direction == 'y':
                if self.vel.y > 0:
                    if (self.pos.y - self.vel.y) <= plat.rect.top + 1: # Check previous bottom
                        self.rect.bottom = plat.rect.top
                        if not self.on_ground: self.can_wall_jump=False; self.wall_climb_timer=0; self.vel.x *= 0.8
                        self.on_ground=True; self.vel.y=0
                elif self.vel.y < 0:
                    if ((self.pos.y - self.rect.height) - self.vel.y) >= plat.rect.bottom -1 : # Check previous top
                         if self.on_ladder: self.on_ladder = False
                         self.rect.top = plat.rect.bottom; self.vel.y=0
                self.pos.y = self.rect.bottom # Update pos after y-collision resolution
        if direction == 'x' and collided_wall_side != 0 and not self.on_ground and not self.on_ladder:
             self.touching_wall = collided_wall_side
             self.can_wall_jump = not (self.state == 'wall_climb' and self.is_holding_climb_ability_key)

    def check_ladder_collisions(self, ladders):
        if not self._valid_init: return
        check_r = self.rect.inflate(-self.rect.width * 0.6, 0); self.can_grab_ladder = False
        for ladder in pygame.sprite.spritecollide(self, ladders, False, collided=lambda p,l: check_r.colliderect(l.rect)):
            if abs(self.rect.centerx - ladder.rect.centerx) < ladder.rect.width * 0.7 and ladder.rect.top < self.rect.bottom and self.rect.top < ladder.rect.bottom:
                  self.can_grab_ladder = True; break

    def check_character_collisions(self, direction, enemies):
        if not self._valid_init or self.is_dead: return False
        collision_occurred = False
        for enemy in pygame.sprite.spritecollide(self, enemies, False):
            if enemy.is_dead: continue; collision_occurred = True
            if direction == 'x':
                push_dir = 0
                if self.vel.x >= 0 and self.rect.centerx < enemy.rect.centerx: self.rect.right = enemy.rect.left; push_dir = -1
                elif self.vel.x <= 0 and self.rect.centerx > enemy.rect.centerx: self.rect.left = enemy.rect.right; push_dir = 1
                elif self.vel.x == 0: # Static collision
                    push_dir = -1 if self.rect.centerx < enemy.rect.centerx else 1
                    if push_dir == -1: self.rect.right = enemy.rect.left
                    else: self.rect.left = enemy.rect.right
                if push_dir != 0:
                    self.vel.x = push_dir * C.CHARACTER_BOUNCE_VELOCITY
                    if hasattr(enemy, 'vel'): enemy.vel.x = -push_dir * C.CHARACTER_BOUNCE_VELOCITY; enemy.rect.x += -push_dir * 2
                    self.pos.x = self.rect.centerx # Update internal position
            elif direction == 'y':
                if self.vel.y > 0 and self.rect.bottom > enemy.rect.top: self.rect.bottom = enemy.rect.top; self.on_ground=True; self.vel.y=0
                elif self.vel.y < 0 and self.rect.top < enemy.rect.bottom: self.rect.top = enemy.rect.bottom; self.vel.y=0
                self.pos.y = self.rect.bottom # Update internal position
        return collision_occurred

    def check_hazard_collisions(self, hazards):
        now = pygame.time.get_ticks()
        if not self._valid_init or self.is_dead or (self.is_taking_hit and now - self.hit_timer < self.hit_cooldown): return
        damaged_this_frame = False
        for hazard in pygame.sprite.spritecollide(self, hazards, False):
            if isinstance(hazard, Lava) and hazard.rect.collidepoint((self.rect.centerx, self.rect.bottom - 1)) and not damaged_this_frame:
                self.take_damage(C.LAVA_DAMAGE); damaged_this_frame = True
                if not self.is_dead:
                     self.vel.y = C.PLAYER_JUMP_STRENGTH * 0.7
                     self.vel.x = - (1 if self.rect.centerx < hazard.rect.centerx else -1) * 6 # Push away from center
                     self.on_ground = False # Ensure airborne after bounce
                break

    def check_attack_collisions(self, enemies):
        if not self._valid_init or not self.is_attacking or self.is_dead: return
        if self.facing_right: self.attack_hitbox.midleft = self.rect.midright
        else: self.attack_hitbox.midright = self.rect.midleft
        self.attack_hitbox.centery = self.rect.centery + (-10 if self.is_crouching else 0)
        for enemy in pygame.sprite.spritecollide(self, enemies, False, collided=lambda p,e: self.attack_hitbox.colliderect(e.rect)):
            if not enemy.is_dead and hasattr(enemy, 'take_damage') and callable(enemy.take_damage):
                 can_damage = True
                 if hasattr(enemy, 'is_taking_hit') and hasattr(enemy, 'hit_timer') and hasattr(enemy, 'hit_cooldown'):
                     if enemy.is_taking_hit and (pygame.time.get_ticks() - enemy.hit_timer < enemy.hit_cooldown): can_damage = False
                 if can_damage: enemy.take_damage(C.PLAYER_ATTACK_DAMAGE)

    def take_damage(self, amount):
        now = pygame.time.get_ticks()
        if not self._valid_init or self.is_dead or (self.is_taking_hit and now - self.hit_timer < self.hit_cooldown):
            return
        self.current_health -= amount
        self.current_health = max(0, self.current_health)
        if self.current_health <= 0:
            if not self.is_dead: self.set_state('death')
        else:
            if not (self.is_taking_hit and now - self.hit_timer < self.hit_duration):
                 self.set_state('hit')

    def self_inflict_damage(self, amount):
        """Player inflicts damage upon themselves."""
        if not self._valid_init or self.is_dead:
            return
        self.take_damage(amount)

    def heal_to_full(self):
        """ Restores the player's health to its maximum value. """
        if not self._valid_init or self.is_dead: return
        self.current_health = self.max_health
        print(f"Player {self.player_id} healed to full: {self.current_health}/{self.max_health}")
        if self.is_taking_hit: self.is_taking_hit = False
        # If healing revives, uncomment below:
        # if self.is_dead: self.is_dead = False; self.set_state('idle')

    def reset_state(self, spawn_pos):
        if not self._valid_init: return
        self.pos = pygame.math.Vector2(spawn_pos[0], spawn_pos[1])
        self.rect.midbottom = (round(self.pos.x), round(self.pos.y))
        self.vel = pygame.math.Vector2(0, 0)
        self.acc = pygame.math.Vector2(0, C.PLAYER_GRAVITY if hasattr(C, 'PLAYER_GRAVITY') else 0.7)
        self.current_health = self.max_health; self.is_dead = False; self.is_taking_hit = False
        self.is_attacking = False; self.attack_type = 0; self.is_dashing = False; self.is_rolling = False; self.is_sliding = False
        self.on_ladder = False; self.touching_wall = 0; self.facing_right = True
        self.set_state('idle')
        print(f"Player {self.player_id} reset to {self.pos} with {self.current_health} HP.")

    def get_network_data(self):
        # Basic implementation, expand as needed for network sync
        return {'pos': (self.pos.x, self.pos.y), 'vel': (self.vel.x, self.vel.y), 'state': self.state,
                'facing_right': self.facing_right, 'current_health': self.current_health, 'is_dead': self.is_dead,
                'is_attacking': self.is_attacking, 'attack_type': self.attack_type,
                'current_frame': self.current_frame, 'last_anim_update': self.last_anim_update, # For smoother anim sync
                'player_id': self.player_id} # Include player_id for server to identify

    def set_network_data(self, data): # Basic implementation
        if data is None: return
        self.pos.x, self.pos.y = data.get('pos', (self.pos.x, self.pos.y))
        self.vel.x, self.vel.y = data.get('vel', (self.vel.x, self.vel.y))
        new_state = data.get('state', self.state)
        # Only call set_state if it's truly different to avoid interrupting animations unnecessarily
        # unless the server is also sending frame data for perfect sync.
        if self.state != new_state and not self.is_dead: # Don't change state if dead, let death anim play
            self.set_state(new_state)
        self.facing_right = data.get('facing_right', self.facing_right)
        self.current_health = data.get('current_health', self.current_health)
        self.is_dead = data.get('is_dead', self.is_dead)
        self.is_attacking = data.get('is_attacking', self.is_attacking)
        self.attack_type = data.get('attack_type', self.attack_type)
        # For smoother animation sync from server:
        self.current_frame = data.get('current_frame', self.current_frame)
        self.last_anim_update = data.get('last_anim_update', self.last_anim_update)
        self.rect.midbottom = (round(self.pos.x), round(self.pos.y)) # Crucial to update rect


    def handle_network_input(self, input_data_dict):
        # This is a conceptual placeholder for client-side player (controlled by server)
        # or server-side player (controlled by client input).
        # It would map dictionary keys (like 'left_held': True) to player actions.
        # E.g., if input_data_dict.get('left_held'): self.acc.x = -C.PLAYER_ACCEL
        # This method should essentially mirror parts of _process_input_logic,
        # but using the dictionary from the network instead of direct Pygame key/event checks.
        # This requires a well-defined input_data_dict structure.
        # print(f"P{self.player_id} received network input: {input_data_dict}") # For debugging
        
        # Example of processing (needs to be robust and match get_input_state structure)
        # This is highly simplified and needs careful implementation matching get_input_state
        if not self._valid_init or self.is_dead: return

        self.acc.x = 0 # Reset acceleration
        if input_data_dict.get('left_held'):
            self.acc.x = -C.PLAYER_ACCEL
            if self.facing_right and self.on_ground: self.set_state('turn') # Basic turn
            self.facing_right = False
        if input_data_dict.get('right_held'):
            self.acc.x = C.PLAYER_ACCEL
            if not self.facing_right and self.on_ground: self.set_state('turn') # Basic turn
            self.facing_right = True
        
        # Event-like actions (these would ideally be distinct flags like 'jump_pressed_this_tick')
        if input_data_dict.get('up_pressed_event'): # Assuming 'up_pressed_event' is sent for jump
            if self.on_ground: self.vel.y = C.PLAYER_JUMP_STRENGTH; self.set_state('jump'); self.on_ground = False
        # Add similar for attack, dash, roll based on flags in input_data_dict
        # This needs to be carefully designed to match what get_input_state sends.


    def get_input_state(self, current_keys, current_events, key_map_for_player=None):
        # This method should generate a dictionary representing the player's current input.
        # This dictionary is then sent over the network by the client.
        input_state = {
            'left_held': False, 'right_held': False, 'up_held': False, 'down_held': False,
            'attack1_pressed_event': False, 'attack2_pressed_event': False,
            'dash_pressed_event': False, 'roll_pressed_event': False,
            'interact_pressed_event': False,
            # 'action_reset': False, # This might be handled at a higher level, not per-player input
            # 'action_self_harm': False # Could be added if client requests self-harm
        }

        if key_map_for_player: # Use the provided key map
            input_state['left_held'] = current_keys[key_map_for_player['left']]
            input_state['right_held'] = current_keys[key_map_for_player['right']]
            input_state['up_held'] = current_keys[key_map_for_player['up']]
            input_state['down_held'] = current_keys[key_map_for_player['down']]

            for event in current_events:
                if event.type == pygame.KEYDOWN:
                    if event.key == key_map_for_player.get('attack1'): input_state["attack1_pressed_event"] = True
                    if event.key == key_map_for_player.get('attack2'): input_state["attack2_pressed_event"] = True
                    if event.key == key_map_for_player.get('dash'): input_state["dash_pressed_event"] = True
                    if event.key == key_map_for_player.get('roll'): input_state["roll_pressed_event"] = True
                    if event.key == key_map_for_player.get('interact'): input_state["interact_pressed_event"] = True
                    # If you add a self-harm key to the map (e.g., 'self_harm': pygame.K_h)
                    # if 'self_harm' in key_map_for_player and event.key == key_map_for_player.get('self_harm'):
                    #     input_state["action_self_harm"] = True
        else: # Fallback to default P1 keys if no map provided (less flexible for network)
            input_state['left_held'] = current_keys[pygame.K_a]
            input_state['right_held'] = current_keys[pygame.K_d]
            input_state['up_held'] = current_keys[pygame.K_w]
            input_state['down_held'] = current_keys[pygame.K_s]
            for event in current_events:
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_v: input_state["attack1_pressed_event"] = True # Assuming V,B for P1 if no map
                    if event.key == pygame.K_b: input_state["attack2_pressed_event"] = True
                    if event.key == pygame.K_LSHIFT: input_state["dash_pressed_event"] = True
                    if event.key == pygame.K_LCTRL: input_state["roll_pressed_event"] = True
                    if event.key == pygame.K_e: input_state["interact_pressed_event"] = True
        return input_state

========== START OF FILE: tiles.py ==========

# -*- coding: utf-8 -*-
"""
Defines classes for static and interactive tiles in the game world.
"""
import pygame
from constants import GRAY, BLUE, ORANGE_RED # Import colors

class Platform(pygame.sprite.Sprite):
    """ Standard solid platform. """
    def __init__(self, x, y, width, height, color=GRAY):
        super().__init__()
        self.image = pygame.Surface((width, height))
        self.image.fill(color)
        # Prevent negative width/height which causes Surface errors
        self.rect = self.image.get_rect(topleft=(x, y))
        if width <= 0 or height <= 0:
            print(f"Warning: Platform created with non-positive dimensions: w={width}, h={height} at ({x},{y})")
            # Optionally create a minimal valid rect/image or handle error
            self.image = pygame.Surface((1, 1)) # Minimal surface
            self.image.fill(color)
            self.rect = self.image.get_rect(topleft=(x,y))


class Ladder(pygame.sprite.Sprite):
    """ Climbable ladder area. """
    def __init__(self, x, y, width, height):
        super().__init__()
        # Ensure valid dimensions
        width = max(1, width)
        height = max(1, height)
        self.image = pygame.Surface((width, height)).convert_alpha()
        self.image.set_alpha(100) # Make semi-transparent
        self.image.fill((0, 0, 0, 0)) # Fully transparent background

        # Draw visual cues (rungs, rails)
        rung_color = (40, 40, 180, 200) # Slightly transparent dark blue
        num_rungs = int(height / 15)
        if num_rungs > 0: # Avoid division by zero if height is too small
            rung_spacing = height / num_rungs
            for i in range(1, num_rungs):
                rung_y = i * rung_spacing
                pygame.draw.line(self.image, rung_color, (0, rung_y), (width, rung_y), 2)
        # Draw side rails (ensure lines are within surface bounds)
        pygame.draw.line(self.image, rung_color, (min(2, width-1), 0), (min(2, width-1), height), 3)
        pygame.draw.line(self.image, rung_color, (max(0, width - 3), 0), (max(0, width - 3), height), 3)

        self.rect = self.image.get_rect(topleft=(x, y))

class Lava(pygame.sprite.Sprite):
    """ Dangerous lava tile that damages characters. """
    def __init__(self, x, y, width, height, color=ORANGE_RED):
        super().__init__()
        # Ensure valid dimensions
        width = max(1, width)
        height = max(1, height)
        self.image = pygame.Surface((width, height))
        self.image.fill(color)
        # Optional: Add visual effect like simple noise/flicker
        # for _ in range(int(width*height*0.1)): # Add some darker spots
        #      px = random.randint(0, width-1)
        #      py = random.randint(0, height-1)
        #      dark_color = (max(0,color[0]-50), max(0,color[1]-20), color[2])
        #      self.image.set_at((px, py), dark_color)

# -*- coding: utf-8 -*-
"""
Defines classes for static and interactive tiles in the game world.
"""
import pygame
from constants import GRAY, BLUE, ORANGE_RED # Import colors

class Platform(pygame.sprite.Sprite):
    """ Standard solid platform. """
    def __init__(self, x, y, width, height, color=GRAY):
        super().__init__()
        self.image = pygame.Surface((width, height))
        self.image.fill(color)
        # Prevent negative width/height which causes Surface errors
        self.rect = self.image.get_rect(topleft=(x, y))
        if width <= 0 or height <= 0:
            print(f"Warning: Platform created with non-positive dimensions: w={width}, h={height} at ({x},{y})")
            # Optionally create a minimal valid rect/image or handle error
            self.image = pygame.Surface((1, 1)) # Minimal surface
            self.image.fill(color)
            self.rect = self.image.get_rect(topleft=(x,y))


class Ladder(pygame.sprite.Sprite):
    """ Climbable ladder area. """
    def __init__(self, x, y, width, height):
        super().__init__()
        # Ensure valid dimensions
        width = max(1, width)
        height = max(1, height)
        self.image = pygame.Surface((width, height)).convert_alpha()
        self.image.set_alpha(100) # Make semi-transparent
        self.image.fill((0, 0, 0, 0)) # Fully transparent background

        # Draw visual cues (rungs, rails)
        rung_color = (40, 40, 180, 200) # Slightly transparent dark blue
        num_rungs = int(height / 15)
        if num_rungs > 0: # Avoid division by zero if height is too small
            rung_spacing = height / num_rungs
            for i in range(1, num_rungs):
                rung_y = i * rung_spacing
                pygame.draw.line(self.image, rung_color, (0, rung_y), (width, rung_y), 2)
        # Draw side rails (ensure lines are within surface bounds)
        pygame.draw.line(self.image, rung_color, (min(2, width-1), 0), (min(2, width-1), height), 3)
        pygame.draw.line(self.image, rung_color, (max(0, width - 3), 0), (max(0, width - 3), height), 3)

        self.rect = self.image.get_rect(topleft=(x, y))

class Lava(pygame.sprite.Sprite):
    """ Dangerous lava tile that damages characters. """
    def __init__(self, x, y, width, height, color=ORANGE_RED):
        super().__init__()
        # Ensure valid dimensions
        width = max(1, width)
        height = max(1, height)
        self.image = pygame.Surface((width, height))
        self.image.fill(color)
        self.rect = self.image.get_rect(topleft=(x, y))

========== START OF FILE: ui.py ==========

# -*- coding: utf-8 -*-
"""
Functions for drawing User Interface elements like health bars and player HUDs.
"""
import pygame
import constants as C # Import constants with C. prefix

# --- Font Initialization (Initialize once) ---
# It's good practice to initialize fonts once, e.g., when the UI module is imported or in a setup function.
# For simplicity, we'll do it here. Handle font loading errors gracefully.
try:
    pygame.font.init() # Ensure the font module is initialized
    HUD_FONT_SIZE = 20
    HUD_FONT = pygame.font.Font(None, HUD_FONT_SIZE) # Use default system font
    # For a custom font: HUD_FONT = pygame.font.Font("path/to/your/font.ttf", HUD_FONT_SIZE)
except pygame.error as e:
    print(f"Warning: Could not initialize font: {e}. Using fallback.")
    HUD_FONT = None
except Exception as e: # Catch other potential errors during font loading
    print(f"Warning: An unexpected error occurred while initializing font: {e}. Using fallback.")
    HUD_FONT = None

if HUD_FONT is None: # Fallback if font loading failed
    try: # Try a very basic Pygame font if default failed
        HUD_FONT = pygame.font.SysFont("arial", HUD_FONT_SIZE) # Common system font
    except pygame.error: # If even SysFont fails
        print("Critical Warning: All font loading failed. Text HUD elements will not be drawn.")
        HUD_FONT = None # Ensure it's None so checks below work

# --- Existing Health Bar Function ---
def draw_health_bar(surface, x, y, width, height, current_hp, max_hp):
    """ Draws a health bar at the given position with color transition. """
    if max_hp <= 0: return

    current_hp = max(0, current_hp)
    width = max(1, width)
    height = max(1, height)
    hp_ratio = min(1, current_hp / max_hp)

    try:
        health_color = pygame.Color(C.RED).lerp(C.GREEN, hp_ratio)
    except AttributeError: # Manual lerp for older Pygame or if Color.lerp is missing
        r = int(C.RED[0] * (1 - hp_ratio) + C.GREEN[0] * hp_ratio)
        g = int(C.RED[1] * (1 - hp_ratio) + C.GREEN[1] * hp_ratio)
        b = int(C.RED[2] * (1 - hp_ratio) + C.GREEN[2] * hp_ratio)
        health_color = (max(0, min(255, r)), max(0, min(255, g)), max(0, min(255, b)))

    background_rect = pygame.Rect(x, y, width, height)
    pygame.draw.rect(surface, C.DARK_GRAY, background_rect)

    health_fill_width = int(width * hp_ratio)
    if health_fill_width > 0:
        health_rect = pygame.Rect(x, y, health_fill_width, height)
        pygame.draw.rect(surface, health_color, health_rect)
    pygame.draw.rect(surface, C.BLACK, background_rect, 1)


# --- NEW: Player HUD Function ---
def draw_player_hud(surface, x, y, player, player_number):
    """
    Draws the Heads-Up Display for a given player.
    Includes player label and health bar.

    Args:
        surface (pygame.Surface): The surface to draw on.
        x (int): The top-left x-coordinate for the HUD.
        y (int): The top-left y-coordinate for the HUD.
        player (Player): The player object, expected to have 'current_health' and 'max_health'.
        player_number (int): The number of the player (e.g., 1 or 2).
    """
    if not player or not hasattr(player, 'current_health') or not hasattr(player, 'max_health'):
        # print(f"Warning: Invalid player object or missing health attributes for HUD P{player_number}.")
        return

    # --- Player Label ---
    label_text = f"P{player_number}"
    if HUD_FONT:
        try:
            label_surface = HUD_FONT.render(label_text, True, C.WHITE)
            surface.blit(label_surface, (x, y))
            label_height = label_surface.get_height()
        except pygame.error as e: # Catch errors during rendering (e.g. font not loaded)
            print(f"Warning: Could not render HUD label for P{player_number}: {e}")
            label_height = HUD_FONT_SIZE # Estimate height
        except Exception as e:
            print(f"Warning: Unexpected error rendering HUD label for P{player_number}: {e}")
            label_height = HUD_FONT_SIZE
    else: # No font loaded
        label_height = 0 # No label to draw, so no height offset for health bar

    # --- Health Bar ---
    # Position health bar below the label
    health_bar_x = x
    health_bar_y = y + label_height + 5  # Add some padding
    health_bar_width = C.HEALTH_BAR_WIDTH * 2 # Make it a bit wider for HUD
    health_bar_height = C.HEALTH_BAR_HEIGHT + 4 # Make it a bit taller for HUD

    draw_health_bar(surface, health_bar_x, health_bar_y,
                    health_bar_width, health_bar_height,
                    player.current_health, player.max_health)

    # --- Optional: Draw Health Value Text ---
    if HUD_FONT:
        try:
            health_text = f"{int(player.current_health)}/{int(player.max_health)}"
            health_text_surface = HUD_FONT.render(health_text, True, C.WHITE)
            # Position text next to or on the health bar
            text_x = health_bar_x + health_bar_width + 10
            text_y = health_bar_y + (health_bar_height - health_text_surface.get_height()) / 2 # Center vertically
            surface.blit(health_text_surface, (text_x, text_y))
        except pygame.error as e:
            print(f"Warning: Could not render HUD health text for P{player_number}: {e}")
        except Exception as e:
            print(f"Warning: Unexpected error rendering HUD health text for P{player_number}: {e}")


# Example of how you might call this in your main loop (for testing ui.py directly)
if __name__ == '__main__':
    pygame.init()
    if not pygame.font.get_init(): # Ensure font module is initialized if running directly
        pygame.font.init()
        if HUD_FONT is None: # Re-attempt basic font loading if it failed at module level
            try:
                HUD_FONT = pygame.font.SysFont("arial", 20)
            except:
                print("Main test: Font loading failed.")


    screen_width = 300
    screen_height = 200
    screen = pygame.display.set_mode((screen_width, screen_height))
    pygame.display.set_caption("UI Test")

    # Dummy player object for testing
    class DummyPlayer:
        def __init__(self, current_hp, max_hp):
            self.current_health = current_hp
            self.max_health = max_hp

    player1_dummy = DummyPlayer(80, 100)
    player2_dummy = DummyPlayer(50, C.PLAYER_MAX_HEALTH)


    running = True
    clock = pygame.time.Clock()

    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            if event.type == pygame.KEYDOWN: # Simple test to change health
                if event.key == pygame.K_1:
                    player1_dummy.current_health = max(0, player1_dummy.current_health -10)
                if event.key == pygame.K_2:
                    player2_dummy.current_health = max(0, player2_dummy.current_health -10)


        screen.fill(C.LIGHT_BLUE) # Background

        # Test draw_player_hud
        if HUD_FONT: # Only draw if font is available
            draw_player_hud(screen, 10, 10, player1_dummy, 1)
            draw_player_hud(screen, 10, 70, player2_dummy, 2)
        else:
            # Fallback: just draw health bars if no font
            draw_health_bar(screen, 10, 10, C.HEALTH_BAR_WIDTH * 2, C.HEALTH_BAR_HEIGHT + 4, player1_dummy.current_health, player1_dummy.max_health)
            draw_health_bar(screen, 10, 70, C.HEALTH_BAR_WIDTH * 2, C.HEALTH_BAR_HEIGHT + 4, player2_dummy.current_health, player2_dummy.max_health)


        pygame.display.flip()
        clock.tick(C.FPS)

    pygame.quit()