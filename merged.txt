

########## START OF FILE: assets.py ##########

# assets.py
# -*- coding: utf-8 -*-
## version 1.0.0.3 (Changed constants import style for diagnostics)
"""
Handles loading game assets, primarily animations from GIF files.
Includes a helper function `resource_path` to ensure correct asset pathing
both during local development and when the game is packaged by PyInstaller (especially --onedir).
"""
import pygame
import os
import sys
from PIL import Image # Pillow library for GIF processing
from typing import Dict, List, Optional # For type hinting

# --- Import Constants (specifically colors for placeholder images) ---
# Attempting a different import style for diagnostics
try:
    import constants # Import the whole module
    RED = constants.RED
    BLACK = constants.BLACK
    BLUE = constants.BLUE
    YELLOW = constants.YELLOW
except ImportError:
    print("Assets Warning: Failed to import 'constants' (using 'import constants'). Using fallback colors.")
    RED = (255, 0, 0)
    BLACK = (0, 0, 0)
    BLUE = (0, 0, 255)
    YELLOW = (255, 255, 0)
except AttributeError as e:
    # This block will catch if 'constants' was imported but one of the specific color names is missing.
    print(f"Assets Warning: Imported 'constants' but an attribute is missing: {e}. Using fallback colors.")
    RED = (255, 0, 0)
    BLACK = (0, 0, 0)
    BLUE = (0, 0, 255)
    YELLOW = (255, 255, 0)
except Exception as e_general_import: # Catch any other unexpected error during constants import
    print(f"Assets CRITICAL: Unexpected error importing 'constants': {e_general_import}. Using fallback colors.")
    RED = (255, 0, 0)
    BLACK = (0, 0, 0)
    BLUE = (0, 0, 255)
    YELLOW = (255, 255, 0)


# --- Helper Function for PyInstaller Compatibility ---
def resource_path(relative_path: str) -> str:
    """ 
    Get the absolute path to a resource, works for development and for PyInstaller.
    When running as a PyInstaller bundle (especially --onedir or --onefile),
    assets are often bundled relative to sys._MEIPASS.

    Args:
        relative_path (str): The path to the resource relative to the project root
                             (or where assets are expected to be found).

    Returns:
        str: The absolute path to the resource.
    """
    try:
        base_path = sys._MEIPASS
    except AttributeError:
        base_path = os.path.abspath(".")
    full_asset_path = os.path.join(base_path, relative_path)
    return full_asset_path
# ----------------------------------------------------


# --- GIF Loading Function ---
def load_gif_frames(full_path_to_gif_file: str) -> List[pygame.Surface]:
    """
    Loads all frames from a GIF file using the Pillow library and converts them
    into a list of Pygame Surface objects. Handles transparency.
    """
    loaded_frames: List[pygame.Surface] = []
    try:
        pil_gif_image = Image.open(full_path_to_gif_file)
        frame_index = 0
        while True: 
            try:
                pil_gif_image.seek(frame_index) 
                current_pil_frame = pil_gif_image.copy()
                rgba_pil_frame = current_pil_frame.convert('RGBA') 
                frame_pixel_data = rgba_pil_frame.tobytes() 
                frame_dimensions = rgba_pil_frame.size     
                pygame_surface_frame = pygame.image.frombuffer(frame_pixel_data, frame_dimensions, "RGBA")
                pygame_surface_frame = pygame_surface_frame.convert_alpha() 
                loaded_frames.append(pygame_surface_frame)
                frame_index += 1
            except EOFError:
                break # End of frames
            except Exception as e_frame: 
                print(f"Assets Error: Processing frame {frame_index} in '{full_path_to_gif_file}': {e_frame}")
                frame_index += 1 # Try next frame

        if not loaded_frames: 
             print(f"Assets Error: No frames loaded from '{full_path_to_gif_file}'. Creating a RED placeholder.")
             placeholder_surface = pygame.Surface((30, 40)).convert_alpha()
             placeholder_surface.fill(RED) # Use RED from constants or fallback
             pygame.draw.rect(placeholder_surface, BLACK, placeholder_surface.get_rect(), 1) # Use BLACK
             return [placeholder_surface] 
        
        return loaded_frames

    except FileNotFoundError:
        print(f"Assets Error: GIF file not found at resolved path: '{full_path_to_gif_file}'")
    except Exception as e_load: 
        print(f"Assets Error: Loading GIF '{full_path_to_gif_file}' with Pillow: {e_load}")
    
    # Fallback placeholder if any error occurs during loading
    placeholder_surface_on_error = pygame.Surface((30, 40)).convert_alpha()
    placeholder_surface_on_error.fill(RED) # Use RED
    pygame.draw.rect(placeholder_surface_on_error, BLACK, placeholder_surface_on_error.get_rect(), 2) # Use BLACK
    return [placeholder_surface_on_error]


# --- Player/Enemy Animation Loading Function ---
def load_all_player_animations(relative_asset_folder: str = 'characters/player1') -> Optional[Dict[str, List[pygame.Surface]]]:
    """
    Loads all defined animations for a character.
    """
    animations_dict: Dict[str, List[pygame.Surface]] = {}
    animation_filenames_map = {
        'attack': '__Attack.gif', 'attack2': '__Attack2.gif', 'attack_combo': '__AttackCombo2hit.gif',
        'attack_nm': '__AttackNoMovement.gif', 'attack2_nm': '__Attack2NoMovement.gif',
        'attack_combo_nm': '__AttackComboNoMovement.gif', 
        'crouch': '__Crouch.gif', 'crouch_trans': '__CrouchTransition.gif', 
        'crouch_walk': '__CrouchWalk.gif', 'crouch_attack': '__CrouchAttack.gif', 
        'dash': '__Dash.gif', 
        'death': '__Death.gif', 'death_nm': '__DeathNoMovement.gif', 
        'fall': '__Fall.gif', 'hit': '__Hit.gif', 'idle': '__Idle.gif', 
        'jump': '__Jump.gif', 'jump_fall_trans': '__JumpFallInbetween.gif',
        'roll': '__Roll.gif', 'run': '__Run.gif', 
        'slide': '__SlideAll.gif', 'slide_trans_start': '__SlideTransitionStart.gif', 
        'slide_trans_end': '__SlideTransitionEnd.gif',
        'turn': '__TurnAround.gif', 
        'wall_climb': '__WallClimb.gif', 'wall_climb_nm': '__WallClimbNoMovement.gif', 
        'wall_hang': '__WallHang.gif', 'wall_slide': '__WallSlide.gif',
    }

    print(f"Assets Info: Attempting to load animations from relative folder: '{relative_asset_folder}'")
    missing_files_log: List[tuple[str, str, str]] = [] 

    for anim_state_name, gif_filename in animation_filenames_map.items():
         relative_path_to_gif = os.path.join(relative_asset_folder, gif_filename)
         absolute_gif_path = resource_path(relative_path_to_gif)

         if not os.path.exists(absolute_gif_path):
             missing_files_log.append(
                 (anim_state_name, relative_path_to_gif, absolute_gif_path)
             )
             animations_dict[anim_state_name] = [] # Mark as missing for later placeholder generation
             continue

         loaded_animation_frames = load_gif_frames(absolute_gif_path)
         animations_dict[anim_state_name] = loaded_animation_frames

         # Check if load_gif_frames returned its RED placeholder due to an internal error
         if not animations_dict[anim_state_name] or \
            (len(animations_dict[anim_state_name]) == 1 and \
             animations_dict[anim_state_name][0].get_size() == (30,40) and \
             animations_dict[anim_state_name][0].get_at((0,0)) == RED): # RED from constants/fallback
             print(f"Assets Warning: Failed to load frames for state '{anim_state_name}' from existing file '{absolute_gif_path}'. RED Placeholder used.")

    if missing_files_log:
        print("\n--- Assets: Missing Animation Files Detected ---")
        try: base_path_for_log = sys._MEIPASS
        except AttributeError: base_path_for_log = os.path.abspath(".")
        
        for name, rel_path, res_path in missing_files_log:
            print(f"- State '{name}': Expected relative path: '{rel_path}', Resolved path checked: '{res_path}'")
        print(f"(Asset loading base path used by resource_path: '{base_path_for_log}')")
        print("--------------------------------------------\n")

    # Check for critical 'idle' animation
    idle_anim_is_missing_or_placeholder = (
        'idle' not in animations_dict or 
        not animations_dict['idle'] or 
        (len(animations_dict['idle']) == 1 and 
         animations_dict['idle'][0].get_size() == (30,40) and 
         animations_dict['idle'][0].get_at((0,0)) == RED) # RED from constants/fallback
    )

    if idle_anim_is_missing_or_placeholder:
        idle_file_rel_path = os.path.join(relative_asset_folder, animation_filenames_map.get('idle', '__Idle.gif'))
        idle_file_abs_path_checked = resource_path(idle_file_rel_path)
        if 'idle' not in animations_dict or not animations_dict['idle']: 
            print(f"CRITICAL Assets Error: 'idle' animation file ('{idle_file_rel_path}') not found or empty. Checked: '{idle_file_abs_path_checked}'.")
        else: # It's the RED placeholder
            print(f"CRITICAL Assets Error: 'idle' animation failed to load correctly (is RED placeholder) from '{idle_file_abs_path_checked}'.")
        print("Assets: Returning None due to critical 'idle' animation failure.")
        return None

    # Provide blue placeholders for other missing/failed non-critical animations
    for anim_name_check in animation_filenames_map:
        if anim_name_check == 'idle': continue # Already handled

        animation_is_missing_or_placeholder = (
            anim_name_check not in animations_dict or 
            not animations_dict[anim_name_check] or 
            (len(animations_dict[anim_name_check]) == 1 and 
             animations_dict[anim_name_check][0].get_size() == (30,40) and 
             animations_dict[anim_name_check][0].get_at((0,0)) == RED) # RED from constants/fallback
        )

        if animation_is_missing_or_placeholder:
            if anim_name_check not in animations_dict or not animations_dict[anim_name_check]:
                 # This case means the file was missing (missing_files_log handled the print)
                 # and animations_dict[anim_name_check] was set to []
                 print(f"Assets Warning: Animation state '{anim_name_check}' (file missing). Providing a BLUE placeholder.")
            else: # This case means file existed but load_gif_frames returned the RED placeholder
                 print(f"Assets Warning: Animation state '{anim_name_check}' (load failed, is RED placeholder). Using a BLUE placeholder.")

            blue_placeholder = pygame.Surface((30, 40)).convert_alpha()
            blue_placeholder.fill(BLUE) # BLUE from constants/fallback
            pygame.draw.line(blue_placeholder, RED, (0,0), (30,40), 2) # RED for cross
            pygame.draw.line(blue_placeholder, RED, (0,40), (30,0), 2)
            animations_dict[anim_name_check] = [blue_placeholder]

    print(f"Assets Info: Finished loading animations. {len(animations_dict)} animation states processed for '{relative_asset_folder}'.")
    return animations_dict
# ------------------------------------------


# --- Example Usage (if assets.py is run directly for testing) ---
if __name__ == "__main__":
    print("Running assets.py directly for testing...")
    # Pygame init is needed for Surface creation, even for tests not drawing to screen
    pygame.init() 
    # Note: If constants.py is in the same dir, 'import constants' should work here.
    # If it fails here too, the problem is more fundamental with constants.py visibility.

    print("\n--- Testing resource_path ---")
    test_relative_path = 'characters/player1/__Idle.gif' 
    resolved_test_path = resource_path(test_relative_path)
    print(f"Resolved path for '{test_relative_path}': {resolved_test_path}")
    print(f"Does it exist? {os.path.exists(resolved_test_path)}")

    test_character_asset_folder = 'characters/player1' 
    print(f"\n--- Testing load_all_player_animations with relative folder: '{test_character_asset_folder}' ---")
    
    loaded_player_animations = load_all_player_animations(relative_asset_folder=test_character_asset_folder)

    if loaded_player_animations:
        print(f"\nAssets Test: Successfully loaded animation data dictionary.")
        if 'idle' in loaded_player_animations and loaded_player_animations['idle']:
            print(f"Idle animation loaded with {len(loaded_player_animations['idle'])} frames.")
            first_idle_frame = loaded_player_animations['idle'][0]
            if first_idle_frame.get_size() == (30, 40): # Standard placeholder size
                 # Check color using the RED defined at the top of this file (either from constants or fallback)
                 if first_idle_frame.get_at((0,0)) == RED: 
                     print("Assets Test WARNING: 'idle' animation appears to be the RED (load failure) placeholder!")
                 elif first_idle_frame.get_at((0,0)) == BLUE: # BLUE defined at top
                     print("Assets Test WARNING: 'idle' animation appears to be a BLUE (non-critical missing) placeholder! (This shouldn't happen for idle due to critical check)")
        else:
            print("Assets Test ERROR: 'idle' animation missing or empty in the returned dictionary (after critical check).")
    else:
        print("\nAssets Test: Animation loading failed (load_all_player_animations returned None). Likely due to critical 'idle' animation issue.")

    pygame.quit()

########## START OF FILE: camera.py ##########

# -*- coding: utf-8 -*-
"""
camera.py
Defines the Camera class for managing the game's viewport.
"""
# version 1.0.0.2 (Adapted to use absolute level Y boundaries)
import pygame

class Camera:
    def __init__(self, level_width: int, level_top_y_abs: int, level_bottom_y_abs: int, 
                 screen_width: int, screen_height: int):
        """
        Initializes the camera.

        Args:
            level_width (int): The total width of the game level.
            level_top_y_abs (int): The absolute Y coordinate of the top of the level (e.g., top of ceiling wall).
            level_bottom_y_abs (int): The absolute Y coordinate of the bottom of the level (e.g., bottom of floor wall).
            screen_width (int): The width of the game screen/window.
            screen_height (int): The height of the game screen/window.
        """
        self.camera_rect = pygame.Rect(0, 0, screen_width, screen_height)
        self.level_width = level_width
        self.level_top_y_abs = level_top_y_abs         # Absolute top Y of the entire level
        self.level_bottom_y_abs = level_bottom_y_abs   # Absolute bottom Y of the entire level
        self.screen_width = screen_width
        self.screen_height = screen_height
        
        # Calculate effective level height (the total scrollable span)
        self.effective_level_height = self.level_bottom_y_abs - self.level_top_y_abs

        # print(f"Camera Initialized: LvlW:{level_width}, LvlTopY:{level_top_y_abs}, LvlBotY:{level_bottom_y_abs} (EffH:{self.effective_level_height}), ScreenWH: {screen_width}x{screen_height}")


    def apply(self, target):
        """
        Applies the camera offset to a target sprite or rect.

        Args:
            target (pygame.sprite.Sprite or pygame.Rect): The sprite or rect to offset.

        Returns:
            pygame.Rect: A new Rect representing the target's position on the screen.
        """
        if isinstance(target, pygame.sprite.Sprite):
            return target.rect.move(self.camera_rect.topleft)
        elif isinstance(target, pygame.Rect):
            return target.move(self.camera_rect.topleft)
        else:
            raise TypeError("Camera.apply() target must be a Sprite or Rect.")


    def update(self, target_sprite):
        """
        Updates the camera's position to follow the target_sprite.
        The camera attempts to keep the target_sprite centered on the screen,
        while respecting the level boundaries defined by absolute coordinates.

        Args:
            target_sprite (pygame.sprite.Sprite): The sprite the camera should follow.
                                                 Expected to have a 'rect' attribute.
        """
        if not target_sprite or not hasattr(target_sprite, 'rect'):
            self.static_update() 
            return

        # Calculate desired camera top-left (x, y) to center the target_sprite.
        # The camera_rect.x and .y are negative offsets applied to world coordinates.
        x = -target_sprite.rect.centerx + int(self.screen_width / 2)
        y = -target_sprite.rect.centery + int(self.screen_height / 2)

        # --- Horizontal Clamping ---
        # Don't scroll left past the beginning of the level (camera_rect.x should not be > 0).
        x = min(0, x)
        # Don't scroll right past the end of the level.
        if self.level_width > self.screen_width:
            # max_camera_x ensures the right edge of the level aligns with the right edge of the screen.
            x = max(-(self.level_width - self.screen_width), x)
        else: 
            # Level is narrower than or same width as the screen, so no horizontal scrolling needed.
            # Camera x offset can be 0 to align level left, or centered if desired.
            # For now, align left by default (x=0).
            x = 0 

        # --- Vertical Clamping (using absolute level Y boundaries) ---
        if self.effective_level_height <= self.screen_height:
            # Level is shorter than or same height as the screen.
            # Center the level vertically within the screen.
            # The camera's y offset will be such that the level's visual center aligns with screen center.
            # camera_y = -(level_visual_center_y - screen_center_y)
            # level_visual_center_y = self.level_top_y_abs + self.effective_level_height / 2
            # screen_center_y = self.screen_height / 2
            y = -(self.level_top_y_abs + self.effective_level_height / 2 - self.screen_height / 2)
        else:
            # Level is taller than the screen, allow vertical scrolling.
            # Don't scroll above the level's absolute top (camera_rect.y = -level_top_y_abs).
            y = min(-self.level_top_y_abs, y)
            # Don't scroll below the level's absolute bottom.
            # The camera's y should be such that (level_bottom_y_abs + camera_rect.y) == screen_height.
            # So, camera_rect.y = screen_height - level_bottom_y_abs.
            # But since our 'y' is an offset, it's max(-(level_bottom_y_abs - screen_height), y).
            y = max(-(self.level_bottom_y_abs - self.screen_height), y)
            
        self.camera_rect.x = int(x) # Ensure integer positions for rect
        self.camera_rect.y = int(y)
        # print(f"Camera Updated: Target ({target_sprite.rect.centerx},{target_sprite.rect.centery}), CamRect ({self.camera_rect.x},{self.camera_rect.y})")


    def static_update(self):
        """
        Called when there's no target to follow or if static camera behavior is desired.
        The camera remains in its current position.
        """
        # If no target, we might want to ensure camera is still clamped,
        # especially if level dimensions changed.
        # For now, it just keeps its current position.
        # If clamping is needed even without a target, call update(None) or replicate clamping logic.
        pass 

    def get_pos(self):
        """ Returns the camera's current topleft offset (usually negative or zero values). """
        return (self.camera_rect.x, self.camera_rect.y)

    def set_pos(self, x, y):
        """ Manually sets the camera's topleft offset. """
        self.camera_rect.x = int(x)
        self.camera_rect.y = int(y)
        # print(f"Camera Position Manually Set: ({self.camera_rect.x},{self.camera_rect.y})")

    def set_level_dimensions(self, level_width: int, level_top_y_abs: int, level_bottom_y_abs: int):
        """
        Updates the camera's knowledge of the level dimensions.
        Useful if the level changes or its boundaries are redefined.

        Args:
            level_width (int): New total width of the level.
            level_top_y_abs (int): New absolute Y of the level's top.
            level_bottom_y_abs (int): New absolute Y of the level's bottom.
        """
        self.level_width = level_width
        self.level_top_y_abs = level_top_y_abs
        self.level_bottom_y_abs = level_bottom_y_abs
        self.effective_level_height = self.level_bottom_y_abs - self.level_top_y_abs
        # print(f"Camera Level Dimensions Updated: LvlW:{self.level_width}, LvlTopY:{self.level_top_y_abs}, LvlBotY:{self.level_bottom_y_abs} (EffH:{self.effective_level_height})")
        
        # Optionally, re-clamp camera position immediately if needed:
        # For example, if a target was being tracked:
        # if self.camera_rect.x != 0 or self.camera_rect.y != 0: # Or some other check if it needs update
        #    current_target = ... (if you store it)
        #    self.update(current_target if current_target else None) 
        # Or, if no target, ensure it's valid for the new boundaries (e.g., set to default 0,0 and then clamp)
        # self.set_pos(self.camera_rect.x, self.camera_rect.y) # Re-apply existing pos to trigger clamping via update
        # (This would require self.update to correctly handle a None target for clamping)
        # For now, manual re-clamping would be done by calling update() after set_level_dimensions.

    def set_screen_dimensions(self, screen_width: int, screen_height: int):
        """
        Updates the camera's knowledge of the screen dimensions.
        Important if the game window is resized.
        """
        self.screen_width = screen_width
        self.screen_height = screen_height
        self.camera_rect.width = screen_width
        self.camera_rect.height = screen_height
        # print(f"Camera Screen Dimensions Updated: {self.screen_width}x{self.screen_height}")
        # After screen resize, the camera position might need re-clamping.
        # This is typically handled by calling self.update(target_sprite) in the main loop's resize event.

########## START OF FILE: client_logic.py ##########

########## START OF FILE: client_logic.py ##########

# client_logic.py
# -*- coding: utf-8 -*-
"""
version 1.0000000.1
Handles client-side game logic, connection to server, and LAN discovery.
"""
import pygame
import socket
import time
import traceback
import constants as C
from network_comms import get_local_ip, encode_data, decode_data_stream
from game_state_manager import set_network_game_state
from enemy import Enemy # For print_limiter access if needed, or for type hinting
from game_ui import draw_platformer_scene_on_surface # For drawing client's view

class ClientState:
    """
    A simple class to hold client-specific state used by the client's
    main loop and helper functions.
    """
    def __init__(self):
        self.client_tcp_socket = None        # TCP socket for communication with the server
        self.server_state_buffer = b""       # Buffer for accumulating data from the server
        self.last_received_server_state = None # Stores the most recent complete game state from server
        self.app_running = True              # Global flag: True if the application is running (controlled by main.py)
        
        # Configuration for LAN discovery (can be loaded from constants.py)
        self.service_name = getattr(C, "SERVICE_NAME", "platformer_adventure_lan_v1")
        self.discovery_port_udp = getattr(C, "DISCOVERY_PORT_UDP", 5556)
        self.client_search_timeout_s = getattr(C, "CLIENT_SEARCH_TIMEOUT_S", 5.0)
        self.buffer_size = getattr(C, "BUFFER_SIZE", 8192)


def find_server_on_lan(screen: pygame.Surface, fonts: dict, 
                       clock_obj: pygame.time.Clock, client_state_obj: ClientState):
    """
    Searches for a game server on the LAN by listening for UDP broadcasts.
    Displays a "Searching..." message on the screen.
    Returns (found_server_ip, found_server_port) or (None, None) if not found or cancelled.
    """
    print("DEBUG Client (find_server_on_lan): Starting LAN server search.") # DEBUG
    pygame.display.set_caption("Platformer - Searching for Server on LAN...")
    current_width, current_height = screen.get_size()
    search_text_surf = fonts.get("large", pygame.font.Font(None, 30)).render( # Fallback font
        "Searching for server on LAN...", True, C.WHITE
    )
    
    listen_socket, found_server_ip, found_server_port = None, None, None

    try:
        # Create and configure the UDP socket for listening to broadcasts
        listen_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
        listen_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        # Bind to all available interfaces on the specified discovery port
        listen_socket.bind(('', client_state_obj.discovery_port_udp)) 
        listen_socket.settimeout(0.5) # Non-blocking recvfrom
        print(f"DEBUG Client (find_server_on_lan): UDP listen socket bound to port {client_state_obj.discovery_port_udp}.") # DEBUG
    except socket.error as e:
        print(f"Client Error: Failed to bind UDP listen socket on port {client_state_obj.discovery_port_udp}: {e}")
        screen.fill(C.BLACK)
        err_msg = f"Error: Cannot listen on UDP port {client_state_obj.discovery_port_udp}."
        if fonts.get("small"):
            err_surf = fonts["small"].render(err_msg, True, C.RED)
            screen.blit(err_surf, err_surf.get_rect(center=(current_width//2, current_height // 2)))
        pygame.display.flip(); time.sleep(4)
        return None, None

    start_search_time = time.time()
    client_local_ip = get_local_ip() 
    print(f"DEBUG Client (find_server_on_lan): Searching for LAN servers (Service: '{client_state_obj.service_name}'). My IP: {client_local_ip}. Timeout: {client_state_obj.client_search_timeout_s}s.") # DEBUG

    # Loop for the duration of the search timeout or until app quits/server found
    while time.time() - start_search_time < client_state_obj.client_search_timeout_s and \
          client_state_obj.app_running and not found_server_ip:
        
        # Handle Pygame events (Quit, Resize, Escape to cancel search)
        for event in pygame.event.get():
             if event.type == pygame.QUIT: client_state_obj.app_running = False; break
             if event.type == pygame.VIDEORESIZE:
                if not screen.get_flags() & pygame.FULLSCREEN:
                    current_width,current_height=max(320,event.w),max(240,event.h)
                    screen=pygame.display.set_mode((current_width,current_height), pygame.RESIZABLE|pygame.DOUBLEBUF)
                    search_text_surf = fonts.get("large", pygame.font.Font(None,30)).render(
                        "Searching for server on LAN...", True, C.WHITE) # Re-render if size changes
             if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
                 print("DEBUG Client (find_server_on_lan): LAN server search cancelled by user.");  # DEBUG
                 if listen_socket: listen_socket.close()
                 return None, None # Exit search and return to menu
        if not client_state_obj.app_running: break

        # Update "Searching..." display
        screen.fill(C.BLACK)
        screen.blit(search_text_surf, search_text_surf.get_rect(center=(current_width//2, current_height//2)))
        pygame.display.flip()
        clock_obj.tick(10) # Low FPS during search

        raw_udp_data, decoded_udp_message = None, None
        try:
            raw_udp_data, sender_address = listen_socket.recvfrom(client_state_obj.buffer_size)
            # print(f"DEBUG Client (find_server_on_lan): Received UDP data from {sender_address}: {raw_udp_data[:60]}...") # DEBUG - noisy
            decoded_messages_list, _ = decode_data_stream(raw_udp_data)
            if not decoded_messages_list: continue 
            
            decoded_udp_message = decoded_messages_list[0] 
            # print(f"DEBUG Client (find_server_on_lan): Decoded UDP message: {decoded_udp_message}") # DEBUG
            if (isinstance(decoded_udp_message, dict) and
                decoded_udp_message.get("service") == client_state_obj.service_name and
                isinstance(decoded_udp_message.get("tcp_ip"), str) and
                isinstance(decoded_udp_message.get("tcp_port"), int)):
                
                server_ip = decoded_udp_message["tcp_ip"]
                server_port = decoded_udp_message["tcp_port"]
                print(f"DEBUG Client (find_server_on_lan): Found server '{client_state_obj.service_name}' at {server_ip}:{server_port}") # DEBUG
                found_server_ip, found_server_port = server_ip, server_port
        except socket.timeout:
            continue 
        except Exception as e:
            print(f"Client: Error processing received UDP broadcast: {e}")
            traceback.print_exc()

    if listen_socket: listen_socket.close() 

    if not found_server_ip and client_state_obj.app_running: 
        print(f"DEBUG Client (find_server_on_lan): No server found for '{client_state_obj.service_name}' after timeout.") # DEBUG
        screen.fill(C.BLACK)
        if fonts.get("large"):
            fail_surf = fonts["large"].render("Server Not Found!", True, C.RED)
            screen.blit(fail_surf, fail_surf.get_rect(center=(current_width//2, current_height//2)))
        pygame.display.flip(); time.sleep(3) 
    elif not client_state_obj.app_running:
        print("DEBUG Client (find_server_on_lan): LAN server search aborted because application is quitting.") # DEBUG
        
    return found_server_ip, found_server_port


def run_client_mode(screen: pygame.Surface, clock: pygame.time.Clock, 
                    fonts: dict, game_elements_ref: dict, 
                    client_state_obj: ClientState, target_ip_port_str: str = None):
    """
    Main function to run the game in client mode.
    Connects to a server (either specified or found via LAN) and synchronizes game state.
    """
    print("DEBUG Client (run_client_mode): Entering client mode.") # DEBUG
    client_state_obj.app_running = True 
    current_width, current_height = screen.get_size()
    
    server_ip_to_connect, server_port_to_connect = None, C.SERVER_PORT_TCP 

    if target_ip_port_str: 
        print(f"DEBUG Client (run_client_mode): Direct IP specified: {target_ip_port_str}") # DEBUG
        ip_parts = target_ip_port_str.rsplit(':', 1)
        server_ip_to_connect = ip_parts[0]
        if len(ip_parts) > 1: 
            try: server_port_to_connect = int(ip_parts[1])
            except ValueError: 
                print(f"Client Warning: Invalid port in '{target_ip_port_str}'. Using default {C.SERVER_PORT_TCP}.")
    else: 
        print("DEBUG Client (run_client_mode): No direct IP, attempting LAN discovery.") # DEBUG
        server_ip_to_connect, found_server_port = find_server_on_lan(screen, fonts, clock, client_state_obj)
        if found_server_port: server_port_to_connect = found_server_port

    if not server_ip_to_connect: 
        print("DEBUG Client (run_client_mode): Exiting client mode (no server target).") # DEBUG
        return 
    if not client_state_obj.app_running: 
        print("DEBUG Client (run_client_mode): Exiting client mode (application closed).") # DEBUG
        return

    if client_state_obj.client_tcp_socket: 
        try: client_state_obj.client_tcp_socket.close()
        except: pass
    client_state_obj.client_tcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    
    connection_succeeded, connection_error_msg = False, "Unknown Connection Error"
    try:
        print(f"DEBUG Client (run_client_mode): Attempting to connect to server at {server_ip_to_connect}:{server_port_to_connect}...") # DEBUG
        pygame.display.set_caption(f"Platformer - Connecting to {server_ip_to_connect}...")
        screen.fill(C.BLACK) 
        if fonts.get("large"):
            conn_text_surf = fonts["large"].render(f"Connecting...", True, C.WHITE)
            screen.blit(conn_text_surf, conn_text_surf.get_rect(center=(current_width//2, current_height//2)))
        pygame.display.flip()

        client_state_obj.client_tcp_socket.settimeout(10.0) 
        client_state_obj.client_tcp_socket.connect((server_ip_to_connect, server_port_to_connect))
        client_state_obj.client_tcp_socket.settimeout(0.05) 
        print("DEBUG Client (run_client_mode): TCP Connection to server successful!") # DEBUG
        connection_succeeded = True
    except socket.timeout: connection_error_msg = "Connection Timed Out"
    except socket.error as e: connection_error_msg = f"Connection Error ({e.strerror if hasattr(e, 'strerror') else e})"
    except Exception as e: connection_error_msg = f"Unexpected Connection Error: {e}"

    if not connection_succeeded:
        print(f"DEBUG Client (run_client_mode): Failed to connect to server: {connection_error_msg}") # DEBUG
        screen.fill(C.BLACK) 
        if fonts.get("large"):
            fail_text_surf = fonts["large"].render(f"Connection Failed", True, C.RED)
            screen.blit(fail_text_surf, fail_text_surf.get_rect(center=(current_width//2, current_height//2 - 30)))
        if fonts.get("small"):
            reason_surf = fonts["small"].render(connection_error_msg, True, C.WHITE)
            screen.blit(reason_surf, reason_surf.get_rect(center=(current_width//2, current_height//2 + 30)))
        pygame.display.flip(); time.sleep(3)
        if client_state_obj.client_tcp_socket: client_state_obj.client_tcp_socket.close()
        client_state_obj.client_tcp_socket = None
        return 

    pygame.display.set_caption("Platformer - CLIENT (You are P2: WASD+VB | Self-Harm: H | Heal: G | Reset: Enter)")
    
    p2_controlled_by_client = game_elements_ref.get("player2") 
    p1_remote_on_client = game_elements_ref.get("player1")     
    print(f"DEBUG Client (run_client_mode): P1 (remote) instance: {p1_remote_on_client}, P2 (local) instance: {p2_controlled_by_client}") # DEBUG
    if p1_remote_on_client: print(f"DEBUG Client: P1 Valid: {p1_remote_on_client._valid_init}, P1 Pos: {p1_remote_on_client.pos if hasattr(p1_remote_on_client, 'pos') else 'N/A'}") # DEBUG
    if p2_controlled_by_client: print(f"DEBUG Client: P2 Valid: {p2_controlled_by_client._valid_init}, P2 Pos: {p2_controlled_by_client.pos if hasattr(p2_controlled_by_client, 'pos') else 'N/A'}") # DEBUG

    
    p2_client_key_map = { 
        'left': pygame.K_a, 'right': pygame.K_d, 'up': pygame.K_w, 'down': pygame.K_s,
        'attack1': pygame.K_v, 'attack2': pygame.K_b, 'dash': pygame.K_LSHIFT,
        'roll': pygame.K_LCTRL, 'interact': pygame.K_e,
    }

    client_game_active = True
    client_state_obj.server_state_buffer = b"" 
    client_state_obj.last_received_server_state = None 

    while client_game_active and client_state_obj.app_running:
        dt_sec = clock.tick(C.FPS) / 1000.0 
        now_ticks_client = pygame.time.get_ticks()

        client_initiated_actions = {'action_reset': False, 'action_self_harm': False, 'action_heal': False}
        server_indicated_game_over = False
        if client_state_obj.last_received_server_state and \
           'game_over' in client_state_obj.last_received_server_state:
            server_indicated_game_over = client_state_obj.last_received_server_state['game_over']

        pygame_events_client = pygame.event.get()
        keys_pressed_client = pygame.key.get_pressed()
        for event in pygame_events_client:
            if event.type == pygame.QUIT: client_game_active = False; client_state_obj.app_running = False; break
            if event.type == pygame.VIDEORESIZE:
                if not screen.get_flags() & pygame.FULLSCREEN:
                    current_width,current_height=max(320,event.w),max(240,event.h)
                    screen=pygame.display.set_mode((current_width,current_height), pygame.RESIZABLE|pygame.DOUBLEBUF)
                    if game_elements_ref.get("camera"): 
                        game_elements_ref["camera"].screen_width = current_width
                        game_elements_ref["camera"].screen_height = current_height
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE: client_game_active = False 
                if event.key == pygame.K_RETURN and server_indicated_game_over :
                    client_initiated_actions['action_reset'] = True
                if event.key == pygame.K_h: client_initiated_actions['action_self_harm'] = True
                if event.key == pygame.K_g: client_initiated_actions['action_heal'] = True
        
        if not client_state_obj.app_running or not client_game_active: break

        p2_input_state_for_server = {}
        if p2_controlled_by_client and hasattr(p2_controlled_by_client, 'get_input_state_for_network'):
             p2_input_state_for_server = p2_controlled_by_client.get_input_state_for_network(
                 keys_pressed_client, pygame_events_client, p2_client_key_map
             )
        p2_input_state_for_server.update(client_initiated_actions) 

        if client_state_obj.client_tcp_socket:
            client_input_payload = {"input": p2_input_state_for_server}
            encoded_client_payload = encode_data(client_input_payload)
            if encoded_client_payload:
                try:
                    # print(f"DEBUG Client: Sending input to server: {client_input_payload}") # DEBUG - noisy
                    client_state_obj.client_tcp_socket.sendall(encoded_client_payload)
                except socket.error as e:
                    print(f"Client: Send to server failed: {e}. Server might have disconnected.")
                    client_game_active = False; break 
        
        if client_state_obj.client_tcp_socket:
            try:
                server_data_chunk = client_state_obj.client_tcp_socket.recv(client_state_obj.buffer_size * 2) 
                if not server_data_chunk: 
                    print("DEBUG Client: Server disconnected (received empty data from recv).") # DEBUG
                    client_game_active = False; break
                
                # print(f"DEBUG Client: Received chunk from server: {server_data_chunk[:100]}...") # DEBUG - noisy
                client_state_obj.server_state_buffer += server_data_chunk
                decoded_server_states, client_state_obj.server_state_buffer = \
                    decode_data_stream(client_state_obj.server_state_buffer)
                
                if decoded_server_states: 
                    client_state_obj.last_received_server_state = decoded_server_states[-1] 
                    # print(f"DEBUG Client: Received new game state. P1 pos: {client_state_obj.last_received_server_state.get('p1', {}).get('pos')}, P2 pos: {client_state_obj.last_received_server_state.get('p2', {}).get('pos')}") # DEBUG
                    set_network_game_state(client_state_obj.last_received_server_state, game_elements_ref, client_player_id=2)
                    # After state update, verify player instances
                    # p1_after_update = game_elements_ref.get("player1")
                    # p2_after_update = game_elements_ref.get("player2")
                    # if p1_after_update: print(f"DEBUG Client: P1 after state update. Pos: {p1_after_update.pos if hasattr(p1_after_update, 'pos') else 'N/A'}, Valid: {p1_after_update._valid_init}, Alive: {p1_after_update.alive() if hasattr(p1_after_update, 'alive') else 'N/A'}") # DEBUG
                    # if p2_after_update: print(f"DEBUG Client: P2 after state update. Pos: {p2_after_update.pos if hasattr(p2_after_update, 'pos') else 'N/A'}, Valid: {p2_after_update._valid_init}, Alive: {p2_after_update.alive() if hasattr(p2_after_update, 'alive') else 'N/A'}") # DEBUG

            
            except socket.timeout: pass 
            except socket.error as e:
                print(f"Client: Recv error from server: {e}. Server might have disconnected.")
                client_game_active = False; break
            except Exception as e:
                print(f"Client: Error processing data from server: {e}"); traceback.print_exc()
                client_game_active = False; break

        if p1_remote_on_client and p1_remote_on_client.alive() and p1_remote_on_client._valid_init and \
           hasattr(p1_remote_on_client, 'animate'):
            p1_remote_on_client.animate() 

        if p2_controlled_by_client and p2_controlled_by_client.alive() and \
           p2_controlled_by_client._valid_init and hasattr(p2_controlled_by_client, 'animate'):
            p2_controlled_by_client.animate() 

        for enemy_client in game_elements_ref.get("enemy_list", []):
            if enemy_client.alive() and enemy_client._valid_init and hasattr(enemy_client, 'animate'):
                enemy_client.animate()
            if enemy_client.is_dead and hasattr(enemy_client, 'death_animation_finished') and \
               enemy_client.death_animation_finished and enemy_client.alive():
                if hasattr(Enemy, 'print_limiter') and Enemy.print_limiter.can_print(f"client_killing_enemy_{enemy_client.enemy_id}"):
                     print(f"Client: Visually removing enemy {enemy_client.enemy_id} as death anim finished.")
                enemy_client.kill() 

        for proj_client in game_elements_ref.get("projectile_sprites", pygame.sprite.Group()):
            if proj_client.alive() and hasattr(proj_client, 'animate'):
                proj_client.animate() 

        game_elements_ref.get("collectible_sprites", pygame.sprite.Group()).update(dt_sec)

        client_camera = game_elements_ref.get("camera")
        if client_camera:
            camera_focus_target_client = None
            if p2_controlled_by_client and p2_controlled_by_client.alive() and \
               p2_controlled_by_client._valid_init and not p2_controlled_by_client.is_dead :
                camera_focus_target_client = p2_controlled_by_client
            elif p1_remote_on_client and p1_remote_on_client.alive() and \
                 p1_remote_on_client._valid_init and not p1_remote_on_client.is_dead:
                camera_focus_target_client = p1_remote_on_client 
            
            if camera_focus_target_client: client_camera.update(camera_focus_target_client)
            else: client_camera.static_update() 
            
        try:
            draw_platformer_scene_on_surface(screen, game_elements_ref, fonts, now_ticks_client)
        except Exception as e:
            print(f"Client draw error: {e}"); traceback.print_exc()
            client_game_active=False; break
        pygame.display.flip()

    print("DEBUG Client: Exiting active game loop.") # DEBUG
    if client_state_obj.client_tcp_socket:
        print("DEBUG Client: Closing TCP socket to server.") # DEBUG
        try: client_state_obj.client_tcp_socket.shutdown(socket.SHUT_RDWR)
        except: pass
        try: client_state_obj.client_tcp_socket.close()
        except: pass
        client_state_obj.client_tcp_socket = None
    print("DEBUG Client: Client mode finished and returned to caller.") # DEBUG

########## END OF FILE: client_logic.py ##########

########## START OF FILE: constants.py ##########

# constants.py
# -*- coding: utf-8 -*-
"""
Stores constant values used throughout the game.
"""
# version 1.0.0.2 (Added Network Constants)

# --- Gameplay / Physics ---
FPS = 60
PLAYER_ACCEL = 0.5
PLAYER_FRICTION = -0.15  # Negative value!
PLAYER_GRAVITY = 0.7
PLAYER_JUMP_STRENGTH = -15
PLAYER_RUN_SPEED_LIMIT = 7
PLAYER_DASH_SPEED = 15
PLAYER_ROLL_SPEED = 9
PLAYER_WALL_SLIDE_SPEED = 2
PLAYER_WALL_CLIMB_SPEED = -4
PLAYER_LADDER_CLIMB_SPEED = 3
PLAYER_MAX_HEALTH = 100
CHARACTER_BOUNCE_VELOCITY = 2.5 # Pixels per frame push back on collision

# --- Animation ---
ANIM_FRAME_DURATION = 80 # ms per frame for most animations

# Player Attack Specifics
PLAYER_ATTACK1_DAMAGE = 10
PLAYER_ATTACK2_DAMAGE = 5
PLAYER_COMBO_ATTACK_DAMAGE = 20
PLAYER_CROUCH_ATTACK_DAMAGE = 5
PLAYER_ATTACK2_FRAME_DURATION_MULTIPLIER = 1.5

CHARACTER_ATTACK_STATE_DURATION = 480 # ms

# --- Projectile Constants ---
FIREBALL_DAMAGE = 50
FIREBALL_SPEED = 9
FIREBALL_COOLDOWN = 750
FIREBALL_LIFESPAN = 2500
FIREBALL_SPRITE_PATH = "characters/weapons/fire.gif"
FIREBALL_DIMENSIONS = (61, 58)

# --- Enemy Constants ---
ENEMY_MAX_HEALTH = 80
ENEMY_RUN_SPEED_LIMIT = 5
ENEMY_ACCEL = 0.4
ENEMY_FRICTION = -0.12
ENEMY_DETECTION_RANGE = 100
ENEMY_ATTACK_RANGE = 60
ENEMY_ATTACK_DAMAGE = 10
ENEMY_ATTACK_COOLDOWN = 1500
ENEMY_PATROL_DIST = 150
ENEMY_HIT_STUN_DURATION = 300
ENEMY_HIT_COOLDOWN = 500
ENEMY_HIT_BOUNCE_Y = PLAYER_JUMP_STRENGTH * 0.3

# --- Colors ---
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
RED = (255, 0, 0)
DARK_RED = (139, 0, 0)
GREEN = (0, 255, 0)
YELLOW = (255, 255, 0) 
DARK_GREEN = (0, 100, 0)
BLUE = (0, 0, 255)
GRAY = (128, 128, 128)
DARK_GRAY = (50, 50, 50)
LIGHT_BLUE = (173, 216, 230)
ORANGE_RED = (255, 69, 0)

# --- UI ---
HEALTH_BAR_WIDTH = 50
HEALTH_BAR_HEIGHT = 8
HEALTH_BAR_OFFSET_ABOVE = 5

# --- Map ---
TILE_SIZE = 40
LAVA_PATCH_HEIGHT = 20
LAVA_DAMAGE = 50

# --- Network Constants ---
SERVER_IP_BIND = '0.0.0.0'  # Listen on all available interfaces
SERVER_PORT_TCP = 5555      # Default TCP port for the game server
SERVICE_NAME = "platformer_adventure_lan_v1" # Name for LAN discovery
DISCOVERY_PORT_UDP = 5556   # UDP port for LAN discovery broadcasts
BUFFER_SIZE = 8192          # Network buffer size for send/recv
BROADCAST_INTERVAL_S = 1.0  # How often server broadcasts its presence (seconds)
CLIENT_SEARCH_TIMEOUT_S = 5.0 # How long client searches for LAN server (seconds)

# --- Other ---
PLAYER_SELF_DAMAGE = 10
TERMINAL_VELOCITY_Y = 18

########## START OF FILE: couch_play_logic.py ##########

# couch_play_logic.py
# -*- coding: utf-8 -*-
"""
version 1.0000000.1
Handles the game logic for the local couch co-op (two players on one machine) mode.
"""
import pygame
import traceback # For detailed error logging if needed
import constants as C
from game_state_manager import reset_game_state # For resetting the game
from enemy import Enemy # For potential type hinting or accessing Enemy.print_limiter
from items import Chest # For type checking if Chest is valid
from game_ui import draw_platformer_scene_on_surface # For drawing the game scene

def run_couch_play_mode(screen: pygame.Surface, clock: pygame.time.Clock, 
                        fonts: dict, game_elements_ref: dict, app_status_obj):
    """
    Main loop for the couch co-op game mode.
    Manages input for two local players and updates the game state.

    Args:
        screen: The main Pygame display surface.
        clock: The Pygame clock for managing FPS.
        fonts: A dictionary of loaded Pygame font objects.
        game_elements_ref: A dictionary containing references to game objects
                           (players, sprite groups, camera, etc.).
        app_status_obj: An object (like main's AppStatus) with an 'app_running' attribute
                        to signal if the whole application should quit.
    """
    pygame.display.set_caption("Platformer - Couch Co-op (P1:WASD+VB, P2:IJKL+OP | Harm:H,N | Heal:G,M | Reset:R)")
    current_width, current_height = screen.get_size()

    # Get player instances from the game_elements dictionary
    p1 = game_elements_ref.get("player1")
    p2 = game_elements_ref.get("player2")
    
    # Define key mappings for Player 1 and Player 2
    p1_key_map_config = {
        'left': pygame.K_a, 'right': pygame.K_d, 'up': pygame.K_w, 'down': pygame.K_s,
        'attack1': pygame.K_v, 'attack2': pygame.K_b, 'dash': pygame.K_LSHIFT,
        'roll': pygame.K_LCTRL, 'interact': pygame.K_e 
    }
    p2_key_map_config = {
        'left': pygame.K_j, 'right': pygame.K_l, 'up': pygame.K_i, 'down': pygame.K_k,
        'attack1': pygame.K_o, 'attack2': pygame.K_p, 
        'dash': pygame.K_SEMICOLON, # Example: often RSHIFT for P2, or a nearby key
        'roll': pygame.K_QUOTE,   # Example: often RCTRL for P2, or a nearby key
        'interact': pygame.K_BACKSLASH 
    }

    couch_game_active = True
    while couch_game_active and app_status_obj.app_running:
        dt_sec = clock.tick(C.FPS) / 1000.0 # Delta time for physics consistency
        now_ticks_couch = pygame.time.get_ticks() # For time-based logic if any
        
        pygame_events = pygame.event.get() # Get all events once per frame
        keys_pressed = pygame.key.get_pressed() # Get all held keys once per frame
        
        host_requested_reset_couch = False

        # Handle global events (Quit, Resize, Escape, Reset, Debug keys)
        for event in pygame_events:
            if event.type == pygame.QUIT:
                couch_game_active = False
                app_status_obj.app_running = False # Signal entire application to quit
                break
            if event.type == pygame.VIDEORESIZE:
                if not screen.get_flags() & pygame.FULLSCREEN: # Handle window resize
                    current_width, current_height = max(320,event.w), max(240,event.h)
                    screen = pygame.display.set_mode((current_width,current_height), pygame.RESIZABLE|pygame.DOUBLEBUF)
                    if game_elements_ref.get("camera"): # Update camera's screen dimensions
                        game_elements_ref["camera"].screen_width = current_width
                        game_elements_ref["camera"].screen_height = current_height
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    couch_game_active = False # Exit couch mode to main menu
                    break
                if event.key == pygame.K_r: # Reset game state
                    host_requested_reset_couch = True
                
                # Player 1 debug keys
                if p1 and p1._valid_init:
                    if event.key == pygame.K_h and hasattr(p1, 'self_inflict_damage'):
                        p1.self_inflict_damage(C.PLAYER_SELF_DAMAGE)
                    if event.key == pygame.K_g and hasattr(p1, 'heal_to_full'):
                        p1.heal_to_full()
                
                # Player 2 debug keys
                if p2 and p2._valid_init:
                    if event.key == pygame.K_n and hasattr(p2, 'self_inflict_damage'): # 'N' for P2 self-harm
                        p2.self_inflict_damage(C.PLAYER_SELF_DAMAGE)
                    if event.key == pygame.K_m and hasattr(p2, 'heal_to_full'): # 'M' for P2 heal
                        p2.heal_to_full()
        
        if not app_status_obj.app_running or not couch_game_active: break

        # Handle inputs for both local players
        if p1 and p1._valid_init and not p1.is_dead: # Only process input if P1 is valid and not dead
            if hasattr(p1, 'handle_mapped_input'):
                p1.handle_mapped_input(keys_pressed, pygame_events, p1_key_map_config)
        
        if p2 and p2._valid_init and not p2.is_dead: # Only process input if P2 is valid and not dead
            if hasattr(p2, 'handle_mapped_input'):
                p2.handle_mapped_input(keys_pressed, pygame_events, p2_key_map_config)

        # If reset was requested, trigger it
        if host_requested_reset_couch:
            print("Couch Play: Game state reset triggered.")
            # reset_game_state returns the new chest instance (or None)
            game_elements_ref["current_chest"] = reset_game_state(game_elements_ref)

        # --- Local Authoritative Game Logic Updates ---
        # Update Player 1
        if p1 and p1._valid_init:
            # List of other players for P1's collision/interaction checks
            other_players_for_p1_update = [char for char in [p2] if char and char._valid_init and char.alive() and char is not p1]
            p1.update(dt_sec, game_elements_ref["platform_sprites"], game_elements_ref["ladder_sprites"], 
                      game_elements_ref["hazard_sprites"], other_players_for_p1_update, game_elements_ref["enemy_list"])
        
        # Update Player 2
        if p2 and p2._valid_init:
            other_players_for_p2_update = [char for char in [p1] if char and char._valid_init and char.alive() and char is not p2]
            p2.update(dt_sec, game_elements_ref["platform_sprites"], game_elements_ref["ladder_sprites"], 
                      game_elements_ref["hazard_sprites"], other_players_for_p2_update, game_elements_ref["enemy_list"])

        # Update Enemies
        # Enemies target any active player
        active_players_for_enemy_ai_couch = [char for char in [p1, p2] if char and char._valid_init and not char.is_dead and char.alive()]
        for enemy_couch in list(game_elements_ref.get("enemy_list", [])): # Iterate copy for safe removal
            if enemy_couch._valid_init:
                enemy_couch.update(dt_sec, active_players_for_enemy_ai_couch, 
                                   game_elements_ref["platform_sprites"], game_elements_ref["hazard_sprites"])
                # If enemy's death animation finishes, remove it
                if enemy_couch.is_dead and hasattr(enemy_couch, 'death_animation_finished') and \
                   enemy_couch.death_animation_finished and enemy_couch.alive():
                    if hasattr(Enemy, 'print_limiter') and Enemy.print_limiter.can_print(f"couch_killing_enemy_{enemy_couch.enemy_id}"):
                         print(f"Couch Play: Auto-killing enemy {enemy_couch.enemy_id} as death anim finished.")
                    enemy_couch.kill() # Removes from all sprite groups it's in
            # else: if enemy_couch.alive(): enemy_couch.kill() # Should be handled by init checks

        # Update Projectiles (collision against players and enemies)
        hittable_characters_couch_group = pygame.sprite.Group()
        if p1 and p1.alive() and p1._valid_init: hittable_characters_couch_group.add(p1)
        if p2 and p2.alive() and p2._valid_init: hittable_characters_couch_group.add(p2)
        for enemy_inst_proj_couch in game_elements_ref.get("enemy_list", []):
            if enemy_inst_proj_couch and enemy_inst_proj_couch.alive() and enemy_inst_proj_couch._valid_init:
                hittable_characters_couch_group.add(enemy_inst_proj_couch)
        game_elements_ref.get("projectile_sprites", pygame.sprite.Group()).update(
            dt_sec, game_elements_ref["platform_sprites"], hittable_characters_couch_group
        )
        
        # Update Collectibles (e.g., Chest animations, and collection logic)
        game_elements_ref.get("collectible_sprites", pygame.sprite.Group()).update(dt_sec)
        couch_current_chest = game_elements_ref.get("current_chest")
        if Chest and couch_current_chest and couch_current_chest.alive(): # Check Chest class exists
            player_who_collected_chest_couch = None
            # Check P1 collision with chest
            if p1 and p1._valid_init and not p1.is_dead and p1.alive() and \
               pygame.sprite.collide_rect(p1, couch_current_chest):
                player_who_collected_chest_couch = p1
            # Check P2 collision with chest (only if P1 didn't collect it this frame)
            elif p2 and p2._valid_init and not p2.is_dead and p2.alive() and \
                 pygame.sprite.collide_rect(p2, couch_current_chest):
                player_who_collected_chest_couch = p2
            
            if player_who_collected_chest_couch:
                couch_current_chest.collect(player_who_collected_chest_couch) # collect() should call self.kill()
                game_elements_ref["current_chest"] = None # Mark as collected
        
        # Update Camera
        couch_camera = game_elements_ref.get("camera")
        if couch_camera:
            # Simple camera focus: prioritize P1, then P2 if P1 is dead/invalid, or static if both out.
            camera_focus_target_couch = None
            if p1 and p1.alive() and p1._valid_init and not p1.is_dead:
                camera_focus_target_couch = p1
            elif p2 and p2.alive() and p2._valid_init and not p2.is_dead:
                camera_focus_target_couch = p2
            
            if camera_focus_target_couch: couch_camera.update(camera_focus_target_couch)
            else: couch_camera.static_update() # No valid target, camera remains static

        # Draw the game scene
        try:
            draw_platformer_scene_on_surface(screen, game_elements_ref, fonts, now_ticks_couch)
        except Exception as e:
            print(f"Couch Play draw error: {e}"); traceback.print_exc()
            couch_game_active=False; break # Exit on critical draw error
        pygame.display.flip()

    # --- End of Couch Play Game Loop ---
    print("Exiting Couch Play mode.")
    # app_status_obj.app_running will be False if QUIT was pressed, otherwise True.
    # No network connections or threads to clean up in couch mode.

########## START OF FILE: enemy.py ##########

# enemy.py
# -*- coding: utf-8 -*-
## version 1.0.0.8 (Removed debug prints, final cleanup)
"""
Defines the Enemy class, a CPU-controlled character.
Handles AI-driven movement (via enemy_ai_handler), animations, states,
combat (via enemy_combat_handler), and network synchronization
(via enemy_network_handler).
Each instance randomly selects a color variant for its animations if configured.
"""
import pygame
import random
import math
import os

from utils import PrintLimiter 
import constants as C 
from assets import load_all_player_animations 
from tiles import Lava 

from enemy_ai_handler import set_enemy_new_patrol_target, enemy_ai_update
from enemy_combat_handler import check_enemy_attack_collisions, enemy_take_damage
from enemy_network_handler import get_enemy_network_data, set_enemy_network_data


class Enemy(pygame.sprite.Sprite):
    # Class-level print limiter for non-critical warnings or infrequent info.
    # For heavy debugging, print statements should be temporary or use a more verbose logger.
    print_limiter = PrintLimiter(default_limit=3, default_period=10.0) 

    def __init__(self, start_x, start_y, patrol_area=None, enemy_id=None):
        super().__init__()
        self.spawn_pos = pygame.math.Vector2(start_x, start_y) 
        self.patrol_area = patrol_area 
        self.enemy_id = enemy_id if enemy_id is not None else id(self) 
        self._valid_init = True 
        character_base_asset_folder = 'characters'
        available_enemy_colors = ['cyan', 'green', 'pink', 'purple', 'red', 'yellow'] 
        if not available_enemy_colors: 
             if Enemy.print_limiter.can_print(f"enemy_{self.enemy_id}_init_no_colors"): # Use unique key
                print(f"Enemy Warning (ID: {self.enemy_id}): No enemy colors defined! Defaulting to 'player1' assets.")
             available_enemy_colors = ['player1'] 
        self.color_name = random.choice(available_enemy_colors) 
        chosen_enemy_asset_folder = os.path.join(character_base_asset_folder, self.color_name)
        
        self.animations = load_all_player_animations(relative_asset_folder=chosen_enemy_asset_folder)
        if self.animations is None: 
            print(f"Enemy CRITICAL (ID: {self.enemy_id}, Color: {self.color_name}): Failed loading animations from '{chosen_enemy_asset_folder}'.")
            self.image = pygame.Surface((30, 40)).convert_alpha(); self.image.fill(C.BLUE) 
            self.rect = self.image.get_rect(midbottom=(start_x, start_y))
            self._valid_init = False; self.is_dead = True; return 
        
        self._last_facing_right = True 
        self._last_state_for_debug = "init" # Can be removed if not actively debugging state machine
        self.state = 'idle'      
        self.current_frame = 0   
        self.last_anim_update = pygame.time.get_ticks() 
        
        initial_idle_animation = self.animations.get('idle')
        if not initial_idle_animation: 
             if Enemy.print_limiter.can_print(f"enemy_{self.enemy_id}_init_idle_missing"): # Use unique key
                print(f"Enemy Warning (ID: {self.enemy_id}, Color: {self.color_name}): 'idle' animation missing. Attempting fallback.")
             first_anim_key = next(iter(self.animations), None)
             initial_idle_animation = self.animations.get(first_anim_key) if first_anim_key and self.animations.get(first_anim_key) else None
        
        if initial_idle_animation and len(initial_idle_animation) > 0:
            self.image = initial_idle_animation[0]
        else: 
            self.image = pygame.Surface((30, 40)).convert_alpha(); self.image.fill(C.BLUE) 
            print(f"Enemy CRITICAL (ID: {self.enemy_id}): No suitable initial animation found after fallbacks.")
            self._valid_init = False; self.is_dead = True; return
            
        self.rect = self.image.get_rect(midbottom=(start_x, start_y)) 
        self.pos = pygame.math.Vector2(start_x, start_y) 
        self.vel = pygame.math.Vector2(0, 0)             
        self.acc = pygame.math.Vector2(0, getattr(C, 'ENEMY_GRAVITY', getattr(C, 'PLAYER_GRAVITY', 0.8))) 
        self.facing_right = random.choice([True, False]) 
        self.on_ground = False     
        self.ai_state = 'patrolling' 
        self.patrol_target_x = start_x 
        set_enemy_new_patrol_target(self) 
        self.is_attacking = False; self.attack_timer = 0
        self.attack_duration = getattr(C, 'ENEMY_ATTACK_STATE_DURATION', getattr(C, 'CHARACTER_ATTACK_STATE_DURATION', 500)) 
        self.attack_type = 0 
        self.attack_cooldown_timer = 0 
        self.post_attack_pause_timer = 0 
        self.post_attack_pause_duration = getattr(C, 'ENEMY_POST_ATTACK_PAUSE_DURATION', 200) 
        self.is_taking_hit = False; self.hit_timer = 0 
        self.hit_duration = getattr(C, 'ENEMY_HIT_STUN_DURATION', 300) 
        self.hit_cooldown = getattr(C, 'ENEMY_HIT_COOLDOWN', 500)      
        self.is_dead = False
        self.death_animation_finished = False 
        self.state_timer = 0 
        self.max_health = getattr(C, 'ENEMY_MAX_HEALTH', 100)
        self.current_health = self.max_health
        self.attack_hitbox = pygame.Rect(0, 0, 50, 35) 
        try: self.standard_height = self.animations['idle'][0].get_height() if self.animations.get('idle') else 60
        except (KeyError, IndexError, TypeError): self.standard_height = 60 


    def set_state(self, new_state: str):
        if not self._valid_init: return 
        
        animation_key_to_validate = new_state 
        valid_direct_animation_states = ['idle', 'run', 'attack', 'attack_nm', 'hit', 'death', 'death_nm', 'fall']
        
        if new_state not in valid_direct_animation_states: 
            if new_state in ['chasing', 'patrolling']:
                animation_key_to_validate = 'run' 
            elif 'attack' in new_state: 
                animation_key_to_validate = new_state 
            else: 
                animation_key_to_validate = 'idle'

        if animation_key_to_validate not in self.animations or not self.animations[animation_key_to_validate]:
            if Enemy.print_limiter.can_print(f"enemy_{self.enemy_id}_set_state_anim_miss_{animation_key_to_validate}"): # Use unique key
                print(f"Enemy Warning (ID: {self.enemy_id}): Animation for key '{animation_key_to_validate}' (from logical: '{new_state}') missing. Trying 'idle'.")
            animation_key_to_validate = 'idle' 
            if 'idle' not in self.animations or not self.animations['idle']: 
                 if Enemy.print_limiter.can_print(f"enemy_{self.enemy_id}_set_state_crit_idle_miss"): # Use unique key
                    print(f"Enemy CRITICAL (ID: {self.enemy_id}): Cannot find valid 'idle' animation. Halting state change for '{new_state}'.")
                 return 

        can_change_state_now = (self.state != new_state or new_state == 'death') and \
                               not (self.is_dead and not self.death_animation_finished and new_state != 'death')

        if can_change_state_now:
            self._last_state_for_debug = new_state # Keep if still useful for your own debugging
            if 'attack' not in new_state: self.is_attacking = False; self.attack_type = 0
            if new_state != 'hit': self.is_taking_hit = False

            self.state = new_state 
            self.current_frame = 0 
            current_ticks_ms = pygame.time.get_ticks()
            self.last_anim_update = current_ticks_ms 
            self.state_timer = current_ticks_ms       

            if 'attack' in new_state: 
                self.is_attacking = True; self.attack_type = 1 
                self.attack_timer = current_ticks_ms; self.vel.x = 0 
            elif new_state == 'hit': 
                 self.is_taking_hit = True; self.hit_timer = self.state_timer 
                 self.vel.x *= -0.5 
                 self.vel.y = getattr(C, 'ENEMY_HIT_BOUNCE_Y', getattr(C, 'PLAYER_JUMP_STRENGTH', -10) * 0.3)
                 self.is_attacking = False 
            elif new_state == 'death': 
                 self.is_dead = True; self.vel.x = 0; self.vel.y = 0 
                 self.acc.xy = 0, 0; self.current_health = 0 
                 self.death_animation_finished = False 
            
            self.animate() 
        elif not self.is_dead: 
             self._last_state_for_debug = self.state 

    def animate(self):
        if not self._valid_init or not hasattr(self, 'animations') or not self.animations: return
        if not self.alive() and not (self.is_dead and not self.death_animation_finished): return

        current_time_ms = pygame.time.get_ticks()
        animation_frame_duration_ms = getattr(C, 'ANIM_FRAME_DURATION', 100) 

        determined_animation_key = 'idle' 

        if self.is_dead:
            determined_animation_key = 'death_nm' if abs(self.vel.x) < 0.1 and abs(self.vel.y) < 0.1 and \
                                     self.animations.get('death_nm') else 'death'
            if not self.animations.get(determined_animation_key):
                determined_animation_key = 'death' if self.animations.get('death') else 'idle' 
        elif self.post_attack_pause_timer > 0 and current_time_ms < self.post_attack_pause_timer: 
            determined_animation_key = 'idle' 
        elif self.state in ['patrolling', 'chasing'] or (self.state == 'run' and abs(self.vel.x) > 0.1): 
             determined_animation_key = 'run' if abs(self.vel.x) > 0.1 else 'idle'
        elif self.is_attacking: 
            determined_animation_key = 'attack_nm' if self.animations.get('attack_nm') else 'attack'
            if not self.animations.get(determined_animation_key): determined_animation_key = 'idle'
        elif self.is_taking_hit: 
            determined_animation_key = 'hit' if self.animations.get('hit') else 'idle'
        elif not self.on_ground: 
            determined_animation_key = 'fall' if self.animations.get('fall') else 'idle'
        elif self.state == 'idle': 
            determined_animation_key = 'idle'
        elif self.state == 'run': 
            determined_animation_key = 'run' if abs(self.vel.x) > 0.1 else 'idle' 
        
        if not self.animations.get(determined_animation_key):
            if Enemy.print_limiter.can_print(f"enemy_{self.enemy_id}_animate_key_fallback_{determined_animation_key}"): # Use unique key
                print(f"Enemy Animate Warning (ID: {self.enemy_id}): Key '{determined_animation_key}' invalid for state '{self.state}'. Defaulting to 'idle'.")
            determined_animation_key = 'idle'
        
        current_animation_frames_list = self.animations.get(determined_animation_key)

        if not current_animation_frames_list: 
            if hasattr(self, 'image') and self.image: self.image.fill(C.BLUE) 
            if Enemy.print_limiter.can_print(f"enemy_{self.enemy_id}_animate_no_frames_{determined_animation_key}"): # Use unique key
                print(f"Enemy CRITICAL Animate (ID: {self.enemy_id}): No frames for '{determined_animation_key}' (state: {self.state})")
            return

        if not (self.is_dead and self.death_animation_finished): 
            if current_time_ms - self.last_anim_update > animation_frame_duration_ms: 
                self.last_anim_update = current_time_ms 
                self.current_frame += 1 
                
                if self.current_frame >= len(current_animation_frames_list): 
                    if self.is_dead: 
                        self.current_frame = len(current_animation_frames_list) - 1 
                        self.death_animation_finished = True
                        final_death_image_surface = current_animation_frames_list[self.current_frame]
                        if not self.facing_right: final_death_image_surface = pygame.transform.flip(final_death_image_surface, True, False)
                        old_enemy_midbottom = self.rect.midbottom
                        self.image = final_death_image_surface
                        self.rect = self.image.get_rect(midbottom=old_enemy_midbottom)
                        return 
                    elif self.state == 'hit': 
                        self.set_state('idle' if self.on_ground else 'fall') 
                        return 
                    else: 
                        self.current_frame = 0
                
                if self.current_frame >= len(current_animation_frames_list) and not self.is_dead : self.current_frame = 0
        
        if self.is_dead and self.death_animation_finished and not self.alive(): 
            return 

        if not current_animation_frames_list or self.current_frame < 0 or \
           self.current_frame >= len(current_animation_frames_list):
            self.current_frame = 0 
            if not current_animation_frames_list: 
                if hasattr(self, 'image') and self.image: self.image.fill(C.BLUE); return

        image_for_this_frame = current_animation_frames_list[self.current_frame]
        current_facing_is_right_for_anim = self.facing_right
        if not current_facing_is_right_for_anim: 
            image_for_this_frame = pygame.transform.flip(image_for_this_frame, True, False)
        
        if self.image is not image_for_this_frame or self._last_facing_right != current_facing_is_right_for_anim:
            old_enemy_midbottom_pos = self.rect.midbottom 
            self.image = image_for_this_frame 
            self.rect = self.image.get_rect(midbottom=old_enemy_midbottom_pos) 
            self._last_facing_right = current_facing_is_right_for_anim 


    def _ai_update(self, players_list_for_targeting):
        enemy_ai_update(self, players_list_for_targeting)

    def _check_attack_collisions(self, player_target_list_for_combat):
        check_enemy_attack_collisions(self, player_target_list_for_combat)

    def take_damage(self, damage_amount_taken):
        enemy_take_damage(self, damage_amount_taken) 

    def get_network_data(self):
        return get_enemy_network_data(self)

    def set_network_data(self, received_network_data):
        set_enemy_network_data(self, received_network_data)


    def update(self, dt_sec, players_list_for_logic, platforms_group, hazards_group):
        if not self._valid_init: return 
        
        if self.is_dead and self.alive(): 
            if not self.death_animation_finished: 
                if not self.on_ground: 
                    self.vel.y += self.acc.y 
                    self.vel.y = min(self.vel.y, getattr(C, 'TERMINAL_VELOCITY_Y', 18))
                    self.pos.y += self.vel.y
                    self.rect.bottom = round(self.pos.y)
                    self.on_ground = False 
                    for platform_sprite in pygame.sprite.spritecollide(self, platforms_group, False):
                        if self.vel.y > 0 and self.rect.bottom > platform_sprite.rect.top and \
                           (self.pos.y - self.vel.y) <= platform_sprite.rect.top + 1:
                            self.rect.bottom = platform_sprite.rect.top
                            self.on_ground = True; self.vel.y = 0; self.acc.y = 0 
                            self.pos.y = self.rect.bottom; break
            self.animate() 
            return 

        if self.is_dead and self.death_animation_finished:
            if self.alive(): self.kill() 
            return

        current_time_ms = pygame.time.get_ticks()

        if self.post_attack_pause_timer > 0 and current_time_ms >= self.post_attack_pause_timer:
            self.post_attack_pause_timer = 0 

        if self.is_taking_hit and current_time_ms - self.hit_timer > self.hit_cooldown:
            self.is_taking_hit = False 

        self._ai_update(players_list_for_logic) 

        if not self.is_dead: 
            self.vel.y += self.acc.y 
            
            enemy_friction_val = getattr(C, 'ENEMY_FRICTION', -0.12)
            enemy_run_speed_max = getattr(C, 'ENEMY_RUN_SPEED_LIMIT', 5)
            terminal_fall_speed_y = getattr(C, 'TERMINAL_VELOCITY_Y', 18) 

            self.vel.x += self.acc.x 

            apply_friction_to_enemy = self.on_ground and self.acc.x == 0 
            if apply_friction_to_enemy:
                friction_force_on_enemy = self.vel.x * enemy_friction_val
                if abs(self.vel.x) > 0.1: self.vel.x += friction_force_on_enemy
                else: self.vel.x = 0 

            self.vel.x = max(-enemy_run_speed_max, min(enemy_run_speed_max, self.vel.x))
            self.vel.y = min(self.vel.y, terminal_fall_speed_y)
            
            self.on_ground = False 

            self.pos.x += self.vel.x
            self.rect.centerx = round(self.pos.x)
            self.check_platform_collisions('x', platforms_group) 
            
            collided_horizontally_with_player = self.check_character_collision('x', players_list_for_logic)

            self.pos.y += self.vel.y
            self.rect.bottom = round(self.pos.y)
            self.check_platform_collisions('y', platforms_group) 

            if not collided_horizontally_with_player: 
                self.check_character_collision('y', players_list_for_logic)

            self.pos.x = self.rect.centerx
            self.pos.y = self.rect.bottom

            self.check_hazard_collisions(hazards_group)
            
            if self.is_attacking: 
                self._check_attack_collisions(players_list_for_logic) 
        
        self.animate()


    def check_platform_collisions(self, direction: str, platforms_group: pygame.sprite.Group):
        for platform_sprite in pygame.sprite.spritecollide(self, platforms_group, False):
            if direction == 'x': 
                original_vel_x = self.vel.x 
                if self.vel.x > 0: self.rect.right = platform_sprite.rect.left 
                elif self.vel.x < 0: self.rect.left = platform_sprite.rect.right 
                self.vel.x = 0 
                if self.ai_state == 'patrolling': 
                    if abs(original_vel_x) > 0.1 and \
                       (abs(self.rect.right - platform_sprite.rect.left) < 2 or \
                        abs(self.rect.left - platform_sprite.rect.right) < 2) :
                        set_enemy_new_patrol_target(self) 
            elif direction == 'y': 
                if self.vel.y > 0: 
                    if self.rect.bottom > platform_sprite.rect.top and \
                       (self.pos.y - self.vel.y) <= platform_sprite.rect.top + 1: 
                         self.rect.bottom = platform_sprite.rect.top
                         self.on_ground = True; self.vel.y = 0
                elif self.vel.y < 0: 
                    if self.rect.top < platform_sprite.rect.bottom and \
                       ((self.pos.y - self.rect.height) - self.vel.y) >= platform_sprite.rect.bottom -1:
                         self.rect.top = platform_sprite.rect.bottom
                         self.vel.y = 0 
            if direction == 'x': self.pos.x = self.rect.centerx
            else: self.pos.y = self.rect.bottom


    def check_character_collision(self, direction: str, player_list: list): 
        if not self._valid_init or self.is_dead or not self.alive(): return False
        collision_with_player_occurred = False
        for player_char_sprite in player_list:
            if not (player_char_sprite and player_char_sprite._valid_init and \
                    not player_char_sprite.is_dead and player_char_sprite.alive()):
                continue
            if self.rect.colliderect(player_char_sprite.rect): 
                collision_with_player_occurred = True
                bounce_vel_on_collision = getattr(C, 'CHARACTER_BOUNCE_VELOCITY', 2.5)
                if direction == 'x': 
                    push_direction_for_enemy = -1 if self.rect.centerx < player_char_sprite.rect.centerx else 1
                    if push_direction_for_enemy == -1: self.rect.right = player_char_sprite.rect.left
                    else: self.rect.left = player_char_sprite.rect.right
                    self.vel.x = push_direction_for_enemy * bounce_vel_on_collision 
                    if hasattr(player_char_sprite, 'vel'): 
                        player_char_sprite.vel.x = -push_direction_for_enemy * bounce_vel_on_collision
                    if hasattr(player_char_sprite, 'pos') and hasattr(player_char_sprite, 'rect'): 
                        player_char_sprite.pos.x += (-push_direction_for_enemy * 1.5) 
                        player_char_sprite.rect.centerx = round(player_char_sprite.pos.x)
                    self.pos.x = self.rect.centerx 
                elif direction == 'y': 
                    if self.vel.y > 0 and self.rect.bottom > player_char_sprite.rect.top and \
                       self.rect.centery < player_char_sprite.rect.centery:
                        self.rect.bottom = player_char_sprite.rect.top; self.on_ground = True; self.vel.y = 0
                    elif self.vel.y < 0 and self.rect.top < player_char_sprite.rect.bottom and \
                         self.rect.centery > player_char_sprite.rect.centery:
                        self.rect.top = player_char_sprite.rect.bottom; self.vel.y = 0
                    self.pos.y = self.rect.bottom 
        return collision_with_player_occurred


    def check_hazard_collisions(self, hazards_group: pygame.sprite.Group):
        current_time_ms = pygame.time.get_ticks()
        if not self._valid_init or self.is_dead or not self.alive() or \
           (self.is_taking_hit and current_time_ms - self.hit_timer < self.hit_cooldown): 
            return
        damage_taken_from_hazard_this_frame = False
        hazard_check_point_enemy_feet = (self.rect.centerx, self.rect.bottom - 1) 
        for hazard_sprite in hazards_group:
            if isinstance(hazard_sprite, Lava) and \
               hazard_sprite.rect.collidepoint(hazard_check_point_enemy_feet) and \
               not damage_taken_from_hazard_this_frame:
                self.take_damage(getattr(C, 'LAVA_DAMAGE', 50)) 
                damage_taken_from_hazard_this_frame = True
                if not self.is_dead: 
                     self.vel.y = getattr(C, 'PLAYER_JUMP_STRENGTH', -15) * 0.3 
                     push_dir_from_lava_hazard = 1 if self.rect.centerx < hazard_sprite.rect.centerx else -1
                     self.vel.x = -push_dir_from_lava_hazard * 4 
                     self.on_ground = False 
                break 


    def reset(self):
        if not self._valid_init: return
        self.pos = self.spawn_pos.copy() 
        self.rect.midbottom = (round(self.pos.x), round(self.pos.y))
        self.vel.xy = 0,0 
        self.acc.xy = 0, getattr(C, 'ENEMY_GRAVITY', getattr(C, 'PLAYER_GRAVITY', 0.7)) 
        self.current_health = self.max_health
        self.is_dead = False
        self.death_animation_finished = False
        self.is_taking_hit = False
        self.is_attacking = False; self.attack_type = 0
        self.hit_timer = 0; self.attack_timer = 0; self.attack_cooldown_timer = 0
        self.post_attack_pause_timer = 0 
        self.facing_right = random.choice([True, False]) 
        self.on_ground = False 
        self.ai_state = 'patrolling'
        set_enemy_new_patrol_target(self) 
        if hasattr(self.image, 'get_alpha') and self.image.get_alpha() is not None and \
           self.image.get_alpha() < 255:
            self.image.set_alpha(255) 
        self.set_state('idle')

########## START OF FILE: enemy_ai_handler.py ##########

# enemy_ai_handler.py
# -*- coding: utf-8 -*-
"""
version 1.0.0.2 (Corrected set_state logic for patrol/chase transitions)
Handles AI logic for enemies, including patrolling, chasing, and attacking decisions.
Functions here will typically take an 'enemy' instance as their first argument.
"""
import pygame
import random
import math
import constants as C # For accessing enemy-specific constants and general game constants

def set_enemy_new_patrol_target(enemy):
    """
    Sets a new patrol target X-coordinate for the enemy instance.
    If a patrol_area (pygame.Rect) is defined for the enemy, it patrols within that area.
    Otherwise, it patrols a set distance from its current position.

    Args:
        enemy (Enemy): The enemy instance for which to set a new patrol target.
    """
    # if not hasattr(enemy, 'rect') or not hasattr(enemy, 'pos'): # Guard against incomplete enemy object
    #     if hasattr(enemy, 'print_limiter') and enemy.print_limiter.can_print(f"enemy_patrol_target_no_rect_{enemy.enemy_id}"):
    #         print(f"ENEMY AI WARN ({enemy.enemy_id}): set_enemy_new_patrol_target called on enemy without rect/pos.")
        # return

    if enemy.patrol_area and isinstance(enemy.patrol_area, pygame.Rect):
         min_x_patrol = enemy.patrol_area.left + enemy.rect.width / 2
         max_x_patrol = enemy.patrol_area.right - enemy.rect.width / 2
         
         if min_x_patrol < max_x_patrol: 
             enemy.patrol_target_x = random.uniform(min_x_patrol, max_x_patrol)
         else: 
             enemy.patrol_target_x = enemy.patrol_area.centerx
    else: 
        patrol_direction = 1 if random.random() > 0.5 else -1
        enemy.patrol_target_x = enemy.pos.x + patrol_direction * getattr(C, 'ENEMY_PATROL_DIST', 150)


def enemy_ai_update(enemy, players_list_for_ai):
    """
    Updates the enemy's AI state (e.g., patrolling, chasing, attacking) and behavior
    based on player proximity and other conditions. Modifies the enemy instance directly.

    Args:
        enemy (Enemy): The enemy instance to update.
        players_list_for_ai (list): A list of player Sprites that the AI can target.
    """
    current_time_ms = pygame.time.get_ticks() 
    
    if enemy.post_attack_pause_timer > 0 and current_time_ms < enemy.post_attack_pause_timer:
        enemy.acc.x = 0 
        if enemy.state != 'idle': 
            enemy.set_state('idle') 
        return 

    if not enemy._valid_init or enemy.is_dead or not enemy.alive() or \
       (enemy.is_taking_hit and current_time_ms - enemy.hit_timer < enemy.hit_cooldown):
        enemy.acc.x = 0 
        return

    closest_target_player = None
    min_squared_distance_to_player = float('inf') 

    for player_candidate in players_list_for_ai:
        is_candidate_targetable = (
            player_candidate and player_candidate._valid_init and
            hasattr(player_candidate, 'pos') and hasattr(player_candidate, 'rect') and
            player_candidate.alive() and not getattr(player_candidate, 'is_dead', True) 
        )
        if is_candidate_targetable:
            squared_dist = (player_candidate.pos.x - enemy.pos.x)**2 + \
                           (player_candidate.pos.y - enemy.pos.y)**2
            if squared_dist < min_squared_distance_to_player:
                min_squared_distance_to_player = squared_dist
                closest_target_player = player_candidate
    
    if not closest_target_player: 
        enemy.ai_state = 'patrolling' 
        # If the AI decides to patrol, and the enemy's logical state isn't already
        # 'patrolling' or 'run' (which is used for patrol animation), then set it.
        # This allows transitioning from 'idle' to 'patrolling'.
        if enemy.state not in ['patrolling', 'run']: 
            enemy.set_state('patrolling') 
        
        if abs(enemy.pos.x - enemy.patrol_target_x) < 10: 
            set_enemy_new_patrol_target(enemy) 
        
        should_face_right_for_patrol = (enemy.patrol_target_x > enemy.pos.x)
        patrol_acceleration = getattr(C, 'ENEMY_ACCEL', 0.4) * 0.7 
        enemy.acc.x = patrol_acceleration * (1 if should_face_right_for_patrol else -1)
        
        if not enemy.is_attacking and enemy.facing_right != should_face_right_for_patrol:
            enemy.facing_right = should_face_right_for_patrol
        return 

    distance_to_target_player = math.sqrt(min_squared_distance_to_player) 
    enemy_attack_cooldown_duration = getattr(C, 'ENEMY_ATTACK_COOLDOWN', 1500) 
    enemy_attack_range = getattr(C, 'ENEMY_ATTACK_RANGE', 60) 
    enemy_detection_range = getattr(C, 'ENEMY_DETECTION_RANGE', 200) 
    enemy_standard_acceleration = getattr(C, 'ENEMY_ACCEL', 0.4)
    is_attack_off_cooldown = current_time_ms - enemy.attack_cooldown_timer > enemy_attack_cooldown_duration
    vertical_distance_to_player = abs(closest_target_player.rect.centery - enemy.rect.centery)
    has_vertical_line_of_sight = vertical_distance_to_player < enemy.rect.height * 1.0 
    is_player_in_attack_range = distance_to_target_player < enemy_attack_range and has_vertical_line_of_sight
    is_player_in_detection_range = distance_to_target_player < enemy_detection_range and has_vertical_line_of_sight

    if enemy.is_attacking and current_time_ms - enemy.attack_timer >= enemy.attack_duration:
         enemy.is_attacking = False; enemy.attack_type = 0      
         enemy.attack_cooldown_timer = current_time_ms 
         enemy.post_attack_pause_timer = current_time_ms + enemy.post_attack_pause_duration 
         enemy.set_state('idle'); enemy.acc.x = 0         
         return 

    if enemy.is_attacking:
        enemy.acc.x = 0 
        return

    current_target_acceleration_x = 0 
    current_target_facing_right = enemy.facing_right 

    if is_player_in_attack_range and is_attack_off_cooldown:
        enemy.ai_state = 'attacking'
        current_target_facing_right = (closest_target_player.pos.x > enemy.pos.x) 
        enemy.facing_right = current_target_facing_right
        attack_animation_key_to_use = 'attack_nm' if 'attack_nm' in enemy.animations and \
                                       enemy.animations['attack_nm'] else 'attack'
        enemy.set_state(attack_animation_key_to_use) 
        return 
    
    elif is_player_in_detection_range:
        enemy.ai_state = 'chasing'
        current_target_facing_right = (closest_target_player.pos.x > enemy.pos.x) 
        current_target_acceleration_x = enemy_standard_acceleration * (1 if current_target_facing_right else -1)
        # If AI decides to chase, and logical state isn't 'chasing' or 'run', set it.
        if enemy.state not in ['chasing', 'run']: 
            enemy.set_state('chasing') 
    
    else: 
        enemy.ai_state = 'patrolling'
        # If AI decides to patrol (because player is out of detection range),
        # and logical state isn't 'patrolling' or 'run', set it.
        if enemy.state not in ['patrolling', 'run']: 
            enemy.set_state('patrolling')
        
        if abs(enemy.pos.x - enemy.patrol_target_x) < 10: 
            set_enemy_new_patrol_target(enemy) 
        
        current_target_facing_right = (enemy.patrol_target_x > enemy.pos.x)
        current_target_acceleration_x = enemy_standard_acceleration * 0.7 * \
                                        (1 if current_target_facing_right else -1)

    enemy.acc.x = current_target_acceleration_x
    if not enemy.is_attacking and enemy.facing_right != current_target_facing_right:
         enemy.facing_right = current_target_facing_right

########## START OF FILE: enemy_combat_handler.py ##########

# enemy_combat_handler.py
# -*- coding: utf-8 -*-
"""
version 1.0000000.1
Handles enemy combat mechanics: checking attack collisions and processing damage taken.
Functions here will typically take an 'enemy' instance as their first argument.
"""
import pygame
import constants as C # For accessing damage values, hit stun duration, etc.

def check_enemy_attack_collisions(enemy, player_target_list):
    """
    Checks if the enemy's current attack (if any) hits any player in the target list.
    Applies damage to the player if a hit is registered.

    Args:
        enemy (Enemy): The attacking enemy instance.
        player_target_list (list): A list of Player sprites to check for collision.
    """
    # Enemy must be valid, actively attacking, and alive to deal damage
    if not enemy._valid_init or not enemy.is_attacking or enemy.is_dead or not enemy.alive():
        return

    # Position the enemy's attack hitbox based on its facing direction and current position.
    # It's assumed that enemy.attack_hitbox is a pygame.Rect attribute of the enemy instance,
    # and its size is defined in the Enemy class or constants.
    if enemy.facing_right:
        enemy.attack_hitbox.midleft = enemy.rect.midright # Position hitbox to the right
    else:
        enemy.attack_hitbox.midright = enemy.rect.midleft # Position hitbox to the left
    
    # Vertically align the hitbox with the enemy's center (can be adjusted if attacks are high/low)
    enemy.attack_hitbox.centery = enemy.rect.centery 
    
    current_time_ms = pygame.time.get_ticks()

    for player_sprite in player_target_list:
        # Ensure the player target is valid, alive, and not dead
        if not (player_sprite and player_sprite._valid_init and \
                not player_sprite.is_dead and player_sprite.alive()):
            continue

        # --- Check if the player target is currently invincible (e.g., recently hit) ---
        player_is_currently_invincible = False
        if hasattr(player_sprite, 'is_taking_hit') and hasattr(player_sprite, 'hit_timer') and \
           hasattr(player_sprite, 'hit_cooldown'):
            if player_sprite.is_taking_hit and \
               (current_time_ms - player_sprite.hit_timer < player_sprite.hit_cooldown):
                player_is_currently_invincible = True
        
        if player_is_currently_invincible:
            continue # Skip this player if they are invincible

        # --- Perform collision check between enemy's attack hitbox and player's rect ---
        if enemy.attack_hitbox.colliderect(player_sprite.rect):
            # A hit is registered!
            if hasattr(player_sprite, 'take_damage') and callable(player_sprite.take_damage):
                # Apply damage to the player
                damage_to_inflict_on_player = getattr(C, 'ENEMY_ATTACK_DAMAGE', 10) # Default damage
                # Future: Could have different damage based on enemy.attack_type if enemies have multiple attacks
                
                player_sprite.take_damage(damage_to_inflict_on_player)
                
                # Optional: Prevent the same attack swing from hitting the same player multiple times.
                # This might involve adding the player_sprite to a list of 'already_hit_this_swing'
                # on the enemy instance, and clearing that list when a new attack starts.
                # For simplicity here, one hit per check_attack_collisions call against a target.
                # If called every frame an attack is active, it might hit multiple frames.
                # Often, the attack state itself (is_attacking) is cleared after one successful hit check
                # or after a certain number of active frames.
                # For now, let's assume one hit is sufficient for this attack instance.
                # If the game design wants an attack to hit only once per animation,
                # the enemy.is_attacking flag or a specific hit flag should be managed carefully.
                
                # Example: If an attack should only connect once per animation, you might do:
                # if enemy.is_attacking and not getattr(enemy, '_has_hit_this_attack_swing', False):
                #     player_sprite.take_damage(damage_to_inflict_on_player)
                #     enemy._has_hit_this_attack_swing = True # Set a flag
                # (This flag would need to be reset when a new attack starts in enemy.set_state)
                
                # For now, simple damage application on collision.
                # If multiple players can be hit by one swing, this loop continues.
                # If only one player can be hit, you might 'return' here.

def enemy_take_damage(enemy, damage_amount):
    """
    Handles the enemy instance taking a specified amount of damage.
    Updates health and potentially triggers 'hit' or 'death' states for the enemy.

    Args:
        enemy (Enemy): The enemy instance receiving damage.
        damage_amount (int): The amount of damage to inflict.
    """
    current_time_ms = pygame.time.get_ticks()
    
    # Enemy cannot take damage if invalid, already dead, not in game world, or in hit cooldown
    if not enemy._valid_init or enemy.is_dead or not enemy.alive() or \
       (enemy.is_taking_hit and current_time_ms - enemy.hit_timer < enemy.hit_cooldown):
        # if enemy.print_limiter.can_print(f"enemy_{enemy.enemy_id}_damage_ignored_handler", limit=3): # Use enemy's limiter
        #     print(f"DEBUG Enemy {enemy.enemy_id} (CombatHandler): Damage IGNORED due to state/cooldown.")
        return

    enemy.current_health -= damage_amount
    enemy.current_health = max(0, enemy.current_health) # Clamp health at 0 (cannot be negative)

    # if enemy.print_limiter.can_print(f"enemy_{enemy.enemy_id}_health_update_handler", limit=5):
    #     print(f"DEBUG Enemy {enemy.enemy_id} (CombatHandler): Took {damage_amount} damage. New HP: {enemy.current_health}/{enemy.max_health}")

    if enemy.current_health <= 0: # Health has reached zero or below
        if not enemy.is_dead: # If not already marked as dead, transition to death state
            enemy.set_state('death') # This will trigger death animation and logic in Enemy class
    else: # Enemy is damaged but still alive
        # Transition to 'hit' state to show visual feedback and potentially interrupt actions,
        # but only if not already in a 'hit' state during its active stun duration.
        # ENEMY_HIT_STUN_DURATION is the duration the enemy is stunned and in 'hit' anim.
        # ENEMY_HIT_COOLDOWN is total invincibility time, which might be longer.
        if not (enemy.state == 'hit' and current_time_ms - enemy.state_timer < getattr(C, 'ENEMY_HIT_STUN_DURATION', 300)):
             enemy.set_state('hit') # Trigger hit animation and stun period

########## START OF FILE: enemy_network_handler.py ##########

# enemy_network_handler.py
# -*- coding: utf-8 -*-
"""
version 1.0000000.1
Handles network-related data serialization and deserialization for the Enemy class.
Functions here will typically take an 'enemy' instance as their first argument.
"""
import pygame
import constants as C # For any network-specific constants if needed in future

def get_enemy_network_data(enemy):
    """
    Gathers essential enemy data into a dictionary for network transmission.
    This is typically called by the server to send enemy states to clients.

    Args:
        enemy (Enemy): The enemy instance whose data is being serialized.

    Returns:
        dict: A dictionary containing the enemy's network-relevant state.
    """
    # Ensure all serialized values are basic Python types for JSON compatibility
    data = {
        'enemy_id': enemy.enemy_id, # Crucial for identifying the enemy across network
        '_valid_init': enemy._valid_init, # Client needs to know if this enemy is valid
        
        'pos': (enemy.pos.x, enemy.pos.y), 
        'vel': (enemy.vel.x, enemy.vel.y), 
        'facing_right': enemy.facing_right, 
        
        'state': enemy.state, # Current logical state (e.g., 'idle', 'run', 'attack_nm')
        'current_frame': enemy.current_frame, 
        'last_anim_update': enemy.last_anim_update, # Timestamp for animation synchronization
        
        'current_health': enemy.current_health, 
        'is_dead': enemy.is_dead,
        'death_animation_finished': enemy.death_animation_finished,
        
        'is_attacking': enemy.is_attacking, 
        'attack_type': enemy.attack_type, # If enemies have different attack types
        # 'attack_timer': enemy.attack_timer, # Potentially useful for client-side prediction of attack end
        # 'attack_duration': enemy.attack_duration, # Also for prediction
        
        'is_taking_hit': enemy.is_taking_hit, # To sync hit stun visuals/invincibility
        # 'hit_timer': enemy.hit_timer, # For clients to potentially predict end of hit stun

        'post_attack_pause_timer': enemy.post_attack_pause_timer, # For syncing post-attack behavior

        # Optional: Send AI state if clients need to visualize or react to it,
        # though usually AI is server-authoritative and clients just see the results (movement, attacks).
        # 'ai_state': enemy.ai_state, 
        
        # Send color_name so clients can load the correct colored enemy assets
        'color_name': getattr(enemy, 'color_name', 'default_color') # Fallback if not present
    }
    return data

def set_enemy_network_data(enemy, network_data): 
    """
    Applies received network data to update the local enemy instance's state.
    This is primarily used on clients to reflect the server's authoritative state for each enemy.

    Args:
        enemy (Enemy): The enemy instance to be updated.
        network_data (dict): The dictionary of enemy state received over the network.
    """
    if network_data is None: return # No data to apply
    
    # --- Critical: Update _valid_init first ---
    # If the server says this enemy is no longer valid, remove it or mark it.
    # This is important if an enemy is dynamically removed by the server.
    enemy._valid_init = network_data.get('_valid_init', enemy._valid_init)
    if not enemy._valid_init:
        if enemy.alive(): # If the enemy sprite was in any groups
            enemy.kill()  # Remove from all groups
        return # No further updates if enemy is marked invalid by network

    # --- Update core physical attributes ---
    pos_data = network_data.get('pos')
    if pos_data: enemy.pos.x, enemy.pos.y = pos_data
    
    vel_data = network_data.get('vel')
    if vel_data: enemy.vel.x, enemy.vel.y = vel_data
    
    enemy.facing_right = network_data.get('facing_right', enemy.facing_right)
    
    # --- Update health and death status ---
    # Health is authoritative from server
    enemy.current_health = network_data.get('current_health', enemy.current_health)
    new_is_dead_from_net = network_data.get('is_dead', enemy.is_dead)
    enemy.death_animation_finished = network_data.get('death_animation_finished', enemy.death_animation_finished)

    # --- Handle transitions related to death status, ensuring animations are triggered ---
    if new_is_dead_from_net and not enemy.is_dead: # Enemy was alive, network says it's dead
        enemy.is_dead = True
        enemy.current_health = 0 # Ensure health is zero if dead
        enemy.set_state('death') # Trigger death state logic (animation, physics changes)
    elif not new_is_dead_from_net and enemy.is_dead: # Enemy was dead, network says it's alive (e.g., server reset an enemy)
        enemy.is_dead = False
        enemy.death_animation_finished = False # Reset this flag
        if enemy.state in ['death', 'death_nm']: # If stuck in a death animation state
            enemy.set_state('idle') # Transition to a neutral, alive state
    else: # No change in is_dead status, or local already matches network
        enemy.is_dead = new_is_dead_from_net # Ensure local is_dead matches network

    # --- Update combat and action states ---
    enemy.is_attacking = network_data.get('is_attacking', enemy.is_attacking)
    enemy.attack_type = network_data.get('attack_type', enemy.attack_type)
    # enemy.attack_timer = network_data.get('attack_timer', enemy.attack_timer) # If sent
    # enemy.attack_duration = network_data.get('attack_duration', enemy.attack_duration) # If sent
    
    # Update hit stun state: if network says enemy is taking a hit, reflect that
    new_is_taking_hit_from_net = network_data.get('is_taking_hit', enemy.is_taking_hit)
    if new_is_taking_hit_from_net and not enemy.is_taking_hit: # Start of hit stun based on network
        enemy.is_taking_hit = True
        enemy.hit_timer = pygame.time.get_ticks() # Reset local hit timer for visual/cooldown purposes
        if enemy.state != 'hit' and not enemy.is_dead: enemy.set_state('hit') # Trigger hit anim if not already
    elif not new_is_taking_hit_from_net and enemy.is_taking_hit: # End of hit stun by network
        enemy.is_taking_hit = False
        if enemy.state == 'hit' and not enemy.is_dead: enemy.set_state('idle') # Transition out of hit anim

    enemy.post_attack_pause_timer = network_data.get('post_attack_pause_timer', enemy.post_attack_pause_timer)
    
    # --- Update logical state and animation frame/timestamp for smooth visuals ---
    new_logical_state_from_net = network_data.get('state', enemy.state)
    # Apply new state if different, carefully avoiding re-triggering death anim if already in it
    if enemy.state != new_logical_state_from_net and \
       not (enemy.is_dead and new_logical_state_from_net in ['death', 'death_nm']):
         enemy.set_state(new_logical_state_from_net) # This will reset current_frame and last_anim_update
    else: # If state is the same, or it's a death state, just sync animation details
        enemy.current_frame = network_data.get('current_frame', enemy.current_frame)
        enemy.last_anim_update = network_data.get('last_anim_update', enemy.last_anim_update)
    
    # Sync color_name (important if enemies can change appearance or if client creates them based on net data)
    # This assumes the Enemy class can handle a color change if its assets are structured that way.
    # If color_name only matters at init, this might not be needed here unless an enemy could transform.
    # network_color_name = network_data.get('color_name')
    # if network_color_name and hasattr(enemy, 'color_name') and enemy.color_name != network_color_name:
    #     enemy.color_name = network_color_name
    #     # Potentially trigger a reload of animations if color change means different spritesheets
    #     # enemy.animations = load_all_player_animations(relative_asset_folder=f"characters/{enemy.color_name}")
    #     # This part is complex and depends heavily on how your assets are structured.
    
    # --- Finalize visual position and trigger animation update ---
    enemy.rect.midbottom = (round(enemy.pos.x), round(enemy.pos.y)) # Update visual position
    
    # Ensure animation is updated if enemy is valid and part of the game world
    if enemy._valid_init and enemy.alive(): # alive() checks if the sprite is in any groups
        enemy.animate()

########## START OF FILE: game_setup.py ##########

########## START OF FILE: game_setup.py ##########

# game_setup.py
# -*- coding: utf-8 -*-
"""
Handles initialization of game elements, levels, and entities.
version 1.0.0.5 (Chest spawning restricted to 'ledge' platform_type)
"""
import pygame
import random
import traceback
import constants as C
from player import Player
from enemy import Enemy
from items import Chest # Ensure Chest is importable
import levels as LevelLoader
from camera import Camera

def initialize_game_elements(current_width, current_height, for_game_mode="unknown", existing_sprites_groups=None):
    """
    Initializes all platformer game elements for a given mode.
    Returns a dictionary containing all initialized game objects and parameters.
    """
    print(f"DEBUG GameSetup: Initializing elements. Mode: '{for_game_mode}', Screen: {current_width}x{current_height}") # DEBUG

    platform_sprites = pygame.sprite.Group()
    ladder_sprites = pygame.sprite.Group()
    hazard_sprites = pygame.sprite.Group()
    enemy_sprites = pygame.sprite.Group()
    collectible_sprites = pygame.sprite.Group()
    projectile_sprites = existing_sprites_groups.get('projectile_sprites') if existing_sprites_groups else pygame.sprite.Group()
    all_sprites = existing_sprites_groups.get('all_sprites') if existing_sprites_groups else pygame.sprite.Group()

    # Clear sprite groups passed in or newly created
    print(f"DEBUG GameSetup: Clearing existing sprite groups...") # DEBUG
    player1_to_kill = existing_sprites_groups.get('player1')
    if player1_to_kill and hasattr(player1_to_kill, 'kill'):
        player1_to_kill.kill()
    
    player2_to_kill = existing_sprites_groups.get('player2')
    if player2_to_kill and hasattr(player2_to_kill, 'kill'):
        player2_to_kill.kill()

    current_chest_to_kill = existing_sprites_groups.get('current_chest')
    if current_chest_to_kill and hasattr(current_chest_to_kill, 'kill'):
        current_chest_to_kill.kill()
    
    for i, sprite_group in enumerate([platform_sprites, ladder_sprites, hazard_sprites, enemy_sprites, collectible_sprites, projectile_sprites, all_sprites]):
        if sprite_group is not None: 
            for sprite in sprite_group: 
                 if hasattr(sprite, 'kill'): sprite.kill()
            sprite_group.empty()
            
    enemy_list = []

    print("DEBUG GameSetup: Loading level data via LevelLoader...") # DEBUG
    try:
        platform_data_group, ladder_data_group, hazard_data_group, local_enemy_spawns_data_list, \
        p1_spawn_tuple, lvl_total_width_pixels, lvl_min_y_abs, lvl_max_y_abs, \
        main_ground_y_reference, main_ground_height_reference = \
            LevelLoader.load_map_cpu(current_width, current_height) # Using load_map_cpu as default

        platform_sprites.add(platform_data_group.sprites())
        ladder_sprites.add(ladder_data_group.sprites())
        hazard_sprites.add(hazard_data_group.sprites())
        
        player1_spawn_pos = p1_spawn_tuple
        p2_spawn_x = p1_spawn_tuple[0] + C.TILE_SIZE * 1.5
        # Ensure P2 spawn is within the playable horizontal area
        if p2_spawn_x + (C.TILE_SIZE / 2) > lvl_total_width_pixels - C.TILE_SIZE: 
            p2_spawn_x = lvl_total_width_pixels - C.TILE_SIZE * 2.5 
        if p2_spawn_x - (C.TILE_SIZE / 2) < C.TILE_SIZE:
            p2_spawn_x = C.TILE_SIZE * 2.5
        player2_spawn_pos = (p2_spawn_x, p1_spawn_tuple[1])
        
        level_pixel_width = lvl_total_width_pixels
        ground_level_y = main_ground_y_reference
        ground_platform_height = main_ground_height_reference
        print(f"DEBUG GameSetup: Level geometry loaded. Width: {level_pixel_width}, MinY: {lvl_min_y_abs}, MaxY: {lvl_max_y_abs}, P1 Spawn: {player1_spawn_pos}, P2 Spawn: {player2_spawn_pos}") # DEBUG
    except Exception as e:
        print(f"CRITICAL ERROR loading level: {e}")
        traceback.print_exc()
        return None

    all_sprites.add(platform_sprites.sprites(), ladder_sprites.sprites(), hazard_sprites.sprites())
    player1, player2 = None, None # Initialize to None

    # --- Player Initialization ---
    # Create Player 1 if mode is host, couch, single_player, or any client mode (as placeholder)
    if for_game_mode in ["host", "couch_play", "single_player", "join_lan", "join_ip"]:
        p1_role = "local"
        if for_game_mode in ["join_lan", "join_ip"]:
            p1_role = "remote placeholder for client"
        
        print(f"DEBUG GameSetup: Initializing player 1 ({p1_role}) for mode '{for_game_mode}' at {player1_spawn_pos}...")
        player1 = Player(player1_spawn_pos[0], player1_spawn_pos[1], player_id=1)
        if not player1._valid_init: 
            print(f"CRITICAL GameSetup: P1 ({p1_role}) init failed.")
            return None
        all_sprites.add(player1)
        print(f"DEBUG GameSetup: P1 ({p1_role}) initialized. Instance: {player1}, Valid: {player1._valid_init}, Pos: {player1.pos if hasattr(player1, 'pos') else 'N/A'}")

    # Create Player 2 if mode is couch, host (as placeholder), or any client mode (as local player)
    if for_game_mode in ["couch_play", "host", "join_lan", "join_ip"]:
        p2_role = "unknown"
        if for_game_mode == "couch_play": p2_role = "local (couch)"
        elif for_game_mode == "host": p2_role = "remote placeholder for host"
        elif for_game_mode in ["join_lan", "join_ip"]: p2_role = "local client"

        print(f"DEBUG GameSetup: Initializing player 2 ({p2_role}) for mode '{for_game_mode}' at {player2_spawn_pos}...")
        player2 = Player(player2_spawn_pos[0], player2_spawn_pos[1], player_id=2)
        if not player2._valid_init: 
            print(f"CRITICAL GameSetup: P2 ({p2_role}) init failed.")
            return None
        all_sprites.add(player2)
        print(f"DEBUG GameSetup: P2 ({p2_role}) initialized. Instance: {player2}, Valid: {player2._valid_init}, Pos: {player2.pos if hasattr(player2, 'pos') else 'N/A'}")


    if player1 and hasattr(player1, 'set_projectile_group_references'):
        player1.set_projectile_group_references(projectile_sprites, all_sprites)
    if player2 and hasattr(player2, 'set_projectile_group_references'):
        player2.set_projectile_group_references(projectile_sprites, all_sprites)

    if for_game_mode in ["host", "couch_play", "single_player"]: 
        print(f"DEBUG GameSetup: Spawning {len(local_enemy_spawns_data_list)} enemies (server/local)...") # DEBUG
        for i, spawn_data_item in enumerate(local_enemy_spawns_data_list):
            try:
                patrol_rect_data = spawn_data_item.get('patrol')
                patrol_rect_obj = None
                if patrol_rect_data:
                    try: patrol_rect_obj = pygame.Rect(patrol_rect_data)
                    except TypeError: print(f"Warning: Invalid patrol data for enemy {i}: {patrol_rect_data}")
                
                enemy = Enemy(spawn_data_item['pos'][0], spawn_data_item['pos'][1], patrol_area=patrol_rect_obj, enemy_id=i)
                if enemy._valid_init:
                    all_sprites.add(enemy); enemy_sprites.add(enemy); enemy_list.append(enemy)
                else: print(f"Error: Enemy {i} at {spawn_data_item['pos']} init failed.")
            except Exception as e: print(f"Error spawning enemy {i} at {spawn_data_item.get('pos', 'N/A')}: {e}")
        print(f"DEBUG GameSetup: Enemies spawned: {len(enemy_list)}") # DEBUG
    
    current_chest = None
    if Chest and for_game_mode in ["host", "couch_play", "single_player"]:
        current_chest = spawn_chest(platform_sprites, main_ground_y_reference) 
        if current_chest:
            all_sprites.add(current_chest)
            collectible_sprites.add(current_chest)
            print(f"DEBUG GameSetup: Chest spawned at {current_chest.rect.topleft if current_chest else 'N/A'}") # DEBUG
        else:
            print(f"DEBUG GameSetup: Chest NOT spawned.") # DEBUG

    camera_instance = Camera(level_pixel_width, lvl_min_y_abs, lvl_max_y_abs, current_width, current_height)
    print(f"DEBUG GameSetup: Camera initialized. LvlW={level_pixel_width}, LvlTopY={lvl_min_y_abs}, LvlBotY={lvl_max_y_abs}, ScreenWH= {current_width}x{current_height}") # DEBUG

    game_elements_dict = {
        "player1": player1, "player2": player2, "camera": camera_instance,
        "current_chest": current_chest, 
        "enemy_list": enemy_list,
        "platform_sprites": platform_sprites, "ladder_sprites": ladder_sprites,
        "hazard_sprites": hazard_sprites, "enemy_sprites": enemy_sprites,
        "collectible_sprites": collectible_sprites, "projectile_sprites": projectile_sprites,
        "all_sprites": all_sprites,
        "level_pixel_width": level_pixel_width, 
        "level_min_y_absolute": lvl_min_y_abs,
        "level_max_y_absolute": lvl_max_y_abs,
        "ground_level_y": ground_level_y,
        "ground_platform_height": ground_platform_height,
        "player1_spawn_pos": player1_spawn_pos, 
        "player2_spawn_pos": player2_spawn_pos,
        "enemy_spawns_data_cache": local_enemy_spawns_data_list 
    }
    print(f"DEBUG GameSetup: initialize_game_elements returning. P1: {player1}, P2: {player2}") # DEBUG
    if player1: print(f"DEBUG GameSetup: P1 in all_sprites: {player1 in all_sprites}") #DEBUG
    if player2: print(f"DEBUG GameSetup: P2 in all_sprites: {player2 in all_sprites}") #DEBUG
    return game_elements_dict

def spawn_chest(all_platform_sprites_group, main_ground_y_surface_level):
    """
    Spawns a chest ONLY on platforms explicitly marked as 'ledge' (platform_type="ledge").
    Tries to pick a ledge within a reasonable vertical band if possible.
    """
    if Chest is None: 
        print("Warning: Chest class not available for spawning.")
        return None
    try:
        # Filter for platforms that are specifically designated as ledges and are wide enough
        ledge_platforms = [
            p for p in all_platform_sprites_group
            if hasattr(p, 'platform_type') and p.platform_type == "ledge" and p.rect.width > C.TILE_SIZE * 1.25
        ]

        if not ledge_platforms:
            print("Warning: No 'ledge' type platforms found to spawn chest on. Chest will not spawn.")
            return None

        candidate_platforms = []
        # Tier 1: Ledges within a moderate vertical band around the main ground.
        # This encourages chests to spawn in more accessible/central areas.
        moderate_y_min = main_ground_y_surface_level - C.TILE_SIZE * 4 
        moderate_y_max = main_ground_y_surface_level + C.TILE_SIZE * 1 
        candidate_platforms = [
            p for p in ledge_platforms # Start with already filtered ledge_platforms
            if moderate_y_min <= p.rect.top <= moderate_y_max
        ]

        # Tier 2: If no Tier 1, use any available ledge_platform.
        if not candidate_platforms:
            candidate_platforms = list(ledge_platforms) 
            # This ensures we still use a ledge if none were in the "moderate" band.

        if not candidate_platforms: # Should not happen if ledge_platforms was not empty
            print("Error: No suitable 'ledge' platforms remained after tiering. Chest will not spawn.")
            return None

        chosen_platform = random.choice(candidate_platforms)
        
        # Ensure chest spawns within platform horizontal bounds, slightly inset
        chest_inset = C.TILE_SIZE * 0.5 
        min_cx = chosen_platform.rect.left + chest_inset
        max_cx = chosen_platform.rect.right - chest_inset
        
        # If platform is too narrow for inset, place in center
        cx = random.randint(int(min_cx), int(max_cx)) if min_cx < max_cx else chosen_platform.rect.centerx
        # Chest constructor expects midbottom X,Y. Spawn with bottom of chest at the top surface of the platform.
        cy = chosen_platform.rect.top 
        
        new_chest = Chest(cx, cy) # Chest's rect will be anchored midbottom=(cx, cy)
        if hasattr(new_chest, '_valid_init') and new_chest._valid_init:
            platform_info = f"'{chosen_platform.platform_type}' platform (Color: {chosen_platform.color if hasattr(chosen_platform, 'color') else 'N/A'})"
            print(f"Chest object created on {platform_info} at y={chosen_platform.rect.top}. Chest midbottom: ({int(new_chest.rect.midbottom[0])}, {int(new_chest.rect.midbottom[1])}).")
            return new_chest
        else:
            print("Failed to initialize new chest object (invalid init after creation).")
    except Exception as e:
        print(f"Error creating new chest object: {e}")
        traceback.print_exc()
    return None

########## END OF FILE: game_setup.py ##########

########## START OF FILE: game_state_manager.py ##########

########## START OF FILE: game_state_manager.py ##########

# game_state_manager.py
# -*- coding: utf-8 -*-
"""
version 1.0.0.3 (Players always update from network state on client; enemy color sync)
Manages game state, including reset and network synchronization.
"""
import pygame
import traceback
import os # Added for os.path.join
from game_setup import spawn_chest # For respawning chest
from enemy import Enemy # For creating new enemies on client
from items import Chest # For type checking and creating new chests on client
from projectiles import Fireball # For creating projectiles on client
from assets import load_all_player_animations # Added for reloading enemy animations
import constants as C # Added for fallback color C.BLUE

def reset_game_state(game_elements):
    """Resets the state of players, enemies, and collectibles."""
    print("DEBUG GSM: --- Resetting Platformer Game State ---") # DEBUG
    player1 = game_elements.get("player1")
    player2 = game_elements.get("player2")
    enemy_list = game_elements.get("enemy_list", [])
    current_chest = game_elements.get("current_chest")
    player1_spawn_pos = game_elements.get("player1_spawn_pos")
    player2_spawn_pos = game_elements.get("player2_spawn_pos")
    all_sprites = game_elements.get("all_sprites")
    enemy_sprites = game_elements.get("enemy_sprites")
    collectible_sprites = game_elements.get("collectible_sprites")
    projectile_sprites = game_elements.get("projectile_sprites")
    camera = game_elements.get("camera")

    if player1 and hasattr(player1, 'reset_state'):
        print(f"DEBUG GSM: Resetting P1 at {player1_spawn_pos}") # DEBUG
        player1.reset_state(player1_spawn_pos)
        if not player1.alive() and player1._valid_init: all_sprites.add(player1) # Ensure in group
        print("DEBUG GSM: P1 Reset complete.") # DEBUG
    if player2 and hasattr(player2, 'reset_state'):
        print(f"DEBUG GSM: Resetting P2 at {player2_spawn_pos}") # DEBUG
        player2.reset_state(player2_spawn_pos)
        if not player2.alive() and player2._valid_init: all_sprites.add(player2) # Ensure in group
        print("DEBUG GSM: P2 Reset complete.") # DEBUG

    for enemy_instance in enemy_list:
        if hasattr(enemy_instance, 'reset'):
            enemy_instance.reset()
            if enemy_instance._valid_init and not enemy_instance.alive(): # If reset somehow made it not alive but valid
                all_sprites.add(enemy_instance) # Re-add to ensure it's drawn/updated if it revives
                enemy_sprites.add(enemy_instance)
    print(f"DEBUG GSM: {len(enemy_list)} enemies processed for reset.") # DEBUG

    if projectile_sprites:
        for proj in projectile_sprites: proj.kill()
        projectile_sprites.empty()
        print("DEBUG GSM: Projectiles cleared.") # DEBUG


    if current_chest and current_chest.alive(): current_chest.kill()
    print(f"DEBUG GSM: Existing chest killed (if any).") # DEBUG


    new_chest = spawn_chest(game_elements.get("platform_sprites"), game_elements.get("ground_level_y"))
    if new_chest:
        all_sprites.add(new_chest)
        collectible_sprites.add(new_chest)
        game_elements["current_chest"] = new_chest # Update the reference in game_elements
        print("DEBUG GSM: Chest respawned.") # DEBUG
    else:
        game_elements["current_chest"] = None # Ensure it's None if spawn fails
        print("DEBUG GSM: Failed to respawn chest or Chest class not available.") # DEBUG

    if camera: camera.set_pos(0,0) # Reset camera position to default
    print("DEBUG GSM: Camera position reset.") # DEBUG

    print("DEBUG GSM: --- Game State Reset Finished ---\n") # DEBUG
    return new_chest # Return the new chest so main can update its reference if needed

def get_network_game_state(game_elements):
    """Gathers all relevant game state for network transmission."""
    # print("DEBUG GSM (get_network_game_state): Gathering state...") # DEBUG
    player1 = game_elements.get("player1")
    player2 = game_elements.get("player2")
    enemy_list = game_elements.get("enemy_list", [])
    current_chest = game_elements.get("current_chest")
    projectile_sprites = game_elements.get("projectile_sprites", pygame.sprite.Group()) # Default to empty group

    state = {'p1': None, 'p2': None, 'enemies': {}, 'chest': None, 'game_over': False, 'projectiles': []}

    if player1 and hasattr(player1, 'get_network_data'):
        state['p1'] = player1.get_network_data()
        # print(f"DEBUG GSM (get_network_game_state): P1 data: {state['p1']}") # DEBUG
    if player2 and hasattr(player2, 'get_network_data'):
        state['p2'] = player2.get_network_data()
        # print(f"DEBUG GSM (get_network_game_state): P2 data: {state['p2']}") # DEBUG


    # Include enemies that are alive or in the process of dying (animation not finished)
    for enemy in enemy_list:
        if hasattr(enemy, 'enemy_id') and hasattr(enemy, 'get_network_data'):
            if enemy.alive() or (enemy.is_dead and not enemy.death_animation_finished):
                 state['enemies'][str(enemy.enemy_id)] = enemy.get_network_data()

    if current_chest and current_chest.alive() and hasattr(current_chest, 'rect'):
        state['chest'] = {
            'pos': (current_chest.rect.centerx, current_chest.rect.centery),
            'is_collected': getattr(current_chest, 'is_collected', False)
        }

    # Determine game_over based on P1's state (typical for host/P1 centric games)
    p1_truly_gone = True # Assume P1 is gone
    if player1 and player1._valid_init: # If P1 was properly initialized
        if player1.alive(): # Is in sprite groups (could be dead but animating)
            if hasattr(player1, 'is_dead') and player1.is_dead: # Logically dead
                if hasattr(player1, 'death_animation_finished') and not player1.death_animation_finished:
                    p1_truly_gone = False # Still animating death, so not truly gone for game over
            else: # Alive and not dead
                p1_truly_gone = False
    state['game_over'] = p1_truly_gone # True if P1 is invalid OR dead AND death animation finished

    state['projectiles'] = [proj.get_network_data() for proj in projectile_sprites if hasattr(proj, 'get_network_data')]
    # print(f"DEBUG GSM (get_network_game_state): Final state to send (P1 Pos: {state['p1'].get('pos') if state['p1'] else 'N/A'}, P2 Pos: {state['p2'].get('pos') if state['p2'] else 'N/A'}, Num Enemies: {len(state['enemies'])})") # DEBUG
    return state

def set_network_game_state(network_state_data, game_elements, client_player_id=None): # client_player_id kept for potential future use
    """
    Applies received network state to local game elements.
    On the client, this updates both remote players and the client's own player
    to reflect the server's authoritative state.
    """
    # print(f"DEBUG GSM (set_network_game_state): Applying network state. Client ID: {client_player_id}") # DEBUG
    # if network_state_data: # DEBUG
        # print(f"DEBUG GSM (set_network_game_state): Received P1 data: {network_state_data.get('p1')}") # DEBUG
        # print(f"DEBUG GSM (set_network_game_state): Received P2 data: {network_state_data.get('p2')}") # DEBUG
    # else: # DEBUG
        # print("DEBUG GSM (set_network_game_state): network_state_data is None.") # DEBUG
        # return # DEBUG

    player1 = game_elements.get("player1")
    player2 = game_elements.get("player2")
    enemy_list = game_elements.get("enemy_list", []) 
    current_chest = game_elements.get("current_chest") 
    all_sprites = game_elements.get("all_sprites")
    enemy_sprites = game_elements.get("enemy_sprites")
    collectible_sprites = game_elements.get("collectible_sprites")
    projectile_sprites = game_elements.get("projectile_sprites", pygame.sprite.Group())
    enemy_spawns_data_cache = game_elements.get("enemy_spawns_data_cache", [])


    # Update Player 1 state from network data
    if player1 and 'p1' in network_state_data and network_state_data['p1'] and hasattr(player1, 'set_network_data'):
        # print(f"DEBUG GSM (set_network_game_state): Applying state to P1. Current P1 valid: {player1._valid_init}, alive: {player1.alive() if hasattr(player1, 'alive') else 'N/A'}") # DEBUG
        p1_data = network_state_data['p1']
        # print(f"DEBUG GSM (set_network_game_state): P1 network data being applied: pos={p1_data.get('pos')}, state={p1_data.get('state')}, valid={p1_data.get('_valid_init')}") # DEBUG
        player1.set_network_data(p1_data)
        # print(f"DEBUG GSM (set_network_game_state): P1 after set_network_data. Valid: {player1._valid_init}, Alive: {player1.alive()}, Pos: {player1.pos if hasattr(player1, 'pos') else 'N/A'}") # DEBUG
        if player1._valid_init and not player1.is_dead and not player1.alive():
             # print(f"DEBUG GSM (set_network_game_state): P1 became valid/alive but not in all_sprites. Adding.") # DEBUG
             all_sprites.add(player1)
        # elif not player1._valid_init and player1.alive(): # Should be handled by player1.set_network_data
            # print(f"DEBUG GSM (set_network_game_state): P1 became INvalid but IS in all_sprites. kill() should have been called.") #DEBUG

    # Update Player 2 state from network data
    if player2 and 'p2' in network_state_data and network_state_data['p2'] and hasattr(player2, 'set_network_data'):
        # print(f"DEBUG GSM (set_network_game_state): Applying state to P2. Current P2 valid: {player2._valid_init}, alive: {player2.alive() if hasattr(player2, 'alive') else 'N/A'}") # DEBUG
        p2_data = network_state_data['p2']
        # print(f"DEBUG GSM (set_network_game_state): P2 network data being applied: pos={p2_data.get('pos')}, state={p2_data.get('state')}, valid={p2_data.get('_valid_init')}") # DEBUG
        player2.set_network_data(p2_data)
        # print(f"DEBUG GSM (set_network_game_state): P2 after set_network_data. Valid: {player2._valid_init}, Alive: {player2.alive()}, Pos: {player2.pos if hasattr(player2, 'pos') else 'N/A'}") # DEBUG
        if player2._valid_init and not player2.is_dead and not player2.alive():
             # print(f"DEBUG GSM (set_network_game_state): P2 became valid/alive but not in all_sprites. Adding.") # DEBUG
             all_sprites.add(player2)
        # elif not player2._valid_init and player2.alive(): # Should be handled by player2.set_network_data
            # print(f"DEBUG GSM (set_network_game_state): P2 became INvalid but IS in all_sprites. kill() should have been called.") #DEBUG


    # Enemy state synchronization (critical for clients)
    if 'enemies' in network_state_data:
        received_enemy_data_map = network_state_data['enemies']
        # print(f"DEBUG GSM (set_network_game_state): Syncing {len(received_enemy_data_map)} enemies from network.") # DEBUG
        current_client_enemies_map = {str(enemy.enemy_id): enemy for enemy in enemy_list if hasattr(enemy, 'enemy_id')}

        for enemy_id_str, enemy_data_from_server in received_enemy_data_map.items():
            enemy_id_int = int(enemy_id_str)
            # print(f"DEBUG GSM (set_network_game_state): Processing enemy ID {enemy_id_str} from network. Data: {enemy_data_from_server.get('pos')}, valid: {enemy_data_from_server.get('_valid_init')}") # DEBUG

            if enemy_data_from_server.get('_valid_init', False): 
                if enemy_id_str in current_client_enemies_map: 
                    client_enemy = current_client_enemies_map[enemy_id_str]
                    # print(f"DEBUG GSM (set_network_game_state): Updating existing enemy ID {enemy_id_str}.") # DEBUG
                    if hasattr(client_enemy, 'set_network_data'):
                        client_enemy.set_network_data(enemy_data_from_server)
                        if client_enemy._valid_init and not client_enemy.alive():
                            if (client_enemy.is_dead and not client_enemy.death_animation_finished) or \
                               (not client_enemy.is_dead):
                                 # print(f"DEBUG GSM (set_network_game_state): Re-adding enemy {enemy_id_str} to sprite groups.") # DEBUG
                                 all_sprites.add(client_enemy); enemy_sprites.add(client_enemy)
                else: 
                    # print(f"DEBUG GSM (set_network_game_state): Creating NEW enemy ID {enemy_id_str}.") # DEBUG
                    try:
                        spawn_pos_e_default = enemy_data_from_server.get('pos', (0,0)) 
                        patrol_area_e_obj = None
                        if enemy_id_int < len(enemy_spawns_data_cache):
                            original_spawn_info = enemy_spawns_data_cache[enemy_id_int]
                            spawn_pos_e_default = original_spawn_info.get('pos', spawn_pos_e_default)
                            patrol_data_from_level = original_spawn_info.get('patrol')
                            if patrol_data_from_level:
                                try: patrol_area_e_obj = pygame.Rect(patrol_data_from_level)
                                except TypeError: print(f"Client: Invalid patrol data from cache for new enemy {enemy_id_int}.")
                        else:
                            print(f"Client: No original spawn data in cache for new enemy_id {enemy_id_int}.")

                        new_enemy_instance = Enemy(spawn_pos_e_default[0], spawn_pos_e_default[1],
                                             patrol_area=patrol_area_e_obj, enemy_id=enemy_id_int)
                        # print(f"DEBUG GSM (set_network_game_state): New enemy {enemy_id_str} created. Valid: {new_enemy_instance._valid_init}") # DEBUG


                        if new_enemy_instance._valid_init:
                            server_color_name = enemy_data_from_server.get('color_name')
                            if server_color_name and hasattr(new_enemy_instance, 'color_name') and new_enemy_instance.color_name != server_color_name:
                                # print(f"DEBUG GSM (set_network_game_state): Enemy {enemy_id_str} color mismatch (local '{new_enemy_instance.color_name}', net '{server_color_name}'). Reloading animations.") # DEBUG
                                new_enemy_instance.color_name = server_color_name
                                enemy_asset_folder = os.path.join('characters', server_color_name)
                                new_enemy_instance.animations = load_all_player_animations(
                                    relative_asset_folder=enemy_asset_folder
                                )
                                if new_enemy_instance.animations is None:
                                    print(f"Client CRITICAL: Failed to reload animations for enemy {enemy_id_int} with server color {server_color_name} from '{enemy_asset_folder}'")
                                    new_enemy_instance._valid_init = False
                                    if hasattr(C, 'BLUE'):
                                        new_enemy_instance.image = pygame.Surface((30, 40)).convert_alpha()
                                        new_enemy_instance.image.fill(C.BLUE)
                                        new_enemy_instance.rect = new_enemy_instance.image.get_rect(midbottom=(spawn_pos_e_default[0], spawn_pos_e_default[1]))
                                else:
                                    initial_idle_animation_new_color = new_enemy_instance.animations.get('idle')
                                    if initial_idle_animation_new_color and len(initial_idle_animation_new_color) > 0:
                                        new_enemy_instance.image = initial_idle_animation_new_color[0]
                                    else:
                                        if hasattr(C, 'BLUE'):
                                            new_enemy_instance.image = pygame.Surface((30, 40)).convert_alpha()
                                            new_enemy_instance.image.fill(C.BLUE)
                                    new_enemy_instance.rect = new_enemy_instance.image.get_rect(midbottom=(spawn_pos_e_default[0], spawn_pos_e_default[1]))
                                # print(f"DEBUG GSM (set_network_game_state): Enemy {enemy_id_str} animations reloaded. New valid: {new_enemy_instance._valid_init}") # DEBUG


                        if new_enemy_instance._valid_init:
                            new_enemy_instance.set_network_data(enemy_data_from_server)
                            all_sprites.add(new_enemy_instance); enemy_sprites.add(new_enemy_instance)
                            enemy_list.append(new_enemy_instance)
                            # print(f"DEBUG GSM (set_network_game_state): New enemy {enemy_id_str} added to lists and groups.") # DEBUG
                        # else: # DEBUG
                            # print(f"DEBUG GSM (set_network_game_state): New enemy {enemy_id_str} was NOT valid after creation/color sync.") # DEBUG
                    except Exception as e:
                        print(f"Client: Error creating new instance of enemy {enemy_id_str}: {e}")
                        traceback.print_exc()

            elif enemy_id_str in current_client_enemies_map: # Server says enemy invalid, but client has it
                enemy_to_remove = current_client_enemies_map[enemy_id_str]
                # print(f"DEBUG GSM (set_network_game_state): Server marked enemy {enemy_id_str} as invalid. Removing from client.") # DEBUG
                if enemy_to_remove.alive(): enemy_to_remove.kill()
                if enemy_to_remove in enemy_list: enemy_list.remove(enemy_to_remove)

        server_enemy_ids_present_in_message = set(received_enemy_data_map.keys())
        client_enemy_ids_to_remove_fully = set(current_client_enemies_map.keys()) - server_enemy_ids_present_in_message
        for removed_id_str_fully in client_enemy_ids_to_remove_fully:
            if removed_id_str_fully in current_client_enemies_map:
                enemy_to_remove_fully = current_client_enemies_map[removed_id_str_fully]
                # print(f"DEBUG GSM (set_network_game_state): Enemy {removed_id_str_fully} not in server message. Removing from client.") # DEBUG
                if enemy_to_remove_fully.alive(): enemy_to_remove_fully.kill()
                if enemy_to_remove_fully in enemy_list: enemy_list.remove(enemy_to_remove_fully)


    # Chest state synchronization
    if 'chest' in network_state_data:
        chest_data_from_server = network_state_data['chest']
        # print(f"DEBUG GSM (set_network_game_state): Chest data from server: {chest_data_from_server}") # DEBUG
        if chest_data_from_server and Chest is not None: 
            chest_pos_center_server = chest_data_from_server.get('pos')
            chest_is_collected_server = chest_data_from_server.get('is_collected', False)

            if chest_is_collected_server: 
                if current_chest and current_chest.alive(): current_chest.kill()
                game_elements["current_chest"] = None 
                # print(f"DEBUG GSM (set_network_game_state): Server says chest collected. Cleared local chest.") # DEBUG
            elif chest_pos_center_server: 
                if not current_chest or not current_chest.alive(): 
                    # print(f"DEBUG GSM (set_network_game_state): Client needs to create chest at {chest_pos_center_server}.") # DEBUG
                    if current_chest: current_chest.kill() 
                    try:
                        temp_chest_surf_for_height = Chest(0,0).image
                        temp_chest_height_approx = temp_chest_surf_for_height.get_height() if temp_chest_surf_for_height else 30
                        chest_spawn_x_midbottom = chest_pos_center_server[0]
                        chest_spawn_y_midbottom = chest_pos_center_server[1] + temp_chest_height_approx / 2
                        new_chest_instance_client = Chest(chest_spawn_x_midbottom, chest_spawn_y_midbottom)
                        if hasattr(new_chest_instance_client, '_valid_init') and new_chest_instance_client._valid_init:
                            all_sprites.add(new_chest_instance_client)
                            collectible_sprites.add(new_chest_instance_client)
                            game_elements["current_chest"] = new_chest_instance_client
                            if hasattr(game_elements["current_chest"], 'is_collected'):
                                game_elements["current_chest"].is_collected = False
                            # print(f"DEBUG GSM (set_network_game_state): New client chest created: {new_chest_instance_client}") # DEBUG
                        else:
                            game_elements["current_chest"] = None
                            # print(f"DEBUG GSM (set_network_game_state): New client chest FAILED init.") # DEBUG
                    except Exception as e:
                        # print(f"DEBUG GSM (set_network_game_state): Exception creating client chest: {e}") # DEBUG
                        game_elements["current_chest"] = None
                elif current_chest: # Client has a chest, server has one uncollected - ensure local not marked collected
                    # print(f"DEBUG GSM (set_network_game_state): Client and server both have uncollected chest. Ensuring local is_collected is False.") # DEBUG
                    if hasattr(current_chest, 'is_collected'):
                        current_chest.is_collected = False

        elif not network_state_data.get('chest'): # Server says no chest
            if current_chest and current_chest.alive(): current_chest.kill()
            game_elements["current_chest"] = None
            # print(f"DEBUG GSM (set_network_game_state): Server says NO chest. Cleared local chest.") # DEBUG


    # Projectile state synchronization
    if 'projectiles' in network_state_data:
        received_proj_data_map = {p_data['id']: p_data for p_data in network_state_data.get('projectiles', []) if 'id' in p_data}
        # print(f"DEBUG GSM (set_network_game_state): Syncing {len(received_proj_data_map)} projectiles from network.") # DEBUG
        current_client_proj_map = {p.projectile_id: p for p in projectile_sprites if hasattr(p, 'projectile_id')}

        for proj_id_server, proj_data_server in received_proj_data_map.items():
            # print(f"DEBUG GSM (set_network_game_state): Processing projectile ID {proj_id_server} from network. Pos: {proj_data_server.get('pos')}") # DEBUG
            if proj_id_server in current_client_proj_map:
                existing_proj_client = current_client_proj_map[proj_id_server]
                if hasattr(existing_proj_client, 'set_network_data'):
                    existing_proj_client.set_network_data(proj_data_server)
            else: # New projectile for this client
                owner_instance_client = None
                owner_id_from_server = proj_data_server.get('owner_id')
                if owner_id_from_server is not None:
                    if owner_id_from_server == 1 and player1: owner_instance_client = player1
                    elif owner_id_from_server == 2 and player2: owner_instance_client = player2
                
                # print(f"DEBUG GSM (set_network_game_state): Attempting to create new projectile {proj_id_server}. Owner ID: {owner_id_from_server}, Owner instance client-side: {owner_instance_client}") # DEBUG


                if owner_instance_client and 'pos' in proj_data_server and 'vel' in proj_data_server:
                    direction_vec_server = pygame.math.Vector2(proj_data_server['vel'])
                    if direction_vec_server.length_squared() == 0:
                        direction_vec_server = pygame.math.Vector2(1,0) if owner_instance_client.facing_right else pygame.math.Vector2(-1,0)

                    try:
                        new_proj_client = Fireball(proj_data_server['pos'][0], proj_data_server['pos'][1],
                                             direction_vec_server, owner_instance_client)
                        new_proj_client.projectile_id = proj_id_server
                        if hasattr(new_proj_client, 'set_network_data'):
                            new_proj_client.set_network_data(proj_data_server)
                        projectile_sprites.add(new_proj_client)
                        all_sprites.add(new_proj_client)
                        # print(f"DEBUG GSM (set_network_game_state): New projectile {proj_id_server} created and added.") # DEBUG
                    except Exception as e:
                        print(f"DEBUG GSM (set_network_game_state): Error creating new projectile {proj_id_server}: {e}") # DEBUG
                        traceback.print_exc()
                # else: # DEBUG
                    # print(f"DEBUG GSM (set_network_game_state): Cannot create projectile {proj_id_server} - owner missing or data incomplete.") # DEBUG


        client_proj_ids_to_remove = set(current_client_proj_map.keys()) - set(received_proj_data_map.keys())
        for removed_proj_id_client in client_proj_ids_to_remove:
            if removed_proj_id_client in current_client_proj_map:
                proj_to_kill_client = current_client_proj_map[removed_proj_id_client]
                # print(f"DEBUG GSM (set_network_game_state): Projectile {removed_proj_id_client} not in server message. Removing from client.") # DEBUG
                if proj_to_kill_client.alive(): proj_to_kill_client.kill()
    # print(f"DEBUG GSM (set_network_game_state): Network state application finished. P1 alive: {player1.alive() if player1 else 'N/A'}, P2 alive: {player2.alive() if player2 else 'N/A'}") # DEBUG

########## END OF FILE: game_state_manager.py ##########

########## START OF FILE: game_ui.py ##########

########## START OF FILE: game_ui.py ##########

# ui.py
# -*- coding: utf-8 -*-
## version 1.0.0.3 (Added default_input_text to get_server_ip_input_dialog)
"""
Functions for drawing User Interface elements like health bars, player HUDs,
main menus, input dialogs, and the main game scene.
"""
import pygame
import time # For cursor blinking in input dialog and message display timings
import constants as C # For accessing color constants and UI-related dimensions
from typing import Dict, Optional, Any # For type hinting

# --- Pyperclip & Pygame Scrap Check (for paste functionality in input dialog) ---
PYPERCLIP_AVAILABLE_UI_MODULE = False
try:
    import pyperclip
    PYPERCLIP_AVAILABLE_UI_MODULE = True
except ImportError:
    pass 

SCRAP_INITIALIZED_UI_MODULE = False # This will be updated by check_pygame_scrap_init_status

def check_pygame_scrap_init_status():
    """Checks and updates the status of Pygame's scrap module initialization."""
    global SCRAP_INITIALIZED_UI_MODULE
    try:
        if pygame.scrap.get_init(): 
            SCRAP_INITIALIZED_UI_MODULE = True
        else:
            SCRAP_INITIALIZED_UI_MODULE = False
    except (AttributeError, pygame.error): 
        SCRAP_INITIALIZED_UI_MODULE = False
    return SCRAP_INITIALIZED_UI_MODULE


# --- Health Bar Drawing Function ---
def draw_health_bar(surface: pygame.Surface, x: int, y: int, 
                    width: int, height: int, 
                    current_hp: float, max_hp: float):
    if max_hp <= 0: return

    current_hp_clamped = max(0, min(current_hp, max_hp))
    bar_width = max(1, int(width)) # Ensure width is at least 1 and int
    bar_height = max(1, int(height)) # Ensure height is at least 1 and int
    
    health_ratio = current_hp_clamped / max_hp

    # Determine health bar color (lerping from red to green)
    # Ensure C.RED and C.GREEN are available, otherwise fallback
    color_red = getattr(C, 'RED', (255,0,0))
    color_green = getattr(C, 'GREEN', (0,255,0))
    color_dark_gray = getattr(C, 'DARK_GRAY', (50,50,50))
    color_black = getattr(C, 'BLACK', (0,0,0))

    try: 
        # Pygame's Color.lerp is convenient if available
        health_color = pygame.Color(color_red).lerp(pygame.Color(color_green), health_ratio)
    except AttributeError: # Fallback manual lerp if pygame.Color.lerp is not available or constants are not Color objects
        r = int(color_red[0] * (1 - health_ratio) + color_green[0] * health_ratio)
        g = int(color_red[1] * (1 - health_ratio) + color_green[1] * health_ratio)
        b = int(color_red[2] * (1 - health_ratio) + color_green[2] * health_ratio)
        health_color = (max(0, min(255, r)), max(0, min(255, g)), max(0, min(255, b)))

    background_rect = pygame.Rect(x, y, bar_width, bar_height)
    pygame.draw.rect(surface, color_dark_gray, background_rect)

    health_fill_width = int(bar_width * health_ratio)
    if health_fill_width > 0: 
        health_fill_rect = pygame.Rect(x, y, health_fill_width, bar_height)
        pygame.draw.rect(surface, health_color, health_fill_rect)
    
    pygame.draw.rect(surface, color_black, background_rect, 1) 


# --- Player HUD Drawing Function ---
def draw_player_hud(surface: pygame.Surface, x: int, y: int, 
                    player_instance: Any, 
                    player_number: int, 
                    hud_font_obj: Optional[pygame.font.Font]):
    if not player_instance or not hasattr(player_instance, 'current_health') or \
       not hasattr(player_instance, 'max_health'):
        # print(f"DEBUG UI (draw_player_hud): P{player_number} instance invalid or no health attributes. Skipping HUD.") # DEBUG
        return

    # DEBUG: Print player instance details for HUD
    # if hasattr(player_instance, 'player_id'):
    #     print(f"DEBUG UI (draw_player_hud): Drawing HUD for P{player_number} (ID: {player_instance.player_id}). Valid: {getattr(player_instance, '_valid_init', 'N/A')}, Alive: {player_instance.alive() if hasattr(player_instance, 'alive') else 'N/A'}, Pos: {getattr(player_instance, 'pos', 'N/A')}") # DEBUG
    # else:
    #     print(f"DEBUG UI (draw_player_hud): Drawing HUD for P{player_number}. Instance has no player_id.") # DEBUG


    player_label_text = f"P{player_number}"
    label_height_offset = 0 
    color_white = getattr(C, 'WHITE', (255,255,255))
    
    if hud_font_obj: 
        try:
            label_surface = hud_font_obj.render(player_label_text, True, color_white) 
            surface.blit(label_surface, (x, y)) 
            label_height_offset = label_surface.get_height() 
        except Exception as e: 
            print(f"UI Warning: Could not render HUD label for P{player_number}: {e}")
            label_height_offset = getattr(hud_font_obj, 'get_height', lambda: 20)() # Fallback height
    else: 
        # print(f"DEBUG UI (draw_player_hud): No HUD font for P{player_number} label.") # DEBUG
        label_height_offset = 0 

    health_bar_pos_x = x
    health_bar_pos_y = y + label_height_offset + 5  
    hud_health_bar_width = getattr(C, 'HUD_HEALTH_BAR_WIDTH', getattr(C, 'HEALTH_BAR_WIDTH', 50) * 2)
    hud_health_bar_height = getattr(C, 'HUD_HEALTH_BAR_HEIGHT', getattr(C, 'HEALTH_BAR_HEIGHT', 8) + 4)

    draw_health_bar(surface, health_bar_pos_x, health_bar_pos_y,
                    hud_health_bar_width, hud_health_bar_height,
                    player_instance.current_health, player_instance.max_health)

    if hud_font_obj: 
        try:
            health_value_text = f"{int(player_instance.current_health)}/{int(player_instance.max_health)}"
            health_text_surface = hud_font_obj.render(health_value_text, True, color_white)
            health_text_pos_x = health_bar_pos_x + hud_health_bar_width + 10 
            health_text_pos_y = health_bar_pos_y + (hud_health_bar_height - health_text_surface.get_height()) // 2 # Use // for int
            surface.blit(health_text_surface, (health_text_pos_x, health_text_pos_y))
        except Exception as e: 
            print(f"UI Warning: Could not render HUD health text for P{player_number}: {e}")
    # else:
        # print(f"DEBUG UI (draw_player_hud): No HUD font for P{player_number} health text.") # DEBUG


# --- Main Game Scene Drawing Function ---
def draw_platformer_scene_on_surface(screen_surface: pygame.Surface, 
                                     game_elements: Dict[str, Any], 
                                     fonts: Dict[str, Optional[pygame.font.Font]], 
                                     current_game_time_ticks: int): 
    # print(f"DEBUG UI (draw_scene): Frame {current_game_time_ticks // (1000//C.FPS if C.FPS > 0 else 16)}") # DEBUG frame number
    camera_instance = game_elements.get("camera")
    all_sprites_group = game_elements.get("all_sprites") 
    enemy_list_for_health_bars = game_elements.get("enemy_list", [])
    player1_instance = game_elements.get("player1")
    player2_instance = game_elements.get("player2")
    
    font_for_hud = fonts.get("medium")
    if font_for_hud is None:
        font_for_hud = pygame.font.Font(None, 24) if pygame.font.get_init() else None
        
    current_screen_width, _ = screen_surface.get_size()
    bg_color = getattr(C, 'LIGHT_BLUE', (135, 206, 235))
    screen_surface.fill(bg_color) 

    if camera_instance and all_sprites_group:
        # print(f"DEBUG UI (draw_scene): Camera Pos: {camera_instance.get_pos()}, Num All Sprites: {len(all_sprites_group)}") # DEBUG
        drawn_p1 = False
        drawn_p2 = False
        for entity_sprite in all_sprites_group: 
            if entity_sprite.alive() and hasattr(entity_sprite, 'image') and hasattr(entity_sprite, 'rect'):
                 applied_rect = camera_instance.apply(entity_sprite.rect)
                 # DEBUG Player specific draw info
                 if entity_sprite is player1_instance:
                     # print(f"DEBUG UI (draw_scene): Drawing P1 (ID {getattr(entity_sprite, 'player_id', 'N/A')}). Alive: {entity_sprite.alive()}, Valid: {getattr(entity_sprite, '_valid_init', 'N/A')}. World Rect: {entity_sprite.rect}, Screen Rect: {applied_rect}, Image Size: {entity_sprite.image.get_size() if entity_sprite.image else 'No Image'}") # DEBUG
                     drawn_p1 = True
                 elif entity_sprite is player2_instance:
                     # print(f"DEBUG UI (draw_scene): Drawing P2 (ID {getattr(entity_sprite, 'player_id', 'N/A')}). Alive: {entity_sprite.alive()}, Valid: {getattr(entity_sprite, '_valid_init', 'N/A')}. World Rect: {entity_sprite.rect}, Screen Rect: {applied_rect}, Image Size: {entity_sprite.image.get_size() if entity_sprite.image else 'No Image'}") # DEBUG
                     drawn_p2 = True

                 screen_surface.blit(entity_sprite.image, applied_rect)
        # if player1_instance and not drawn_p1:
            # print(f"DEBUG UI (draw_scene): P1 instance exists but was NOT drawn from all_sprites. Alive: {player1_instance.alive() if hasattr(player1_instance, 'alive') else 'N/A'}, Valid: {getattr(player1_instance, '_valid_init', 'N/A')}") # DEBUG
        # if player2_instance and not drawn_p2:
            # print(f"DEBUG UI (draw_scene): P2 instance exists but was NOT drawn from all_sprites. Alive: {player2_instance.alive() if hasattr(player2_instance, 'alive') else 'N/A'}, Valid: {getattr(player2_instance, '_valid_init', 'N/A')}") # DEBUG

        
        for enemy_sprite in enemy_list_for_health_bars:
            if enemy_sprite.alive() and getattr(enemy_sprite, '_valid_init', False) and not \
               (getattr(enemy_sprite, 'is_dead', False) and getattr(enemy_sprite, 'death_animation_finished', False)) and \
               hasattr(enemy_sprite, 'current_health') and hasattr(enemy_sprite, 'max_health'):
                
                enemy_rect_on_screen = camera_instance.apply(enemy_sprite.rect) 
                health_bar_width_enemy = getattr(C, 'HEALTH_BAR_WIDTH', 50)
                health_bar_height_enemy = getattr(C, 'HEALTH_BAR_HEIGHT', 8)
                health_bar_pos_x_enemy = enemy_rect_on_screen.centerx - health_bar_width_enemy // 2 # Use //
                health_bar_pos_y_enemy = enemy_rect_on_screen.top - health_bar_height_enemy - \
                                         getattr(C, 'HEALTH_BAR_OFFSET_ABOVE', 5) 
                
                draw_health_bar(screen_surface, health_bar_pos_x_enemy, health_bar_pos_y_enemy, 
                                health_bar_width_enemy, health_bar_height_enemy, 
                                enemy_sprite.current_health, enemy_sprite.max_health)
    elif all_sprites_group: 
        # print(f"DEBUG UI (draw_scene): No camera, using all_sprites.draw(). Num All Sprites: {len(all_sprites_group)}") # DEBUG
        all_sprites_group.draw(screen_surface) # Fallback if no camera

    if player1_instance and getattr(player1_instance, '_valid_init', False) and player1_instance.alive():
        # print(f"DEBUG UI (draw_scene): P1 is valid and alive for HUD. HP: {player1_instance.current_health}") # DEBUG
        draw_player_hud(screen_surface, 10, 10, player1_instance, 1, font_for_hud)
    # elif player1_instance:
        # print(f"DEBUG UI (draw_scene): P1 instance exists for HUD but is not valid or not alive. Valid: {getattr(player1_instance, '_valid_init', 'N/A')}, Alive: {player1_instance.alive() if hasattr(player1_instance, 'alive') else 'N/A'}") # DEBUG
    # else:
        # print(f"DEBUG UI (draw_scene): P1 instance is None for HUD.") # DEBUG

    
    if player2_instance and getattr(player2_instance, '_valid_init', False) and player2_instance.alive():
        # print(f"DEBUG UI (draw_scene): P2 is valid and alive for HUD. HP: {player2_instance.current_health}") # DEBUG
        p2_hud_estimated_width = getattr(C, 'HUD_HEALTH_BAR_WIDTH', getattr(C, 'HEALTH_BAR_WIDTH',50)*2) + 120 
        p2_hud_pos_x = current_screen_width - p2_hud_estimated_width - 10 
        draw_player_hud(screen_surface, p2_hud_pos_x, 10, player2_instance, 2, font_for_hud)
    # elif player2_instance:
        # print(f"DEBUG UI (draw_scene): P2 instance exists for HUD but is not valid or not alive. Valid: {getattr(player2_instance, '_valid_init', 'N/A')}, Alive: {player2_instance.alive() if hasattr(player2_instance, 'alive') else 'N/A'}") # DEBUG
    # else:
        # print(f"DEBUG UI (draw_scene): P2 instance is None for HUD.") # DEBUG


# --- Main Menu Function ---
def show_main_menu(screen_surface: pygame.Surface, clock_obj: pygame.time.Clock, 
                   fonts: Dict[str, Optional[pygame.font.Font]], 
                   app_status_obj: Any) -> Optional[str]:
    button_standard_width = 350
    button_standard_height = 55
    button_vertical_spacing = 20
    gap_after_title = 60
    
    current_screen_width, current_screen_height = screen_surface.get_size()

    font_title = fonts.get("large")
    if font_title is None : font_title = pygame.font.Font(None, 60) if pygame.font.get_init() else None
    if font_title is None: 
        print("UI Error: Large font for menu title not available.")
        return "quit"
        
    title_text_surface = font_title.render("Platformer Adventure LAN", True, getattr(C, 'WHITE', (255,255,255)))
    
    menu_buttons_definition = {
        "host":       {"text": "Host Game",       "action": "host"},
        "join_lan":   {"text": "Join Game (LAN)", "action": "join_lan"},
        "join_ip":    {"text": "Join by IP",      "action": "join_ip"},
        "couch_play": {"text": "Couch Play",      "action": "couch_play"},
        "quit":       {"text": "Quit Game",       "action": "quit"}
    }
    
    font_button_text = fonts.get("medium")
    if font_button_text is None: font_button_text = pygame.font.Font(None, 30) if pygame.font.get_init() else None
    if font_button_text is None: 
        print("UI Error: Medium font for menu buttons not available.")
        return "quit"

    title_rect_for_display = title_text_surface.get_rect(center=(current_screen_width // 2, current_screen_height // 4))
    
    def update_menu_button_geometries(): # Removed title_rect_for_display from nonlocal as it's recalculated
        nonlocal current_screen_width, current_screen_height # Allow modification
        # title_rect_calculated = title_text_surface.get_rect(center=(current_screen_width // 2, current_screen_height // 4))
        
        num_menu_buttons = len(menu_buttons_definition)
        # total_buttons_block_height = (num_menu_buttons * button_standard_height) + \
        #                              ((num_menu_buttons - 1) * button_vertical_spacing)
        first_button_start_y = title_rect_for_display.bottom + gap_after_title # Use the member title_rect
        
        current_button_y_pos = first_button_start_y
        for _, button_props_dict in menu_buttons_definition.items():
            button_props_dict["rect"] = pygame.Rect(0, 0, button_standard_width, button_standard_height)
            button_props_dict["rect"].centerx = current_screen_width // 2 
            button_props_dict["rect"].top = current_button_y_pos
            button_props_dict["text_surf"] = font_button_text.render(button_props_dict["text"], True, getattr(C, 'WHITE', (255,255,255)))
            button_props_dict["text_rect"] = button_props_dict["text_surf"].get_rect(
                center=button_props_dict["rect"].center
            )
            current_button_y_pos += button_standard_height + button_vertical_spacing 
        # return title_rect_calculated # Not needed to return if modifying global/nonlocal directly

    update_menu_button_geometries() # Initial setup

    selected_menu_action = None 
    while selected_menu_action is None and app_status_obj.app_running:
        mouse_cursor_pos = pygame.mouse.get_pos() 
        
        for event in pygame.event.get(): 
            if event.type == pygame.QUIT:
                app_status_obj.app_running = False 
                selected_menu_action = "quit" 
            if event.type == pygame.VIDEORESIZE: 
                 if not screen_surface.get_flags() & pygame.FULLSCREEN: 
                     try:
                         current_screen_width,current_screen_height=max(320,event.w),max(240,event.h) 
                         screen_surface=pygame.display.set_mode((current_screen_width,current_screen_height), 
                                                                pygame.RESIZABLE|pygame.DOUBLEBUF)
                         # Recalculate title_rect here as screen size changed
                         title_rect_for_display = title_text_surface.get_rect(center=(current_screen_width // 2, current_screen_height // 4))
                         update_menu_button_geometries() 
                     except pygame.error as e: print(f"UI Menu resize error: {e}")
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE: 
                    app_status_obj.app_running = False
                    selected_menu_action = "quit"
            if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1: 
                for button_props_item in menu_buttons_definition.values():
                    if "rect" in button_props_item and button_props_item["rect"].collidepoint(mouse_cursor_pos):
                        selected_menu_action = button_props_item["action"] 
                        break 
        if not app_status_obj.app_running: break 

        screen_surface.fill(getattr(C, 'BLACK', (0,0,0))) 
        if title_rect_for_display: screen_surface.blit(title_text_surface, title_rect_for_display) 
        
        for button_properties in menu_buttons_definition.values():
            if "rect" in button_properties: # Ensure rect exists
                is_mouse_hovering_button = button_properties["rect"].collidepoint(mouse_cursor_pos)
                button_color_to_draw = getattr(C, 'GREEN', (0,255,0)) if is_mouse_hovering_button else getattr(C, 'BLUE', (0,0,255))
                pygame.draw.rect(screen_surface, button_color_to_draw, button_properties["rect"], border_radius=8)
                if "text_surf" in button_properties and "text_rect" in button_properties:
                    screen_surface.blit(button_properties["text_surf"], button_properties["text_rect"])
        
        pygame.display.flip() 
        clock_obj.tick(30) 
        
    return selected_menu_action


# --- IP Address Input Dialog Function ---
def get_server_ip_input_dialog(screen_surface: pygame.Surface, clock_obj: pygame.time.Clock, 
                               fonts: Dict[str, Optional[pygame.font.Font]], 
                               app_status_obj: Any, 
                               default_input_text: str = "") -> Optional[str]: # Added default_input_text
    """
    Displays a dialog to get server IP address input from the user.
    """
    current_input_text = default_input_text # Use the passed default_input_text
    input_dialog_active = True
    is_cursor_visible = True 
    last_cursor_blink_time = time.time() 
    
    current_screen_width, current_screen_height = screen_surface.get_size()
    # Ensure input_box_rect width is reasonable, at least some minimum
    input_box_width = max(200, current_screen_width // 2)
    input_box_rect = pygame.Rect(0, 0, input_box_width, 50)
    input_box_rect.center = (current_screen_width // 2, current_screen_height // 2)
    
    pygame.key.set_repeat(250, 25) 
    paste_status_message = None 
    paste_message_display_start_time = 0 
    
    check_pygame_scrap_init_status() # Ensure SCRAP_INITIALIZED_UI_MODULE is up-to-date

    font_prompt_text = fonts.get("medium")
    if font_prompt_text is None: font_prompt_text = pygame.font.Font(None, 30) if pygame.font.get_init() else None
    font_info_text = fonts.get("small")
    if font_info_text is None: font_info_text = pygame.font.Font(None, 20) if pygame.font.get_init() else None
    font_input_field_text = fonts.get("medium") # Using medium for input field text
    if font_input_field_text is None: font_input_field_text = pygame.font.Font(None, 30) if pygame.font.get_init() else None

    if not all([font_prompt_text, font_info_text, font_input_field_text]):
        print("UI Error: Essential fonts for IP input dialog not available.")
        pygame.key.set_repeat(0,0) # Reset key repeat
        return None # Cannot render dialog

    while input_dialog_active and app_status_obj.app_running:
        current_loop_time = time.time()
        if current_loop_time - last_cursor_blink_time > 0.5: 
            is_cursor_visible = not is_cursor_visible
            last_cursor_blink_time = current_loop_time
        
        for event in pygame.event.get(): 
            if event.type == pygame.QUIT:
                app_status_obj.app_running = False; input_dialog_active = False; current_input_text = None
            if event.type == pygame.VIDEORESIZE: 
                 if not screen_surface.get_flags() & pygame.FULLSCREEN:
                     try:
                         current_screen_width,current_screen_height=max(320,event.w),max(240,event.h)
                         screen_surface=pygame.display.set_mode((current_screen_width,current_screen_height),
                                                                pygame.RESIZABLE|pygame.DOUBLEBUF)
                         input_box_width = max(200, current_screen_width // 2)
                         input_box_rect = pygame.Rect(0,0, input_box_width, 50)
                         input_box_rect.center = (current_screen_width // 2, current_screen_height // 2)
                     except pygame.error as e: print(f"UI IP Input Dialog resize error: {e}")
            if event.type == pygame.KEYDOWN:
                paste_status_message = None 
                if event.key == pygame.K_ESCAPE: 
                    input_dialog_active = False; current_input_text = None 
                elif event.key == pygame.K_RETURN: 
                    input_dialog_active = False 
                elif event.key == pygame.K_BACKSPACE: 
                    current_input_text = current_input_text[:-1]
                elif event.key == pygame.K_v and \
                     (event.mod & pygame.KMOD_CTRL or event.mod & pygame.KMOD_META): # Ctrl+V or Cmd+V
                    
                    pasted_text_content = ""
                    paste_method_attempted = "None"
                    try:
                        if SCRAP_INITIALIZED_UI_MODULE:
                            clipboard_data_bytes = pygame.scrap.get(pygame.SCRAP_TEXT) 
                            if clipboard_data_bytes: # Ensure it's not None
                                pasted_text_content = clipboard_data_bytes.decode('utf-8', errors='ignore').replace('\x00', '').strip()
                            if pasted_text_content: paste_method_attempted = "pygame.scrap"
                        
                        if not pasted_text_content and PYPERCLIP_AVAILABLE_UI_MODULE:
                            clipboard_data_str = pyperclip.paste()
                            if isinstance(clipboard_data_str, str):
                                pasted_text_content = clipboard_data_str.replace('\x00', '').strip()
                            if pasted_text_content: paste_method_attempted = "pyperclip"
                    except Exception as e_paste_error:
                        print(f"UI Paste error (Method: {paste_method_attempted}): {e_paste_error}")

                    if pasted_text_content: current_input_text += pasted_text_content 
                    else: 
                        paste_status_message = "Paste Failed or Clipboard Empty"
                        paste_message_display_start_time = current_loop_time
                # Allow letters, numbers, '.', ':', '-' for IP/Port and hostnames
                elif event.unicode.isprintable() and \
                     (event.unicode.isalnum() or event.unicode in ['.', ':', '-']): 
                    current_input_text += event.unicode 
        
        if not app_status_obj.app_running: break 

        screen_surface.fill(getattr(C, 'BLACK', (0,0,0))) 
        
        prompt_text_surface = font_prompt_text.render("Enter Host IP Address or IP:Port", True, getattr(C, 'WHITE', (255,255,255)))
        screen_surface.blit(prompt_text_surface, prompt_text_surface.get_rect(
            center=(current_screen_width // 2, current_screen_height // 2 - 60))
        )
        
        info_text_surface = font_info_text.render("(Enter=Confirm, Esc=Cancel, Ctrl+V=Paste)", True, getattr(C, 'GRAY', (128,128,128)))
        screen_surface.blit(info_text_surface, info_text_surface.get_rect(
            center=(current_screen_width // 2, current_screen_height - 40))
        )

        pygame.draw.rect(screen_surface, getattr(C, 'GRAY', (128,128,128)), input_box_rect, border_radius=5) 
        pygame.draw.rect(screen_surface, getattr(C, 'WHITE', (255,255,255)), input_box_rect, 2, border_radius=5) 

        input_text_surface = font_input_field_text.render(current_input_text, True, getattr(C, 'BLACK', (0,0,0))) 
        input_text_rect_render = input_text_surface.get_rect(
            midleft=(input_box_rect.left + 10, input_box_rect.centery) 
        )
        
        # Clipping logic for text input field
        input_box_clipping_area = input_box_rect.inflate(-12, -12) # Small padding
        if input_text_rect_render.width > input_box_clipping_area.width: 
            input_text_rect_render.right = input_box_clipping_area.right # Scroll text left
        else: 
            input_text_rect_render.left = input_box_clipping_area.left # Align left if fits

        screen_surface.set_clip(input_box_clipping_area)
        screen_surface.blit(input_text_surface, input_text_rect_render)
        screen_surface.set_clip(None) # Reset clipping area

        # Draw cursor
        if is_cursor_visible:
            cursor_pos_x = input_text_rect_render.right + 2 # Position cursor after text
            # Ensure cursor stays within the visible input box area
            cursor_pos_x = max(input_box_clipping_area.left, 
                               min(cursor_pos_x, input_box_clipping_area.right - 1))
            pygame.draw.line(screen_surface, getattr(C, 'BLACK', (0,0,0)), 
                             (cursor_pos_x, input_box_rect.top + 5), 
                             (cursor_pos_x, input_box_rect.bottom - 5), 2) 
        
        # Display paste status message if any
        if paste_status_message and current_loop_time - paste_message_display_start_time < 2.0:
            paste_message_surf = font_info_text.render(paste_status_message, True, getattr(C, 'RED', (255,0,0)))
            screen_surface.blit(paste_message_surf, paste_message_surf.get_rect(
                center=(current_screen_width//2, input_box_rect.bottom + 30))
            )
        elif paste_status_message: # Clear message after timeout
            paste_status_message = None 
            
        pygame.display.flip() 
        clock_obj.tick(30) # Lower FPS for UI dialogs is fine
        
    pygame.key.set_repeat(0,0) # Disable key repeat when dialog closes
    
    return current_input_text.strip() if current_input_text is not None else None
########## END OF FILE: game_ui.py ##########

########## START OF FILE: items.py ##########

# items.py
# -*- coding: utf-8 -*-
"""
Defines collectible items like Chests.
Uses resource_path helper for PyInstaller compatibility.
"""
# version 1.00000.1
import pygame
import os
import sys # Needed for resource_path logic (imported via assets)
import random

# Import necessary components
import constants as C
# Import BOTH the loader AND the path helper from assets.py
from assets import load_gif_frames, resource_path

class Chest(pygame.sprite.Sprite):
    """
    A chest that restores player health when collected.
    """
    def __init__(self, x, y):
        super().__init__()

        # --- Define the relative path to the asset ---
        # This path is relative to the project root (or wherever resource_path resolves from)
        relative_chest_path = os.path.join('characters', 'items', 'chest.gif')

        # --- Use resource_path to get the correct full path ---
        # resource_path figures out if we're running bundled or locally
        full_chest_path = resource_path(relative_chest_path)
        print(f"Attempting to load chest GIF from resolved path: {full_chest_path}") # Debug print resolved path

        # --- Load frames using the full path ---
        self.frames = load_gif_frames(full_chest_path)

        # --- Error Handling and Placeholder ---
        # Check if loading failed OR if load_gif_frames returned its standard red placeholder
        # (assuming the standard placeholder size is 30x40 from assets.py)
        is_placeholder = False
        if self.frames and len(self.frames) == 1:
             placeholder_check_surf = self.frames[0]
             # Basic check based on size and maybe color (adjust size if your placeholder is different)
             if placeholder_check_surf.get_size() == (30, 40) and placeholder_check_surf.get_at((0,0)) == C.RED:
                 is_placeholder = True

        if not self.frames or is_placeholder:
            # Provide a specific fallback surface for the chest if loading fails OR returns default placeholder
            if not self.frames:
                print(f"Error: Failed to load chest from '{full_chest_path}'. Using placeholder.")
            else: # It returned a placeholder
                print(f"Warning: Chest loaded as a default placeholder from '{full_chest_path}'. Check file/path.")

            self.image = pygame.Surface((30, 30)).convert_alpha()
            self.image.fill(C.YELLOW) # Use a distinct placeholder color for chest issues
            pygame.draw.rect(self.image, C.BLACK, self.image.get_rect(), 1)
            pygame.draw.line(self.image, C.BLACK, (0, 0), (30, 30), 1) # Add cross to placeholder
            pygame.draw.line(self.image, C.BLACK, (0, 30), (30, 0), 1)
            self.frames = [self.image] # Make frames list contain the specific chest placeholder
            self._valid_init = False # Indicate potential issue, though it might still draw
        else:
            # Successfully loaded actual frames
            self.image = self.frames[0] # Use the first frame
            self._valid_init = True
            print(f"Successfully loaded {len(self.frames)} frame(s) for chest.")

        self.rect = self.image.get_rect(midbottom=(x, y))
        self.pos = pygame.math.Vector2(x, y) # Store position if needed later

        # Animation state
        self.current_frame = 0
        self.last_anim_update = pygame.time.get_ticks()
        self.is_collected = False # Flag to prevent multiple collections

    def update(self, dt):
        """ Handles animation if the GIF has multiple frames. dt is not used here yet. """
        # Don't animate if initialization potentially failed or only 1 frame (placeholder/static)
        if not self._valid_init or len(self.frames) <= 1:
            return

        now = pygame.time.get_ticks()
        # Adjust ANIM_FRAME_DURATION if chest animation speed should differ
        anim_speed_multiplier = 2 # Example: make chest animation slower than player/enemy
        if now - self.last_anim_update > C.ANIM_FRAME_DURATION * anim_speed_multiplier:
            self.last_anim_update = now
            self.current_frame = (self.current_frame + 1) % len(self.frames) # Loop animation
            current_midbottom = self.rect.midbottom # Store position anchor
            self.image = self.frames[self.current_frame]
            # Re-center rect if frame sizes change during animation (unlikely for simple items)
            self.rect = self.image.get_rect(midbottom=current_midbottom) # Re-anchor rect after getting new image

    def collect(self, player):
        """ Action when the player collects the chest. """
        # Only collect if properly initialized and not already collected
        if not self.is_collected and self._valid_init:
            print("Player collected chest!")
            # Ensure player has the heal_to_full method before calling it
            if hasattr(player, 'heal_to_full') and callable(player.heal_to_full):
                player.heal_to_full()
            else:
                print("Warning: Player object does not have 'heal_to_full' method.")
            self.is_collected = True
            self.kill() # Remove sprite from all groups it belongs to

########## START OF FILE: levels.py ##########

# levels.py
# -*- coding: utf-8 -*-
"""
levels.py
Returns sprite groups for platforms, ladders, hazards, spawns, level width,
and absolute min/max Y coordinates for the entire level.
"""
# version 1.0.0.9 (Added platform_type tags to all platforms)
import pygame
import random
from tiles import Platform, Ladder, Lava # Import tile classes
from constants import TILE_SIZE, GRAY, DARK_GREEN, ORANGE_RED, LAVA_PATCH_HEIGHT, BLACK
import constants as C # Already imported, but C alias is good practice

FENCE_WIDTH = 8
FENCE_HEIGHT = 15
FENCE_COLOR = GRAY

def _add_map_boundary_walls(platforms_group, map_total_width, all_content_sprites_list,
                            initial_screen_height_fallback, extra_sky_clearance=0):
    """
    Calculates content extents and adds TILE_SIZE thick boundary walls.
    map_total_width is the outer width including walls.
    extra_sky_clearance pushes the ceiling collision object higher.
    Returns min_y_overall, max_y_overall (absolute top/bottom of level including walls).
    """
    if not all_content_sprites_list:
        print("Warning: _add_map_boundary_walls called with empty content list. Using fallback extents.")
        min_y_content = 0 - TILE_SIZE * 5
        max_y_content = initial_screen_height_fallback
    else:
        all_rects = [s.rect for s in all_content_sprites_list if hasattr(s, 'rect')]
        if not all_rects:
            min_y_content = 0 - TILE_SIZE * 5
            max_y_content = initial_screen_height_fallback
        else:
            min_y_content = min(r.top for r in all_rects)
            max_y_content = max(r.bottom for r in all_rects)

    ceiling_object_top_y = min_y_content - TILE_SIZE - extra_sky_clearance
    level_min_y_abs = ceiling_object_top_y
    level_max_y_abs = max_y_content + TILE_SIZE
    boundary_box_height = level_max_y_abs - level_min_y_abs

    platforms_group.add(Platform(0, ceiling_object_top_y, map_total_width, TILE_SIZE, GRAY, platform_type="boundary"))
    platforms_group.add(Platform(0, max_y_content, map_total_width, TILE_SIZE, GRAY, platform_type="boundary"))
    platforms_group.add(Platform(0, level_min_y_abs, TILE_SIZE, boundary_box_height, GRAY, platform_type="boundary"))
    platforms_group.add(Platform(map_total_width - TILE_SIZE, level_min_y_abs, TILE_SIZE, boundary_box_height, GRAY, platform_type="boundary"))

    return level_min_y_abs, level_max_y_abs


def load_map_original(initial_width, initial_height):
    """ Creates the original level layout with boundary walls and colored ledges. """
    platforms = pygame.sprite.Group()
    ladders = pygame.sprite.Group()
    hazards = pygame.sprite.Group()
    enemy_spawns_data = []

    map_total_width = initial_width * 2.5
    player_spawn = (TILE_SIZE + 60, initial_height - TILE_SIZE - TILE_SIZE - 1)
    main_ground_y_ref = initial_height - TILE_SIZE
    main_ground_segment_height_ref = TILE_SIZE

    # Ground
    ground = Platform(TILE_SIZE, main_ground_y_ref, map_total_width - 2 * TILE_SIZE, main_ground_segment_height_ref, GRAY, platform_type="ground")
    platforms.add(ground)

    # Ledges
    platforms.add(Platform(TILE_SIZE + 160, initial_height - 150, 250, 20, DARK_GREEN, platform_type="ledge"))
    platforms.add(Platform(TILE_SIZE + 410, initial_height - 300, 180, 20, DARK_GREEN, platform_type="ledge"))
    platforms.add(Platform(min(map_total_width - TILE_SIZE - 200, TILE_SIZE + initial_width - 350), initial_height - 450, 200, 20, DARK_GREEN, platform_type="ledge"))
    platforms.add(Platform(min(map_total_width - TILE_SIZE - 150, TILE_SIZE + initial_width + 150), initial_height - 250, 150, 20, DARK_GREEN, platform_type="ledge"))
    platforms.add(Platform(TILE_SIZE + 860, initial_height - 550, 100, 20, DARK_GREEN, platform_type="ledge"))

    # Structural Wall
    wall_mid_x = TILE_SIZE + 760
    wall_mid_width = 30
    if wall_mid_x + wall_mid_width > map_total_width - TILE_SIZE:
        wall_mid_width = max(1, (map_total_width - TILE_SIZE) - wall_mid_x)
    platforms.add(Platform(wall_mid_x, initial_height - 400, wall_mid_width, 360, GRAY, platform_type="wall"))

    # Ladders
    ladder_width = 40
    ladder_height_main = 250
    ladders.add(Ladder(min(map_total_width - TILE_SIZE - ladder_width, TILE_SIZE + initial_width - 500),
                       main_ground_y_ref - ladder_height_main, ladder_width, ladder_height_main))
    ladders.add(Ladder(TILE_SIZE + 310, initial_height - 250, ladder_width, 150))

    all_content_sprites = list(platforms.sprites()) + list(ladders.sprites())
    level_min_y_abs, level_max_y_abs = _add_map_boundary_walls(platforms, map_total_width, all_content_sprites, initial_height, extra_sky_clearance=TILE_SIZE * 5)

    return platforms, ladders, hazards, enemy_spawns_data, player_spawn, \
           map_total_width, level_min_y_abs, level_max_y_abs, \
           main_ground_y_ref, main_ground_segment_height_ref

def load_map_lava(initial_width, initial_height):
    """ Creates a level with lava, boundary walls, and colored ledges. """
    platforms = pygame.sprite.Group()
    ladders = pygame.sprite.Group()
    hazards = pygame.sprite.Group()
    enemy_spawns_data = []
    map_total_width = initial_width * 2.8
    player_spawn_x = TILE_SIZE + 30
    player_spawn_y = initial_height - 120 - TILE_SIZE
    player_spawn = (player_spawn_x, player_spawn_y)
    main_ground_y_ref = initial_height - TILE_SIZE

    # Ledges
    platforms.add(Platform(TILE_SIZE, initial_height - 120, 150, 20, DARK_GREEN, platform_type="ledge"))
    platforms.add(Platform(TILE_SIZE + 260, initial_height - 180, 120, 20, DARK_GREEN, platform_type="ledge"))
    platforms.add(Platform(TILE_SIZE + 460, initial_height - 150, 100, 20, DARK_GREEN, platform_type="ledge"))
    platforms.add(Platform(TILE_SIZE + 660, initial_height - 200, 130, 20, DARK_GREEN, platform_type="ledge"))
    platforms.add(Platform(TILE_SIZE + 860, initial_height - 250, 100, 20, DARK_GREEN, platform_type="ledge"))
    platforms.add(Platform(TILE_SIZE + 1210, initial_height - 350, 150, 20, DARK_GREEN, platform_type="ledge"))
    platforms.add(Platform(TILE_SIZE + 1560, initial_height - 480, 200, 20, DARK_GREEN, platform_type="ledge"))

    # Structural Walls
    wall1_height = (main_ground_y_ref) - (initial_height - 400)
    platforms.add(Platform(TILE_SIZE + 1060, initial_height - 400, 30, wall1_height, GRAY, platform_type="wall"))
    wall2_height = (main_ground_y_ref) - (initial_height - 500)
    platforms.add(Platform(TILE_SIZE + 1410, initial_height - 500, 30, wall2_height, GRAY, platform_type="wall"))

    # Lava
    lava_y_surface = main_ground_y_ref
    hazards.add(Lava(TILE_SIZE, lava_y_surface, 1100 - TILE_SIZE, LAVA_PATCH_HEIGHT, ORANGE_RED))
    hazards.add(Lava(1130, lava_y_surface, 320, LAVA_PATCH_HEIGHT, ORANGE_RED))
    lava3_start_x = 1550
    lava3_width = (map_total_width - TILE_SIZE) - lava3_start_x
    if lava3_width > 0:
        hazards.add(Lava(lava3_start_x, lava_y_surface, lava3_width, LAVA_PATCH_HEIGHT, ORANGE_RED))

    all_content_sprites = list(platforms.sprites()) + list(hazards.sprites())
    level_min_y_abs, level_max_y_abs = _add_map_boundary_walls(platforms, map_total_width, all_content_sprites, initial_height, extra_sky_clearance=TILE_SIZE * 5)

    return platforms, ladders, hazards, enemy_spawns_data, player_spawn, \
           map_total_width, level_min_y_abs, level_max_y_abs, \
           main_ground_y_ref, 0

def load_map_cpu_extended(initial_width, initial_height):
    """
    Creates a larger level with CPU enemies, DEEP LAVA WELLS with fences,
    boundary walls, and colored ledges. Platform height adjusted.
    """
    platforms = pygame.sprite.Group()
    ladders = pygame.sprite.Group()
    hazards = pygame.sprite.Group()
    enemy_spawns_data = []
    map_total_width = initial_width * 3.5
    main_ground_y_ref = initial_height - TILE_SIZE
    main_ground_segment_height_ref = TILE_SIZE
    player_spawn = (TILE_SIZE * 2, main_ground_y_ref)
    gap_width_lava = TILE_SIZE * 4
    lava_collision_y_level = main_ground_y_ref + 1
    fence_y_pos = main_ground_y_ref - FENCE_HEIGHT

    # Ground Segments
    seg1_start_x = TILE_SIZE
    seg1_width = (initial_width * 0.7) - TILE_SIZE
    seg1_end_x = seg1_start_x + seg1_width
    platforms.add(Platform(seg1_start_x, main_ground_y_ref, seg1_width, main_ground_segment_height_ref, GRAY, platform_type="ground"))

    lava1_start_x = seg1_end_x
    lava1_width = gap_width_lava
    hazards.add(Lava(lava1_start_x, lava_collision_y_level, lava1_width, LAVA_PATCH_HEIGHT, ORANGE_RED))
    platforms.add(Platform(lava1_start_x - FENCE_WIDTH, fence_y_pos, FENCE_WIDTH, FENCE_HEIGHT, FENCE_COLOR, platform_type="fence"))
    platforms.add(Platform(lava1_start_x + lava1_width, fence_y_pos, FENCE_WIDTH, FENCE_HEIGHT, FENCE_COLOR, platform_type="fence"))

    seg2_start_x = lava1_start_x + lava1_width
    seg2_width = initial_width * 1.0
    seg2_end_x = seg2_start_x + seg2_width
    platforms.add(Platform(seg2_start_x, main_ground_y_ref, seg2_width, main_ground_segment_height_ref, GRAY, platform_type="ground"))

    lava2_start_x = seg2_end_x
    lava2_width = gap_width_lava * 0.8
    hazards.add(Lava(lava2_start_x, lava_collision_y_level, lava2_width, LAVA_PATCH_HEIGHT, ORANGE_RED))
    platforms.add(Platform(lava2_start_x - FENCE_WIDTH, fence_y_pos, FENCE_WIDTH, FENCE_HEIGHT, FENCE_COLOR, platform_type="fence"))
    platforms.add(Platform(lava2_start_x + lava2_width, fence_y_pos, FENCE_WIDTH, FENCE_HEIGHT, FENCE_COLOR, platform_type="fence"))

    seg3_start_x = lava2_start_x + lava2_width
    seg3_width = (map_total_width - TILE_SIZE) - seg3_start_x
    if seg3_width > 0:
        platforms.add(Platform(seg3_start_x, main_ground_y_ref, seg3_width, main_ground_segment_height_ref, GRAY, platform_type="ground"))

    # Floating Platforms (Ledges)
    plat1_x = TILE_SIZE + (initial_width * 0.3 - TILE_SIZE)
    plat1_x = max(seg1_start_x + TILE_SIZE, min(plat1_x, seg1_end_x - TILE_SIZE*7))
    platforms.add(Platform(plat1_x, main_ground_y_ref - TILE_SIZE * 1.8, TILE_SIZE * 6, TILE_SIZE * 0.5, DARK_GREEN, platform_type="ledge"))
    platforms.add(Platform(seg2_start_x + TILE_SIZE * 2, main_ground_y_ref - TILE_SIZE * 3, TILE_SIZE * 8, TILE_SIZE * 0.5, DARK_GREEN, platform_type="ledge"))
    platforms.add(Platform(seg3_start_x + TILE_SIZE * 4, main_ground_y_ref - TILE_SIZE * 5.5, TILE_SIZE * 7, TILE_SIZE * 0.5, DARK_GREEN, platform_type="ledge"))

    # Enemy Spawns
    spawn_y_on_ground = main_ground_y_ref - 1
    enemy1_x_pos = seg2_start_x + seg2_width * 0.5
    patrol_rect_enemy1 = pygame.Rect(
        seg2_start_x + TILE_SIZE, main_ground_y_ref - TILE_SIZE * 2,
        seg2_width - TILE_SIZE * 2, TILE_SIZE * 2
    )
    enemy_spawns_data.append({'pos': (enemy1_x_pos, spawn_y_on_ground), 'patrol': patrol_rect_enemy1})

    enemy2_platform_ref_x = seg2_start_x + TILE_SIZE * 2
    enemy2_platform = next((p for p in platforms if p.rect.left == enemy2_platform_ref_x and p.rect.width == TILE_SIZE * 8 and p.platform_type == "ledge"), None)
    if enemy2_platform:
        enemy2_x_pos = enemy2_platform.rect.centerx
        enemy2_y_pos = enemy2_platform.rect.top - 1
        enemy_spawns_data.append({'pos': (enemy2_x_pos, enemy2_y_pos), 'patrol': None})

    enemy3_x_pos = seg3_start_x + seg3_width * 0.3
    enemy_spawns_data.append({'pos': (enemy3_x_pos, spawn_y_on_ground), 'patrol': None})

    all_content_sprites = list(platforms.sprites()) + list(hazards.sprites())
    sky_clearance = TILE_SIZE * 10
    level_min_y_abs, level_max_y_abs = _add_map_boundary_walls(platforms, map_total_width, all_content_sprites, initial_height, extra_sky_clearance=sky_clearance)

    return platforms, ladders, hazards, enemy_spawns_data, player_spawn, \
           map_total_width, level_min_y_abs, level_max_y_abs, \
           main_ground_y_ref, main_ground_segment_height_ref

load_map_cpu = load_map_cpu_extended

# --- Test block for levels.py (if run directly) ---
if __name__ == '__main__':
    pygame.init()
    screen_width_test = 1000
    screen_height_test = 700
    test_screen = pygame.display.set_mode((screen_width_test, screen_height_test), pygame.RESIZABLE)

    test_platforms, test_ladders, test_hazards, test_enemy_spawns, test_player_spawn, \
    test_level_width, test_level_min_y, test_level_max_y, \
    test_main_ground_y, test_main_ground_h = \
        load_map_cpu_extended(screen_width_test, screen_height_test)
    pygame.display.set_caption("Level.py - Map Test (load_map_cpu_extended)")

    all_test_sprites = pygame.sprite.Group()
    all_test_sprites.add(test_platforms.sprites(), test_ladders.sprites(), test_hazards.sprites())

    if test_enemy_spawns:
        for spawn_info in test_enemy_spawns:
            spawn_pos = spawn_info['pos']
            enemy_placeholder = pygame.sprite.Sprite()
            enemy_placeholder.image = pygame.Surface((TILE_SIZE*0.5, TILE_SIZE*0.8))
            enemy_placeholder.image.fill(ORANGE_RED)
            enemy_placeholder.rect = enemy_placeholder.image.get_rect(midbottom=spawn_pos)
            all_test_sprites.add(enemy_placeholder)
            if spawn_info.get('patrol'):
                patrol_rect_vis = spawn_info['patrol'].copy()
                patrol_placeholder = pygame.sprite.Sprite()
                patrol_placeholder.image = pygame.Surface((patrol_rect_vis.width, patrol_rect_vis.height), pygame.SRCALPHA)
                patrol_placeholder.image.fill((255,0,255,50))
                pygame.draw.rect(patrol_placeholder.image, (255,0,255, 150), patrol_placeholder.image.get_rect(), 1)
                patrol_placeholder.rect = patrol_rect_vis
                all_test_sprites.add(patrol_placeholder)

    class TestDummyPlayer(pygame.sprite.Sprite):
        def __init__(self, x, y):
            super().__init__()
            self.image = pygame.Surface((TILE_SIZE * 0.75, TILE_SIZE))
            self.image.fill(DARK_GREEN)
            self.rect = self.image.get_rect(midbottom=(x,y))
            self.vel = pygame.math.Vector2(0,0)
            self.on_ground_flag = False
            self.gravity = C.PLAYER_GRAVITY
            self.jump_strength = C.PLAYER_JUMP_STRENGTH

        def update(self, platform_group_for_collision):
            self.vel.y += self.gravity
            if self.vel.y > C.TERMINAL_VELOCITY_Y: self.vel.y = C.TERMINAL_VELOCITY_Y
            pressed_keys = pygame.key.get_pressed()
            if pressed_keys[pygame.K_LEFT]: self.vel.x = -5
            elif pressed_keys[pygame.K_RIGHT]: self.vel.x = 5
            else: self.vel.x = 0
            if pressed_keys[pygame.K_UP] and self.on_ground_flag:
                self.vel.y = self.jump_strength
                self.on_ground_flag = False
            self.rect.x += self.vel.x
            self.test_collision_resolution('x', platform_group_for_collision)
            self.rect.y += self.vel.y
            self.on_ground_flag = False
            self.test_collision_resolution('y', platform_group_for_collision)

        def test_collision_resolution(self, direction, platform_group_to_collide_with):
            for plat in pygame.sprite.spritecollide(self, platform_group_to_collide_with, False):
                if plat.image.get_alpha() == 0 : continue
                if direction == 'x':
                    if self.vel.x > 0: self.rect.right = plat.rect.left
                    if self.vel.x < 0: self.rect.left = plat.rect.right
                    self.vel.x = 0
                if direction == 'y':
                    if self.vel.y > 0:
                        self.rect.bottom = plat.rect.top
                        self.on_ground_flag = True
                        self.vel.y = 0
                    if self.vel.y < 0:
                        self.rect.top = plat.rect.bottom
                        self.vel.y = 0

    dummy_test_player = TestDummyPlayer(test_player_spawn[0], test_player_spawn[1])
    all_test_sprites.add(dummy_test_player)
    camera_x_offset = 0
    camera_y_offset = 0
    test_game_running = True
    test_clock = pygame.time.Clock()
    effective_level_height_for_test = test_level_max_y - test_level_min_y

    while test_game_running:
        current_screen_width, current_screen_height = test_screen.get_size()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                test_game_running = False
            if event.type == pygame.VIDEORESIZE:
                 test_screen = pygame.display.set_mode((event.w, event.h), pygame.RESIZABLE)
        dummy_test_player.update(test_platforms)
        camera_x_offset = -dummy_test_player.rect.centerx + current_screen_width // 2
        camera_y_offset = -dummy_test_player.rect.centery + current_screen_height // 2
        camera_x_offset = min(0, camera_x_offset)
        if test_level_width > current_screen_width:
            camera_x_offset = max(-(test_level_width - current_screen_width), camera_x_offset)
        else:
            camera_x_offset = 0
        if effective_level_height_for_test <= current_screen_height:
            camera_y_offset = -(test_level_min_y + effective_level_height_for_test / 2 - current_screen_height / 2)
        else:
            camera_y_offset = min(-test_level_min_y, camera_y_offset)
            camera_y_offset = max(-(test_level_max_y - current_screen_height), camera_y_offset)
        test_screen.fill(BLACK)
        for sprite_to_draw in all_test_sprites:
            test_screen.blit(sprite_to_draw.image,
                             (sprite_to_draw.rect.x + camera_x_offset,
                              sprite_to_draw.rect.y + camera_y_offset))
        pygame.display.flip()
        test_clock.tick(60)
    pygame.quit()

########## START OF FILE: main.py ##########

# main.py
# -*- coding: utf-8 -*-
## version 1.0.0.3 (Moved pygame.scrap.init(), updated game_elements keys, camera screen update)
# -*- coding: utf-8 -*-
import sys
import os
import pygame
import traceback # For detailed error logging

# --- Pyperclip Check ---
PYPERCLIP_AVAILABLE_MAIN = False
try:
    import pyperclip
    PYPERCLIP_AVAILABLE_MAIN = True
    print("Pyperclip library found and imported successfully for main.")
except ImportError:
    print("Main: Pyperclip library not found (pip install pyperclip). Paste in UI may be limited.")

# --- Platformer Game Module Imports ---
try:
    import constants as C
    from camera import Camera
    from items import Chest
    import levels as LevelLoader
    from game_setup import initialize_game_elements
    from server_logic import ServerState, run_server_mode
    from client_logic import ClientState, run_client_mode
    from couch_play_logic import run_couch_play_mode
    import game_ui # For main menu, input dialog, and scene drawing

    print("Platformer modules imported successfully.")
except ImportError as e:
    print(f"FATAL MAIN: Failed to import a required platformer module: {e}")
    traceback.print_exc()
    sys.exit(1)
except Exception as e:
    print(f"FATAL MAIN: An unexpected error occurred during platformer module imports: {e}")
    traceback.print_exc()
    sys.exit(1)

# --- Pygame Initialization ---
os.environ['SDL_VIDEO_WINDOW_POS'] = '0,0' # Attempt to position window at top-left
pygame.init() # Initialize all Pygame modules (sound, font, etc.)
pygame.font.init() # Explicitly initialize font module

# --- Application State Object ---
class AppStatus:
    """Simple object to hold the global application running flag."""
    def __init__(self):
        self.app_running = True

# --- Display Setup ---
try:
    display_info = pygame.display.Info()
    monitor_width = display_info.current_w
    monitor_height = display_info.current_h
    initial_width = max(800, min(1600, monitor_width * 3 // 4))
    initial_height = max(600, min(900, monitor_height * 3 // 4))
    WIDTH, HEIGHT = initial_width, initial_height
    screen_flags = pygame.RESIZABLE | pygame.DOUBLEBUF
    screen = pygame.display.set_mode((WIDTH, HEIGHT), screen_flags)
    pygame.display.set_caption("Platformer Adventure LAN")
    print(f"Initial window dimensions: {WIDTH}x{HEIGHT}")
except Exception as e:
    print(f"FATAL MAIN: Error setting up Pygame display: {e}")
    pygame.quit()
    sys.exit(1)

# --- Pygame Scrap Initialization (AFTER display is set up) ---
SCRAP_INITIALIZED_MAIN = False
try:
    pygame.scrap.init() 
    SCRAP_INITIALIZED_MAIN = pygame.scrap.get_init()
    if SCRAP_INITIALIZED_MAIN: print("Main: pygame.scrap clipboard module initialized successfully.")
    else: print("Main Warning: pygame.scrap initialized but status check failed (video system likely not ready when first called).")
except AttributeError: 
    print("Main Warning: pygame.scrap module not found or available on this system.")
except pygame.error as e: # Catches specific Pygame errors, e.g., "video system not initialized"
    print(f"Main Warning: pygame.scrap module could not be initialized: {e}")
except Exception as e: 
    print(f"Main Warning: An unexpected error occurred during pygame.scrap init: {e}")


# --- Global Game Variables (managed primarily within game modes) ---
game_elements = {
    "player1": None, "player2": None, "camera": None,
    "current_chest": None, "enemy_list": [],
    "platform_sprites": pygame.sprite.Group(),
    "ladder_sprites": pygame.sprite.Group(),
    "hazard_sprites": pygame.sprite.Group(),
    "enemy_sprites": pygame.sprite.Group(),
    "collectible_sprites": pygame.sprite.Group(),
    "projectile_sprites": pygame.sprite.Group(),
    "all_sprites": pygame.sprite.Group(),
    # These will be properly updated by initialize_game_elements from level data
    "level_pixel_width": WIDTH, 
    "level_min_y_absolute": 0, 
    "level_max_y_absolute": HEIGHT,
    "ground_level_y": HEIGHT - C.TILE_SIZE if 'C' in globals() and C.TILE_SIZE else HEIGHT - 40,
    "ground_platform_height": C.TILE_SIZE if 'C' in globals() and C.TILE_SIZE else 40,
    "player1_spawn_pos": (100, HEIGHT - (C.TILE_SIZE*2 if 'C' in globals() and C.TILE_SIZE else 80)),
    "player2_spawn_pos": (150, HEIGHT - (C.TILE_SIZE*2 if 'C' in globals() and C.TILE_SIZE else 80)),
    "enemy_spawns_data_cache": []
}

# --- Main Execution ---
if __name__ == "__main__":
    main_clock = pygame.time.Clock()
    app_status = AppStatus()

    fonts = {
        "small": None, "medium": None, "large": None, "debug": None
    }
    try:
        fonts["small"] = pygame.font.Font(None, 28)
        fonts["medium"] = pygame.font.Font(None, 36)
        fonts["large"] = pygame.font.Font(None, 72)
        fonts["debug"] = pygame.font.Font(None, 20)
        if any(f is None for f in fonts.values()): # Check if any font failed to load
            raise pygame.error("One or more default fonts failed to load.")
        print("Fonts loaded successfully.")
    except pygame.error as e:
        print(f"FATAL MAIN: Font loading error: {e}. Ensure Pygame font module is working.")
        app_status.app_running = False 
    except Exception as e:
        print(f"FATAL MAIN: Unexpected error during font loading: {e}")
        app_status.app_running = False

    # --- Main Application Loop ---
    while app_status.app_running:
        current_screen_width, current_screen_height = screen.get_size()
        pygame.display.set_caption("Platformer Adventure - Main Menu")
        
        menu_choice = game_ui.show_main_menu(screen, main_clock, fonts, app_status)
        
        if not app_status.app_running or menu_choice == "quit":
            app_status.app_running = False
            break

        initialized_elements = initialize_game_elements(
            current_screen_width, current_screen_height, 
            for_game_mode=menu_choice,
            existing_sprites_groups={ 
                "all_sprites": game_elements["all_sprites"],
                "projectile_sprites": game_elements["projectile_sprites"],
                "player1": game_elements.get("player1"), 
                "player2": game_elements.get("player2"),
                "current_chest": game_elements.get("current_chest")
            }
        )

        if initialized_elements is None:
            print(f"Main Error: Failed to initialize game elements for mode '{menu_choice}'. Returning to menu.")
            # Use getattr for constants in case C failed to load, providing a fallback
            screen.fill(getattr(C, 'BLACK', (0,0,0))) 
            if fonts.get("medium"):
                err_text = f"Error starting {menu_choice} mode."
                err_color = getattr(C, 'RED', (255,0,0))
                err_surf = fonts["medium"].render(err_text, True, err_color)
                screen.blit(err_surf, err_surf.get_rect(center=(current_screen_width//2, current_screen_height//2)))
            pygame.display.flip()
            pygame.time.wait(3000)
            continue

        game_elements.update(initialized_elements)
        
        # Ensure camera knows about current screen dimensions, especially after potential resize
        if game_elements.get("camera"):
            # The camera was initialized with screen_width/height from initialize_game_elements
            # but if the screen was resized *while in the menu*, this updates it.
            if hasattr(game_elements["camera"], "set_screen_dimensions"):
                 game_elements["camera"].set_screen_dimensions(current_screen_width, current_screen_height)
            else: # Fallback if method doesn't exist (older camera version)
                 game_elements["camera"].screen_width = current_screen_width
                 game_elements["camera"].screen_height = current_screen_height
                 game_elements["camera"].camera_rect.width = current_screen_width
                 game_elements["camera"].camera_rect.height = current_screen_height


        # --- Launch the selected game mode ---
        if menu_choice == "host":
            server_state = ServerState() 
            server_state.app_running = app_status.app_running 
            run_server_mode(screen, main_clock, fonts, game_elements, server_state)
            app_status.app_running = server_state.app_running
        
        elif menu_choice == "join_lan":
            client_state = ClientState() 
            client_state.app_running = app_status.app_running
            run_client_mode(screen, main_clock, fonts, game_elements, client_state, target_ip_port_str=None)
            app_status.app_running = client_state.app_running
            
        elif menu_choice == "join_ip":
            target_ip_input = game_ui.get_server_ip_input_dialog( 
                screen, main_clock, fonts, app_status, default_input_text="127.0.0.1:5555" # MODIFIED HERE
            )
            if target_ip_input and app_status.app_running: 
                client_state = ClientState()
                client_state.app_running = app_status.app_running
                run_client_mode(screen, main_clock, fonts, game_elements, client_state, target_ip_port_str=target_ip_input)
                app_status.app_running = client_state.app_running
            elif not app_status.app_running: 
                 print("Main: IP input cancelled due to application quit.")
                 break 
            
        elif menu_choice == "couch_play":
            run_couch_play_mode(screen, main_clock, fonts, game_elements, app_status)

    # --- Application Cleanup ---
    print("Main: Exiting application gracefully.")
    pygame.quit()
    if SCRAP_INITIALIZED_MAIN:
        try:
            if pygame.scrap.get_init(): # Check again before quitting
                pygame.scrap.quit()
        except Exception as e: # Catch any error during scrap.quit
            print(f"Main Warning: Error during pygame.scrap.quit(): {e}")
    sys.exit(0)

########## START OF FILE: network_comms.py ##########

# network_comms.py
# -*- coding: utf-8 -*-
# version 1.0000000.1
"""
Networking utilities for data encoding/decoding and IP retrieval.
"""
import socket
import json

def get_local_ip():
    """Gets the local IP address of the machine."""
    best_ip = '127.0.0.1'
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.connect(("8.8.8.8", 80)) # Connect to a known external server (doesn't send data)
        best_ip = s.getsockname()[0]
        s.close()
    except Exception:
        try:
            best_ip = socket.gethostbyname(socket.gethostname())
        except Exception:
            best_ip = '127.0.0.1' # Fallback
    return best_ip

def encode_data(data):
    """Encodes Python dictionary to JSON bytes with a newline delimiter."""
    try:
        return json.dumps(data).encode('utf-8') + b'\n'
    except TypeError as e:
        print(f"Encoding Error: {e} Data: {str(data)[:100]}")
        return None
    except Exception as e:
        print(f"Unexpected Encoding Error: {e}")
        return None

def decode_data_stream(byte_buffer):
    """
    Decodes a stream of newline-delimited JSON byte data.
    Returns a list of decoded objects and the remaining unparsed buffer.
    """
    decoded_objects = []
    remaining_buffer = byte_buffer
    while b'\n' in remaining_buffer:
        message, remaining_buffer = remaining_buffer.split(b'\n', 1)
        if not message:  # Skip empty messages (e.g. if multiple newlines)
            continue
        try:
            decoded_objects.append(json.loads(message.decode('utf-8')))
        except json.JSONDecodeError as e:
            # print(f"JSON Decode Error: {e}. Malformed message: {message[:100]}") # Optional: log malformed
            continue # Skip malformed JSON
        except Exception as e:
            # print(f"Unexpected Decode Error: {e}. Message: {message[:100]}") # Optional: log other errors
            continue
    return decoded_objects, remaining_buffer

########## START OF FILE: player.py ##########

########## START OF FILE: player.py ##########

# player.py
# -*- coding: utf-8 -*-
"""
## version 1.0000000.1
Defines the Player class, handling core attributes, physics, animation,
and state transitions. Delegates input, combat, and network handling
to respective handler modules for improved organization.
"""
import pygame
import os # Not strictly needed here if assets.py handles all pathing
import sys # Not strictly needed here
import math
# import time # Only if PrintLimiter was defined directly in this file

from utils import PrintLimiter # Use the shared PrintLimiter from utils.py
import constants as C # Game constants
from assets import load_all_player_animations # For loading player sprites
from tiles import Lava # For type checking in hazard collision

# Import handler modules that contain functions operating on the Player instance
from player_input_handler import process_player_input_logic
from player_combat_handler import (fire_player_fireball, check_player_attack_collisions, 
                                   player_take_damage, player_self_inflict_damage, player_heal_to_full)
from player_network_handler import (get_player_network_data, set_player_network_data, 
                                    handle_player_network_input, get_player_input_state_for_network)


class Player(pygame.sprite.Sprite):
    """
    Represents a player character in the game.
    Manages player's state, animation, physics, and interactions.
    Delegates complex input, combat, and network logic to specialized handlers.
    """
    print_limiter = PrintLimiter(default_limit=5, default_period=3.0) # Class-level limiter for player messages

    def __init__(self, start_x, start_y, player_id=1):
        super().__init__()
        self.player_id = player_id
        self._valid_init = True # Flag to indicate if initialization was successful
        print(f"DEBUG Player (init P{self.player_id}): Initializing at ({start_x}, {start_y})") # DEBUG

        # --- Determine Asset Folder based on Player ID ---
        if self.player_id == 1: asset_folder_path = 'characters/player1'
        elif self.player_id == 2: asset_folder_path = 'characters/player2'
        else: # Fallback for any other player_id
            asset_folder_path = 'characters/player1' # Default to player1 assets
            if Player.print_limiter.can_print(f"player_init_unrecognized_id_{self.player_id}"):
                print(f"Player Info ({self.player_id}): Unrecognized ID. Defaulting to player1 assets from '{asset_folder_path}'.")
        
        print(f"DEBUG Player (init P{self.player_id}): Asset folder path: '{asset_folder_path}'") # DEBUG
        # --- Load Animations ---
        self.animations = load_all_player_animations(relative_asset_folder=asset_folder_path)
        if self.animations is None: # Critical failure if essential animations (like idle) are missing
            print(f"CRITICAL Player Init Error ({self.player_id}): Failed to load critical animations from '{asset_folder_path}'. Player will be invalid.")
            # Create a minimal placeholder image for error representation
            self.image = pygame.Surface((30, 40)).convert_alpha()
            self.image.fill(C.RED) # Red indicates error
            self.rect = self.image.get_rect(midbottom=(start_x, start_y))
            self.is_dead = True; self._valid_init = False # Mark as invalid and stop further initialization
            print(f"DEBUG Player (init P{self.player_id}): Animation load FAILED. _valid_init set to False.") # DEBUG
            return

        print(f"DEBUG Player (init P{self.player_id}): Animations loaded. Number of animation states: {len(self.animations)}") # DEBUG
        if 'idle' not in self.animations or not self.animations['idle']: # DEBUG
            print(f"DEBUG Player (init P{self.player_id}): CRITICAL - 'idle' animation missing after load_all_player_animations returned non-None.") # DEBUG


        # --- Initialize Core Attributes ---
        # Standard height (from idle animation, used for some calculations)
        try: self.standard_height = self.animations['idle'][0].get_height()
        except (KeyError, IndexError, TypeError): # Handle if 'idle' animation is missing or empty
            self.standard_height = 60 # Fallback height
            if Player.print_limiter.can_print(f"player_init_idle_height_warning_{self.player_id}"):
                print(f"Player Warning ({self.player_id}): Could not get idle animation height, using default {self.standard_height}.")

        # Animation and State Variables
        self._last_facing_right = True # Tracks last facing direction for image flipping (True for right)
        self._last_state_for_debug = "init" # For debugging state transitions
        self.state = 'idle'      # Current logical state of the player
        self.current_frame = 0   # Index of the current animation frame
        self.last_anim_update = pygame.time.get_ticks() # Timestamp of last animation frame update

        # Set initial image (first frame of idle animation)
        idle_animation_frames = self.animations.get('idle')
        if idle_animation_frames and len(idle_animation_frames) > 0:
            self.image = idle_animation_frames[0]
            print(f"DEBUG Player (init P{self.player_id}): Initial image set from 'idle' animation, frame 0. Image size: {self.image.get_size()}") # DEBUG
        else: # Fallback if idle animation is missing (should be caught by load_all_player_animations)
            self.image = pygame.Surface((30,40)); self.image.fill(C.RED) # Error placeholder
            print(f"CRITICAL Player Init Error ({self.player_id}): 'idle' animation missing or empty after loader. Player invalid.")
            self._valid_init = False; return

        self.rect = self.image.get_rect(midbottom=(start_x, start_y)) # Player's collision rectangle
        print(f"DEBUG Player (init P{self.player_id}): Initial rect: {self.rect}") # DEBUG
        
        # Physics and Movement Attributes
        self.pos = pygame.math.Vector2(start_x, start_y) # Precise position (floating point)
        self.vel = pygame.math.Vector2(0, 0)             # Current velocity
        self.acc = pygame.math.Vector2(0, C.PLAYER_GRAVITY) # Current acceleration (gravity applied by default)
        self.facing_right = True   # True if facing right, False if facing left
        self.on_ground = False     # True if standing on a solid platform
        self.on_ladder = False     # True if currently on a ladder
        self.can_grab_ladder = False # True if overlapping a ladder and can interact
        self.touching_wall = 0       # -1 for left wall, 1 for right wall, 0 for no wall contact
        self.can_wall_jump = False   # True if conditions for a wall jump are met
        self.wall_climb_timer = 0    # Timer for wall climb duration ability

        # Player State Flags and Timers (for actions like dash, roll, attack, etc.)
        self.is_crouching = False
        self.is_dashing = False; self.dash_timer = 0; self.dash_duration = getattr(C, 'PLAYER_DASH_DURATION', 150) # ms
        self.is_rolling = False; self.roll_timer = 0; self.roll_duration = getattr(C, 'PLAYER_ROLL_DURATION', 300) # ms
        self.is_sliding = False; self.slide_timer = 0; self.slide_duration = getattr(C, 'PLAYER_SLIDE_DURATION', 400) # ms
        
        self.is_attacking = False; self.attack_timer = 0; self.attack_duration = 300 # ms, duration varies by attack type
        self.attack_type = 0 # 0:none, 1:attack1, 2:attack2, 3:combo, 4:crouch_attack
        self.can_combo = False # Flag indicating if player is in a window to perform a combo attack
        self.combo_window = getattr(C, 'PLAYER_COMBO_WINDOW', 150) # ms time window for combo input

        self.wall_climb_duration = getattr(C, 'PLAYER_WALL_CLIMB_DURATION', 500) # Max ms for a wall climb attempt

        self.is_taking_hit = False; self.hit_timer = 0 # Timer for current hit stun / invincibility period
        self.hit_duration = getattr(C, 'PLAYER_HIT_STUN_DURATION', 300) # ms duration of the hit stun animation/effect
        self.hit_cooldown = getattr(C, 'PLAYER_HIT_COOLDOWN', 600)   # ms total invincibility period after being hit

        self.is_dead = False # True if player's health is zero or less
        self.death_animation_finished = False # True when the death animation sequence has completed
        self.state_timer = 0 # General timer that can be used by states for duration tracking

        # Health and Combat
        self.max_health = C.PLAYER_MAX_HEALTH
        self.current_health = self.max_health
        self.attack_hitbox = pygame.Rect(0, 0, 45, 30) # Default size, positioned dynamically during attack checks

        # Input State Flags (primarily set by input handlers, read by update/state logic)
        self.is_trying_to_move_left = False
        self.is_trying_to_move_right = False
        self.is_holding_climb_ability_key = False # Usually 'up' key, for climbing ladders/walls
        self.is_holding_crouch_ability_key = False # Usually 'down' key, for crouching/sliding

        # Fireball / Projectile Attributes
        self.fireball_cooldown_timer = 0 # Timestamp of last fireball fired (for cooldown)
        self.fireball_last_input_dir = pygame.math.Vector2(1.0 if self.facing_right else -1.0, 0.0) # Default aim direction
        self.projectile_sprites_group = None # Reference to game's projectile group (set by main game)
        self.all_sprites_group = None      # Reference to game's all_sprites group (set by main game)
        
        # Player-specific key for firing fireball (allows different keys for P1/P2)
        self.fireball_key = None 
        if self.player_id == 1: self.fireball_key = getattr(C, 'P1_FIREBALL_KEY', pygame.K_1)
        elif self.player_id == 2: self.fireball_key = getattr(C, 'P2_FIREBALL_KEY', pygame.K_0)
        print(f"DEBUG Player (init P{self.player_id}): Init completed. _valid_init: {self._valid_init}") # DEBUG


    def set_projectile_group_references(self, projectile_group: pygame.sprite.Group, 
                                        all_sprites_group: pygame.sprite.Group):
        """
        Called by the main game setup to provide the Player instance with references
        to the sprite groups needed for managing projectiles.
        """
        self.projectile_sprites_group = projectile_group
        self.all_sprites_group = all_sprites_group

    def set_state(self, new_state: str):
        """
        Sets the player's logical and animation state, handling transitions and
        state-specific initializations.

        Args:
            new_state (str): The key for the new state (e.g., 'idle', 'run', 'attack').
        """
        if not self._valid_init: return # Cannot change state if player init failed
        
        original_new_state_request = new_state # For debugging purposes

        # --- Validate that the requested animation state exists; fallback if necessary ---
        animation_frames_for_new_state = self.animations.get(new_state)
        if not animation_frames_for_new_state: # Animation for new_state doesn't exist or is empty
            # Determine a sensible fallback state
            fallback_state_key = 'fall' if not self.on_ground else 'idle'
            if fallback_state_key in self.animations and self.animations[fallback_state_key]:
                new_state = fallback_state_key # Use idle/fall as fallback
                if Player.print_limiter.can_print(f"player_set_state_fallback_{self.player_id}_{original_new_state_request}"):
                    print(f"Player Warning ({self.player_id}): State '{original_new_state_request}' anim missing. Fallback to '{new_state}'.")
            else: # Critical: Even idle/fall animations are missing (should be caught by asset loader)
                first_available_anim_key = next((key for key, anim in self.animations.items() if anim), None)
                if not first_available_anim_key: # No animations loaded at all
                    if Player.print_limiter.can_print(f"player_set_state_no_anims_{self.player_id}"):
                        print(f"CRITICAL Player Error ({self.player_id}): No animations available in set_state. Requested: '{original_new_state_request}'. Player invalid.")
                    self._valid_init = False; return # Player cannot function
                new_state = first_available_anim_key # Use the first available animation as a last resort
                if Player.print_limiter.can_print(f"player_set_state_critical_fallback_{self.player_id}"):
                    print(f"Player CRITICAL Warning ({self.player_id}): State '{original_new_state_request}' and fallbacks missing. Using first available: '{new_state}'.")
        
        # --- Determine if a state change is allowed/needed ---
        # Can change if new state is different, OR if it's 'death' (can re-trigger death anim),
        # AND not already dead with death animation finished (unless new state is 'death' itself).
        can_change_state_now = (self.state != new_state or new_state == 'death') and \
                               not (self.is_dead and self.death_animation_finished and new_state != 'death')

        if can_change_state_now:
            # print(f"DEBUG Player ({self.player_id}): Set State: '{self.state}' -> '{new_state}' (Req: '{original_new_state_request}'). Pos: {self.pos.x:.1f},{self.pos.y:.1f}, Vel: {self.vel.x:.1f},{self.vel.y:.1f}") # DEBUG
            self._last_state_for_debug = new_state # Update debug tracker
            
            # --- Reset flags for states the player is exiting ---
            if 'attack' not in new_state and self.is_attacking: self.is_attacking = False; self.attack_type = 0
            if new_state != 'hit': self.is_taking_hit = False # Clear general hit stun if not entering 'hit' state
            if new_state != 'dash': self.is_dashing = False
            if new_state != 'roll': self.is_rolling = False
            if new_state not in ['slide', 'slide_trans_start', 'slide_trans_end']: self.is_sliding = False

            # --- Set the new state and reset animation frame/timers ---
            self.state = new_state
            self.current_frame = 0 # Start animation from the beginning
            self.last_anim_update = pygame.time.get_ticks() # Reset animation timer
            self.state_timer = pygame.time.get_ticks()      # General timer for this new state

            # --- State-Specific Initialization Logic (executed when entering a new state) ---
            if new_state == 'dash':
                self.is_dashing = True; self.dash_timer = self.state_timer # Record dash start time
                self.vel.x = C.PLAYER_DASH_SPEED * (1 if self.facing_right else -1) # Apply dash velocity
                self.vel.y = 0 # Dash is purely horizontal
            elif new_state == 'roll':
                 self.is_rolling = True; self.roll_timer = self.state_timer
                 # Give a speed boost if rolling from standstill or slow movement
                 if abs(self.vel.x) < C.PLAYER_ROLL_SPEED / 2: self.vel.x = C.PLAYER_ROLL_SPEED * (1 if self.facing_right else -1)
                 elif abs(self.vel.x) < C.PLAYER_ROLL_SPEED: self.vel.x += (C.PLAYER_ROLL_SPEED / 3) * (1 if self.facing_right else -1)
                 self.vel.x = max(-C.PLAYER_ROLL_SPEED, min(C.PLAYER_ROLL_SPEED, self.vel.x)) # Clamp to roll speed limit
            elif new_state == 'slide' or new_state == 'slide_trans_start': # Entering slide
                 self.is_sliding = True; self.slide_timer = self.state_timer
                 # Ensure some initial speed if sliding from a slow run (input handler might also do this)
                 if abs(self.vel.x) < C.PLAYER_RUN_SPEED_LIMIT * 0.5:
                     self.vel.x = C.PLAYER_RUN_SPEED_LIMIT * 0.6 * (1 if self.facing_right else -1)
            elif 'attack' in new_state: # Covers all attack variations (attack, attack_nm, attack2, etc.)
                self.is_attacking = True; self.attack_timer = self.state_timer # Record attack start time
                # Calculate attack duration based on animation frames and speed modifier (if any)
                animation_for_this_attack = self.animations.get(new_state)
                num_attack_frames = len(animation_for_this_attack) if animation_for_this_attack else 0
                base_ms_per_frame = C.ANIM_FRAME_DURATION
                
                # Attack 2 might have a different speed (longer frame duration)
                if self.attack_type == 2 and hasattr(C, 'PLAYER_ATTACK2_FRAME_DURATION_MULTIPLIER'):
                    self.attack_duration = num_attack_frames * int(base_ms_per_frame * C.PLAYER_ATTACK2_FRAME_DURATION_MULTIPLIER) if num_attack_frames > 0 else 300 # Default duration
                else:
                    self.attack_duration = num_attack_frames * base_ms_per_frame if num_attack_frames > 0 else 300
                
                # Stop horizontal movement for "No Movement" (_nm) attacks or crouch attacks
                if new_state.endswith('_nm') or new_state == 'crouch_attack':
                    self.vel.x = 0
            elif new_state == 'hit': # Player is hit
                 self.is_taking_hit = True; self.hit_timer = self.state_timer # Start hit stun / invincibility timer
                 # Apply knockback/stun effect physics
                 if not self.on_ground and self.vel.y > -abs(C.PLAYER_JUMP_STRENGTH * 0.5): # If in air and not strongly ascending
                    self.vel.x *= -0.3 # Slight horizontal knockback in opposite direction of current vel
                    self.vel.y = C.PLAYER_JUMP_STRENGTH * 0.4 # Slight vertical pop-up
                 self.is_attacking = False; self.attack_type = 0 # Cancel any current attack
            elif new_state == 'death' or new_state == 'death_nm': # Player dies
                 self.is_dead = True; self.vel.x = 0 # Stop horizontal movement
                 if self.vel.y < -1: self.vel.y = 1 # Stop strong upward momentum (e.g., if died mid-jump)
                 self.acc.x = 0 # No horizontal acceleration during death
                 if not self.on_ground: self.acc.y = C.PLAYER_GRAVITY # Normal gravity if dying in air
                 else: self.vel.y = 0; self.acc.y = 0 # Rest on ground if already there
                 self.death_animation_finished = False # Reset death animation flag
            elif new_state == 'wall_climb':
                 self.wall_climb_timer = self.state_timer # Start wall climb duration timer
                 self.vel.y = C.PLAYER_WALL_CLIMB_SPEED # Apply wall climb speed
            elif new_state == 'wall_slide' or new_state == 'wall_hang':
                 self.wall_climb_timer = 0 # Reset wall climb timer if sliding or hanging (not actively climbing up)

            self.animate() # Update player image immediately to reflect the new state
        
        elif not self.is_dead: # If state didn't change but player is not dead
             self._last_state_for_debug = self.state # Keep debug state current


    def animate(self):
        """
        Updates the player's current image based on its state, frame, and facing direction.
        Handles animation looping, transitions at the end of non-looping animations,
        and image flipping.
        """
        if not self._valid_init or not hasattr(self, 'animations') or not self.animations:
            # print(f"DEBUG Player (animate P{self.player_id}): Animation skipped. Valid: {self._valid_init}, HasAnims: {hasattr(self, 'animations')}, AnimsOK: {bool(self.animations if hasattr(self, 'animations') else False)}") # DEBUG
            return
        if not self.alive(): # Don't animate if sprite is not in any groups (e.g., after self.kill())
            # print(f"DEBUG Player (animate P{self.player_id}): Animation skipped, player not alive (not in groups).") # DEBUG
            return 

        current_time_ms = pygame.time.get_ticks()
        animation_key_to_use = self.state # Start with the player's current logical state

        # --- Determine the correct animation key based on current state and conditions ---
        # This complex logic maps the player's detailed situation to specific animation sheet keys.
        player_is_intending_to_move_lr = self.is_trying_to_move_left or self.is_trying_to_move_right

        if self.is_dead: 
            # Choose between death animation with movement (_nm for No Movement) or static death animation
            animation_key_to_use = 'death_nm' if abs(self.vel.x) < 0.5 and abs(self.vel.y) < 1.0 and \
                                     'death_nm' in self.animations and self.animations['death_nm'] \
                                  else 'death'
            if animation_key_to_use not in self.animations or not self.animations[animation_key_to_use]:
                animation_key_to_use = 'death' # Fallback if preferred death animation is missing
        elif self.is_attacking:
            # Choose attack animation based on attack_type and if player is intending to move
            if self.attack_type == 1: animation_key_to_use = 'attack' if player_is_intending_to_move_lr and 'attack' in self.animations and self.animations['attack'] else 'attack_nm'
            elif self.attack_type == 2: animation_key_to_use = 'attack2' if player_is_intending_to_move_lr and 'attack2' in self.animations and self.animations['attack2'] else 'attack2_nm'
            elif self.attack_type == 3: animation_key_to_use = 'attack_combo' if player_is_intending_to_move_lr and 'attack_combo' in self.animations and self.animations['attack_combo'] else 'attack_combo_nm'
            elif self.attack_type == 4: animation_key_to_use = 'crouch_attack'
            
            # Fallback if specific attack_nm (No Movement) or standard attack animation is missing
            if animation_key_to_use not in self.animations or not self.animations[animation_key_to_use]:
                 base_attack_state_key = animation_key_to_use.replace('_nm', '') # Try without '_nm' suffix
                 if base_attack_state_key in self.animations and self.animations[base_attack_state_key]:
                     animation_key_to_use = base_attack_state_key
                 else: # Ultimate fallback for attack animations
                     animation_key_to_use = 'idle' 
        elif self.state == 'wall_climb': # Specific logic for wall climb animation
             player_is_actively_climbing_wall = self.is_holding_climb_ability_key and \
                                    abs(self.vel.y - C.PLAYER_WALL_CLIMB_SPEED) < 0.1 # Check if actually moving upwards
             animation_key_to_use = 'wall_climb' if player_is_actively_climbing_wall and 'wall_climb' in self.animations and self.animations['wall_climb'] else 'wall_climb_nm'
             if animation_key_to_use not in self.animations or not self.animations[animation_key_to_use]:
                 animation_key_to_use = 'wall_climb' # Fallback to base wall_climb if _nm variant missing
        elif self.state == 'hit': animation_key_to_use = 'hit' # Standard hit animation
        elif not self.on_ground and not self.on_ladder and self.touching_wall == 0 and \
             self.state not in ['jump', 'jump_fall_trans'] and self.vel.y > 1: # Standard falling animation
             animation_key_to_use = 'fall'
        elif self.on_ladder: # Ladder animations
            animation_key_to_use = 'ladder_climb' if abs(self.vel.y) > 0.1 else 'ladder_idle' # Moving or idle on ladder
            if animation_key_to_use not in self.animations or not self.animations[animation_key_to_use]:
                animation_key_to_use = 'idle' # Fallback if specific ladder animations are missing
        # Direct state-to-animation key mappings for special movement/action states
        elif self.is_dashing: animation_key_to_use = 'dash'
        elif self.is_rolling: animation_key_to_use = 'roll'
        elif self.is_sliding: animation_key_to_use = 'slide' # Main sliding animation
        elif self.state == 'slide_trans_start': animation_key_to_use = 'slide_trans_start'
        elif self.state == 'slide_trans_end': animation_key_to_use = 'slide_trans_end'
        elif self.state == 'crouch_trans': animation_key_to_use = 'crouch_trans'
        elif self.state == 'turn': animation_key_to_use = 'turn'
        elif self.state == 'jump': animation_key_to_use = 'jump'
        elif self.state == 'jump_fall_trans': animation_key_to_use = 'jump_fall_trans'
        elif self.state == 'wall_slide': animation_key_to_use = 'wall_slide'
        elif self.state == 'wall_hang': animation_key_to_use = 'wall_hang'
        elif self.on_ground: # Grounded states based on movement intention and crouching
            if self.is_crouching:
                animation_key_to_use = 'crouch_walk' if player_is_intending_to_move_lr and 'crouch_walk' in self.animations and self.animations['crouch_walk'] else 'crouch'
            elif player_is_intending_to_move_lr: animation_key_to_use = 'run'
            else: animation_key_to_use = 'idle'
        
        # Final fallback if the derived animation_key_to_use is invalid or missing
        if animation_key_to_use not in self.animations or not self.animations[animation_key_to_use]: 
            # print(f"DEBUG Player (animate P{self.player_id}): Anim key '{animation_key_to_use}' for state '{self.state}' not found or empty. Falling back to 'idle'.") # DEBUG
            animation_key_to_use = 'idle' # Default to 'idle' animation
        
        current_animation_frames_list = self.animations.get(animation_key_to_use)

        if not current_animation_frames_list: # Should not happen if 'idle' is guaranteed by asset loader
            if hasattr(self, 'image') and self.image: self.image.fill(C.RED) # Error placeholder
            if Player.print_limiter.can_print(f"player_animate_no_frames_{self.player_id}_{animation_key_to_use}"):
                print(f"CRITICAL Player Animate Error ({self.player_id}): No frames found for anim key '{animation_key_to_use}' (Logical state: {self.state})")
            return
        
        # print(f"DEBUG Player (animate P{self.player_id}): Using anim key '{animation_key_to_use}', state '{self.state}', {len(current_animation_frames_list)} frames. Current frame idx: {self.current_frame}") # DEBUG - Can be noisy

        # Determine frame duration (e.g., Attack 2 might be slower, having longer frame durations)
        ms_per_frame_for_current_anim = C.ANIM_FRAME_DURATION
        if self.is_attacking and self.attack_type == 2 and hasattr(C, 'PLAYER_ATTACK2_FRAME_DURATION_MULTIPLIER'):
            ms_per_frame_for_current_anim = int(C.ANIM_FRAME_DURATION * C.PLAYER_ATTACK2_FRAME_DURATION_MULTIPLIER)

        # --- Animation Frame Progression ---
        if not (self.is_dead and self.death_animation_finished): # Don't advance frame if death animation has completed
            if current_time_ms - self.last_anim_update > ms_per_frame_for_current_anim: # Time for next frame
                self.last_anim_update = current_time_ms # Reset timer for this frame
                self.current_frame += 1 # Advance to the next frame
                
                if self.current_frame >= len(current_animation_frames_list): # Reached the end of the animation sequence
                    if self.is_dead: # If death animation just finished playing
                        # if Player.print_limiter.can_print(f"player_animate_death_anim_completed_{self.player_id}"):
                        #     print(f"DEBUG Player ({self.player_id}): Death Animation sequence visually FINISHED.")
                        self.current_frame = len(current_animation_frames_list) - 1 # Hold the last frame of death animation
                        self.death_animation_finished = True
                        # Update image one last time for the final death frame before returning
                        final_death_image_surface = current_animation_frames_list[self.current_frame]
                        if not self.facing_right: final_death_image_surface = pygame.transform.flip(final_death_image_surface, True, False)
                        old_player_midbottom = self.rect.midbottom
                        self.image = final_death_image_surface
                        self.rect = self.image.get_rect(midbottom=old_player_midbottom)
                        return # Stop further animation processing for this frame once death anim is done
                    
                    # --- Handle transitions for non-looping animations ---
                    # Define states whose animations should not loop but transition to another state.
                    non_looping_animation_states = [
                        'attack','attack_nm','attack2','attack2_nm','attack_combo','attack_combo_nm',
                        'crouch_attack','dash','roll','slide','hit','turn','jump',
                        'jump_fall_trans','crouch_trans','slide_trans_start','slide_trans_end']
                    
                    if self.state in non_looping_animation_states: # If current logical state's animation just finished
                         next_logical_state_after_anim = None # Determine the state to transition to
                         current_logical_state_of_player = self.state 
                         player_is_intending_to_move_at_anim_end = self.is_trying_to_move_left or self.is_trying_to_move_right

                         # Determine next state based on the one that just finished
                         if current_logical_state_of_player == 'jump':
                             next_logical_state_after_anim = 'jump_fall_trans' if 'jump_fall_trans' in self.animations and self.animations['jump_fall_trans'] else 'fall'
                         elif current_logical_state_of_player == 'jump_fall_trans':
                             next_logical_state_after_anim = 'fall'
                         elif current_logical_state_of_player == 'hit': 
                             next_logical_state_after_anim = 'fall' if not self.on_ground and not self.on_ladder else 'idle'
                         elif current_logical_state_of_player == 'turn':
                             next_logical_state_after_anim = 'run' if player_is_intending_to_move_at_anim_end else 'idle'
                         elif 'attack' in current_logical_state_of_player: # Any attack animation finished
                              self.is_attacking = False; self.attack_type = 0 # Reset attack flags
                              # Transition based on player's situation after attack
                              if self.on_ladder: pass # Ladder logic will take over if still on ladder
                              elif self.is_crouching: next_logical_state_after_anim = 'crouch'
                              elif not self.on_ground: next_logical_state_after_anim = 'fall'
                              elif player_is_intending_to_move_at_anim_end : next_logical_state_after_anim = 'run'
                              else: next_logical_state_after_anim = 'idle'
                         elif current_logical_state_of_player == 'crouch_trans': # Crouch transition (e.g., stand to crouch) finished
                             self.is_crouching = self.is_holding_crouch_ability_key # Update crouch based on key hold
                             next_logical_state_after_anim = 'crouch' if self.is_crouching else 'idle'
                         elif current_logical_state_of_player == 'slide_trans_start': # Slide entry transition finished
                             next_logical_state_after_anim = 'slide' # Enter main slide animation
                         elif current_logical_state_of_player in ['slide_trans_end', 'slide']: # Slide finished (either main or exit transition)
                             self.is_sliding = False # No longer sliding
                             self.is_crouching = self.is_holding_crouch_ability_key # Check if still holding crouch
                             next_logical_state_after_anim = 'crouch' if self.is_crouching else 'idle'
                         else: # For other non-looping states like dash, roll
                              if current_logical_state_of_player == 'dash': self.is_dashing = False # Dash action ends
                              if current_logical_state_of_player == 'roll': self.is_rolling = False # Roll action ends
                              # Default transition based on environment after action
                              if self.on_ladder: pass 
                              elif self.is_crouching: next_logical_state_after_anim = 'crouch'
                              elif not self.on_ground: next_logical_state_after_anim = 'fall'
                              elif player_is_intending_to_move_at_anim_end : next_logical_state_after_anim = 'run'
                              else: next_logical_state_after_anim = 'idle'
                         
                         if next_logical_state_after_anim: # If a next state was determined
                             self.set_state(next_logical_state_after_anim) # Transition to it
                             return # set_state calls animate(), so return to avoid double processing this frame
                         else: # Should not happen for defined non-looping states; implies missing transition logic
                             self.current_frame = 0 # Loop this non-looping anim (usually an error in state logic)
                    else: # For looping animations (e.g. idle, run, fall), reset to first frame
                        self.current_frame = 0 
                
                # Ensure current_frame is valid after potential reset/change due to animation end
                if self.current_frame >= len(current_animation_frames_list): self.current_frame = 0
        
        # --- Get the actual image surface for the current animation frame ---
        # Handle cases where animation frames might be empty (though asset loader should prevent this)
        if not current_animation_frames_list or self.current_frame < 0 or self.current_frame >= len(current_animation_frames_list):
            # print(f"DEBUG Player (animate P{self.player_id}): Invalid frame index ({self.current_frame}) or empty frame list for anim '{animation_key_to_use}'. Resetting to 0.") # DEBUG
            self.current_frame = 0 # Reset frame index to prevent crash
            if not current_animation_frames_list: # Still no frames (major issue)
                if hasattr(self, 'image') and self.image: self.image.fill(C.RED) # Error placeholder
                return

        image_for_this_frame = current_animation_frames_list[self.current_frame]
        # Flip image horizontally if player is not facing right
        if not self.facing_right: 
            image_for_this_frame = pygame.transform.flip(image_for_this_frame, True, False)
        
        # --- Update player's main image and rect if it changed or facing direction changed ---
        # This optimizes by avoiding unnecessary image/rect updates if nothing visual changed.
        if self.image is not image_for_this_frame or self._last_facing_right != self.facing_right:
            old_player_midbottom_pos = self.rect.midbottom # Preserve position anchor (midbottom)
            self.image = image_for_this_frame # Set the new image
            self.rect = self.image.get_rect(midbottom=old_player_midbottom_pos) # Re-anchor rect
            self._last_facing_right = self.facing_right # Update tracking of last facing direction
            # print(f"DEBUG Player (animate P{self.player_id}): Image updated. New image size: {self.image.get_size()}, Rect: {self.rect}") # DEBUG


    # --- Input Handling Methods (delegate to player_input_handler) ---
    def handle_input(self, keys_pressed_state, pygame_event_list):
        """Handles standard WASD keyboard input by delegating to the input handler."""
        # Default key configuration for Player 1 (or single player)
        default_key_config = {
            'left': pygame.K_a, 'right': pygame.K_d, 'up': pygame.K_w, 'down': pygame.K_s,
            'attack1': pygame.K_v, 'attack2': pygame.K_b, 'dash': pygame.K_LSHIFT,
            'roll': pygame.K_LCTRL, 'interact': pygame.K_e
        }
        process_player_input_logic(self, keys_pressed_state, pygame_event_list, default_key_config)

    def handle_mapped_input(self, keys_pressed_state, pygame_event_list, key_map_dict):
        """Handles input based on a provided key_map dictionary (e.g., for Player 2)."""
        process_player_input_logic(self, keys_pressed_state, pygame_event_list, key_map_dict)

    # --- Combat Handling Methods (delegate to player_combat_handler) ---
    def fire_fireball(self):
        """Initiates firing a fireball by delegating to the combat handler."""
        fire_player_fireball(self)

    def check_attack_collisions(self, list_of_targets):
        """Checks for collisions during an attack by delegating to the combat handler."""
        check_player_attack_collisions(self, list_of_targets)

    def take_damage(self, damage_amount_taken):
        """Processes damage taken by delegating to the combat handler."""
        player_take_damage(self, damage_amount_taken)

    def self_inflict_damage(self, damage_amount_to_self):
        """Inflicts damage on self (debug/special) by delegating to the combat handler."""
        player_self_inflict_damage(self, damage_amount_to_self)

    def heal_to_full(self):
        """Heals player to full health by delegating to the combat handler."""
        player_heal_to_full(self)
        
    # --- Network Handling Methods (delegate to player_network_handler) ---
    def get_network_data(self):
        """Gets player state for network transmission by delegating to the network handler."""
        return get_player_network_data(self)

    def set_network_data(self, received_network_data):
        """Applies received network data to this player by delegating to the network handler."""
        set_player_network_data(self, received_network_data)

    def handle_network_input(self, network_input_data_dict):
        """Processes input commands received over network by delegating to the network handler."""
        handle_player_network_input(self, network_input_data_dict)

    def get_input_state_for_network(self, current_pygame_keys_state, current_pygame_event_list, 
                                    key_map_for_this_player):
        """Gathers local input state for network transmission by delegating to the network handler."""
        return get_player_input_state_for_network(self, current_pygame_keys_state, 
                                                  current_pygame_event_list, key_map_for_this_player)

    # --- Core Update Method (Physics, State Timers, Collisions) ---
    def update(self, dt_sec, platforms_group, ladders_group, hazards_group, 
               other_players_sprite_list, enemies_sprite_list):
        """
        Main update loop for the player. Handles physics, state timer progression,
        and collision detection/resolution.

        Args:
            dt_sec (float): Delta time in seconds since the last frame. Not directly used in this
                            version's physics, but good practice for frame-rate independent movement.
            platforms_group (pygame.sprite.Group): Group of solid platform sprites.
            ladders_group (pygame.sprite.Group): Group of ladder sprites.
            hazards_group (pygame.sprite.Group): Group of hazard sprites (e.g., lava).
            other_players_sprite_list (list): List of other Player sprites for character collision.
            enemies_sprite_list (list): List of Enemy sprites for character and attack collision.
        """
        # print(f"DEBUG Player (update P{self.player_id}): Start of update. Pos: {self.pos.x:.1f},{self.pos.y:.1f}, Vel: {self.vel.x:.1f},{self.vel.y:.1f}, State: {self.state}, Valid: {self._valid_init}, Alive: {self.alive()}") # DEBUG - Very noisy
        if not self._valid_init: return # Do nothing if player initialization failed
        
        # --- Handle Death State Separately ---
        # If player is dead, only handle falling physics (if applicable) and death animation.
        if self.is_dead: 
            if self.alive() and hasattr(self, 'animate'): # Ensure still in sprite groups and can animate
                if not self.death_animation_finished: # If death animation is still playing
                    if not self.on_ground: # Apply gravity if in air during death sequence
                        # self.acc.y should be C.PLAYER_GRAVITY, set in set_state('death')
                        self.vel.y += self.acc.y 
                        self.vel.y = min(self.vel.y, getattr(C, 'TERMINAL_VELOCITY_Y', 18)) # Cap fall speed
                        self.pos.y += self.vel.y # Update position
                        self.rect.bottom = round(self.pos.y) # Update rect
                        # Check for ground collision during death fall
                        self.on_ground = False # Assume not on ground until collision proves otherwise
                        for platform_sprite in pygame.sprite.spritecollide(self, platforms_group, False):
                            # Check if landed on top of platform
                            if self.vel.y > 0 and self.rect.bottom > platform_sprite.rect.top and \
                               (self.pos.y - self.vel.y) <= platform_sprite.rect.top + 1: # Approx. prev bottom
                                self.rect.bottom = platform_sprite.rect.top
                                self.on_ground = True; self.vel.y = 0; self.acc.y = 0 # Stop falling
                                self.pos.y = self.rect.bottom; break # Landed
                self.animate() # Continue playing/holding death animation
            return # No further updates (movement, input, etc.) if dead

        current_time_ms = pygame.time.get_ticks() # Current game time

        # --- Manage State Timers and Cooldowns (Dash, Roll, Slide, Hit Invincibility) ---
        # Dash timer: if dash duration ends, transition out of dash state
        if self.is_dashing and current_time_ms - self.dash_timer > self.dash_duration:
            self.is_dashing = False # Dash action finished
            self.set_state('idle' if self.on_ground else 'fall') # Transition to appropriate state
        
        # Roll timer: if roll duration ends, transition out of roll state
        if self.is_rolling and current_time_ms - self.roll_timer > self.roll_duration:
            self.is_rolling = False # Roll action finished
            self.set_state('idle' if self.on_ground else 'fall')
        
        # Slide timer: if slide duration ends (can also end by friction or animation)
        if self.is_sliding and current_time_ms - self.slide_timer > self.slide_duration:
            # Slide logic in animate() or input_handler often transitions out earlier based on friction/anim end.
            # This timer is a failsafe or for fixed-duration slides.
            if self.state == 'slide': # If still in main slide state by timer end
                self.is_sliding = False
                # Transition to slide end animation or crouch/idle based on input
                slide_end_anim_key = 'slide_trans_end' if 'slide_trans_end' in self.animations else None
                if slide_end_anim_key: self.set_state(slide_end_anim_key)
                else: self.set_state('crouch' if self.is_holding_crouch_ability_key else 'idle')

        # Hit stun / invincibility cooldown: manage when player can be hit again
        if self.is_taking_hit and current_time_ms - self.hit_timer > self.hit_cooldown:
            # Note: self.hit_duration is for the stun animation/effect. self.hit_cooldown is for total invincibility.
            if self.state == 'hit': # If still in 'hit' state after invincibility cooldown (anim might be longer)
                self.is_taking_hit = False # Cooldown over, can be hit again
                # Don't force state change here; let 'hit' animation finish or other logic transition player out.
            else: # Cooldown ended, and player is no longer in 'hit' state (already transitioned)
                self.is_taking_hit = False
        
        # --- Ladder Interaction ---
        self.check_ladder_collisions(ladders_group) # Update self.can_grab_ladder
        if self.on_ladder and not self.can_grab_ladder: # If was on ladder but no longer can grab (e.g., moved off)
            self.on_ladder = False # No longer on ladder
            self.set_state('fall' if not self.on_ground else 'idle') # Transition to fall or idle

        # --- Apply Physics (Movement based on Velocity and Acceleration) ---
        # Vertical movement (gravity, jump, ladder climbing speed)
        should_apply_gravity_this_frame = not (
            self.on_ladder or self.state == 'wall_hang' or
            (self.state == 'wall_climb' and self.vel.y <= C.PLAYER_WALL_CLIMB_SPEED + 0.1) or # If actively climbing up
            self.is_dashing # Dashing is purely horizontal, no gravity
        )
        if should_apply_gravity_this_frame:
            self.vel.y += self.acc.y # self.acc.y is usually C.PLAYER_GRAVITY

        # Horizontal movement (acceleration from input, friction)
        should_apply_horizontal_physics = not (
            self.is_dashing or self.is_rolling or self.on_ladder or
            (self.state == 'wall_climb' and self.vel.y <= C.PLAYER_WALL_CLIMB_SPEED + 0.1) # No horiz control while climbing up
        )
        if should_apply_horizontal_physics:
            self.vel.x += self.acc.x # self.acc.x is set by input_handler

            # --- Apply Friction ---
            friction_coefficient_to_apply = 0 # Default: no friction
            if self.on_ground and self.acc.x == 0 and not self.is_sliding and self.state != 'slide':
                friction_coefficient_to_apply = C.PLAYER_FRICTION # Standard ground friction when not accelerating
            elif not self.on_ground and not self.is_attacking and \
                 self.state not in ['wall_slide','wall_hang','wall_climb','wall_climb_nm']:
                friction_coefficient_to_apply = C.PLAYER_FRICTION * 0.2 # Air friction (less effective)
            elif self.is_sliding or self.state == 'slide':
                friction_coefficient_to_apply = C.PLAYER_FRICTION * 0.7 # Specific friction for sliding

            if friction_coefficient_to_apply != 0:
                 friction_force_applied = self.vel.x * friction_coefficient_to_apply # Friction opposes velocity
                 if abs(self.vel.x) > 0.1: self.vel.x += friction_force_applied # Apply friction
                 else: self.vel.x = 0 # Stop if velocity is very low
                 
                 # If sliding and friction brings velocity very low, end slide
                 if abs(self.vel.x) < 0.5 and (self.is_sliding or self.state == 'slide'):
                     self.is_sliding = False # No longer sliding
                     # Transition to slide end animation or crouch/idle
                     slide_end_anim_key_friction = 'slide_trans_end' if 'slide_trans_end' in self.animations and self.animations['slide_trans_end'] else None
                     if slide_end_anim_key_friction: self.set_state(slide_end_anim_key_friction)
                     else: # No transition animation, decide based on crouch key hold
                         self.is_crouching = self.is_holding_crouch_ability_key
                         self.set_state('crouch' if self.is_crouching else 'idle')
            
            # --- Speed Limiting (Horizontal) ---
            # Apply normal run speed limit, or reduced limit if crouch-walking.
            # Dash, roll, and slide manage their own speeds and are excluded here.
            current_horizontal_speed_limit = C.PLAYER_RUN_SPEED_LIMIT
            if self.is_crouching and self.state == 'crouch_walk':
                current_horizontal_speed_limit *= 0.6 # Slower when crouch-walking
            
            if not self.is_dashing and not self.is_rolling and not self.is_sliding and self.state != 'slide':
                self.vel.x = max(-current_horizontal_speed_limit, min(current_horizontal_speed_limit, self.vel.x))

        # --- Terminal Velocity (Vertical) ---
        # Cap falling speed to prevent excessive acceleration.
        if self.vel.y > 0 and not self.on_ladder: # If moving downwards and not on a ladder
            self.vel.y = min(self.vel.y, getattr(C, 'TERMINAL_VELOCITY_Y', 18))

        # --- Collision Detection and Resolution ---
        self.touching_wall = 0 # Reset wall touch state each frame; will be set by x-collision
        self.on_ground = False # Reset ground state; will be set by y-collision with platforms

        # --- Horizontal Collision Pass ---
        self.pos.x += self.vel.x # Update precise horizontal position
        self.rect.centerx = round(self.pos.x) # Update rect for collision check
        self.check_platform_collisions('x', platforms_group) # Check and resolve platform collisions
        
        # Consolidate list of other characters for collision checks
        all_other_character_sprites = [p for p in other_players_sprite_list if p and p._valid_init and p.alive() and p is not self] + \
                                      [e for e in enemies_sprite_list if e and e._valid_init and e.alive()]
        collided_horizontally_with_character = self.check_character_collisions('x', all_other_character_sprites)

        # --- Vertical Collision Pass ---
        self.pos.y += self.vel.y # Update precise vertical position
        self.rect.bottom = round(self.pos.y) # Update rect for collision check
        self.check_platform_collisions('y', platforms_group) # Check and resolve platform collisions (sets self.on_ground)

        # Only check for vertical character collisions if no horizontal character collision occurred in this frame
        # to prevent characters from getting "stuck" or pushed through each other weirdly due to double collision resolution.
        if not collided_horizontally_with_character: 
            self.check_character_collisions('y', all_other_character_sprites) 

        # --- Synchronize Precise Position with Rect after all collision resolutions ---
        self.pos.x = self.rect.centerx 
        self.pos.y = self.rect.bottom

        # --- Hazard Collisions (e.g., Lava) ---
        self.check_hazard_collisions(hazards_group)

        # --- Attack Collisions (if player is currently attacking) ---
        if self.alive() and not self.is_dead and self.is_attacking: # Ensure player is in a state to attack
            # Targets for melee attacks can be other players or enemies
            targets_for_player_attack = [p for p in other_players_sprite_list if p and p._valid_init and p.alive() and p is not self] + \
                                        [e for e in enemies_sprite_list if e and e._valid_init and e.alive()]
            self.check_attack_collisions(targets_for_player_attack) # Delegates to combat_handler via self.method
        
        # --- Final Animation Update for the Frame ---
        # This ensures the player's visual representation matches their current state and facing direction.
        self.animate()
        # print(f"DEBUG Player (update P{self.player_id}): End of update. Pos: {self.pos.x:.1f},{self.pos.y:.1f}, Rect: {self.rect}, Image: {self.image.get_size() if self.image else 'NoImg'}") # DEBUG - Very Noisy


    def check_platform_collisions(self, direction: str, platforms_group: pygame.sprite.Group):
        """
        Handles collisions between the player and solid platforms.
        Resolves collisions by adjusting player position and velocity.
        Updates `self.on_ground` and `self.touching_wall` flags.

        Args:
            direction (str): The axis of collision to check ('x' or 'y').
            platforms_group (pygame.sprite.Group): The sprite group containing platforms.
        """
        collided_with_wall_on_side = 0 # For detecting wall touch: -1 for left, 1 for right
        
        # Iterate through all platforms the player is currently colliding with
        for platform_sprite in pygame.sprite.spritecollide(self, platforms_group, False):
            if direction == 'x': # --- Horizontal Collision Resolution ---
                if self.vel.x > 0: # Player was moving right, collided with platform's left side
                    self.rect.right = platform_sprite.rect.left # Align player's right edge with platform's left
                    # Check if this collision constitutes a wall touch (player is in air, not on ladder)
                    if not self.on_ground and not self.on_ladder and self.rect.bottom > platform_sprite.rect.top + 5: # +5 to avoid false positives from ground edges
                        collided_with_wall_on_side = 1 # Touched a wall on player's right
                elif self.vel.x < 0: # Player was moving left, collided with platform's right side
                    self.rect.left = platform_sprite.rect.right # Align player's left edge with platform's right
                    if not self.on_ground and not self.on_ladder and self.rect.bottom > platform_sprite.rect.top + 5:
                        collided_with_wall_on_side = -1 # Touched a wall on player's left
                self.vel.x = 0 # Stop horizontal movement due to collision
                self.pos.x = self.rect.centerx # Update precise position based on new rect.centerx
            
            elif direction == 'y': # --- Vertical Collision Resolution ---
                if self.vel.y > 0: # Player was moving down (falling or landing)
                    # Check if player was above or at platform's top edge in the previous frame (approximately)
                    # This helps ensure landing only happens when coming from above.
                    if self.rect.bottom > platform_sprite.rect.top and \
                       (self.pos.y - self.vel.y) <= platform_sprite.rect.top + 1: # pos.y is bottom, vel.y is positive
                        self.rect.bottom = platform_sprite.rect.top # Align player's bottom with platform's top
                        if not self.on_ground: # If this is the frame the player lands
                            self.can_wall_jump=False; self.wall_climb_timer=0 # Reset wall abilities upon landing
                            if not self.is_sliding and self.state != 'slide_trans_end': # Don't kill slide momentum on land
                                self.vel.x *= 0.8 # Apply slight horizontal friction on landing if not sliding
                        self.on_ground=True; self.vel.y=0 # Player is now on ground, stop vertical velocity
                elif self.vel.y < 0: # Player was moving up (e.g., jumping into a ceiling)
                    # Check if player was below or at platform's bottom edge in previous frame (approx)
                    # Player's top edge is at (pos.y - rect.height)
                    if self.rect.top < platform_sprite.rect.bottom and \
                       ((self.pos.y - self.rect.height) - self.vel.y) >= platform_sprite.rect.bottom -1 :
                         if self.on_ladder: self.on_ladder = False # Knocked off ladder if hit ceiling
                         self.rect.top = platform_sprite.rect.bottom # Align player's top with platform's bottom
                         self.vel.y=0 # Stop upward movement due to collision
                self.pos.y = self.rect.bottom # Update precise position based on new rect.bottom
        
        # After checking all platforms, if a wall collision was detected horizontally:
        if direction == 'x' and collided_with_wall_on_side != 0 and \
           not self.on_ground and not self.on_ladder: # Wall interactions only happen in air
             self.touching_wall = collided_with_wall_on_side # Set which side wall is on
             # Player can wall jump unless they are actively climbing upwards (which consumes the jump ability for that climb)
             self.can_wall_jump = not (self.state == 'wall_climb' and self.is_holding_climb_ability_key)


    def check_ladder_collisions(self, ladders_group: pygame.sprite.Group):
        """
        Checks if the player is overlapping a ladder and can grab onto it.
        Updates `self.can_grab_ladder`.

        Args:
            ladders_group (pygame.sprite.Group): The sprite group containing ladders.
        """
        if not self._valid_init: return # Cannot interact if player is invalid
        
        # Use a slightly smaller rectangle for ladder detection to make grabbing more intentional
        # This helps avoid grabbing ladders accidentally when just brushing past the sides.
        # Inflate by negative values to shrink the rect. Shrink width more than height.
        ladder_check_rect = self.rect.inflate(-self.rect.width * 0.6, -self.rect.height * 0.1) 
        
        self.can_grab_ladder = False # Reset flag each frame
        # Check for collision with any ladder using the smaller check_rect
        for ladder_sprite in pygame.sprite.spritecollide(self, ladders_group, False, 
                               collided=lambda player_sprite, ladder_rect_obj: ladder_check_rect.colliderect(ladder_rect_obj.rect)):
            # Additional conditions for a valid grab:
            # Player should be somewhat horizontally centered on the ladder.
            # Player's vertical center should be within the ladder's vertical span.
            if abs(self.rect.centerx - ladder_sprite.rect.centerx) < ladder_sprite.rect.width * 0.7 and \
               ladder_sprite.rect.top < self.rect.centery < ladder_sprite.rect.bottom : 
                  self.can_grab_ladder = True; break # Found a grabbable ladder


    def check_character_collisions(self, direction: str, characters_list: list):
        """
        Handles collisions between this player and other characters (players, enemies).
        Applies a simple push-back effect to both colliding characters.

        Args:
            direction (str): The axis of collision to check ('x' or 'y').
            characters_list (list): A list of other character Sprites to check against.

        Returns:
            bool: True if a collision with another character occurred on this axis, False otherwise.
        """
        if not self._valid_init or self.is_dead or not self.alive(): return False # Cannot collide if in these states
        
        a_character_collision_occurred_this_frame = False
        for other_char_sprite in characters_list:
            if other_char_sprite is self: continue # Skip collision check with self
            
            # Ensure the other character is valid, alive, and not dead
            if not (other_char_sprite and hasattr(other_char_sprite, '_valid_init') and \
                    other_char_sprite._valid_init and hasattr(other_char_sprite, 'is_dead') and \
                    not other_char_sprite.is_dead and other_char_sprite.alive()):
                continue 

            if self.rect.colliderect(other_char_sprite.rect): # If a collision is detected
                a_character_collision_occurred_this_frame = True
                bounce_velocity_on_char_collision = getattr(C, 'CHARACTER_BOUNCE_VELOCITY', 2.5) # From constants
                
                if direction == 'x': # --- Horizontal Character Collision ---
                    # Determine push direction: self is pushed away from other_char
                    push_direction_for_self = -1 if self.rect.centerx < other_char_sprite.rect.centerx else 1
                    
                    # Adjust self's rect to resolve overlap
                    if push_direction_for_self == -1: self.rect.right = other_char_sprite.rect.left
                    else: self.rect.left = other_char_sprite.rect.right
                    self.vel.x = push_direction_for_self * bounce_velocity_on_char_collision # Apply bounce to self
                    
                    # Apply opposite bounce to the other character if it has physics attributes
                    if hasattr(other_char_sprite, 'vel'): 
                        other_char_sprite.vel.x = -push_direction_for_self * bounce_velocity_on_char_collision
                    # Slightly nudge other character's precise position to help prevent immediate re-collision
                    if hasattr(other_char_sprite, 'pos') and hasattr(other_char_sprite, 'rect'): 
                        other_char_sprite.pos.x += (-push_direction_for_self * 1.5) # Small separation nudge
                        other_char_sprite.rect.centerx = round(other_char_sprite.pos.x)
                    self.pos.x = self.rect.centerx # Update self's precise position

                elif direction == 'y': # --- Vertical Character Collision ---
                    # Scenario 1: This player lands on top of another character
                    if self.vel.y > 0 and self.rect.bottom > other_char_sprite.rect.top and \
                       self.rect.centery < other_char_sprite.rect.centery: # Ensure self is mostly above other
                        self.rect.bottom = other_char_sprite.rect.top # Land on top of other character
                        self.on_ground = True; self.vel.y = 0 # Player is now "on_ground" (on the other char)
                    # Scenario 2: This player hits another character from below (e.g., headbutt)
                    elif self.vel.y < 0 and self.rect.top < other_char_sprite.rect.bottom and \
                         self.rect.centery > other_char_sprite.rect.centery: # Ensure self is mostly below other
                        self.rect.top = other_char_sprite.rect.bottom # Align top with other's bottom
                        self.vel.y = 0 # Stop upward movement
                    self.pos.y = self.rect.bottom # Update self's precise position
        return a_character_collision_occurred_this_frame


    def check_hazard_collisions(self, hazards_group: pygame.sprite.Group):
        """
        Checks for collisions with hazards like lava.
        If a collision occurs, player takes damage and is bounced.

        Args:
            hazards_group (pygame.sprite.Group): The sprite group containing hazards.
        """
        current_time_ms = pygame.time.get_ticks()
        # Player cannot be damaged by hazards if invalid, dead, or in hit cooldown period
        if not self._valid_init or self.is_dead or not self.alive() or \
           (self.is_taking_hit and current_time_ms - self.hit_timer < self.hit_cooldown): 
            return
            
        has_been_damaged_by_hazard_this_frame = False
        # Use a specific point for hazard collision (e.g., near player's feet for lava)
        # This prevents taking damage if only the top of the player sprite brushes a hazard.
        hazard_check_point_at_feet = (self.rect.centerx, self.rect.bottom - 2) 

        for hazard_sprite_instance in hazards_group: 
            # Check specifically for Lava instances (can be extended for other hazard types)
            if isinstance(hazard_sprite_instance, Lava) and \
               hazard_sprite_instance.rect.collidepoint(hazard_check_point_at_feet):
                
                if not has_been_damaged_by_hazard_this_frame: # Avoid multiple damage ticks per frame from same hazard type
                    # if Player.print_limiter.can_print(f"player_hazard_touch_{self.player_id}_lava"):
                    #     print(f"DEBUG Player ({self.player_id}): Touched LAVA at {hazard_check_point_at_feet}.")
                    
                    self.take_damage(C.LAVA_DAMAGE) # Delegates to combat_handler via self.take_damage method
                    has_been_damaged_by_hazard_this_frame = True 
                    
                    if not self.is_dead: # If player survived the lava damage, bounce them out
                         self.vel.y = C.PLAYER_JUMP_STRENGTH * 0.75 # Strong bounce upwards
                         # Bounce horizontally away from the center of the lava hazard
                         horizontal_push_direction_from_hazard = 1 if self.rect.centerx < hazard_sprite_instance.rect.centerx else -1
                         self.vel.x = -horizontal_push_direction_from_hazard * \
                                      getattr(C, 'PLAYER_RUN_SPEED_LIMIT', 7) * 0.5 # Moderate horizontal push
                         self.on_ground = False # Player is now in the air
                         self.on_ladder = False # And definitely not on a ladder
                    break # Process one lava collision per frame to avoid multiple damage instances


    def reset_state(self, spawn_position_tuple: tuple):
        """
        Resets the player to their initial state at the given spawn position.
        Called for game restarts or when player respawns.

        Args:
            spawn_position_tuple (tuple): (x, y) coordinates for the player's midbottom.
        """
        print(f"DEBUG Player (reset_state P{self.player_id}): Resetting state to spawn at {spawn_position_tuple}. Current valid: {self._valid_init}") # DEBUG
        if not self._valid_init: 
            # if Player.print_limiter.can_print(f"player_reset_fail_invalid_init_{self.player_id}"):
            #     print(f"Player Warning ({self.player_id}): Cannot reset, _valid_init is False.")
            # Try to re-validate if possible, might be risky if assets truly failed
            asset_folder_path = 'characters/player1' if self.player_id == 1 else 'characters/player2'
            self.animations = load_all_player_animations(relative_asset_folder=asset_folder_path)
            if self.animations is not None:
                self._valid_init = True
                idle_animation_frames = self.animations.get('idle')
                if idle_animation_frames and len(idle_animation_frames) > 0:
                    self.image = idle_animation_frames[0]
                else:
                    self.image = pygame.Surface((30,40)); self.image.fill(C.RED)
                print(f"DEBUG Player (reset_state P{self.player_id}): Re-attempted animation load. New _valid_init: {self._valid_init}") # DEBUG
            else:
                print(f"DEBUG Player (reset_state P{self.player_id}): Re-animation load FAILED. Still invalid.") # DEBUG
                return
        
        # print(f"Player Info ({self.player_id}): RESETTING state to spawn at {spawn_position_tuple}")
        # Reset position and physics
        self.pos = pygame.math.Vector2(spawn_position_tuple[0], spawn_position_tuple[1])
        self.rect.midbottom = (round(self.pos.x), round(self.pos.y))
        self.vel = pygame.math.Vector2(0, 0) # Reset velocity
        self.acc = pygame.math.Vector2(0, C.PLAYER_GRAVITY if hasattr(C, 'PLAYER_GRAVITY') else 0.7) # Reset accel
        
        # Reset health and status flags
        self.current_health = self.max_health
        self.is_dead = False
        self.death_animation_finished = False
        self.is_taking_hit = False
        self.is_attacking = False; self.attack_type = 0
        self.is_dashing = False; self.is_rolling = False; self.is_sliding = False
        self.on_ladder = False; self.touching_wall = 0; self.facing_right = True # Default to facing right
        
        # Reset any lingering timers or cooldowns
        self.hit_timer = 0; self.dash_timer = 0; self.roll_timer = 0; self.slide_timer = 0
        self.attack_timer = 0; self.wall_climb_timer = 0; self.fireball_cooldown_timer = 0
        self.fireball_last_input_dir = pygame.math.Vector2(1.0 if self.facing_right else -1.0, 0.0)

        # Ensure visual state is reset (e.g., if player image was faded out or alpha changed)
        if hasattr(self.image, 'set_alpha') and hasattr(self.image, 'get_alpha') and \
           self.image.get_alpha() is not None and self.image.get_alpha() < 255: # If image is transparent
            self.image.set_alpha(255) # Make fully opaque
        
        self.set_state('idle') # Set to a neutral, stable initial state
        print(f"DEBUG Player (reset_state P{self.player_id}): Reset complete. Pos: {self.pos}, HP: {self.current_health}") # DEBUG

########## END OF FILE: player.py ##########

########## START OF FILE: player_combat_handler.py ##########

# player_combat_handler.py
# -*- coding: utf-8 -*-
"""
version 1.0000000.1
Handles player combat: attacks, damage dealing/taking, healing, and projectile firing.
Functions here will typically take a 'player' instance as their first argument.
"""
import pygame
import constants as C
from projectiles import Fireball # Needed for instantiating Fireball

def fire_player_fireball(player):
    """
    Handles the logic for the player instance firing a fireball.
    Checks cooldowns, determines spawn position and direction, and adds
    the fireball to appropriate sprite groups.

    Args:
        player (Player): The player instance attempting to fire.
    """
    # Basic validation: Player must be valid, alive, and have sprite group references
    if not player._valid_init or player.is_dead or not player.alive():
        return
    if player.projectile_sprites_group is None or player.all_sprites_group is None:
        if player.print_limiter.can_print(f"player_{player.player_id}_fireball_no_group_ref_handler"):
            # Use a unique key for PrintLimiter to avoid message collision
            print(f"Player {player.player_id} (CombatHandler): Cannot fire fireball, projectile/all_sprites group not set.")
        return

    current_time_ms = pygame.time.get_ticks()
    # Check if fireball is off cooldown
    if current_time_ms - player.fireball_cooldown_timer >= C.FIREBALL_COOLDOWN:
        player.fireball_cooldown_timer = current_time_ms # Reset cooldown timer

        # Determine fireball spawn position relative to player
        spawn_x = player.rect.centerx
        spawn_y = player.rect.centery 
        
        # Use the player's last stored aim direction for the fireball
        current_aim_direction = player.fireball_last_input_dir.copy()
        # Ensure the aim direction has a non-zero length (fallback to facing direction)
        if current_aim_direction.length_squared() == 0: 
            current_aim_direction.x = 1.0 if player.facing_right else -1.0
            current_aim_direction.y = 0.0
        
        # Calculate an offset for the fireball's spawn point so it appears slightly in front of the player
        # This helps prevent immediate self-collision or spawning inside walls.
        # Tuned offset value; may need adjustment based on player/fireball sprite sizes.
        offset_distance = (player.rect.width / 2) + (C.FIREBALL_DIMENSIONS[0] / 2) - 35 
        
        # If aiming significantly up or down, adjust offset based on height
        if abs(current_aim_direction.y) > 0.8 * abs(current_aim_direction.x): # More vertical than horizontal aim
            offset_distance = (player.rect.height / 2) + (C.FIREBALL_DIMENSIONS[1] / 2) - 35
        
        # Apply the offset in the aim direction
        if current_aim_direction.length_squared() > 0: # Should always be true after fallback
            offset_vector = current_aim_direction.normalize() * offset_distance
            spawn_x += offset_vector.x
            spawn_y += offset_vector.y
        # else: # This case should ideally not be reached due to the fallback above
        #    spawn_x += (1.0 if player.facing_right else -1.0) * offset_distance

        # Create the new Fireball instance
        new_fireball = Fireball(spawn_x, spawn_y, current_aim_direction, player)
        # Add the fireball to the game's projectile and all_sprites groups
        player.projectile_sprites_group.add(new_fireball)
        player.all_sprites_group.add(new_fireball)
        
        if player.print_limiter.can_print(f"player_{player.player_id}_fire_fireball_msg_combat_handler"):
            print(f"Player {player.player_id} (CombatHandler) fires fireball. Aim Dir: {current_aim_direction}, Spawn Pos: ({spawn_x:.1f}, {spawn_y:.1f})")
    else: # Fireball is on cooldown
        if player.print_limiter.can_print(f"player_{player.player_id}_fireball_cooldown_combat_handler"):
            print(f"Player {player.player_id} (CombatHandler): Fireball on cooldown.")


def check_player_attack_collisions(player, targets_list):
    """
    Checks for collisions between the player's active attack hitbox and a list of targets.
    Applies damage to targets if a hit is registered.

    Args:
        player (Player): The attacking player instance.
        targets_list (list): A list of potential target Sprites (e.g., enemies, other players).
    """
    # Player must be valid, actively attacking, and alive to deal damage
    if not player._valid_init or not player.is_attacking or player.is_dead or not player.alive():
        return

    # --- Position the player's attack hitbox based on facing direction and state ---
    if player.facing_right:
        player.attack_hitbox.midleft = player.rect.midright # Hitbox to the right
    else:
        player.attack_hitbox.midright = player.rect.midleft # Hitbox to the left
    
    # Vertically adjust hitbox if crouching and performing a crouch attack
    # (Assuming attack_type 4 is designated for crouch attacks)
    vertical_offset_for_crouch_attack = -10 if player.is_crouching and player.attack_type == 4 else 0
    player.attack_hitbox.centery = player.rect.centery + vertical_offset_for_crouch_attack
    
    current_time_ms = pygame.time.get_ticks()
    for target_sprite in targets_list:
        if target_sprite is player: continue # Player cannot hit themselves with melee attacks

        # Ensure the target is valid, alive, and not dead
        if not (target_sprite and hasattr(target_sprite, '_valid_init') and target_sprite._valid_init and \
                hasattr(target_sprite, 'is_dead') and not target_sprite.is_dead and target_sprite.alive()):
            continue

        # --- Check if the target is currently invincible (e.g., recently hit) ---
        target_is_currently_invincible = False
        if hasattr(target_sprite, 'is_taking_hit') and hasattr(target_sprite, 'hit_timer') and \
           hasattr(target_sprite, 'hit_cooldown'):
            if target_sprite.is_taking_hit and \
               (current_time_ms - target_sprite.hit_timer < target_sprite.hit_cooldown):
                target_is_currently_invincible = True
        
        if target_is_currently_invincible:
            continue # Skip this target if it's invincible

        # --- Perform collision check between player's attack hitbox and target's rect ---
        if player.attack_hitbox.colliderect(target_sprite.rect):
            if hasattr(target_sprite, 'take_damage') and callable(target_sprite.take_damage):
                # Determine damage amount based on player's current attack type
                damage_to_inflict = 0
                if player.attack_type == 1: damage_to_inflict = C.PLAYER_ATTACK1_DAMAGE
                elif player.attack_type == 2: damage_to_inflict = C.PLAYER_ATTACK2_DAMAGE
                elif player.attack_type == 3: damage_to_inflict = C.PLAYER_COMBO_ATTACK_DAMAGE
                elif player.attack_type == 4: damage_to_inflict = C.PLAYER_CROUCH_ATTACK_DAMAGE
                
                if damage_to_inflict > 0:
                    target_sprite.take_damage(damage_to_inflict) # Call target's take_damage method
                    # Optional: Implement logic for one-hit-per-attack-animation if needed.
                    # This could involve a list on the player of targets already hit in this attack swing.
                    # For simplicity, this example allows multiple targets to be hit if they overlap the hitbox
                    # during the attack's active frames. Many games make attacks hit only once or a few targets.
                    
                    # player.can_combo = False # Example: A successful hit might end a combo window,
                                            # or this is managed by the attack animation finishing.


def player_take_damage(player, damage_amount):
    """
    Handles the player instance taking a specified amount of damage.
    Updates health, and potentially triggers 'hit' or 'death' states.

    Args:
        player (Player): The player instance receiving damage.
        damage_amount (int): The amount of damage to inflict.
    """
    current_time_ms = pygame.time.get_ticks()
    # if player.print_limiter.can_print(f"player_{player.player_id}_take_damage_call_combat_handler", limit=10, period=1.0):
    #     print(f"DEBUG Player {player.player_id} (CombatHandler): take_damage({damage_amount}) called. HP: {player.current_health}")
    
    # Player cannot take damage if invalid, already dead, not in sprite groups, or in hit cooldown
    if not player._valid_init or player.is_dead or not player.alive() or \
       (player.is_taking_hit and current_time_ms - player.hit_timer < player.hit_cooldown): 
        # if player.print_limiter.can_print(f"player_{player.player_id}_damage_ignored_combat_handler", limit=3, period=1.0):
        #     print(f"DEBUG Player {player.player_id} (CombatHandler): Damage IGNORED due to state/cooldown.")
        return

    player.current_health -= damage_amount
    player.current_health = max(0, player.current_health) # Clamp health at 0

    # if player.print_limiter.can_print(f"player_{player.player_id}_health_update_combat_handler", limit=10, period=1.0):
    #     print(f"DEBUG Player {player.player_id} (CombatHandler): New HP: {player.current_health}/{player.max_health}")

    if player.current_health <= 0: # Health has reached zero or below
        if not player.is_dead: # If not already marked as dead, transition to death state
            player.set_state('death') 
    else: # Player is damaged but still alive
        # Transition to 'hit' state if not already in 'hit' state during its active stun duration
        if not (player.state == 'hit' and current_time_ms - player.state_timer < player.hit_duration):
             player.set_state('hit') # Trigger hit animation and stun

def player_self_inflict_damage(player, damage_amount):
    """
    Allows the player instance to inflict damage on themselves.
    Typically used for debugging or special abilities.

    Args:
        player (Player): The player instance.
        damage_amount (int): The amount of damage for self-infliction.
    """
    if not player._valid_init or player.is_dead or not player.alive(): return # Basic validation
    
    # print(f"Player {player.player_id} (CombatHandler) self-inflicted {damage_amount} damage. HP before: {player.current_health}")
    player_take_damage(player, damage_amount) # Use the standardized take_damage logic
    # print(f"Player {player.player_id} (CombatHandler) HP after self-inflict: {player.current_health}/{player.max_health}")

def player_heal_to_full(player):
    """
    Heals the player instance to their maximum health.
    Can also cancel 'hit' stun state.

    Args:
        player (Player): The player instance to be healed.
    """
    if not player._valid_init: return
    # Cannot heal if fully dead and health is zero (unless game has revival mechanics not shown here)
    if player.is_dead and player.current_health <=0 : return 
    
    player.current_health = player.max_health
    # print(f"Player {player.player_id} (CombatHandler) healed to full: {player.current_health}/{player.max_health}")
    
    # If player was in a 'hit' stun, cancel it by transitioning to idle
    if player.is_taking_hit: player.is_taking_hit = False 
    if player.state == 'hit': player.set_state('idle')

########## START OF FILE: player_input_handler.py ##########

# player_input_handler.py
# -*- coding: utf-8 -*-
"""
version 1.0000000.1
Handles processing of player input and translating it to actions.
Functions here will typically take a 'player' instance as their first argument.
"""
import pygame
import constants as C

def process_player_input_logic(player, keys_pressed, pygame_events, key_config_map):
    """
    Core logic for processing raw Pygame input (held keys and events) 
    into player actions and state changes.
    Modifies the 'player' instance directly based on the input and key configuration.

    Args:
        player (Player): The player instance to be controlled.
        keys_pressed (pygame.key.ScancodeWrapper): Snapshot of currently held keys 
                                                   (from pygame.key.get_pressed()).
        pygame_events (list): List of Pygame events for the current frame 
                              (from pygame.event.get()).
        key_config_map (dict): A dictionary mapping action strings 
                               (e.g., 'left', 'attack1') to Pygame key constants 
                               (e.g., pygame.K_a, pygame.K_v).
    """
    if not player._valid_init: return # Do nothing if player initialization failed
    
    current_time_ms = pygame.time.get_ticks() # For managing state timers and cooldowns
    
    # Check if input processing should be blocked (e.g., player is dead or stunned)
    is_input_blocked = player.is_dead or \
                       (player.is_taking_hit and current_time_ms - player.hit_timer < player.hit_duration) 

    if is_input_blocked:
        player.acc.x = 0 # Ensure no accidental movement if input is blocked
        return

    # --- Update Player's Input Intention Flags (based on held keys) ---
    player.is_trying_to_move_left = keys_pressed[key_config_map['left']]
    player.is_trying_to_move_right = keys_pressed[key_config_map['right']]
    player.is_holding_climb_ability_key = keys_pressed[key_config_map['up']] # Often 'up' for climb/jump
    player.is_holding_crouch_ability_key = keys_pressed[key_config_map['down']] # Often 'down' for crouch/slide

    # --- Update Fireball Aim Direction (based on current directional input) ---
    # This ensures the fireball aims correctly even if fired without simultaneous movement.
    fireball_aim_x_input = 0.0
    fireball_aim_y_input = 0.0
    if keys_pressed[key_config_map['left']]: fireball_aim_x_input = -1.0
    elif keys_pressed[key_config_map['right']]: fireball_aim_x_input = 1.0
    
    if keys_pressed[key_config_map['up']]: fireball_aim_y_input = -1.0
    elif keys_pressed[key_config_map['down']]: fireball_aim_y_input = 1.0
    
    # Only update aim if there's active directional input
    if fireball_aim_x_input != 0.0 or fireball_aim_y_input != 0.0:
        player.fireball_last_input_dir.x = fireball_aim_x_input
        player.fireball_last_input_dir.y = fireball_aim_y_input
    elif player.fireball_last_input_dir.length_squared() == 0: # Ensure a default aim if none active
        player.fireball_last_input_dir.x = 1.0 if player.facing_right else -1.0
        player.fireball_last_input_dir.y = 0.0

    # --- Horizontal Movement Acceleration and Facing Direction ---
    player.acc.x = 0 # Reset horizontal acceleration each frame
    player_intends_horizontal_move = False

    # Determine if horizontal movement input is allowed by current player state
    can_player_control_horizontal_movement = not (
        player.is_dashing or player.is_rolling or player.is_sliding or player.on_ladder or
        (player.is_attacking and player.state in ['attack_nm','attack2_nm','attack_combo_nm','crouch_attack']) or 
        player.state in ['turn','hit','death','death_nm','wall_climb','wall_climb_nm','wall_hang']
    )
    
    if can_player_control_horizontal_movement:
        if player.is_trying_to_move_left and not player.is_trying_to_move_right:
            player.acc.x = -C.PLAYER_ACCEL
            player_intends_horizontal_move = True
            # If facing right but trying to move left (and on ground, not in special state), initiate turn
            if player.facing_right and player.on_ground and not player.is_crouching and \
               not player.is_attacking and player.state in ['idle','run']:
                player.set_state('turn')
            player.facing_right = False # Update facing direction
        elif player.is_trying_to_move_right and not player.is_trying_to_move_left:
            player.acc.x = C.PLAYER_ACCEL
            player_intends_horizontal_move = True
            if not player.facing_right and player.on_ground and not player.is_crouching and \
               not player.is_attacking and player.state in ['idle','run']:
                player.set_state('turn')
            player.facing_right = True

    # --- Crouching Logic (based on holding 'down' key) ---
    can_player_initiate_crouch = player.on_ground and not player.on_ladder and \
                                 not (player.is_dashing or player.is_rolling or player.is_sliding or \
                                      player.is_attacking or player.state in ['turn','hit','death'])
    
    if player.is_holding_crouch_ability_key and can_player_initiate_crouch:
        if not player.is_crouching: # Transition to crouch state
            player.is_crouching = True
            player.is_sliding = False # Crouching overrides sliding
            # Use crouch transition animation if available and not already in a crouch-related state
            if 'crouch_trans' in player.animations and player.animations['crouch_trans'] and \
               player.state not in ['crouch','crouch_walk','crouch_trans']:
                player.set_state('crouch_trans')
            # else: player.set_state('crouch') # Optionally, go directly to crouch if no transition
    elif not player.is_holding_crouch_ability_key and player.is_crouching: # Released crouch key
        player.is_crouching = False
        # Transition out of crouch will be handled by general state logic if not attacking/sliding, etc.
        # e.g., if idle and crouch released, will go to 'idle'.

    # --- Ladder Movement (overrides normal vertical movement) ---
    if player.on_ladder:
         player.vel.y = 0 # Stop falling/jumping momentum
         if player.is_holding_climb_ability_key: # Holding 'up' on ladder
             player.vel.y = -C.PLAYER_LADDER_CLIMB_SPEED
         elif player.is_holding_crouch_ability_key: # Holding 'down' on ladder
             player.vel.y = C.PLAYER_LADDER_CLIMB_SPEED

    # --- Process Event-Based Actions (KEYDOWN for discrete actions) ---
    for event in pygame_events:
        if event.type == pygame.KEYDOWN:
            # Jump / Wall Jump / Ladder Jump (triggered by 'up' key press)
            if event.key == key_config_map['up']:
                  can_perform_jump_action = not player.is_crouching and not player.is_attacking and \
                                            not player.is_rolling and not player.is_sliding and \
                                            not player.is_dashing and player.state not in ['turn','hit']
                  if player.on_ground and can_perform_jump_action: # Standard jump from ground
                      player.vel.y = C.PLAYER_JUMP_STRENGTH
                      player.set_state('jump')
                      player.on_ground = False # Important: set immediately to prevent re-jump in same frame
                  elif player.on_ladder and can_perform_jump_action: # Jump off ladder
                      player.vel.y = C.PLAYER_JUMP_STRENGTH * 0.8 # Slightly weaker ladder jump
                      player.vel.x = C.PLAYER_RUN_SPEED_LIMIT * 0.5 * (1 if player.facing_right else -1) # Horizontal push
                      player.on_ladder = False # Leave ladder
                      player.set_state('jump')
                  elif player.can_wall_jump and player.touching_wall != 0 and can_perform_jump_action: # Wall jump
                      player.vel.y = C.PLAYER_JUMP_STRENGTH # Full jump strength
                      player.vel.x = C.PLAYER_RUN_SPEED_LIMIT * 1.5 * (-player.touching_wall) # Jump away from wall
                      player.facing_right = not player.facing_right # Turn to face away from wall
                      player.set_state('jump')
                      # Reset wall interaction state after wall jump
                      player.can_wall_jump = False; player.touching_wall = 0; player.wall_climb_timer = 0
            
            # Attack 1 (Primary Attack)
            if event.key == key_config_map['attack1']:
                  can_perform_attack_action = not player.is_attacking and not player.is_dashing and \
                                              not player.is_rolling and not player.is_sliding and \
                                              not player.on_ladder and player.state not in ['turn','hit']
                  if can_perform_attack_action:
                       player.attack_type = 1 # Set attack type for damage calculation and animation
                       # Determine if attack is with movement or stationary
                       is_moving_for_attack_anim = (player.acc.x !=0 or abs(player.vel.x) > 1.0)
                       attack_animation_key = 'attack' if is_moving_for_attack_anim and \
                                              'attack' in player.animations and player.animations['attack'] \
                                              else 'attack_nm'
                       if player.is_crouching: # If crouching, perform crouch attack
                           player.attack_type = 4 # Crouch attack type
                           attack_animation_key = 'crouch_attack'
                       player.set_state(attack_animation_key) # Set appropriate attack state
            
            # Attack 2 (Secondary / Combo Attack)
            if event.key == key_config_map['attack2']:
                  can_perform_attack2_action = not player.is_dashing and not player.is_rolling and \
                                               not player.is_sliding and not player.on_ladder and \
                                               player.state not in ['turn','hit']
                  # Combo logic: Allow initiating attack2 even if attack1 is in recovery (within combo window)
                  if can_perform_attack2_action:
                       is_moving_for_attack2_anim = (player.acc.x != 0 or abs(player.vel.x) > 1.0)
                       
                       # Check if eligible for a combo (Attack 3)
                       time_since_attack1_ended = current_time_ms - (player.attack_timer + player.attack_duration)
                       is_in_combo_window_for_attack3 = (player.attack_type == 1 and not player.is_attacking and 
                                                         time_since_attack1_ended < player.combo_window)
                       
                       selected_attack2_anim_key = ''
                       if is_in_combo_window_for_attack3 and \
                          'attack_combo' in player.animations and player.animations['attack_combo']:
                           player.attack_type = 3 # Combo attack
                           selected_attack2_anim_key = 'attack_combo' if is_moving_for_attack2_anim and \
                                                       'attack_combo' in player.animations and player.animations['attack_combo'] \
                                                       else 'attack_combo_nm'
                       elif player.is_crouching and 'crouch_attack' in player.animations and \
                            player.animations['crouch_attack'] and not player.is_attacking :
                           # Standard crouch attack if not comboing (usually attack1 key handles this, but can be backup)
                           player.attack_type = 4 
                           selected_attack2_anim_key = 'crouch_attack'
                       elif not player.is_attacking and 'attack2' in player.animations and \
                            player.animations['attack2']: # Standard Attack 2
                           player.attack_type = 2 
                           selected_attack2_anim_key = 'attack2' if is_moving_for_attack2_anim and \
                                                       'attack2' in player.animations and player.animations['attack2'] \
                                                       else 'attack2_nm'
                       elif not player.is_attacking and player.attack_type == 0 and \
                            'attack' in player.animations and player.animations['attack']: 
                           # Fallback to Attack 1 if no other attack type is suitable (e.g., first attack in a sequence)
                           player.attack_type = 1
                           selected_attack2_anim_key = 'attack' if is_moving_for_attack2_anim else 'attack_nm'
                       
                       if selected_attack2_anim_key : player.set_state(selected_attack2_anim_key)

            # Dash Action
            if event.key == key_config_map['dash']:
                  if player.on_ground and not player.is_dashing and not player.is_rolling and \
                     not player.is_attacking and not player.is_crouching and not player.on_ladder and \
                     player.state not in ['turn','hit']:
                      player.set_state('dash') # Initiate dash state

            # Roll Action
            if event.key == key_config_map['roll']:
                  if player.on_ground and not player.is_rolling and not player.is_dashing and \
                     not player.is_attacking and not player.is_crouching and not player.on_ladder and \
                     player.state not in ['turn','hit']:
                      player.set_state('roll') # Initiate roll state
            
            # Slide Action (initiated by 'down' key press *while running*)
            if event.key == key_config_map['down']: # This is KEYDOWN event, not just holding 'down'
                  can_initiate_slide_action = player.on_ground and player.state == 'run' and \
                                              abs(player.vel.x) > C.PLAYER_RUN_SPEED_LIMIT * 0.6 and \
                                              not player.is_sliding and not player.is_crouching and \
                                              not player.is_attacking and not player.is_rolling and \
                                              not player.is_dashing and not player.on_ladder and \
                                              player.state not in ['turn','hit']
                  if can_initiate_slide_action:
                       # Use slide transition animation if available
                       slide_start_anim_key = 'slide_trans_start' if 'slide_trans_start' in player.animations and \
                                                player.animations['slide_trans_start'] else 'slide'
                       if slide_start_anim_key in player.animations and player.animations[slide_start_anim_key]:
                           player.set_state(slide_start_anim_key)
            
            # Interact Action (e.g., grab/release ladders)
            if event.key == key_config_map['interact']:
                  if player.can_grab_ladder and not player.on_ladder: # Grab ladder
                      player.on_ladder = True; player.vel.y=0; player.vel.x=0; player.on_ground=False
                      player.touching_wall=0; player.can_wall_jump=False; player.wall_climb_timer=0
                      player.set_state('ladder_idle') # Go to ladder idle state
                  elif player.on_ladder: # Release from ladder
                      player.on_ladder = False
                      player.set_state('fall' if not player.on_ground else 'idle') # Fall or go to idle
            
            # Fireball Action (using player-specific fireball_key)
            if player.fireball_key and event.key == player.fireball_key:
                 # The actual firing logic is in player_combat_handler, called via player's method
                 if hasattr(player, 'fire_fireball'):
                     player.fire_fireball()


    # --- Determine Player's Logical State Based on Current Conditions (if not in a manually set state) ---
    # This section updates the player's state if no specific action (like attack, dash) took precedence.
    # It handles transitions like idle to run, run to fall, etc.
    is_in_manual_override_or_transition_state = player.is_attacking or player.is_dashing or \
                                                player.is_rolling or player.is_sliding or \
                                                player.is_taking_hit or \
                                                player.state in [
                                                    'jump','turn','death','death_nm','hit','jump_fall_trans',
                                                    'crouch_trans','slide_trans_start','slide_trans_end',
                                                    'wall_climb','wall_climb_nm','wall_hang','wall_slide',
                                                    'ladder_idle','ladder_climb'
                                                ]
    
    if not is_in_manual_override_or_transition_state: # If not in a special state, determine general state
        if player.on_ladder: # Ladder states
            if abs(player.vel.y) > 0.1 : # Moving on ladder
                player.set_state('ladder_climb' if 'ladder_climb' in player.animations and \
                                 player.animations['ladder_climb'] else 'idle')
            else: # Stationary on ladder
                player.set_state('ladder_idle' if 'ladder_idle' in player.animations and \
                                 player.animations['ladder_idle'] else 'idle')
        elif player.on_ground: # Grounded states
             if player.is_crouching: # Crouching (either still or walking)
                 target_crouch_state_key = 'crouch_walk' if player_intends_horizontal_move and \
                                             'crouch_walk' in player.animations and player.animations['crouch_walk'] \
                                             else 'crouch'
                 # Only set if not already in a crouch state (or if changing between crouch/crouch_walk)
                 if player.state not in ['crouch', 'crouch_walk'] or player.state != target_crouch_state_key:
                    player.set_state(target_crouch_state_key if target_crouch_state_key in player.animations and \
                                     player.animations[target_crouch_state_key] else 'idle')
             elif player_intends_horizontal_move: # Running
                 player.set_state('run' if 'run' in player.animations and player.animations['run'] else 'idle')
             else: # Idle on ground
                 player.set_state('idle')
        else: # In Air states (not on ladder, not on ground)
             if player.touching_wall != 0: # Interacting with a wall
                 current_wall_time_ms = pygame.time.get_ticks()
                 is_wall_climb_duration_expired = (player.wall_climb_duration > 0 and player.wall_climb_timer > 0 and
                                                   current_wall_time_ms - player.wall_climb_timer > player.wall_climb_duration)
                 
                 if player.vel.y > C.PLAYER_WALL_SLIDE_SPEED * 0.5 or is_wall_climb_duration_expired:
                     # If sliding down fast enough or climb time expired, transition to wall_slide
                     player.set_state('wall_slide')
                     player.can_wall_jump = True # Can jump off a wall slide
                 elif player.is_holding_climb_ability_key and abs(player.vel.x) < 1.0 and \
                      not is_wall_climb_duration_expired and 'wall_climb' in player.animations and \
                      player.animations['wall_climb']:
                     # If holding climb key, slow horizontal movement, and climb time not up, try to wall_climb
                     player.set_state('wall_climb')
                     player.can_wall_jump = False # Cannot wall jump while actively climbing up
                 else: # Default wall interaction is wall_slide
                     player.set_state('wall_slide')
                     player.can_wall_jump = True
             elif player.vel.y > 1.0 and player.state not in ['jump','jump_fall_trans']: # Standard falling
                  player.set_state('fall' if 'fall' in player.animations and player.animations['fall'] else 'idle')
             elif player.state not in ['jump','jump_fall_trans','fall']: # If in air but not jumping/falling (e.g., after air dash ends)
                  # Could also transition to 'fall' if vel.y is positive.
                  player.set_state('idle') # Or a more specific air_idle if available.

########## START OF FILE: player_network_handler.py ##########

########## START OF FILE: player_network_handler.py ##########

# player_network_handler.py
# -*- coding: utf-8 -*-
"""
version 1.0000000.1
Handles network-related data serialization, deserialization, and input processing
for the Player class in a networked environment.
Functions here will typically take a 'player' instance as their first argument.
"""
import pygame
import constants as C # For potential network-related constants if any

def get_player_network_data(player):
    """
    Gathers essential player data into a dictionary for network transmission.

    Args:
        player (Player): The player instance whose data is being serialized.

    Returns:
        dict: A dictionary containing the player's network-relevant state.
    """
    # Ensure all serialized values are basic Python types (int, float, bool, str, list, dict)
    # Pygame Vector2 needs to be converted to a tuple of floats.
    data = {
        'player_id': player.player_id, 
        '_valid_init': player._valid_init, # Important for client to know if player is valid
        
        'pos': (player.pos.x, player.pos.y), 
        'vel': (player.vel.x, player.vel.y), 
        'facing_right': player.facing_right, 
        
        'state': player.state, # Current logical state string
        'current_frame': player.current_frame, 
        'last_anim_update': player.last_anim_update, # Timestamp for animation sync
        
        'current_health': player.current_health, 
        'is_dead': player.is_dead,
        'death_animation_finished': player.death_animation_finished,
        
        'is_attacking': player.is_attacking, 
        'attack_type': player.attack_type,
        # Add other relevant boolean flags if needed for precise state replication
        'is_crouching': player.is_crouching,
        'is_dashing': player.is_dashing,
        'is_rolling': player.is_rolling,
        'is_sliding': player.is_sliding,
        'on_ladder': player.on_ladder,
        'is_taking_hit': player.is_taking_hit, # To sync hit stun visuals/invincibility
        
        # Fireball aim direction is crucial for remote players to see where fireballs might go
        'fireball_aim_x': player.fireball_last_input_dir.x, 
        'fireball_aim_y': player.fireball_last_input_dir.y
    }
    # print(f"DEBUG PNH (get_player_network_data) for P{player.player_id}: pos={data['pos']}, valid={data['_valid_init']}, alive (instance): {player.alive() if hasattr(player, 'alive') else 'N/A'}") # DEBUG
    return data

def set_player_network_data(player, network_data): 
    """
    Applies received network data to update the local player instance's state.
    This is typically used on clients to reflect the server's authoritative state,
    or on the server to update a remote player's placeholder.

    Args:
        player (Player): The player instance to be updated.
        network_data (dict): The dictionary of player state received over the network.
    """
    if network_data is None:
        # print(f"DEBUG PNH (set_player_network_data) for P{player.player_id}: Received None network_data. No update.") # DEBUG
        return

    # print(f"DEBUG PNH (set_player_network_data) for P{player.player_id}: Applying network data. Current valid: {player._valid_init}, alive: {player.alive() if hasattr(player, 'alive') else 'N/A'}. Net valid: {network_data.get('_valid_init')}, Net pos: {network_data.get('pos')}") # DEBUG
    
    player_id_from_data = network_data.get('player_id', 'Unknown') # For logging

    # Critical: Update _valid_init first.
    new_valid_init = network_data.get('_valid_init', player._valid_init)
    if player._valid_init != new_valid_init:
        # print(f"DEBUG PNH (set_player_network_data) for P{player_id_from_data}: _valid_init changed from {player._valid_init} to {new_valid_init}") # DEBUG
        player._valid_init = new_valid_init
    
    if not player._valid_init:
        if player.alive(): 
            # print(f"DEBUG PNH (set_player_network_data) for P{player_id_from_data}: Player became invalid, killing sprite.") # DEBUG
            player.kill()  
        return 

    pos_data = network_data.get('pos')
    if pos_data: 
        # print(f"DEBUG PNH (set_player_network_data) for P{player_id_from_data}: Old Pos: {player.pos}, New Net Pos: {pos_data}") # DEBUG
        player.pos.x, player.pos.y = pos_data
    
    vel_data = network_data.get('vel')
    if vel_data: player.vel.x, player.vel.y = vel_data
    
    player.facing_right = network_data.get('facing_right', player.facing_right)
    
    player.current_health = network_data.get('current_health', player.current_health)
    new_is_dead_from_net = network_data.get('is_dead', player.is_dead)
    player.death_animation_finished = network_data.get('death_animation_finished', player.death_animation_finished)

    if new_is_dead_from_net and not player.is_dead: 
        # print(f"DEBUG PNH (set_player_network_data) for P{player_id_from_data}: Transitioning to DEAD from network.") # DEBUG
        player.is_dead = True
        player.current_health = 0 
        player.set_state('death') 
    elif not new_is_dead_from_net and player.is_dead: 
        # print(f"DEBUG PNH (set_player_network_data) for P{player_id_from_data}: Transitioning to ALIVE from network (was dead).") # DEBUG
        player.is_dead = False
        player.death_animation_finished = False 
        if player.state in ['death', 'death_nm']: 
            player.set_state('idle') 
    else: 
        player.is_dead = new_is_dead_from_net 

    player.is_attacking = network_data.get('is_attacking', player.is_attacking)
    player.attack_type = network_data.get('attack_type', player.attack_type)
    player.is_crouching = network_data.get('is_crouching', player.is_crouching)
    player.is_dashing = network_data.get('is_dashing', player.is_dashing)
    player.is_rolling = network_data.get('is_rolling', player.is_rolling)
    player.is_sliding = network_data.get('is_sliding', player.is_sliding)
    player.on_ladder = network_data.get('on_ladder', player.on_ladder)
    
    new_is_taking_hit_from_net = network_data.get('is_taking_hit', player.is_taking_hit)
    if new_is_taking_hit_from_net and not player.is_taking_hit: 
        player.is_taking_hit = True
        player.hit_timer = pygame.time.get_ticks() 
        if player.state != 'hit' and not player.is_dead : player.set_state('hit') 
    elif not new_is_taking_hit_from_net and player.is_taking_hit: 
        player.is_taking_hit = False
        if player.state == 'hit' and not player.is_dead : player.set_state('idle') 

    new_logical_state_from_net = network_data.get('state', player.state)
    if player.state != new_logical_state_from_net and \
       not (player.is_dead and new_logical_state_from_net in ['death', 'death_nm']):
         # print(f"DEBUG PNH (set_player_network_data) for P{player_id_from_data}: Setting state from '{player.state}' to '{new_logical_state_from_net}'") # DEBUG
         player.set_state(new_logical_state_from_net)
    else: 
        player.current_frame = network_data.get('current_frame', player.current_frame)
        player.last_anim_update = network_data.get('last_anim_update', player.last_anim_update)
    
    fb_aim_x_net = network_data.get('fireball_aim_x')
    fb_aim_y_net = network_data.get('fireball_aim_y')
    if fb_aim_x_net is not None and fb_aim_y_net is not None:
        player.fireball_last_input_dir.x = float(fb_aim_x_net)
        player.fireball_last_input_dir.y = float(fb_aim_y_net)
    
    player.rect.midbottom = (round(player.pos.x), round(player.pos.y))
    # print(f"DEBUG PNH (set_player_network_data) for P{player_id_from_data}: Updated rect.midbottom to {player.rect.midbottom}") # DEBUG
    
    if player._valid_init and player.alive(): 
        # print(f"DEBUG PNH (set_player_network_data) for P{player_id_from_data}: Player valid and alive, calling animate().") # DEBUG
        player.animate()
    # else: # DEBUG
        # print(f"DEBUG PNH (set_player_network_data) for P{player_id_from_data}: Player NOT valid or NOT alive. Valid: {player._valid_init}, Alive: {player.alive() if hasattr(player, 'alive') else 'N/A'}. Skipping animate.") # DEBUG


def handle_player_network_input(player, received_input_data_dict): 
    """
    Processes input data received over the network for this player instance.
    This is used by the server to update a remote player's actions based on
    what their client sent. It's a simplified version of local input processing.

    Args:
        player (Player): The player instance whose actions are being driven by network input.
        received_input_data_dict (dict): The input state dictionary from the client.
    """
    # print(f"DEBUG PNH (handle_player_network_input) for P{player.player_id}: Processing input: {received_input_data_dict}") # DEBUG
    if not player._valid_init or player.is_dead or not player.alive():
        # print(f"DEBUG PNH (handle_player_network_input) for P{player.player_id}: Input ignored, player not valid/alive. Valid: {player._valid_init}, Dead: {player.is_dead}, Alive: {player.alive() if hasattr(player,'alive') else 'N/A'}") # DEBUG
        return

    player.acc.x = 0 
    
    intends_move_left_net = received_input_data_dict.get('left_held', False)
    intends_move_right_net = received_input_data_dict.get('right_held', False)
    
    net_fireball_aim_x = received_input_data_dict.get('fireball_aim_x')
    net_fireball_aim_y = received_input_data_dict.get('fireball_aim_y')
    if net_fireball_aim_x is not None and net_fireball_aim_y is not None:
        if float(net_fireball_aim_x) != 0.0 or float(net_fireball_aim_y) != 0.0:
            player.fireball_last_input_dir.x = float(net_fireball_aim_x)
            player.fireball_last_input_dir.y = float(net_fireball_aim_y)
    
    can_control_horizontal_via_net = not (
        player.is_dashing or player.is_rolling or player.is_sliding or player.on_ladder or
        (player.is_attacking and player.state in ['attack_nm','attack2_nm','attack_combo_nm','crouch_attack']) or
        player.state in ['turn','hit','death','death_nm','wall_climb','wall_climb_nm','wall_hang']
    )
    
    new_facing_direction_net = player.facing_right 
    if can_control_horizontal_via_net:
        if intends_move_left_net and not intends_move_right_net:
            player.acc.x = -C.PLAYER_ACCEL
            new_facing_direction_net = False
        elif intends_move_right_net and not intends_move_left_net:
            player.acc.x = C.PLAYER_ACCEL
            new_facing_direction_net = True
            
    if player.on_ground and player.state in ['idle', 'run'] and not player.is_attacking and \
       player.facing_right != new_facing_direction_net:
        player.facing_right = new_facing_direction_net
        player.set_state('turn') 
    else: 
        player.facing_right = new_facing_direction_net
    
    can_perform_action_net = not player.is_attacking and not player.is_dashing and \
                             not player.is_rolling and not player.is_sliding and \
                             not player.on_ladder and player.state not in ['turn','hit']
    
    if received_input_data_dict.get('attack1_pressed_event', False) and can_perform_action_net:
        player.attack_type = 4 if player.is_crouching else 1 
        attack_anim_key_net = 'crouch_attack' if player.is_crouching else \
                              ('attack' if (intends_move_left_net or intends_move_right_net) else 'attack_nm')
        player.set_state(attack_anim_key_net)
    
    if received_input_data_dict.get('attack2_pressed_event', False) and can_perform_action_net:
        player.attack_type = 4 if player.is_crouching else 2 
        attack2_anim_key_net = 'crouch_attack' if player.is_crouching else \
                               ('attack2' if (intends_move_left_net or intends_move_right_net) else 'attack2_nm')
        player.set_state(attack2_anim_key_net)

    if received_input_data_dict.get('fireball_pressed_event', False) and can_perform_action_net:
        if hasattr(player, 'fire_fireball'): 
             player.fire_fireball() 

    if received_input_data_dict.get('jump_intent', False) and can_perform_action_net and not player.is_crouching:
         if player.on_ground: 
             player.vel.y = C.PLAYER_JUMP_STRENGTH
             player.set_state('jump')
             player.on_ground = False 

    if received_input_data_dict.get('dash_pressed_event', False) and player.on_ground and \
       can_perform_action_net and not player.is_crouching:
        player.set_state('dash')
    
    if received_input_data_dict.get('roll_pressed_event', False) and player.on_ground and \
       can_perform_action_net and not player.is_crouching:
        player.set_state('roll')
    
    # Set player's intention flags based on network input for server-side update logic
    player.is_holding_crouch_ability_key = received_input_data_dict.get('down_held', False)
    player.is_holding_climb_ability_key = received_input_data_dict.get('up_held', False)
    # print(f"DEBUG PNH (handle_player_network_input) for P{player.player_id}: Accel.x set to {player.acc.x}, FacingRight: {player.facing_right}") # DEBUG


def get_player_input_state_for_network(player, current_pygame_keys, current_pygame_events, key_map):
    """
    Gathers the local player's current input state into a dictionary format
    suitable for sending over the network.

    Args:
        player (Player): The local player instance (used for player_id and fireball_key config).
        current_pygame_keys: The result of pygame.key.get_pressed().
        current_pygame_events: The list from pygame.event.get().
        key_map (dict): The key mapping for this player's controls.

    Returns:
        dict: A dictionary representing the player's input state.
    """
    input_state_dict = {
        'left_held': bool(current_pygame_keys[key_map['left']]),
        'right_held': bool(current_pygame_keys[key_map['right']]),
        'up_held': bool(current_pygame_keys[key_map['up']]),
        'down_held': bool(current_pygame_keys[key_map['down']]),
        
        'attack1_pressed_event': False, 
        'attack2_pressed_event': False,
        'dash_pressed_event': False, 
        'roll_pressed_event': False,
        'interact_pressed_event': False, 
        'jump_intent': False, 
        'fireball_pressed_event': False,
        
        'fireball_aim_x': player.fireball_last_input_dir.x, 
        'fireball_aim_y': player.fireball_last_input_dir.y
    }
    
    for event in current_pygame_events:
        if event.type == pygame.KEYDOWN:
            if event.key == key_map.get('attack1'): input_state_dict["attack1_pressed_event"] = True
            if event.key == key_map.get('attack2'): input_state_dict["attack2_pressed_event"] = True
            if event.key == key_map.get('dash'): input_state_dict["dash_pressed_event"] = True
            if event.key == key_map.get('roll'): input_state_dict["roll_pressed_event"] = True
            if event.key == key_map.get('interact'): input_state_dict["interact_pressed_event"] = True
            if event.key == key_map.get('up'): input_state_dict["jump_intent"] = True 
            
            if player.fireball_key and event.key == player.fireball_key:
                input_state_dict['fireball_pressed_event'] = True
                
    # print(f"DEBUG PNH (get_player_input_state_for_network) for P{player.player_id}: Generated input state: {input_state_dict}") # DEBUG
    return input_state_dict

########## END OF FILE: player_network_handler.py ##########

########## START OF FILE: projectiles.py ##########

# projectiles.py
# -*- coding: utf-8 -*-
"""
Defines projectile classes like Fireball.
"""
# version 1.0.1 (fixed length_sq typo in init)
import pygame
import os # For path joining
import constants as C
from assets import load_gif_frames, resource_path

class Fireball(pygame.sprite.Sprite):
    def __init__(self, x, y, direction_vector, owner_player):
        super().__init__()
        self.owner_player = owner_player
        self.damage = C.FIREBALL_DAMAGE
        self.speed = C.FIREBALL_SPEED

        full_gif_path = resource_path(C.FIREBALL_SPRITE_PATH)
        self.frames = load_gif_frames(full_gif_path)
        
        if not self.frames or \
           (len(self.frames) == 1 and self.frames[0].get_size() == (30,40) and self.frames[0].get_at((0,0)) == C.RED): 
            print(f"Warning: Fireball GIF '{full_gif_path}' failed to load or is default placeholder. Using fallback.")
            self.image = pygame.Surface(C.FIREBALL_DIMENSIONS, pygame.SRCALPHA).convert_alpha()
            self.image.fill((0,0,0,0)) 
            pygame.draw.circle(self.image, (255, 120, 0, 200), (C.FIREBALL_DIMENSIONS[0]//2, C.FIREBALL_DIMENSIONS[1]//2), C.FIREBALL_DIMENSIONS[0]//3)
            pygame.draw.circle(self.image, C.RED, (C.FIREBALL_DIMENSIONS[0]//2, C.FIREBALL_DIMENSIONS[1]//2), C.FIREBALL_DIMENSIONS[0]//4)
            self.frames = [self.image]
        
        self.current_frame_index = 0
        self.image = self.frames[self.current_frame_index]
        self.rect = self.image.get_rect(center=(x, y))
        self.pos = pygame.math.Vector2(self.rect.center)

        # <<< CORRECTED HERE >>>
        if direction_vector.length_squared() > 0: # Was length_sq()
            self.vel = direction_vector.normalize() * self.speed
        else: 
            self.vel = pygame.math.Vector2(1 if owner_player.facing_right else -1, 0) * self.speed
        
        self.spawn_time = pygame.time.get_ticks()
        self.last_anim_update = self.spawn_time
        self.projectile_id = f"fb_{getattr(owner_player, 'player_id', 'unknown')}_{self.spawn_time}"

    def animate(self):
        now = pygame.time.get_ticks()
        anim_duration = C.ANIM_FRAME_DURATION / 1.5 
        if now - self.last_anim_update > anim_duration:
            self.last_anim_update = now
            self.current_frame_index = (self.current_frame_index + 1) % len(self.frames)
            old_center = self.rect.center
            self.image = self.frames[self.current_frame_index]
            if self.vel.x < 0: 
                 self.image = pygame.transform.flip(self.frames[self.current_frame_index], True, False)
            else:
                 self.image = self.frames[self.current_frame_index]
            self.rect = self.image.get_rect(center=old_center)

    def update(self, dt_sec, platforms, characters_to_hit_group): 
        self.pos += self.vel 
        self.rect.center = round(self.pos.x), round(self.pos.y)
        self.animate()

        if pygame.time.get_ticks() - self.spawn_time > C.FIREBALL_LIFESPAN:
            self.kill()
            return

        if pygame.sprite.spritecollideany(self, platforms):
            self.kill()
            return

        hit_characters = pygame.sprite.spritecollide(self, characters_to_hit_group, False)
        for char in hit_characters:
            if char is self.owner_player and (pygame.time.get_ticks() - self.spawn_time < 100): 
                continue
            if char is self.owner_player and not getattr(C, "ALLOW_SELF_FIREBALL_DAMAGE", False): 
                continue

            if hasattr(char, 'take_damage') and callable(char.take_damage):
                can_damage_target = True
                if hasattr(char, 'is_taking_hit') and hasattr(char, 'hit_timer') and hasattr(char, 'hit_cooldown'):
                    now = pygame.time.get_ticks()
                    if char.is_taking_hit and (now - char.hit_timer < char.hit_cooldown):
                        can_damage_target = False
                
                if can_damage_target:
                    char.take_damage(self.damage)
                    self.kill()
                    return 
        
    def get_network_data(self):
        return {
            'id': self.projectile_id,
            'pos': (self.pos.x, self.pos.y),
            'vel': (self.vel.x, self.vel.y), 
            'owner_id': self.owner_player.player_id if self.owner_player else None,
            'frame': self.current_frame_index,
            'spawn_time': self.spawn_time,
            'image_flipped': self.vel.x < 0 
        }

    def set_network_data(self, data):
        self.pos.x, self.pos.y = data['pos']
        if 'vel' in data:
             self.vel.x, self.vel.y = data['vel']
        self.rect.center = round(self.pos.x), round(self.pos.y)
        self.current_frame_index = data.get('frame', self.current_frame_index)
        old_center = self.rect.center
        base_image = self.frames[self.current_frame_index]
        if data.get('image_flipped', False):
            self.image = pygame.transform.flip(base_image, True, False)
        else:
            self.image = base_image
        self.rect = self.image.get_rect(center=old_center)

########## START OF FILE: server_logic.py ##########

########## START OF FILE: server_logic.py ##########

# server_logic.py
# -*- coding: utf-8 -*-
"""
version 1.0000000.1
Handles server-side game logic, connection management, and broadcasting.
"""
import pygame
import socket
import threading
import time
import traceback
import constants as C
from network_comms import get_local_ip, encode_data, decode_data_stream
from game_state_manager import get_network_game_state, reset_game_state
from enemy import Enemy # For print_limiter access if needed, or just for type hinting
from game_ui import draw_platformer_scene_on_surface # For drawing the server's view

# Shared lock for client connection and input buffer
client_lock = threading.Lock()

class ServerState:
    """
    A simple class to hold server-specific shared state used by the server's
    main loop and its threads. This helps in managing shared resources and
    the running state of the server components.
    """
    def __init__(self):
        self.client_connection = None  # Holds the active client socket object
        self.client_address = None     # Holds the (IP, port) of the active client
        self.client_input_buffer = {}  # Stores the last processed input from the client
        self.app_running = True        # Global flag: True if the application is running
        
        # Network socket objects
        self.server_tcp_socket = None  # TCP socket for listening to client connections
        self.server_udp_socket = None  # UDP socket for broadcasting server presence
        
        # Thread objects
        self.broadcast_thread = None       # Thread for LAN broadcasting
        self.client_handler_thread = None  # Thread for handling communication with the connected client
        
        # Configuration (can be loaded from constants.py or passed)
        self.service_name = getattr(C, "SERVICE_NAME", "platformer_adventure_lan_v1")
        self.discovery_port_udp = getattr(C, "DISCOVERY_PORT_UDP", 5556)
        self.server_port_tcp = getattr(C, "SERVER_PORT_TCP", 5555)
        self.buffer_size = getattr(C, "BUFFER_SIZE", 8192)
        self.broadcast_interval_s = getattr(C, "BROADCAST_INTERVAL_S", 1.0)


def broadcast_presence_thread(server_state_obj: ServerState):
    """
    Thread function to periodically broadcast the server's presence on the LAN.
    Uses UDP to send a discovery message.
    """
    current_lan_ip = get_local_ip() # Get the server's LAN IP for the broadcast message
    broadcast_message_dict = {
        "service": server_state_obj.service_name,
        "tcp_ip": current_lan_ip,
        "tcp_port": server_state_obj.server_port_tcp
    }
    broadcast_message_bytes = encode_data(broadcast_message_dict)

    if not broadcast_message_bytes:
        print("Server Error: Could not encode broadcast message for presence.")
        return

    try:
        # Create and configure the UDP socket for broadcasting
        server_state_obj.server_udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
        server_state_obj.server_udp_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        server_state_obj.server_udp_socket.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
        server_state_obj.server_udp_socket.settimeout(0.5) # Timeout for socket operations to allow periodic checks
    except socket.error as e:
        print(f"Server Error: Failed to create UDP broadcast socket: {e}")
        server_state_obj.server_udp_socket = None
        return
    
    broadcast_address = ('<broadcast>', server_state_obj.discovery_port_udp)
    print(f"DEBUG Server (broadcast_presence_thread): Broadcasting presence: {broadcast_message_dict} to {broadcast_address} (LAN IP: {current_lan_ip})") # DEBUG

    while server_state_obj.app_running:
        try:
            server_state_obj.server_udp_socket.sendto(broadcast_message_bytes, broadcast_address)
            # print(f"DEBUG Server (broadcast_presence_thread): Broadcast sent.") # DEBUG - can be very noisy
        except socket.error as sock_err:
            print(f"DEBUG Server (broadcast_presence_thread): Socket error during broadcast send: {sock_err}") # DEBUG
            pass 
        except Exception as e:
            print(f"Server Warning: Unexpected error during broadcast send: {e}")
        
        # Sleep for the broadcast interval, checking app_running periodically for a timely exit
        for _ in range(int(server_state_obj.broadcast_interval_s * 10)): # e.g., check every 100ms
            if not server_state_obj.app_running: break
            time.sleep(0.1)
            
    # Cleanup UDP socket when the thread stops
    if server_state_obj.server_udp_socket:
        server_state_obj.server_udp_socket.close()
        server_state_obj.server_udp_socket = None
    print("DEBUG Server (broadcast_presence_thread): Broadcast thread stopped.") # DEBUG


def handle_client_connection_thread(conn: socket.socket, addr, server_state_obj: ServerState):
    """
    Thread function to handle receiving data from a single connected client.
    Updates the server_state_obj.client_input_buffer with the latest client input.
    """
    print(f"DEBUG Server (handle_client_connection_thread): Client connected from {addr}. Handler thread started.") # DEBUG
    conn.settimeout(1.0) # Use a timeout for recv to keep the loop responsive
    partial_data_from_client = b"" # Buffer for accumulating partial messages

    while server_state_obj.app_running:
        with client_lock: # Synchronize access to shared server state
            if server_state_obj.client_connection is not conn:
                print(f"DEBUG Server Handler ({addr}): Stale connection. Exiting thread.") # DEBUG
                break 
        try:
            chunk = conn.recv(server_state_obj.buffer_size)
            if not chunk: 
                print(f"DEBUG Server Handler ({addr}): Client disconnected (received empty data).") # DEBUG
                break
            
            # print(f"DEBUG Server Handler ({addr}): Received chunk: {chunk[:60]}...") # DEBUG - can be noisy
            partial_data_from_client += chunk
            decoded_inputs, partial_data_from_client = decode_data_stream(partial_data_from_client)

            if decoded_inputs:
                last_input_data = decoded_inputs[-1] 
                # print(f"DEBUG Server Handler ({addr}): Decoded client input: {last_input_data}") # DEBUG
                if "input" in last_input_data:
                    with client_lock:
                        if server_state_obj.client_connection is conn: 
                            server_state_obj.client_input_buffer = last_input_data["input"]
                            # print(f"DEBUG Server Handler ({addr}): Updated client_input_buffer: {server_state_obj.client_input_buffer}") # DEBUG
        except socket.timeout:
            continue 
        except socket.error as e:
            if server_state_obj.app_running:
                print(f"DEBUG Server Handler ({addr}): Socket error: {e}. Assuming disconnect.") # DEBUG
            break 
        except Exception as e:
            if server_state_obj.app_running:
                print(f"DEBUG Server Handler ({addr}): Unexpected error: {e}") # DEBUG
                traceback.print_exc()
            break

    with client_lock:
        if server_state_obj.client_connection is conn: 
            print(f"DEBUG Server Handler ({addr}): Closing active connection from handler.") # DEBUG
            server_state_obj.client_connection = None 
            server_state_obj.client_input_buffer = {"disconnect": True} 
    try:
        conn.shutdown(socket.SHUT_RDWR) 
    except: pass 
    try:
        conn.close() 
    except: pass
    print(f"DEBUG Server: Client handler for {addr} finished.") # DEBUG


def run_server_mode(screen: pygame.Surface, clock: pygame.time.Clock, 
                    fonts: dict, game_elements_ref: dict, server_state_obj: ServerState):
    """
    Main function to run the game in server mode.
    Manages client connections, game loop, and state synchronization.
    """
    print("DEBUG Server: Entering run_server_mode.") # DEBUG
    pygame.display.set_caption("Platformer - HOST (P1: WASD+VB | Self-Harm: H | Heal: G | Reset: R)")
    
    server_state_obj.app_running = True 
    current_width, current_height = screen.get_size()

    if server_state_obj.broadcast_thread and server_state_obj.broadcast_thread.is_alive():
        print("DEBUG Server: Broadcast thread already running (normal if re-entering server mode without full app restart).") # DEBUG
    else:
        print("DEBUG Server: Starting broadcast thread.") # DEBUG
        server_state_obj.broadcast_thread = threading.Thread(
            target=broadcast_presence_thread, args=(server_state_obj,), daemon=True
        )
        server_state_obj.broadcast_thread.start()

    if server_state_obj.server_tcp_socket: 
        print("DEBUG Server: Closing existing TCP socket before creating new one.") # DEBUG
        try: server_state_obj.server_tcp_socket.close()
        except: pass
    
    server_state_obj.server_tcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_state_obj.server_tcp_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    try:
        server_state_obj.server_tcp_socket.bind((C.SERVER_IP_BIND, server_state_obj.server_port_tcp))
        server_state_obj.server_tcp_socket.listen(1) 
        server_state_obj.server_tcp_socket.settimeout(1.0) 
        print(f"DEBUG Server: Listening on {C.SERVER_IP_BIND}:{server_state_obj.server_port_tcp}") # DEBUG
    except socket.error as e:
        print(f"FATAL SERVER ERROR: Failed to bind/listen TCP socket: {e}")
        return 

    print("DEBUG Server: Waiting for Player 2 to connect...") # DEBUG
    temp_client_conn_obj = None 
    while temp_client_conn_obj is None and server_state_obj.app_running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT: server_state_obj.app_running = False; break
            if event.type == pygame.VIDEORESIZE:
                if not screen.get_flags() & pygame.FULLSCREEN:
                    current_width, current_height = max(320,event.w), max(240,event.h)
                    screen = pygame.display.set_mode((current_width, current_height), pygame.RESIZABLE|pygame.DOUBLEBUF)
                    if game_elements_ref.get("camera"): 
                        game_elements_ref["camera"].screen_width = current_width
                        game_elements_ref["camera"].screen_height = current_height
            if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
                server_state_obj.app_running = False; break 
        if not server_state_obj.app_running: break
        
        screen.fill(C.BLACK)
        if fonts.get("large"):
            wait_text_surf = fonts["large"].render("Waiting for P2...", True, C.WHITE)
            screen.blit(wait_text_surf, wait_text_surf.get_rect(center=(current_width//2, current_height//2)))
        pygame.display.flip()
        clock.tick(10) 

        try:
            temp_client_conn_obj, temp_client_addr_tuple = server_state_obj.server_tcp_socket.accept()
            with client_lock:
                 if server_state_obj.client_connection: 
                     print("DEBUG Server: Closing pre-existing client connection before new one.") # DEBUG
                     try: server_state_obj.client_connection.close()
                     except: pass
                 server_state_obj.client_connection = temp_client_conn_obj
                 server_state_obj.client_address = temp_client_addr_tuple
                 server_state_obj.client_input_buffer = {} 
                 print(f"DEBUG Server: Accepted connection from {temp_client_addr_tuple}") # DEBUG
        except socket.timeout:
            continue 
        except Exception as e:
            if server_state_obj.app_running:
                print(f"DEBUG Server: Error during client accept: {e}") # DEBUG
            break 
    
    if not server_state_obj.app_running or server_state_obj.client_connection is None:
        print("DEBUG Server: Exiting wait loop (no client connected or app closed).") # DEBUG
        return 

    print(f"DEBUG Server: Client {server_state_obj.client_address} connected. Starting game...") # DEBUG
    if server_state_obj.client_handler_thread and server_state_obj.client_handler_thread.is_alive():
        print("DEBUG Server: Previous client handler thread still alive. Attempting to join.") # DEBUG
        server_state_obj.client_handler_thread.join(timeout=0.2) 
    
    server_state_obj.client_handler_thread = threading.Thread(
        target=handle_client_connection_thread, 
        args=(server_state_obj.client_connection, server_state_obj.client_address, server_state_obj), 
        daemon=True
    )
    server_state_obj.client_handler_thread.start()
    print("DEBUG Server: Client handler thread started.") # DEBUG

    p1 = game_elements_ref.get("player1") 
    p2 = game_elements_ref.get("player2") 
    if p1: print(f"DEBUG Server: P1 instance from game_elements: {p1}, Valid: {p1._valid_init if p1 else 'N/A'}") # DEBUG
    if p2: print(f"DEBUG Server: P2 instance from game_elements: {p2}, Valid: {p2._valid_init if p2 else 'N/A'}") # DEBUG


    p1_key_map_config = { 
        'left': pygame.K_a, 'right': pygame.K_d, 'up': pygame.K_w, 'down': pygame.K_s,
        'attack1': pygame.K_v, 'attack2': pygame.K_b, 'dash': pygame.K_LSHIFT,
        'roll': pygame.K_LCTRL, 'interact': pygame.K_e
    }
    
    server_game_active = True
    while server_game_active and server_state_obj.app_running:
        dt_sec = clock.tick(C.FPS) / 1000.0 
        now_ticks_server = pygame.time.get_ticks() 
        
        pygame_events = pygame.event.get()
        keys_pressed_p1 = pygame.key.get_pressed()

        is_p1_game_over_for_reset = False
        if p1 and p1._valid_init:
            if p1.is_dead and (not p1.alive() or (hasattr(p1, 'death_animation_finished') and p1.death_animation_finished)):
                is_p1_game_over_for_reset = True
        else: 
            is_p1_game_over_for_reset = True

        host_requested_reset = False
        for event in pygame_events:
            if event.type == pygame.QUIT: server_game_active = False; server_state_obj.app_running = False; break
            if event.type == pygame.VIDEORESIZE:
                if not screen.get_flags() & pygame.FULLSCREEN:
                    current_width, current_height = max(320,event.w), max(240,event.h)
                    screen = pygame.display.set_mode((current_width,current_height), pygame.RESIZABLE|pygame.DOUBLEBUF)
                    if game_elements_ref.get("camera"):
                        game_elements_ref["camera"].screen_width = current_width
                        game_elements_ref["camera"].screen_height = current_height
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE: server_game_active = False 
                if event.key == pygame.K_r: host_requested_reset = True
                if p1 and p1._valid_init: 
                    if event.key == pygame.K_h and hasattr(p1, 'self_inflict_damage'): p1.self_inflict_damage(C.PLAYER_SELF_DAMAGE)
                    if event.key == pygame.K_g and hasattr(p1, 'heal_to_full'): p1.heal_to_full()
        
        if not server_state_obj.app_running or not server_game_active: break

        if p1 and p1._valid_init and not p1.is_dead:
            if hasattr(p1, 'handle_mapped_input'):
                p1.handle_mapped_input(keys_pressed_p1, pygame_events, p1_key_map_config)

        p2_network_input, client_disconnected_signal, p2_requested_reset = None, False, False
        with client_lock: 
            if server_state_obj.client_input_buffer:
                buffered_input = server_state_obj.client_input_buffer
                # print(f"DEBUG Server: Processing client_input_buffer: {buffered_input}") # DEBUG
                if buffered_input.get("disconnect"): client_disconnected_signal = True
                elif buffered_input.get("action_reset", False): p2_requested_reset = True
                elif p2 and p2._valid_init:
                    if buffered_input.get("action_self_harm", False) and hasattr(p2, 'self_inflict_damage'):
                        p2.self_inflict_damage(C.PLAYER_SELF_DAMAGE)
                    elif buffered_input.get("action_heal", False) and hasattr(p2, 'heal_to_full'):
                        p2.heal_to_full()
                else: 
                    p2_network_input = buffered_input.copy()
                server_state_obj.client_input_buffer = {} 

        if client_disconnected_signal:
            print("DEBUG Server: Client disconnected signal received in main loop.") # DEBUG
            server_game_active = False 
            break 

        if p2 and p2._valid_init and p2_network_input and hasattr(p2, 'handle_network_input'):
            # print(f"DEBUG Server: Handling P2 network input: {p2_network_input}") # DEBUG
            p2.handle_network_input(p2_network_input) 

        if host_requested_reset or (p2_requested_reset and is_p1_game_over_for_reset):
            print("DEBUG Server: Game state reset triggered.") # DEBUG
            game_elements_ref["current_chest"] = reset_game_state(game_elements_ref)

        if p1 and p1._valid_init:
            other_players_for_p1_update = [char for char in [p2] if char and char._valid_init and char.alive() and char is not p1]
            p1.update(dt_sec, game_elements_ref["platform_sprites"], game_elements_ref["ladder_sprites"], 
                      game_elements_ref["hazard_sprites"], other_players_for_p1_update, game_elements_ref["enemy_list"])

        if p2 and p2._valid_init:
            other_players_for_p2_update = [char for char in [p1] if char and char._valid_init and char.alive() and char is not p2]
            p2.update(dt_sec, game_elements_ref["platform_sprites"], game_elements_ref["ladder_sprites"], 
                      game_elements_ref["hazard_sprites"], other_players_for_p2_update, game_elements_ref["enemy_list"])

        active_players_for_enemy_ai = [char for char in [p1, p2] if char and char._valid_init and not char.is_dead and char.alive()]
        for enemy in list(game_elements_ref.get("enemy_list", [])): 
            if enemy._valid_init:
                enemy.update(dt_sec, active_players_for_enemy_ai, game_elements_ref["platform_sprites"], game_elements_ref["hazard_sprites"])
                if enemy.is_dead and hasattr(enemy, 'death_animation_finished') and \
                   enemy.death_animation_finished and enemy.alive():
                    if hasattr(Enemy, 'print_limiter') and Enemy.print_limiter.can_print(f"server_killing_enemy_{enemy.enemy_id}"):
                         print(f"Server: Auto-killing enemy {enemy.enemy_id} as death anim finished.")
                    enemy.kill() 
            
        hittable_characters_server_group = pygame.sprite.Group()
        if p1 and p1.alive() and p1._valid_init: hittable_characters_server_group.add(p1)
        if p2 and p2.alive() and p2._valid_init: hittable_characters_server_group.add(p2)
        for enemy_inst_proj in game_elements_ref.get("enemy_list", []):
            if enemy_inst_proj and enemy_inst_proj.alive() and enemy_inst_proj._valid_init:
                hittable_characters_server_group.add(enemy_inst_proj)
        game_elements_ref.get("projectile_sprites", pygame.sprite.Group()).update(dt_sec, game_elements_ref["platform_sprites"], hittable_characters_server_group)
        
        game_elements_ref.get("collectible_sprites", pygame.sprite.Group()).update(dt_sec)
        server_current_chest = game_elements_ref.get("current_chest")
        if server_current_chest and server_current_chest.alive(): 
            player_who_collected_chest = None
            if p1 and p1._valid_init and not p1.is_dead and p1.alive() and pygame.sprite.collide_rect(p1, server_current_chest):
                player_who_collected_chest = p1
            elif p2 and p2._valid_init and not p2.is_dead and p2.alive() and pygame.sprite.collide_rect(p2, server_current_chest):
                player_who_collected_chest = p2
            
            if player_who_collected_chest:
                server_current_chest.collect(player_who_collected_chest) 
                game_elements_ref["current_chest"] = None 
        
        server_camera = game_elements_ref.get("camera")
        if server_camera:
            camera_focus_target = None
            if p1 and p1.alive() and p1._valid_init and not p1.is_dead: camera_focus_target = p1
            elif p2 and p2.alive() and p2._valid_init and not p2.is_dead: camera_focus_target = p2
            
            if camera_focus_target: server_camera.update(camera_focus_target)
            else: server_camera.static_update() 

        if server_state_obj.client_connection: 
            network_state_to_send = get_network_game_state(game_elements_ref)
            # print(f"DEBUG Server: State to send: P1 pos {network_state_to_send.get('p1', {}).get('pos')}, P2 pos {network_state_to_send.get('p2', {}).get('pos')}") # DEBUG
            encoded_game_state = encode_data(network_state_to_send)
            if encoded_game_state:
                try:
                    server_state_obj.client_connection.sendall(encoded_game_state)
                except socket.error as e:
                    print(f"DEBUG Server: Send failed to client: {e}. Client likely disconnected.") # DEBUG
                    server_game_active = False 
                    with client_lock: server_state_obj.client_connection = None 
                    break 
            # else: print("DEBUG Server Error: Failed to encode game state for sending.") # DEBUG
        
        try:
            draw_platformer_scene_on_surface(screen, game_elements_ref, fonts, now_ticks_server)
        except Exception as e:
            print(f"Server draw error: {e}"); traceback.print_exc()
            server_game_active = False; break
        pygame.display.flip()

    print("DEBUG Server: Exiting active game loop.") # DEBUG
    
    connection_to_close_at_server_exit = None
    with client_lock:
        if server_state_obj.client_connection:
            connection_to_close_at_server_exit = server_state_obj.client_connection
            server_state_obj.client_connection = None 
    if connection_to_close_at_server_exit:
        print("DEBUG Server: Mode exit cleanup - closing client connection.") # DEBUG
        try:
            connection_to_close_at_server_exit.shutdown(socket.SHUT_RDWR)
            connection_to_close_at_server_exit.close()
        except: pass 

    if server_state_obj.server_tcp_socket:
        print("DEBUG Server: Closing main TCP listening socket.") # DEBUG
        server_state_obj.server_tcp_socket.close()
        server_state_obj.server_tcp_socket = None
    
    print("DEBUG Server: Server mode finished and returned to caller.") # DEBUG

########## END OF FILE: server_logic.py ##########

########## START OF FILE: tiles.py ##########

# tiles.py
# -*- coding: utf-8 -*-
"""
Defines classes for static and interactive tiles in the game world.
"""
# version 1.0.0.1 (Added platform_type to Platform class)
import pygame
# Import all necessary constants, including DARK_GREEN if not already present
from constants import GRAY, BLUE, ORANGE_RED, DARK_GREEN 

class Platform(pygame.sprite.Sprite):
    """ 
    Standard solid platform.
    Can be tagged with a platform_type (e.g., "ground", "ledge", "wall").
    """
    def __init__(self, x, y, width, height, color=GRAY, platform_type="generic"):
        super().__init__()
        
        # Ensure valid dimensions for the surface
        surf_width = max(1, int(width))
        surf_height = max(1, int(height))
        
        self.image = pygame.Surface((surf_width, surf_height))
        self.image.fill(color)
        self.rect = self.image.get_rect(topleft=(x, y))
        
        self.color = color # Store the color, can be useful for debugging or logic
        self.platform_type = platform_type # Store the type of platform

        if width <= 0 or height <= 0:
            print(f"Warning: Platform created with non-positive dimensions: w={width}, h={height} at ({x},{y}). Using 1x1.")
            # Surface already created with max(1,...) dimensions, rect is based on original x,y


class Ladder(pygame.sprite.Sprite):
    """ Climbable ladder area. """
    def __init__(self, x, y, width, height):
        super().__init__()
        # Ensure valid dimensions
        width = max(1, int(width))
        height = max(1, int(height))
        self.image = pygame.Surface((width, height)).convert_alpha()
        self.image.fill((0, 0, 0, 0)) # Fully transparent background
        self.image.set_alpha(100) # Make semi-transparent visually

        # Draw visual cues (rungs, rails)
        rung_color = (40, 40, 180, 200) # Slightly transparent dark blue
        num_rungs = int(height / 15)
        if num_rungs > 0: # Avoid division by zero if height is too small
            rung_spacing = height / num_rungs
            for i in range(1, num_rungs + 1): # Iterate to include a rung near the top
                rung_y = i * rung_spacing
                # Ensure rung_y is within bounds before drawing
                if rung_y < height -1 : # -1 to keep it within the surface
                    pygame.draw.line(self.image, rung_color, (0, rung_y), (width, rung_y), 2)
        
        # Draw side rails (ensure lines are within surface bounds)
        # Use min/max to prevent drawing outside the surface if width is very small
        rail_thickness = 3
        left_rail_x = min(rail_thickness -1, width -1) # If width=1, rail is at x=0
        right_rail_x = max(0, width - rail_thickness)   # If width=1, rail is at x=0
        
        pygame.draw.line(self.image, rung_color, (left_rail_x, 0), (left_rail_x, height), rail_thickness)
        if width > rail_thickness * 2: # Only draw second rail if there's space
             pygame.draw.line(self.image, rung_color, (right_rail_x, 0), (right_rail_x, height), rail_thickness)

        self.rect = self.image.get_rect(topleft=(x, y))

class Lava(pygame.sprite.Sprite):
    """ Dangerous lava tile that damages characters. """
    def __init__(self, x, y, width, height, color=ORANGE_RED):
        super().__init__()
        # Ensure valid dimensions
        width = max(1, int(width))
        height = max(1, int(height))
        self.image = pygame.Surface((width, height))
        self.image.fill(color)
        self.rect = self.image.get_rect(topleft=(x, y))
        # Optional: Add visual effect like simple noise/flicker
        # import random
        # for _ in range(int(width*height*0.05)): # Add some darker spots
        #      px = random.randint(0, width-1)
        #      py = random.randint(0, height-1)
        #      dark_color_r = max(0, color[0]-random.randint(30,70))
        #      dark_color_g = max(0, color[1]-random.randint(10,40))
        #      dark_color_b = max(0, color[2]-random.randint(0,20))
        #      self.image.set_at((px, py), (dark_color_r, dark_color_g, dark_color_b))

########## START OF FILE: utils.py ##########

# utils.py
# -*- coding: utf-8 -*-
"""
Shared utility classes and functions.
version 1.0000000.1
"""
import time

class PrintLimiter:
    def __init__(self, default_limit=5, default_period=2.0):
        self.counts = {}
        self.timestamps = {}
        self.default_limit = default_limit
        self.default_period = default_period
        self.globally_suppressed = {} # Tracks if the "suppressing further prints" message was shown

    def can_print(self, message_key, limit=None, period=None):
        limit = limit if limit is not None else self.default_limit
        period = period if period is not None else self.default_period
        current_time = time.time()
        
        if message_key not in self.timestamps:
            self.timestamps[message_key] = current_time
            self.counts[message_key] = 0
            self.globally_suppressed[message_key] = False

        if current_time - self.timestamps[message_key] > period:
            self.timestamps[message_key] = current_time
            self.counts[message_key] = 0
            self.globally_suppressed[message_key] = False # Reset suppression message flag

        if self.counts[message_key] < limit:
            self.counts[message_key] += 1
            return True
        elif not self.globally_suppressed[message_key]: # Only print suppression message once per period
            # print(f"[PrintLimiter] Suppressing further prints for '{message_key}' for {period:.1f}s (limit: {limit})") # Keep this commented for less console noise
            self.globally_suppressed[message_key] = True
            return False
        return False